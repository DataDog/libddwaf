[
    {
        "Pattern": "&lt;a\\s*href=(.*?)[\\s|&gt;]",
        "MatchingText": "&lt;a href=&quot;http://www.blah.com&quot;&gt;|||&lt;a href='../blah.html' target=&quot;_top&quot;&a",
        "NonMatchingText": "&lt;a href   =   http://www.idiothtmlprogrammers.com   &gt;",
        "Description": "Retrieves all anchor links in a html document, useful for spidering. You will need to do a replace of &quot; and ' after the regular expression, as the expression gets all links. As far as I know there is no way, even with \\1 groupings, of getting a condition on whether the link contains a &quot;,' or nothing at all (&quot; and ' is easy enough, but what happens if the link starts with &quot;, and has a javascript function call with a string in it). If there is, it's probably quicker to do it like this and do a string replace anyway."
    },
    {
        "Pattern": "^[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\\.)+(?:[a-zA-Z]{2}|aero|asia|biz|cat|com|coop|edu|gov|info|int|jobs|mil|mobi|museum|name|net|org|pro|tel|travel)$",
        "MatchingText": "email@email.com | email@email.cn | e_m81l&em%'l@eMail.MUSEUM | email@em@il.com",
        "NonMatchingText": "email@com | email@email.con | email@email.museet | email@192.0.0.1",
        "Description": "Matches email addresses.  Based on expression at regular-expressions.info/email.html modified to include all top-level domains (TLD)listed on wikipedia as of June 2010.  Needs to be updated as new TLDs are added.\n\nKnown Issues: \n* IP Addresses will not validate\n* Double \"at\" symbols, e.g. email@em@il.com slip by this regex.  Would welcome improvements by a regex ninja."
    },
    {
        "Pattern": "^([\\+][0-9]{1,3}([ \\.\\-])?)?([\\(]{1}[0-9]{3}[\\)])?([0-9A-Z \\.\\-]{1,32})((x|ext|extension)?[0-9]{1,4}?)$",
        "MatchingText": "(123)456-7890 | (123)456-7890 x123 | +1 (123)456-7890 | 12 3456 789 0 x1234 | (123)456-7890x123 |(123)456-7890ext123 | (123)456-7890 extension123 | 123.456.7890 | 1234567890 | 1234567 | 12 34 56 78 90 | 12 3 4567 890123 x4567 | +12 3456 7890 | +12 34 56 7890 | +12 3456 7890 | +12 34567890",
        "NonMatchingText": "(123)456-7890 x 123 | 123.45.6.78+90",
        "Description": "Somewhat conservative expression for evaluating phone numbers.  Based off ideas found at http://stackoverflow.com/questions/123559/a-comprehensive-regex-for-phone-number-validation this allows country codes, with or without the + symbol, area codes surrounded by parenthesis (or not) and numbers delimited by spaces, periods or dashes.  You'll want to independently test for string length based on your needs."
    },
    {
        "Pattern": "^(-?[1-9](\\.\\d+)?)((\\s?[X*]\\s?10[E^]([+-]?\\d+))|(E([+-]?\\d+)))$",
        "MatchingText": "1.1 x 10^9  |  2.34 X 10^12  |  3.14159 * 10^30  |  1.1x10^9  |  2.34X10^12  |  3.14159*10^30  |  1.1 x 10e9  |  2.34 x 10E12  |  3.14159e30  |  1.1 x 10^-9  |  2.34 X 10^-12  |  3.14159E-30  |  -1.1 x 10^9  |  -2.34 X 10E12  |  -3.14159 * 10e30  |  -1.1x10^-9  |  -2.34E-12  |  -3.14159e-30  |  3.1459E+030  |  1x10^9  |  1E9",
        "NonMatchingText": "0.1 x 10^9  |  23.4 x 10^12  |  3.14159 * 10e^30  |  1.1e8.3",
        "Description": "Matches both normalized and E notations, with or without spaces or negative numbers. Make sure to use a case insensitive pattern matcher. Group 1 is the significand, and either group 5 or group 7 is the exponent (one or the other will be null, but never both)."
    },
    {
        "Pattern": "^([a-zA-Z '-]+)$",
        "MatchingText": "Sachin Bhatt|||D'Souza|||Ul-Haq",
        "NonMatchingText": "sac2hin|||sc*&amp;|||sac)in",
        "Description": "Check if the text is a valid firstname or lastname.It allows Characters,'- and space only"
    },
    {
        "Pattern": "^\\d*[0-9](|.\\d*[0-9]|)*$",
        "MatchingText": "123.23 | 123.1234 | 1234 | 1234.456",
        "NonMatchingText": "123a.12 | 123.34d | abc",
        "Description": "Decimal like 123.23\n123.1234\n12345.456"
    },
    {
        "Pattern": "\"^([a-zA-Z])*$\"",
        "MatchingText": "jan |  sara |  America |  how  are  you |",
        "NonMatchingText": "123  | jan12  |  sara036  |  zip code 985",
        "Description": "Using regular expressions, you can just use the English alphabet."
    },
    {
        "Pattern": "^(?:[\\w]\\:|\\\\)(\\\\[a-z_\\-\\s0-9\\.]+)+\\.(txt|gif|pdf|doc|docx|xls|xlsx)$",
        "MatchingText": "\\\\192.168.0.1\\folder\\file.pdf|||\\\\192.168.0.1\\my folder\\folder.2\\file.gif|||c:\\my folder\\abc abc.docx |||c:\\my-folder\\another_folder\\abc.v2.docx",
        "NonMatchingText": "\\\\192.168.0.1\\folder\\fi/le.pdf |||\\\\192.168.0.1\\folder\\\\file.pdf |||\\\\192.168.0.1\\my folder\\folder.2\\.gif |||c:\\my folder\\another_folder\\.docx |||c:\\my folder\\\\another_folder\\abc.docx||| c:\\my folder\\another_folder\\ab*c.v2.docx |||c:\\my?folder\\another_folder\\abc.v2.docx ||| file.xls",
        "Description": "Regular Expression to validate file path and extension.Compatible with JavaScript and ASP.NET"
    },
    {
        "Pattern": "^[^'<>?%!\\s]{1,20}$",
        "MatchingText": "abcd123||| --+abc",
        "NonMatchingText": "abc'123|||abc?|||abc abc|||<script>",
        "Description": "Disallow ' or < or > or ? or % or ! or space in a string. Minimum character is 1 and maximum is 20 in a string."
    },
    {
        "Pattern": "^((?-i:0x)?[A-Fa-f0-9]{32}|\n[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}|\n\\{[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}\\})$",
        "MatchingText": "6F9619FF-8B86-D011-B42D-00C04FC964FF|||0x6F9619FF8B86D011B42D00C04FC964FF|||{6F9619FF-8B86-D011-B42D",
        "NonMatchingText": "{6F9619FF8B86D011B42D00C04FC964FF}|||0X6F9619FF8B86D011B42D00C04FC964FF",
        "Description": "Validates a GUID/UUID, without capture, to the following patterns: [{hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh}],\n[hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh],[hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh],[0xhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh], where 'h' is a valid hex character.  This last pattern is a binary format commonly used with SQL Server 2000.  It allows you to use binary(n) and varbinary(n) parameters that convert well to unique identifier.  Please note that this is not case sensitive EXCEPT the 'x' in the binary pattern.  It must be lower case."
    },
    {
        "Pattern": "^[\\w\\.=-]+@[\\w\\.-]+\\.[\\w]{2,3}$",
        "MatchingText": "a@a.com|||a@a.com.au|||a@a.au",
        "NonMatchingText": "word|||word@|||@word",
        "Description": "Much simpler email expression. This one forces a length of 2 or 3, which fits current specs, but you may need to alter the end as this one allows all numerals on the .COM section."
    },
    {
        "Pattern": "(<meta [.\\w\\W]*?\\>)|(<style [.\\w\\W]*?</style>)|(<link [.\\w\\W]*?\\>)|(<script [.\\w\\W]*?</script>)",
        "MatchingText": "<head runat=\"server\">     <title></title>     <script type=\"text/javascript\">         //         //         function foo() {         }         //     </script>     <style type=\"text/css\">         /*         **         **         */         .foo { font-size : large;}     </style>     <script src=\"includes/JScript1.js\" type=\"text/javascript\"></script>     <link href=\"includes/Stylesheet1.css\" rel=\"stylesheet\" type=\"text/css\" />      <script type=\"text/javascript\">         //         //         function foo2() {         }         //     </script>     <style type=\"text/css\">         /*         ** ",
        "NonMatchingText": "Um.... ",
        "Description": "Parses the objects out from an html header. These objects are: meta, style, link, and script. Use with the multiline option to pull from multine scripts and styles."
    },
    {
        "Pattern": "^((000)(666)(?:[0-6]\\d{2}|7[0-2][0-9]|73[0-3]|7[5-6][0-9]|77[0-2]))-((00)\\d{2})-((0000)\\d{4})$",
        "MatchingText": "455-55-4444|333-22-1111|733-11-1111",
        "NonMatchingText": "734-11-1111|749-11-1111|772-11-1111",
        "Description": "Could not find a regex that truly matched the rules here http://en.wikipedia.org/wiki/Social_Security_number#Valid_SSNs So I modified an existing one to match the valid SSN rules.\nThe first digit set will not match:\n\n000, 666, 734 to 749, and greater than 772.\n\n* Numbers with all zeros in any digit group (000-xx-####, ###-00-####, ###-xx-0000)"
    },
    {
        "Pattern": "/[^/]+$",
        "MatchingText": "/home/pietro/myfile.txt|||/home/pietro/myfile",
        "NonMatchingText": "/home/pietro/mydir/",
        "Description": "Very easy expression to get the file name from a path. I couldn't find it so I wrote it and now I post it here! Hope it could help."
    },
    {
        "Pattern": "([+]?\\d[ ]?[(]?\\d{3}[)]?[ ]?\\d{2,3}[- ]?\\d{2}[- ]?\\d{2})",
        "MatchingText": "88002345675  |  +7 (960) 000 00 00  |  +7(4855)23-34-56",
        "NonMatchingText": "+7(4855)23.34.56  |  7 4855 aaa 234 526  |  8(232)_232_23_12",
        "Description": "Validate Russian phone number (mobile, landline)  that accept a space, a dash between the numbers."
    },
    {
        "Pattern": "Diet Review: Advance Ketogenic Diet Pill for Weight Loss!",
        "MatchingText": "Diet Review: Advance Ketogenic Diet Pill for Weight Loss!",
        "NonMatchingText": "Diet Review: Advance Ketogenic Diet Pill for Weight Loss!",
        "Description": "purefit keto The FDA has not formally defined the terms \"Low-Carb,\" \"Non-Impact Carbs\" and \"Net Carbs\" as it has done with terms relating to fat content in food. That will surely come, but in the meantime many foods that are not particularly low-carb can get away with labeling themselves low-carb. As always, reading the nutritional information on the package and noting serving sizes is your best protection.\n\nhttps://wheretobuyy.com/purefit-keto-weight-loss-product/\n\n"
    },
    {
        "Pattern": "^[0-9]{6}-[0-9pPtTfF][0-9]{3}$",
        "MatchingText": "123456-1234 ||| 123456-P234 |||123456-f234",
        "NonMatchingText": "123456-12 ||| 1234561234 ||| 123456",
        "Description": "Other Swedish personnummer regexps do not take into account that at Swedish universities, foreigners might get special temporary personnummers with a \"P\", \"T\", or \"F\" instead of the first of the four last numbers.\n\nThis code fixes the problem, but does not check the validity of the date, or the last number."
    },
    {
        "Pattern": "^[A-Za-z]{1,2}[\\d]{1,2}([A-Za-z])?\\s?[\\d][A-Za-z]{2}$",
        "MatchingText": "CF1 2AA|||cf564fg",
        "NonMatchingText": "a1234d|||A12 77Y",
        "Description": "UK Postal Codes - The code is normally written in capital letters with a space between the outer and inner parts; it is understandable if the space is omitted.\n\nThis regular expression validates upper or lower case with or without the space:\n"
    },
    {
        "Pattern": "/^([0-2][0-9]\\:[0-5][0-9]\\:[0-5][0-9])\\s+up\\s+([0-9\\:]{1,5})\\s*(days|day|min|mins)?(?:\\,\\s+([0-9\\:]{1,5})\\s*(days|day|min|mins)?)?\\,\\s+([0-9]{1,4})\\susers?\\,\\s+load\\s+average\\:\\s+([0-9\\.]{1,6})\\,\\s+([0-9\\.]{1,6})\\,\\s+([0-9\\.]{1,6})$/",
        "MatchingText": "13:21:33 up 219 days, 1:11,  1 user,  load average: 0.00, 0.00, 0.00|||21:17:21 up 19 days,  9:34,  1 user,  load average: 0.00, 0.00, 0.00|||21:17:21 up 19 days,  9:34,  1 user,  load average: 12.30, 5.02, 1.20",
        "NonMatchingText": "none",
        "Description": "Take the output of the uptime command and split it into a useful array.\n\nUse array combine with the below keys array for usefull output.\n\narray('raw','time','up1','unit1','up2','unit2','users','1min','5min','15min')"
    },
    {
        "Pattern": "\\b(([\\w-]+://?|www[.])[^\\s()<>]+(?:\\([\\w\\d]+\\)|([^[:punct:]\\s]|/)))",
        "MatchingText": "http://foo.com/blah_blah||| http://foo.com/blah_blah/||| (Something like http://foo.com/blah_blah)||| http://foo.com/blah_blah_(wikipedia)||| (Something like http://foo.com/blah_blah_(wikipedia))||| http://foo.com/blah_blah.||| http://foo.com/blah_blah/.||| <http://foo.com/blah_blah>||| <http://foo.com/blah_blah/>||| http://foo.com/blah_blah,||| http://www.example.com/wpstyle/?p=364.||| http://\u272Adf.ws/123||| rdar://1234||| rdar:/1234||| http://userid:password@example.com:8080||| http://userid@example.com||| http://userid@example.com:8080||| http://userid:password@example.com",
        "NonMatchingText": "no_ws.example.com|||no_proto_or_ws.com|||/relative_resource.php",
        "Description": "Identifies the URLs in an arbitrary string of text, where by \u201Carbitrary\u201D let\u2019s agree we mean something unstructured such as an email message or a tweet.  Source: daringfireball.net"
    },
    {
        "Pattern": "^[0-9]+\\.?[0-9]?[0-9]?[0,5]?$",
        "MatchingText": "1.005|||60|||0.08",
        "NonMatchingText": "1.009|||-8|||.005",
        "Description": "The time should be fractional number and divisible by 0.005"
    },
    {
        "Pattern": "^[1-9][0-9]{3}\\s?[a-zA-Z]{2}$",
        "MatchingText": "1234AB|||1234 AB|||1001 AB",
        "NonMatchingText": "0123AB|||1234A B|||0123 AB",
        "Description": "Validates Dutch Postal Codes (ZipCode). There was a previous one listed here, but it's not entirely correct. Namely that dutch postal codes can contain a zero but cannot start with one, so this one is the adjusted version."
    },
    {
        "Pattern": "^([GB])*(([1-9]\\d{8})|([1-9]\\d{11}))$",
        "MatchingText": "123456789|||GB123456789|||GB123456789123",
        "NonMatchingText": "dfddf|||3443443|||34 34 3344",
        "Description": "Simple check of valid UK VAT Registration numbers. The standard format for UK VAT number must be 9 characters long or 12 characters if a branch trader. The GB prefix has been included as optional, but technically you should include it. The UK VAT format also includes Government Departments and Health Authorities, but I have excluded them for the moment."
    },
    {
        "Pattern": "^\\+?972(\\-)?0?[23489]{1}(\\-)?[^0\\D]{1}\\d{6}$",
        "MatchingText": "+972-4-8253055|||972-4-8615466|||972-04-8564521",
        "NonMatchingText": "04-5487665|||05-455665545|||456884624",
        "Description": "Matches an israely phone number with country code. With or without the plus sign. Also allows two or one digit in city code. Checks for a valid city code (02,03,04,08,09)"
    },
    {
        "Pattern": "http://(?:www\\.|)uploaded\\.to/\\?id=[a-z0-9]{6}",
        "MatchingText": "http://www.uploaded.to/?id=123456;http://uploaded.to/?id=abcdef",
        "NonMatchingText": "http://www.uploaded.to/?id=12345678;uploaded.to/?id=123456",
        "Description": "Downloadlinks of the 1-Click-Hoster uploaded.to"
    },
    {
        "Pattern": "/[^imsxeADSUXu]([imsxeADSUXu]*)$/",
        "MatchingText": "/asher/is ||| /(a|the)\\spattern/imxe",
        "NonMatchingText": "/pattern/mjhlk",
        "Description": "This matches the modifiers section of a properly formed PCRE RegEx (at least in PHP).  This of course assumes that the delimiters are not any of the modifiers letters, if that's even possible."
    },
    {
        "Pattern": "'([dmstrl])([ .,?!\\)\\\\/<])",
        "MatchingText": "it's |they'll |we're,|I'd!",
        "NonMatchingText": "its| were| He said 'Hello'.",
        "Description": "Find apostrophes in text.\n\nI use this to curl them, by replacing the above with this expression:\n\u2019$1$2"
    },
    {
        "Pattern": "^.*(([^\\.][\\.][wW][mM][aA])|([^\\.][\\.][mM][pP][3]))$",
        "MatchingText": "thisfile.mp3 | tH@tfile.wma",
        "NonMatchingText": "whatever.exe | somethingelse.mpa | thisagain.wm3 | filenamemp3 | filename..mp3 | filename.wmap3",
        "Description": "Matches a file name to be either a .wma or .mp3 file. This can be used to check file uploads to make sure they are of a certain type. Substitute letters where appropriate for specific file types. This is a better solution (I think) than #343. Works in Javascript and C#."
    },
    {
        "Pattern": " <\\/{0,1}(\\/|b>|i>|p>|a\\s|a>|br|em>|ol|li|strong>)[^>]*>",
        "MatchingText": "<table>...</table>",
        "NonMatchingText": "blah blah blah.",
        "Description": "following a bit of work this morning trying to get something to strip out arbitrary html but leave 'known' tags in place, we have come up with the following which may be useful. This uses the 'negative lookahead' construct using '?!'  It looks for an angle bracket and perhaps a backslash, as long as it is *not* followed by one of the terms in the ?! section. The brackets in this section do not return a value, they are part of the construct. This regexp can therefore be used to replace all unknown tags  with blanks. Obviously you can add other 'good' html tags to the list."
    },
    {
        "Pattern": " <\\/{0,1}(\\/|b>|i>|p>|a\\s|a>|br|em>|ol|li|strong>)[^>]*>",
        "MatchingText": "<table>...</table>",
        "NonMatchingText": "blah blah blah.",
        "Description": "following a bit of work this morning trying to get something to strip out arbitrary html but leave 'known' tags in place, we have come up with the following which may be useful. This uses the 'negative lookahead' construct using '?!'  It looks for an angle bracket and perhaps a backslash, as long as it is *not* followed by one of the terms in the ?! section. The brackets in this section do not return a value, they are part of the construct. This regexp can therefore be used to replace all unknown tags  with blanks. Obviously you can add other 'good' html tags to the list."
    },
    {
        "Pattern": "&lt;/?(\\w+)(\\s*\\w*\\s*=\\s*(&quot;[^&quot;]*&quot;|'[^']'|[^&gt;]*))*|/?&gt;",
        "MatchingText": "&lt;font color=&quot;blue&quot;&gt;|||&lt;/font&gt;|||&lt;br /&gt;",
        "NonMatchingText": "this is a test...",
        "Description": "Matches HTML of XML tags, with or without attributes (single-, double-, or non-quoted), closing tags, or self-closing singleton tags."
    },
    {
        "Pattern": "^(((ht|f)tp(s?))\\://)?(www.|[a-zA-Z].)[a-zA-Z0-9\\-\\.]+\\.(com|edu|gov|mil|net|org|biz|info|name|museum|us|ca|uk)(\\:[0-9]+)*(/($|[a-zA-Z0-9\\.\\,\\;\\?\\'\\\\\\+&amp;%\\$#\\=~_\\-]+))*$",
        "MatchingText": "www.blah.com:8103|||www.blah.com/blah.asp?sort=ASC|||www.blah.com/blah.htm#blah",
        "NonMatchingText": "www.state.ga|||http://www.blah.ru",
        "Description": "Version 1.3.0: I needed a regexp to validate URL's without the ht(f)tp(s):// and include North American domains (like .us and .ca) and there didn't seem to be one available...so I created one. It will also work with ASP QueryStrings and anchor URL's. If you have a problem with the expression or have any suggestions to improve, please write me and let me know. Added .uk domain and expression now allows for URLs that contain JSP session IDs. 4/14/04 - added ability to include URLs that start with server names."
    },
    {
        "Pattern": "^([0-9]{6})[0-9a-zA-Z]{6}$",
        "MatchingText": "123a12|||a12345|||aaaaaa",
        "NonMatchingText": "111111",
        "Description": "matches a six character &quot;password&quot; that has to consist of numbers and letters with at least one letter in it."
    },
    {
        "Pattern": "^[\\n &lt;&quot;']*([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+)",
        "MatchingText": "blah.v.blah@blah-blah.net|||blah-blah.blah@blah.com|||.@.",
        "NonMatchingText": "blah@",
        "Description": "I use this expression to read bounced email addresses returned by the system administrator. The body of the subject should contain the email address somewhere but the location varies.\nExamples:\n  To:      blah.v.blah@blah-blah.net ||\nblah-blah.blah@blah.com ||\n&lt;blah@blah.org&gt;... Deferred: Connection timed out with mail.blah.org. ||\n  blah@blah.net 0n 25-12-2004 21:09"
    },
    {
        "Pattern": "^\\w+\\.((?:\\w+\\.)+\\w+)$",
        "MatchingText": "www.google.com|||www.wave.google.com|||as.vcu.acadia.memco.edu",
        "NonMatchingText": "google.com|||microsoft.com|||memco.edu",
        "Description": "Drops the first subdomain from a domain name with at least one subdomain.  Fails if the domain does not contain a subdomain."
    },
    {
        "Pattern": "^([0-9a-zA-Z]([-.\\w]*[0-9a-zA-Z])*@(([0-9a-zA-Z])+([-\\w]*[0-9a-zA-Z])*\\.)+[a-zA-Z]{2,9})$",
        "MatchingText": "bob@smith.com|||bob@j.smith.museum|||bob.smith@a-1.smith.com",
        "NonMatchingText": "bob@.com|||bob@-a.smith.com",
        "Description": "Email validation based on Rob Eberhardt's (Thanks, Rob!) email expression, but allows single letter subdomains..."
    },
    {
        "Pattern": "^(\\+48\\s*)?\\d{2}\\s*\\d{3}(\\s*|\\-)\\d{2}(\\s*|\\-)\\d{2}$",
        "MatchingText": "+48222222222|+48 22 3333333|+48 22 842 33 33",
        "NonMatchingText": "+48-22-2222222|+49 22 222222",
        "Description": "Polish stationary phone number. Mask +48 XX XXXXXXX\nor +48 XX-XXX-XX-XX or +48 XXXXXXXXX"
    },
    {
        "Pattern": "^((\\d{3}[- ]\\d{3}[- ]\\d{2}[- ]\\d{2})|(\\d{3}[- ]\\d{2}[- ]\\d{2}[- ]\\d{3}))$",
        "MatchingText": "222-22-22-222 | 222-222-22-22 | 222 22 22 222 | 222 222 22 22",
        "NonMatchingText": "2222222222 | XXXXXXXXXX",
        "Description": "allow to insert input for polish tax identyfication number (NIP). Mask accepted:\nXXX-XX-XX-XXX ; XXX-XXX-XX-XX ; XXX XX XX XXX ; XXX XXX XX XX "
    },
    {
        "Pattern": "^(((\\(\\d{3}\\)|\\d{3})( |-|\\.))|(\\(\\d{3}\\)|\\d{3}))?\\d{3}( |-|\\.)?\\d{4}(( |-|\\.)?([Ee]xt|[Xx])[.]?( |-|\\.)?\\d{4})?$",
        "MatchingText": "(123)-456-7890 Ext 1234 | 123-456-7890 | (123).456.7890 | 123.456.7890 | 1234567890ext1234 | 123-456 7890 X 1234",
        "NonMatchingText": "123)4567890 | 800callcat | 123456789",
        "Description": "with or without area code (of various forms)(does not allow for unbalanced parens in the area code).  With or without an extension (of various forms).  Does not allow for leading or trailing space."
    },
    {
        "Pattern": "(<[^>]*?tag[^>]*?(?:identify_by)[^>]*>)((?:.*?(?:<[ \\r\\t]*tag[^>]*>?.*?(?:<.*?/.*?tag.*?>)?)*)*)(<[^>]*?/[^>]*?tag[^>]*?>)",
        "MatchingText": "<tag name=\"identify_by\">jskdfjkfb</tag>",
        "NonMatchingText": "have a look at the description.",
        "Description": "This Pattern matches a HTML like tag and its closing tag without any childtags, that was identified by an attribute or anything identifiable (?) mark inside the opening tag.\nLook for A as Tag and 1 ans identifier. A greedy expression woulds usualy end at the A 2 closing tag, non-greedy will probably end at the A 3 end tag.\ne.g.:\n&lt;A 1&gt;\n &lt;A 2&gt;\n  &lt;A 2&gt;dfgdfg&lt;/A&gt;\n &lt;/A&gt;\n&lt;Z&gt;&lt;/Z&gt;\n&lt;/A&gt;\n&lt;A 3&gt;\n&lt;/A&gt;\n\nReturns:\n0 Full Match\n1 Whole starttag\n2 Content inside the tag\n3 Whole endtag\n\nP.S.: I use it in a parser, to find tags and add code to them, without to know the code, the content or any further infomation."
    },
    {
        "Pattern": "(?:[\\w]*) *= *\"(?:(?:(?:(?:(?:\\\\\\W)*\\\\\\W)*[^\"]*)\\\\\\W)*[^\"]*\")",
        "MatchingText": "<HTMLTAG onClick=\"jsfunc(\\\"foo\\\")\">",
        "NonMatchingText": "<HTMLTAG onClick sometext>",
        "Description": "This Pattern matches HTML attributes with quoted quotes or other non-word characters correctly. I used it in an parser-engine.\nReplace the quotes in this RX to match other boundaries."
    },
    {
        "Pattern": "(?:(?:http|https)://(?:(?:[^/&=()/\u00A7, ]*?)*\\.)+(?:\\w{2,3})+?)(?:/+[^ ?,'\u00A7$&()={\\[\\]}]*)*(?:\\?+.*)?$",
        "MatchingText": "http://www.test.org|||http://www.test.org/page1|||http://www.test.org/folder/subfolder/page.html?get",
        "NonMatchingText": "http://www.test.org%|||http://www.test.org/hgh(s/|||http://www.test.org/hehe/notallowed&/page1.h",
        "Description": "I don't give a f*** to the RFC, fix it yourself for RFC, I just need a valid webresource location. So add forbidden characters as you need them in the character classes or use it as it is. This RegEx is not for searching valid URLs, just for validating. Look at the trailing $."
    },
    {
        "Pattern": "(?:^(?:-)?(?:\\d{1,3}\\.(?:\\d{3}\\.)*\\d{3})(?:\\,\\d+)?$|^(?:-)?\\d*(?:\\,\\d+)?$)",
        "MatchingText": "10000|12.123|5.123,000|,001|1.000.000|1,00",
        "NonMatchingText": "1.0000|12.12.00|5,123.000|.001|1,000,000|1.00",
        "Description": "This validation forces a value wheter to be strict niced or plain input of a numerical value.\nThe separation per thousand should be a (.) dot and must be used exactly or never to be valid.\nCurrently this RX validates german formed values... Just switch \\, with \\. and vice versa to get valid US results."
    },
    {
        "Pattern": "^([A-Za-z]|[A-Za-z][0-9]*|[0-9]*[A-Za-z])+$",
        "MatchingText": "abc, cba,aaccbbaa, 134abc,a23abc123,abc123",
        "NonMatchingText": "123,1,2,3,4,5,6,7,8,9,0,11,22,33....",
        "Description": "This regular expression accepts any combination of alphabets or alphanumeric."
    },
    {
        "Pattern": "(\\+1|1)?[ \\-\\.]?\\(?(?P<areacode>[0-9]{3})\\)?[ \\-\\.]?(?P<prefix>[0-9]{3})[ \\-\\.]?(?P<number>[0-9]{4})[ \\.]*(ext|x)?[ \\.]*(?P<extension>[0-9]{0,5})",
        "MatchingText": "601-555-1212|601 5551212|+1.6015551212|601 555 1212|601.555.1212x232|601.555.1212ext232|1 601.555.1212ext232|+1 601.555.1212ext232|+1.(601)5551212|(601) 555 1212|601.555.1212x232|601.555.1212 x233|601.555.1212 x 234|601.555.1212 ext 234|601.555.1212 ext. 234",
        "NonMatchingText": "601+555+1212",
        "Description": "This regular expression parses virtually any variety of U.S. phone numbers--with or without an extension. If you want a version without the named groups, you can use: (\\+1|1)?[ \\-\\.]?\\(?[0-9]{3}\\)?[ \\-\\.]?[0-9]{3}[ \\-\\.]?[0-9]{4}[ \\.]*(ext|x)?[ \\.]*[0-9]{0,5} "
    },
    {
        "Pattern": "(http[s]?://)?([A-Za-z0-9-]\\.)*(?P<domainName>([A-Za-z0-9-]+\\.)[A-Za-z]{2,3})/?.$",
        "MatchingText": "http://happycatfish.com/|http://happycatfish.com/our-work",
        "NonMatchingText": "http://happycatfish.comm|http://happycatfish.c",
        "Description": "This regular expression is designed just to extract the domain name from a URL. A domain name may neither start with nor end with a dash. I didn't take the time to add in this check and am actually not sure that it could be easily done. Try it for yourself to understand why."
    },
    {
        "Pattern": "^(|(0\\d)|(1[0-2])):(([0-5]\\d)):(([0-5]\\d))\\s([AP]M)$",
        "MatchingText": "11:59:59 AM, 00:59:59 PM",
        "NonMatchingText": "13:59:59, 11:45:60",
        "Description": "This will validate only time."
    },
    {
        "Pattern": "\\d{2}(1[012]|0[0-9])(3[01]|[012]\\d)\\d{6}",
        "MatchingText": "980101026512 631222146325 550331026589",
        "NonMatchingText": "551330016598 442122668888 abcdefghijkl",
        "Description": "To verify the Malaysia new I/C number."
    },
    {
        "Pattern": "(::|(([a-fA-F0-9]{1,4}):){7}(([a-fA-F0-9]{1,4}))|(:(:([a-fA-F0-9]{1,4})){1,6})|((([a-fA-F0-9]{1,4}):){1,6}:)|((([a-fA-F0-9]{1,4}):)(:([a-fA-F0-9]{1,4})){1,6})|((([a-fA-F0-9]{1,4}):){2}(:([a-fA-F0-9]{1,4})){1,5})|((([a-fA-F0-9]{1,4}):){3}(:([a-fA-F0-9]{1,4})){1,4})|((([a-fA-F0-9]{1,4}):){4}(:([a-fA-F0-9]{1,4})){1,3})|((([a-fA-F0-9]{1,4}):){5}(:([a-fA-F0-9]{1,4})){1,2}))",
        "MatchingText": "2001:470:b0b4:1:280:c6ff:fef2:9410|||2001:868:100::3|||2001:888:144a::a441:888:1002|||::1||a:b::|||::FFFF:1.2.3.4",
        "NonMatchingText": "1:2:3:4:5:6:7:8:9|||a::b::c|||x:x:x:x:x:x:x:x",
        "Description": "This RE recognizes IPv6 addresses for all the representations described by RFC 2373:\n1) extended format (with both upper and lowercase HEX)\n2) compressed format (eg 2001::6:a)\n3) IPv4-embedded format (eg ::ffff:1.2.3.4) limited to addresses of the traditional dual-stack configuration\n\nResulting from observation of real-world implementations, case 2) is extended to allow \"::\" for one 0-group alone. Although the RFC is clear on \"::\" being for \"multiple groups of 16-bits of zeros\" only, some tools like \"dig\" for the mac produce those values.\n\nThe RE is simple and quite elegant; it has been tested on over 300 IPv6 addresses collected by dig-ing IPv6-enabled domains; it is used in sshguard's log parser, see http://www.sshguard.net ."
    },
    {
        "Pattern": "((19|20)[0-9]{2})-(([1-9])|(0[1-9])|(1[0-2]))-((3[0-1])|([0-2][0-9])|([0-9]))",
        "MatchingText": "2008-12-15",
        "NonMatchingText": "1556/9/8",
        "Description": "Validate the year month and day."
    },
    {
        "Pattern": "^1+0+$",
        "MatchingText": "10|||110|||1100",
        "NonMatchingText": "0|||01|||101",
        "Description": "A simple regular expression to determine if a subnet mask is contiguous; that is, the submask must start with a 1 bit followed by 0 or more 1 bits, followed by 1 or more 0 bits until the end of the submask."
    },
    {
        "Pattern": "^[a-z]+([\\d_-]*[a-z]+)*@[a-z]{2,}(\\.)[a-z]{2,}(\\.[a-z]{2})?$",
        "MatchingText": "t@alright.com ||| test1ok@alright.com.ha ||| t-e-s-t1_ok@alright.com.ha",
        "NonMatchingText": "test1@alright.com ||| test-@alright.com ||| _test@alright.com ||| test@alright.com.ha.ha",
        "Description": "Starting to learn, so:\n\n1.(one or more)letters\n2.(optional) \"-\", \"_\", numbers + (one or more)letters\n3.\"@\"\n4.(two or more)letters\n5.\".\"\n6.(two or more)letters\n7.(optional) \".\" + (two)letters"
    },
    {
        "Pattern": "^\\$[+-]?([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(\\.[0-9]{1,2})?$",
        "MatchingText": "$-1|||$-1.0|||$1,234.42",
        "NonMatchingText": "anything that doesn't start with $|||$.13|||$2.",
        "Description": "This expression is little tricky since the $ sign is includeded in the\n\t\texpression itself. So whenever you want to make use of the expression be\n\t\tsure to prepend $ sign to the value if it's not present."
    },
    {
        "Pattern": "^http[s]?://([a-zA-Z0-9\\-]+\\.)*([a-zA-Z]{3,61}|[a-zA-Z]{1,}\\.[a-zA-Z]{2})/.*$",
        "MatchingText": "http://www.google.com/;http://google.com/;http://code.google.com/;http://google.co.uk/;http://tx.us/",
        "NonMatchingText": "http://www.google.com; ",
        "Description": "Used for matching a URL and can be used for extracting the domain name from a given URL ending with '/'.\n\nConcat $2 and $3 to get the domain name.\n\n"
    },
    {
        "Pattern": "[0-9]{4}[0-3]{1}[0-9}{1}[0-9]{5}",
        "MatchingText": "44051401458|||77020201233|||88101006122",
        "NonMatchingText": "44059901458|||77028801233|||88109006122",
        "Description": "Polish national ID number PESEL (Powszechny Elektroniczny System Ewidencji Ludnosci)."
    },
    {
        "Pattern": "^(http(s?)\\:\\/\\/)?(www.)?(([A-Za-z]+)([0-9]+)?([A-Za-z0-9\\.\\_\\-]+)?)(\\.)(([a-zA-Z]{2,})([0-9a-zA-Z]+)?)(\\:\\d{0,5})?(\\/|(\\/[A-Za-z]+([a-zA-Z0-9]+)?)+)?(\\?[a-zA-Z0-9\\\\\\&\\%\\_\\.\\/\\-\\=\\~\\*]+)?$",
        "MatchingText": "https://www.test.com|||https://www.test.com/|||https://test.com|||https://test.com/|||http://test.com|||www.test.com|||www.test.com/|||test.com|||test.com|||test069.com|||test.test.com|||test01.test01.com|||test.test.co|||test.com:1|||test.cm:12345|||www.xa.com/abc/a|||www.xa.com/abc|||test.com/con1/method1|||w.google.com|||google.com?te-st=xyz|||oogle.com?test=xyz|||google.com?test=|||google.com?test|||google.com?test=xyz&text|||google.com?test=xyz&text=t&*5",
        "NonMatchingText": "*.google.com|||goole.com/*|||.google.com|||google.com?|||google.com/?|||google.co-m|||@.google.com|||ftp://test.com|||test test.com|||www.xa.com/ab c/a|||test.com:123456|||//test.com|||test.test.c|||01test.test.com|||test.c|||test.test.|||http://www.test.c|||01test.com|||test.01|||",
        "Description": "Web Url validation using regex. need mult-line option"
    },
    {
        "Pattern": "(15(8[48]|9[26]))|((1[6-9]|[2-9]\\d)(0[48]|[13579][26]|[2468][048]))|(([2468][048]|16|3579[26])00)",
        "MatchingText": "1584, 2000, 2048",
        "NonMatchingText": "1200, 1580, 1941, 1800",
        "Description": "Validates four-digit leap years after 1582 (when Pope Gregory XIII switched to the Gregorian calendar). The last recognized leap year is 9996, so no worries with the y3k bug."
    },
    {
        "Pattern": "[a-zA-Z]*( [a-zA-Z]*)?",
        "MatchingText": "John, John Smith, Danilo Guedes",
        "NonMatchingText": "Captain John Smith, John 12, 123",
        "Description": "simple Name or Full Name pattern."
    },
    {
        "Pattern": "(\\d{2}\\.\\d{3}\\.\\d{3}\\/\\d{4}\\-\\d{2})|(\\d{3}\\.\\d{3}\\.\\d{3}\\-\\d{2})",
        "MatchingText": "12.123.123/1234-11  |  123.123.123-12",
        "NonMatchingText": "qualquer letra",
        "Description": "Valida e mascara CNPJ ou CPF dependendo do valor informado. Se informado dois digitos mais o ponto, ser\u00E1 mascarado CNPJ se nao , CPF"
    },
    {
        "Pattern": "^((\\d{0,1}[0-9](\\.\\d{0,1}[0-9])?)|(100))$",
        "MatchingText": "00.00 | 00 | 99.99 | 99.5 | 100",
        "NonMatchingText": "99. | 100.1",
        "Description": "Allow Percentage with optional scale (max length of 2) between (00.00 and 100)"
    },
    {
        "Pattern": "&lt;[^&gt;]*\\n?.*=(&quot;|')?(.*\\.jpg)(&quot;|')?.*\\n?[^&lt;]*&gt;",
        "MatchingText": "&lt;td background=&quot;../img/img.jpg&quot; &gt;|||&lt;img src=img.jpg &gt;|||&lt;img src='img.jpg'",
        "NonMatchingText": "= img.jpg|||img.jpg",
        "Description": "Match any image insert in a tag .\nsimply replace the .jpg in the pattern whit a variable of content type ex:.swf,.js,.gif and loop the pattern to retrieve all tag whit the contenttype pass trought....\n\nVery useful when you have people uploading html document in your site and you want to retrieve all dependecy."
    },
    {
        "Pattern": "([A-Z]:\\\\[^/:\\*;\\/\\:\\?<>\\|]+)|(\\\\{2}[^/:\\*;\\/\\:\\?<>\\|]+)",
        "MatchingText": "C:\\ValidFolder  C:\\ValidFolder\\SubFolder \\\\ValidShare \\\\ValidShare\\Subfolder",
        "NonMatchingText": "C:\\Inval:idPath InvalidFolder\\Subfolder D:\\Invalid*Folder",
        "Description": "This regex will validate whether the value is a valid directory path. "
    },
    {
        "Pattern": "^([a-zA-Z.\\s']{1,50})$",
        "MatchingText": "Jon M. Doe|||Tim L. O'Doul|||...'''''",
        "NonMatchingText": "Doe, Jon|||&lt;&gt;,;:&quot;?/|||%\\$#@!",
        "Description": "This is just a regular special char expression used to get the hax0rs off your back (hopefully).  You can use this for regular open name checking if you wanted.  It only fails on the insert of anything other than a-z, A-Z, and ' or whitespace. I'm open to suggestions, but try to email them to me as well as posting them to help others.  Thanks."
    },
    {
        "Pattern": "([a-zA-Z]{1}[a-zA-Z]*[\\s]{0,1}[a-zA-Z])+([\\s]{0,1}[a-zA-Z]+)",
        "MatchingText": "abc XYZ PqR",
        "NonMatchingText": "ABC     pQr xxx    a",
        "Description": "This Regular expression will simply not allow more than a single space to be entered between two words of a sentence.It will also prohibit user to enter space at the begining and at the end of a sentence.It will require a minimum of juz 2 alphabets for making it a valid expression\n-By Swapnil Shejul"
    },
    {
        "Pattern": "((^[0-9]*).?((BIS)|(TER)|(QUATER))?)?((\\W+)|(^))(([a-z]+.)*)([0-9]{5})?.(([a-z\\'']+.)*)$",
        "MatchingText": "48 bis Avenue Des Champs \u00C9lys\u00E9e 75001 Paris",
        "NonMatchingText": "Rue De La Libert\u00E9 10 1000 Bruxelle",
        "Description": "Find differents parts of a french mail's address.\n\n0       : Complete address\n1       : Number + BIS, TER or QUATER\n2       : Number\n3 et 4  : BIS, TER or QUATER\n5 \u00E0 9   : Nothing\n10      : Street\n11      : Nothing\n12      : Postal code\n13      : City"
    },
    {
        "Pattern": "^(([0-9]{1})|([0-9]{1}[0-9]{1})|([1-3]{1}[0-6]{1}[0-5]{1}))d(([0-9]{1})|(1[0-9]{1})|([1-2]{1}[0-3]{1}))h(([0-9]{1})|([1-5]{1}[0-9]{1}))m$",
        "MatchingText": "365d23h59m ||| 90d18h45m ||| 05d19h45m",
        "NonMatchingText": "366d23h45m ||| 90d24h5m ||| 90d6h60m",
        "Description": "Duration validation similar to MS Project (5d16h45m, etc).  Does not allow more than 365 days, 23 hrs or 59 min."
    },
    {
        "Pattern": "^[a-zA-Z]+(([\\'\\,\\.\\- ][a-zA-Z ])?[a-zA-Z]*)*\\s+&lt;(\\w[-._\\w]*\\w@\\w[-._\\w]*\\w\\.\\w{2,3})&gt;$|^(\\w[-._\\w]*\\w@\\w[-._\\w]*\\w\\.\\w{2,3})$",
        "MatchingText": "Mohit &lt;myadav@yahoo.com&gt;|||Xon &lt;JON@jon.com&gt;|||Xon@something.com",
        "NonMatchingText": "mohit&lt;myadav@yahoo.com&gt;|||Xon &lt;JON@jon.com&gt;, tom &lt;jon@jon.com&gt;|||Xon@somthing.com,",
        "Description": "This Works good until we want a multiple email address validator, I am working on it to make it work with the multiple email address, If anyone can work on this part as to validate a multiple email address then that will produce a very good expression, i think the best of this kind. AIM - to Validate Mohit &lt;myadav@yahoo.com&gt;; Rohit &lt;ryadav@yahoo.com&gt;; .........(any number of times)"
    },
    {
        "Pattern": "Kamagra f\u00FCr h\u00E4ufigste sexuelle Problem bei M\u00E4nnern",
        "MatchingText": "Health",
        "NonMatchingText": "Health institute",
        "Description": "Paare zahlreiche Male das Handtuch werfen im Hinblick auf die Gr\u00FCnde, die mit ihrem Kamagra bestellen http://www.kamagrakaufensie.com/ romantischen Koexistenz identifiziert. Ein romantisches Thema, zum Beispiel, erektile Dysfunktion, das vorstehend als Schw\u00E4che bekannt ist, kann ein Grund sein, auch. Erektile Dysfunktion ist ein Problem, das erectional ein Mann seine Selbstsicherheit und selfregard verlieren macht. Aber es gibt ein solches Medikament f\u00FCr M\u00E4nner, die es Ausdauer Kamagra kaufen Medizin bekannt zu erh\u00F6hen. Es hilft, zu reduzieren gibt Erektion Problem & Ausdauer zu erh\u00F6hen gibt es wie fr\u00FChen Sorten."
    },
    {
        "Pattern": "^[^\\s]+@[^\\.][^\\s]{1,}\\.[A-Za-z]{2,10}$",
        "MatchingText": "foo-bar@foo.the.20.bars.com",
        "NonMatchingText": "foo bar@foo.com | foobar@.com | foo@bar.c",
        "Description": "Simple email regex following some liberal email address validation. Requires non-whitespace name (but allows any other character), an @ symbol, then a non-period character, then some non-whitespace text (but allows just about everything else), and finishes with a tld that is 2 to 10 chars long. Two-characters is the universal minimum, 10 seemed like a good upper limit for now and allows room to grow. You can use this for a quick sanity check. Yes, the user can still enter invalid email addys, but then they won't get their emails, will they?"
    },
    {
        "Pattern": "^[-]?([1-9]{1}[0-9]{0,}(\\.[0-9]{0,2})?|0(\\.[0-9]{0,2})?|\\.[0-9]{1,2})$",
        "MatchingText": "123 | 123.54 | -.54",
        "NonMatchingText": "123.543 | 0012 | 1,000.12",
        "Description": "This regular expression will match on a real / decimal / floating point / numeric string with no more than 2 digits past the decimal. The negative sign (-) is allowed. No leading zeroes or commas. It is based on a currency regular expression by Tom Persing."
    },
    {
        "Pattern": "(\\+)?([-\\._\\(\\) ]?[\\d]{3,20}[-\\._\\(\\) ]?){2,10}",
        "MatchingText": "(604) 789-0136 | +123-45678-908",
        "NonMatchingText": "01.12.23",
        "Description": "Telephone number filter - use to catch and replace phone numbers where you don't want them to appear."
    },
    {
        "Pattern": "^((([sS][r-tR-Tx-zX-Z])\\s*([sx-zSX-Z])?\\s*([a-zA-Z]{2,3}))?\\s*(\\d\\d)\\s*-?\\s*(\\d{6,7}))$",
        "MatchingText": "SR BH 97-578613|||97578613|||SRXBH97578613",
        "NonMatchingText": "RR BH 97-578613|||9757861|||SRAABH 97-578613",
        "Description": "California Resale License number validator. Validates Letters and Numbers or Number only. Letters: First 2 letters can be SR, SS, ST , SX, SY, SZ (TAT Code)  Next optional letter can be S,X,Y,Z.  Next letters must be a minimum of two and a maximum of 3 (District Code).  Numbers:  Can be 8-9 numbers. Numbers can be delimited with a hypen or spaces after the first 2 numbers.  Note: I use () to extract the information I want for use in other scripts."
    },
    {
        "Pattern": "^(1\\s*[-\\/\\.]?)?(\\((\\d{3})\\)|(\\d{3}))\\s*[-\\/\\.]?\\s*(\\d{3})\\s*[-\\/\\.]?\\s*(\\d{4})\\s*(([xX]|[eE][xX][tT])\\.?\\s*(\\d+))*$",
        "MatchingText": "2405525009|||1(240) 652-5009|||240/752-5009 ext.55",
        "NonMatchingText": "(2405525009|||2 (240) 652-5009",
        "Description": "This regular expressions matches phone numbers with area codes and optional US country code and optional phone extension.  User have so many ways of entering phone numbers into input fields.  This allows for some of the ones I've encountered.  Feel free to contact me if you find ones that do not match."
    },
    {
        "Pattern": "^([0-9a-fA-F]{4}|0)(\\:([0-9a-fA-F]{4}|0)){7}$",
        "MatchingText": "3e4f:123f:c12a:5566:888e:9975:aaff:2344|||3e4f:123f:c12a:0:0:0:0:2344|||0000:0000:0000:0000:0000:000",
        "NonMatchingText": "3e4f:123f:c12a:5566:888e:9975:aafg:2344|||3e4f:123f:c12a:0:0:0:1:2344|||0000:0000:0000:0000:0000:000",
        "Description": "IPv6 address (128 bit). Matches hexadecimal patterns and single 0 in the address."
    },
    {
        "Pattern": "^(102[0-3]|10[0-1]\\d|[1-9][0-9]{0,2}|0)$",
        "MatchingText": "0|||123|||1023",
        "NonMatchingText": "1024|||9999|||99999",
        "Description": "Port Numbers: Well Known Ports: 0 through 1023.  Matches numbers in range of 0 through 1023."
    },
    {
        "Pattern": "^(4915[0-1]|491[0-4]\\d|490\\d\\d|4[0-8]\\d{3}|[1-3]\\d{4}|[2-9]\\d{3}|1[1-9]\\d{2}|10[3-9]\\d|102[4-9])$",
        "MatchingText": "1024|||49151|||30100",
        "NonMatchingText": "1023|||49152|||50000",
        "Description": "Port Numbers: Registered Ports: 1024 through 49151.  Matches numbers in range of 1024 through 49151."
    },
    {
        "Pattern": "^(6553[0-5]|655[0-2]\\d|65[0-4]\\d\\d|6[0-4]\\d{3}|5\\d{4}|49[2-9]\\d\\d|491[6-9]\\d|4915[2-9])$",
        "MatchingText": "49152|||65535|||50000",
        "NonMatchingText": "49151|||65536|||66000",
        "Description": "Port Numbers: Dynamic and/or Private Ports: 49152 through 65535.  Matches numbers in range of 49152 through 65535."
    },
    {
        "Pattern": "^(4915[0-1]|491[0-4]\\d|490\\d\\d|4[0-8]\\d{3}|[1-3]\\d{4}|[1-9]\\d{0,3}|0)$",
        "MatchingText": "0|||1023|||49151",
        "NonMatchingText": "49152|||50000|||60000",
        "Description": "Port Numbers: Well Known Ports &amp; Registered Ports: 0 through 49151.  Matches numbers in range of 0 through 49151."
    },
    {
        "Pattern": "^(6553[0-5]|655[0-2]\\d|65[0-4]\\d\\d|6[0-4]\\d{3}|[1-5]\\d{4}|[1-9]\\d{0,3}|0)$",
        "MatchingText": "1023|||49151|||65535",
        "NonMatchingText": "65536|||66000|||67000",
        "Description": "Port Numbers: Well Known Ports, Registered Ports &amp; Dynamic and/or Private Ports: 0 through 65536.  Matches numbers in range of 0 through 65536."
    },
    {
        "Pattern": "^((0?[1-9]|1[012])(\\s*:\\s*([0-5]\\d))?(\\s*:\\s*([0-5]\\d))?(\\s*([AaPp])[Mm]?)$|(2[0-3]|[1]\\d|0?\\d)(\\s*:\\s*([0-5]\\d))(\\s*:\\s*([0-5]\\d))?)$",
        "MatchingText": "3:00:59|||12pm|||6:30 a",
        "NonMatchingText": "12|||25pm|||6:60 a",
        "Description": "Matches a time string.  A loose validation for easy user entry. Saves the information needed for a correct time setting."
    },
    {
        "Pattern": "^#(\\d{6})|^#([A-F]{6})|^#([A-F]|[0-9]){6}",
        "MatchingText": "#000000|#FFFFFF|#000FFF|#FFF000|#A1B2C3",
        "NonMatchingText": "#ffffff|#ABC|#123|#AJKSDD|#a1b2c3|abcdef|123456",
        "Description": "Hexadecimal color values to validate the system must begin with a # symbol, which can be combination of numbers and letters AF, but the letters must be uppercase."
    },
    {
        "Pattern": "^\\s*([\\(]?)\\[?\\s*\\d{3}\\s*\\]?[\\)]?\\s*[\\-]?[\\.]?\\s*\\d{3}\\s*[\\-]?[\\.]?\\s*\\d{4}$",
        "MatchingText": "6105551515|||(610) 555 - 1212|||[610]555.1212",
        "NonMatchingText": "1 (610) 555-1212|||(610) 555-1212 ext*",
        "Description": "US 10-Digit Phone number matching.\n*Requires Area Code\n*Brackets optional, supports: () and []\n*seperators optional, supports: - and .\n*whitespace optional"
    },
    {
        "Pattern": "^[A-Z]{2}[0-9]{6}[A-DFM]{1}$",
        "MatchingText": "AB123456D|||AB123456F|||AB123456M",
        "NonMatchingText": "AB123456E|||ab123456d",
        "Description": "UK National Insurance Number (NINO) validation. (The following modifications have been made: Only A to D are permitted as the last letter, and all letters should be in uppercase. For temporary numbers F and M are permitted for female and male holders.)"
    },
    {
        "Pattern": "^[A-Z]{1,2}[1-9][0-9]?[A-Z]? [0-9][A-Z]{2,}|GIR 0AA$",
        "MatchingText": "G1 1AA |||GIR 0AA|||SW1 1ZZ",
        "NonMatchingText": "BT01 3RT|||G111 1AA",
        "Description": "Matches UK postcodes according to the following rules 1. LN NLL eg N1 1AA 2. LLN NLL eg SW4 0QL 3. LNN NLL eg M23 4PJ 4. LLNN NLL eg WS14 0JT 5. LLNL NLL eg SW1N 4TB 6. LNL NLL eg W1C 8LQ. Modifications: 1) Doesn't allow leading zeros in first part (outward) eg BT01 3RT is incorrect; it should be BT1 3RT. 2) Only allows uppercase letters, which is the preference of the UK Post Office. 3) Permits the only postcode to break the rules - GIR 0AA (for the old Girobank, now Alliance &amp; Leicester bank, address)"
    },
    {
        "Pattern": "(\\$(([0-9]?)[a-zA-Z]+)([0-9]?))",
        "MatchingText": "$FirstName ||| $4LastName ||| $PlantName3",
        "NonMatchingText": "$-FirstName ||| $LastName-23 ||| $#PlantName",
        "Description": "Matches token words based on the use of a \"$\" (USD) prefix."
    },
    {
        "Pattern": "^([a-zA-Z0-9][a-zA-Z0-9_]*(\\.{0,1})?[a-zA-Z0-9\\-_]+)*(\\.{0,1})@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.)|([a-zA-Z0-9\\-]+(\\.([a-zA-Z]{2,10}))(\\.([a-zA-Z]{2,10}))?(\\.([a-zA-Z]{2,10}))?))[\\s]*$",
        "MatchingText": "myemail@mail.com | my.email@mail.co.in | 1stmyemail@gmail.com | my.email.address@mail.com | my.email@in.mycompany.com | my.email@city.mycompany.com",
        "NonMatchingText": "my.b.email@gmail.com ",
        "Description": "Validates almost all email addresses. Tested and running fine on a major web portal"
    },
    {
        "Pattern": "/^[a-zA-Z\\s]+$/",
        "MatchingText": "test | TEST | Test",
        "NonMatchingText": "1Test",
        "Description": "Accepts only characters in small and caps."
    },
    {
        "Pattern": "^[a-zA-Z][0-9][a-zA-Z]\\s?[0-9][a-zA-Z][0-9]$",
        "MatchingText": "T2p 3c7|||T3P3c7|||T2P 3C7",
        "NonMatchingText": "123456|||3C7T2P|||11T21RWW",
        "Description": "Match Canadia Zip Code. You can have a space in the middle Like T2P 3C7, or no space like T2P3C7"
    },
    {
        "Pattern": "^((\\d{5}-\\d{4})|(\\d{5})|([A-Z]\\d[A-Z]\\s\\d[A-Z]\\d))$",
        "MatchingText": "44240|||44240-5555|||T2P 3C7",
        "NonMatchingText": "44240ddd|||t44240-55|||t2p3c7",
        "Description": " This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits. The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9.  "
    },
    {
        "Pattern": "(?P<Code>[\\s\\S]*?)(?P<NonCode>'.*?\\r?\\n|(?P<quot>\"|')(?:(?:(\\<quot>).|\\<quot>{2})*)(?:\\<quot>))",
        "MatchingText": "Response.Write \"my \"\"quoted\"\" string\"  ' some comment",
        "NonMatchingText": "..",
        "Description": "This expression matches all VBScript or VB code. Line comments (with ') and strings are inlcuded in named groups. Strings with double quotes (i.e. \"this is my \"\"string\"\".\") is supported. Expression is only tested with RegEx for .net 2.0."
    },
    {
        "Pattern": "(?P<Code>[\\s\\S]*?)(?P<Comment>'.*?\\r?\\n|(?P<quot>\"|')(?:(?:(\\<quot>).|\\<quot>{2})*)(?:\\<quot>))",
        "MatchingText": "<vbcode>",
        "NonMatchingText": "...",
        "Description": "This matches all code in a VBScript or VB code. Line comments (with ') and strings are inlcuded in named groups."
    },
    {
        "Pattern": "((\\+351|00351|351)?)(2\\d{1}|(9(3|6|2|1)))\\d{7}",
        "MatchingText": "217896545 ||| +351214563214 ||| 917894125 ||| 00351917896352",
        "NonMatchingText": "dfsdfdf9122222 ||| 528521445 ||| +6542544545",
        "Description": "Validates mobile and land-line numbers. Also validates international Portuguese code +351."
    },
    {
        "Pattern": "^\\\\(\\\\[\\w-]+){1,}(\\\\[\\w-()]+(\\s[\\w-()]+)*)+(\\\\(([\\w-()]+(\\s[\\w-()]+)*)+\\.[\\w]+)?)?$",
        "MatchingText": "\\\\server\\directory\\|||\\\\server\\directory with space|||\\\\server\\directory1\\directory2\\file1.xxx",
        "NonMatchingText": "c:\\directory|||c:\\directory\\file.xx|||\\\\server\\\\directory\\file.xx.xx",
        "Description": "Validates UNC Paths, with or without files. Does not validate on shares ($) or local files (c:\\xxx). \n\nThanks to Erlend Oftedal for helping me out with this one!"
    },
    {
        "Pattern": "^((((19|20)(([02468][048])|([13579][26]))-02-29))|((20[0-9][0-9])|(19[0-9][0-9]))-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))$",
        "MatchingText": "2002-01-31|||1997-04-30|||2004-01-01",
        "NonMatchingText": "2002-01-32|||2003-02-29|||04-01-01",
        "Description": "Based on some of the other patterns on RegExpLib. This is the ISO way of writing dates."
    },
    {
        "Pattern": "^(([0-9]{3})[ \\-\\/]?([0-9]{3})[ \\-\\/]?([0-9]{3}))|([0-9]{9})|([\\+]?([0-9]{3})[ \\-\\/]?([0-9]{2})[ \\-\\/]?([0-9]{3})[ \\-\\/]?([0-9]{3}))$",
        "MatchingText": "031 123 456|||031-123-456|||031/123/456|||031123456|||+386 31 123 456|||+38631 123 456|||+386-41-041-041|||+386/41/041/041|||386 41 041 041|||38641041041",
        "NonMatchingText": "0038631123456",
        "Description": "I'm using this to match Slovenian phone numbers. It's a bit rusty... If you have better version or updated please send it to me."
    },
    {
        "Pattern": "ICON=\"[^\"]+\"",
        "MatchingText": "<DT><A HREF=\"http://www.gmail.com/\" ADD_DATE=\"1147950005\" LAST_MODIFIED=\"1147950022\" ICON_URI=\"https://mail.google.com/favicon.ico\" ICON=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAiElEQVQ4jdWPsQ3AIAwEGYtZ2IZpvIGHoaRLm47q0wCyiY2SKspL3/mOJ4T/p8SI0TNnNKJtz5whGSUoMQLMcMOM9T7I14+UfEmHj5TUiikA4EsWGIAtMCUGvBWAWUkULFbZglrRiJREwo0IqNURDLgfjO/I2fLmJlhhN11iLngcb8GbTsHnuQAHliL7fehqZAAAAABJRU5ErkJggg==\" LAST_CHARSET=\"UTF-8\">Google Mail</A>",
        "NonMatchingText": "<DT><A HREF=\"http://flickr.com/\" ADD_DATE=\"1107635483\" LAST_VISIT=\"1189245562\" LAST_MODIFIED=\"1114539579\" LAST_CHARSET=\"UTF-8\" ID=\"rdf:#$Ppq5x3\">Flickr</A>",
        "Description": "Remove favicon base64 data from Firefox bookmark HTML files, thereby reducing file size (useful for HTML bookmark backup and transfer)."
    },
    {
        "Pattern": "^\\(?\\d{3}?\\)?\\-?\\d{3}?\\-?\\d{4}?$",
        "MatchingText": "(425)345-3456",
        "NonMatchingText": "425-234-4444",
        "Description": "Matches US phone numbers with area code inclosed in parents..."
    },
    {
        "Pattern": "https://www.raghuraicenterforphotography.com/\n",
        "MatchingText": "Diploma in Photography",
        "NonMatchingText": "Raghu Rai Center For Photography",
        "Description": "Best Photography college in india, best fashion photography course in india, best photography institute in india.\nMore Info- https://www.raghuraicenterforphotography.com/diploma-in-photography-in-delhi/\n"
    },
    {
        "Pattern": "(^(((GIR)\\s{0,1}((0AA))))|(([A-PR-UWYZ][0-9][0-9]?)|([A-PR-UWYZ][A-HK-Y][0-9][0-9]?)|([A-PR-UWYZ][0-9][A-HJKSTUW])|([A-PR-UWYZ][A-HK-Y][0-9][ABEHMNPRVWXY]))\\s{0,1}([0-9][ABD-HJLNP-UW-Z]{2})$)",
        "MatchingText": "GIR 0AA|||EC4N 4SA|||S25 2XT",
        "NonMatchingText": "GIR 0AB|||QC4C 4SV|||Q25 2XT",
        "Description": "United Kingdom Postcode expression, modified for use with Microsoft.Net regular expression validations.\n( see http://www.govtalk.gov.uk/gdsc/html/frames/PostCode.htm \nand\nhttp://www.govtalk.gov.uk/gdsc/schemas/bs7666-v2-0.xsd )"
    },
    {
        "Pattern": "(^([0-9]|[0-1][0-9]|[2][0-3]):([0-5][0-9])(\\s{0,1})(AM|PM|am|pm|aM|Am|pM|Pm{2,2})$)|(^([0-9]|[1][0-9]|[2][0-3])(\\s{0,1})(AM|PM|am|pm|aM|Am|pM|Pm{2,2})$)",
        "MatchingText": "8am|||8 am|||8:00 am",
        "NonMatchingText": "8a|||8 a|||8:00 a",
        "Description": "Validate \u201CTime\u201D Data to Work with SQL Server\nThis is a fix (I hope) for a problem with the original expression.  It originally allowed any combination of am or pm. For example: ma, aa, mm, mp, etc."
    },
    {
        "Pattern": "/^(8-?|\\+?7-?)?(\\(?\\d{3}\\)?)-?(\\d-?){6}\\d$/",
        "MatchingText": "+7(912)2517699  |  8(912)2517699  |  7(912)2517699 | 7-912-251-76-99 | 8-(912)-251-76-99 | 9122517699 | 8-912-25-17-699 | 7(912)-251-7699 |...",
        "NonMatchingText": "x",
        "Description": "Regular expression for any format Russian mobile phone numbers. Any non-existent format will not work"
    },
    {
        "Pattern": "Ersatzakku f\u00FCr Fujitsu Siemens Amilo Pa 2510? Brandneue 4400mAh Fujitsu Siemens Amilo Pa 2510 Akku ist Ersatz f\u00FCr Laptop-Modelle / Nr. Amilo Pi 2512 ,Amilo Pi 2550 ,Fujitsu Siemens ,Amilo Li 1818 ,Fujitsu Siemens ,Amilo Pa 1510 ,Fujitsu 23GL1GA0F-8A ,Fujitsu L50-3S4000-S1P3...",
        "MatchingText": "http://www.pcakku.com/fujitsu-siemens-amilo-pa-2510-laptop-akku.html",
        "NonMatchingText": "Fujitsu Siemens Amilo Pa 2510 AC Adapter/Netzteil, Notebook Power Charger/Adapter",
        "Description": "Akku f\u00FCr Fujitsu Siemens Amilo Pa 2510, Ersatzakku Fujitsu Siemens Amilo Pa 2510  http://www.pcakku.com/fujitsu-siemens-amilo-pa-2510-laptop-akku.html"
    },
    {
        "Pattern": "Akku f\u00FCr DELL XPS L321X, Ersatzakku DELL XPS L321X",
        "MatchingText": "http://www.pcakku.com/dell-xps-l321x-laptop-akku.html",
        "NonMatchingText": "DELL XPS L321X AC Adapter/Netzteil, Notebook Power Charger/Adapter",
        "Description": "http://www.pcakku.com/dell-xps-l321x-laptop-akku.html Ersatzakku f\u00FCr DELL XPS L321X? Brandneue 47Wh DELL XPS L321X Akku ist Ersatz f\u00FCr Laptop-Modelle / Nr. DELL XPS 13 ,DELL XPS 13-L321X ,DELL XPS 13-L322X ,DELL XPS L321X ,DELL XPS L322X ,DELL Y9N00...\n\n"
    },
    {
        "Pattern": "^[0,1]?\\d{1}\\/(([0-2]?\\d{1})|([3][0,1]{1}))\\/(([1]{1}[9]{1}[9]{1}\\d{1})|([2-9]{1}\\d{3}))$",
        "MatchingText": "01/01/1990|||12/12/9999|||3/28/2001",
        "NonMatchingText": "3-8-01|||13/32/1001|||03/32/1989",
        "Description": "This expression checks the validity of a date (US, but it is easily editable for other format's). Year's 1990-9999, Month's 1 or 01 to 12, Day's 1 or 01 to 31. Still needs to have individual months added (i.e., Feb's 28 days), and some how to check for leap year...the months issue should not be to hard, but the leap year seems like a real chore. Please let me know if you have any suggestions for leap year.\n\n"
    },
    {
        "Pattern": "^[a-zA-Z][a-zA-Z\\-' ]*[a-zA-Z ]$",
        "MatchingText": "Pierre-Francis d'Astier de Weyergans-Migery|Jeanne d'Arc|Nicolas Sarkozy|Charles de Gaulle|Dominique Strauss-Kahn",
        "NonMatchingText": "-tutu|tutu-|'tutu|tutu'|tu1tu|tu*tu|1tutu|tutu*",
        "Description": "Check for person name in database for example.\nA person name is a string compound of letters in upper or lower case and three more typographical characters, the hyphen (-), the simple quote or apostrophe (') and the space. For these three characters, not at the beginning or the end of the string."
    },
    {
        "Pattern": ";?(?:(?:\"((?:[^\"]|\"\")*)\")|([^;]*))",
        "MatchingText": "abc;efg;\"Column with ;\";\"Column with ; and \"\"double quotes\"\"\";;ijk;",
        "NonMatchingText": "abc,efg,'test',ijk",
        "Description": "This expressions parses one line from a CSV file which has been written with Excel. It does cover all variants: simple value, value masked by double quotes (including semicolons between double quotes which don't count) and double quotes masked by double quotes (\"\"). Replace all semicolons within the regex to change the separator character."
    },
    {
        "Pattern": "(^[0-9]*$)(^[a-zA-Z]*$)^([a-zA-Z0-9]{6,15})$",
        "MatchingText": "C2dfeed|||sporttrak1|||11223a",
        "NonMatchingText": "pookie|||d34_fff|||123456",
        "Description": "I built this expression to test a string in ASP for valid username and password constraints.  It can be adapted for any number of scenerios.  For instance in this case, we needed to ensure the username someone wanted was not all numbers or all letters and was 6-15 characters in length with no special characters.  This expression tests negatively for all number cases, then all letter cases, and lastly tests for only alphanumeric characters in the required range.  In other words: the match must be alphanumeric with at least one number, one letter, and be between 6-15 character in length.  "
    },
    {
        "Pattern": "^[0-9]{10}$|^\\(0[1-9]{1}\\)[0-9]{8}$|^[0-9]{8}$|^[0-9]{4}[ ][0-9]{3}[ ][0-9]{3}$|^\\(0[1-9]{1}\\)[ ][0-9]{4}[ ][0-9]{4}$|^[0-9]{4}[ ][0-9]{4}$",
        "MatchingText": "9999 999 999|||(09) 9999 9999|||99999999",
        "NonMatchingText": "99999999999|||9999999|||(99)99999999",
        "Description": "Australian phone numbers including Mobiles and common spacing used. This is used only to test normal contact numbers for residential purposes for example not information lines like 139999.\n\nOther Matching:\n9999999999, 9999 9999, (09)99999999"
    },
    {
        "Pattern": "^(?:(?:0?[1-9])|(?:[12]\\d)|3[01])/(?:(?:0?[1-9])|(?:1[012]))/(?:(?:19|20))\\d{2}$",
        "MatchingText": "1/2/2000 12/10/1950 21/04/1989 05/01",
        "NonMatchingText": "40/20/2000 32/13/2100",
        "Description": "Matches potentially valid dates (from 1/1/1900 - 31/12/2099), according to European Standard (D/M/Y).\nDOES NOT check whether the date is completely valid (ie 31st Feb will be considered valid by this expression)."
    },
    {
        "Pattern": "A(?:CCESS|LLEY|PPROACH|R(?:CADE|TERY)|VE(?:NUE)?)|B(?:A(?:NK|SIN|Y)|E(?:ACH|ND)|L(?:DG|VD)|O(?:ULEVARD|ARDWALK|WL)|R(?:ACE|AE|EAK|IDGE|O(?:ADWAY|OK|W))|UILDING|YPASS)|C(?:A(?:NAL|USEWAY)|ENTRE(?:WAY)?|HASE|IRC(?:LET?|U(?:IT|S))|L(?:OSE)?|O(?:MMON|NCOURSE|PSE|R(?:NER|SO)|UR(?:SE|T(?:YARD)?)|VE)|R(?:ES(?:CENT|T)?|IEF|OSS(?:ING)?)|U(?:LDESAC|RVE))|D(?:ALE|EVIATION|IP|OWNS|R(?:IVE(?:WAY)?)?)|E(?:ASEMENT|DGE|LBOW|N(?:D|TRANCE)|S(?:PLANADE|TATE)|X(?:P(?:(?:RESS)?WAY)|TENSION))|F(?:AIRWAY|IRETRAIL|O(?:LLOW|R(?:D|MATION))|R(?:(?:EEWAY|ONT(?:AGE)?)))|G(?:A(?:P|RDENS?|TE(?:S|WAY)?)|L(?:ADE|EN)|R(?:ANGE|EEN|O(?:UND|VET?)))|H(?:AVEN|E(?:ATH|IGHTS)|I(?:GHWAY|LL)|UB|WY)|I(?:NTER(?:CHANGE)?|SLAND)|JUNCTION|K(?:EY|NOLL)|L(?:A(?:NE(?:WAY)?)?|IN(?:E|K)|O(?:O(?:KOUT|P)|WER))|M(?:ALL|E(?:A(?:D|NDER)|WS)|OTORWAY)|NOOK|O(?:UTLOOK|VERPASS)|P(?:A(?:R(?:ADE|K(?:LANDS|WAY)?)|SS|TH(?:WAY)?)|DE|IER|L(?:A(?:CE|ZA))?|O(?:CKET|INT|RT)|RO(?:MENADE|PERTY)|URSUIT)?|QUA(?:D(?:RANT)?|YS?)|R(?:AMBLE|D|E(?:ACH|S(?:ERVE|T)|T(?:REAT|URN))|I(?:D(?:E|GE)|NG|S(?:E|ING))|O(?:AD(?:WAY)?|TARY|U(?:ND|TE)|W)|UN)|S(?:(?:ER(?:VICE)?WAY)|IDING|LOPE|PUR|QUARE|T(?:EPS|RAND|R(?:EET|IP))?|UBWAY)|T(?:ARN|CE|ERRACE|HRO(?:UGHWAY|WAY)|O(?:LLWAY|P|R)|RA(?:CK|IL)|URN)|UNDERPASS|V(?:AL(?:E|LEY)|I(?:EW|STA))|W(?:A(?:LK(?:WAY)?|Y)|HARF|YND)",
        "MatchingText": "RD ROAD ROADWAY HIGHWAY HWY",
        "NonMatchingText": "RAD STRET PAS",
        "Description": "Matches any and all matches of the street types detailed at http://www.abs.gov.au/Ausstats/abs@.nsf/66f306f503e529a5ca25697e0017661f/2a46946e38f31d0cca256c62007dbb98!OpenDocument"
    },
    {
        "Pattern": "([A-Z][\\w\\d\\.\\-]+)(?:(?:\\+)([\\w\\d\\.\\-]+))?@([A-Z0-9][\\w\\.-]*[A-Z0-9]\\.[A-Z][A-Z\\.]*[A-Z])",
        "MatchingText": "username+tag@sub.domain.com; username+tag@domain.com; username@sub.domain.com; username@domain.com; user.name@domain.co.uk",
        "NonMatchingText": "a@nowhere",
        "Description": "I got tired of sites not recognising my Gmail account when I used tags, so I created this regexp which allows them to be included. Outputted variables are #1 - Username, #2 - Tag (or blank), #3 - Domain"
    },
    {
        "Pattern": "/(\\d{4})-?(\\d{2})-?(\\d{2})[T\\s]?(\\d{2}):?(\\d{2})(?::?(\\d{2})(\\.\\d+)?)?(Z|(?:([+-]\\d{2})(?::?(\\d{2}))?))?/i",
        "MatchingText": "1978-12-18T17:17:00Z|||1978-12-19T02:17:00+09|||1978-12-18T17:17:00-00:00|||1978-12-18T12:17:00-0500|||1978-12-18 17:17:00|||1978-12-18 17:17:00.021Z|||19781218T171700Z|||19781219T021700+09|||19781218T171700-00:00|||19781218T121700-0500|||19781218 171700|||19781218 171700.021Z",
        "NonMatchingText": "foo|||78-12-18T17:17:00Z|||1978-12|||1978-12-18A",
        "Description": "Parses various timestrings in the ISO8601 (or similar) format into a predictable array of elements.\n\n[1] = Year\n[2] = Month\n[3] = Day\n[4] = Hour\n[5] = Minute\n[6] = Seconds\n[8] = \"Z\" is UTC\n[9] = Timezone Offset Hour\n[10] = Timezone Offset Minute"
    },
    {
        "Pattern": "<body[\\d\\sa-z\\W\\S\\s]*>",
        "MatchingText": "<body>",
        "NonMatchingText": "<br>",
        "Description": "This will find the open body tag regardless of any properties or Event Handlers associated with it. This is great for global implementations  of analytics or anything that needs to be placed after the body tag."
    },
    {
        "Pattern": "^[A-Za-z]{3,4}[ |\\-]{0,1}[0-9]{6}[ |\\-]{0,1}[0-9A-Za-z]{3}$",
        "MatchingText": "LOZG7502123T7|||LOZG-750212-3T7|||LOZ 750212 3T7",
        "NonMatchingText": "LOZG750212",
        "Description": "This Regex matches Mexican RFC's (Registro Federal de Contribuyentes) with 3 or 4 letters in the first section. It accepts spaces and dashes between sections."
    },
    {
        "Pattern": "^[A-Za-z]{4}[ |\\-]{0,1}[0-9]{6}[ |\\-]{0,1}[0-9A-Za-z]{3}$",
        "MatchingText": "LOZG7802117B9|||LOZG-780211-7B9|||LOZG780211-7B9",
        "NonMatchingText": "LO-ZG-78-02-11-7B9",
        "Description": "Regular expression that matches Mexican RFC's (Registro Federal de Contribuyentes)."
    },
    {
        "Pattern": "^\\[assembly: AssemblyVersion\\(\\&quot;([0-9]+)\\.([0-9]+)\\.([0-9]+)\\.([0-9]+)",
        "MatchingText": "[assembly: AssemblyVersion(&quot;1.0.5.5&quot;)]|||[assembly: AssemblyVersion(&quot;1.0.3.5&quot;)]|",
        "NonMatchingText": "[assembly: AssemblyVersion(&quot;1.0.*&quot;)]",
        "Description": "using match.Result(&quot;$1.$2.$3.$4&quot;) \nwill return the assembly version of a given c# AssemblyInfo.cs file"
    },
    {
        "Pattern": "\\d{2}.?\\d{3}.?\\d{3}/?\\d{4}-?\\d{2}",
        "MatchingText": "00.000.000/0000-00|||00000000000000",
        "NonMatchingText": "00-000-000-000-00|||AA.AAA.AAA/AAAA-AA",
        "Description": "This regular expressions matches CNPJ number. CNPJ is a Registration Number of Brazilian Companies."
    },
    {
        "Pattern": "(SELECT\\s[\\w\\*\\)\\(\\,\\s]+\\sFROM\\s[\\w]+)|\n(UPDATE\\s[\\w]+\\sSET\\s[\\w\\,\\'\\=]+)|\n(INSERT\\sINTO\\s[\\d\\w]+[\\s\\w\\d\\)\\(\\,]*\\sVALUES\\s\\([\\d\\w\\'\\,\\)]+)|\n(DELETE\\sFROM\\s[\\d\\w\\'\\=]+)",
        "MatchingText": "SELECT * FROM TABLE|||UPDATE TABLE SET FIELD=VALUE WHERE ID_FIELD=VALUE_ID|||DELETE FROM TABLE WHERE",
        "NonMatchingText": "SELECT TABLE|||UPDATE SET TABLE|||INSERT INTO FIELD=VALUE TABLE",
        "Description": "This RE match the SQL Basics Queries (SELECT, UPDATE, INSERT and DELETE)."
    },
    {
        "Pattern": "^[-+]?\\d+(\\.\\d)?\\d*$",
        "MatchingText": "-3 ||| 3.1231 ||| +972",
        "NonMatchingText": ".3 ||| 51. ||| +3.3.1",
        "Description": "Number(no space or thousand separator with point(.) as decimal delimiter."
    },
    {
        "Pattern": "\\b([0]?[1-9]|[1,2]\\d|3[0,1])[-/]([0]?[1-9]|[1][0,1,2])[-/](\\d{1,2}|[1][9]\\d\\d|[2][0]\\d\\d)\\b",
        "MatchingText": "1/1/1900|||31/12/10|||20/1/1010",
        "NonMatchingText": "33/1/1900|||1/13/1800|||1/1/987",
        "Description": "Validates strings of type dd/mm/yyyy. checking dd to be between 1-31, mm between 1-12 and yyyy between 1900-2099."
    },
    {
        "Pattern": ".*(\\.[Jj][Pp][Gg]|\\.[Gg][Ii][Ff]|\\.[Jj][Pp][Ee][Gg]|\\.[Pp][Nn][Gg])",
        "MatchingText": "foo.gif|foo.jpg|foo.png",
        "NonMatchingText": "foo.txt|foo.zip|foo.exe",
        "Description": "This expression should work to validate that an uploaded file's extension is either jpg, gif, or png."
    },
    {
        "Pattern": "^[$]?[0-9]*(\\.)?[0-9]?[0-9]?$",
        "MatchingText": "4.42|||$4.42",
        "NonMatchingText": "asdf",
        "Description": "Should match prices with or without a dollar sign."
    },
    {
        "Pattern": "^\\d{9}[\\d|X]$",
        "MatchingText": "1234123412|||123412341X",
        "NonMatchingText": "not an isbn",
        "Description": "A very simple ISBN validation expression - it just checks for a 10 digit number where the last digit could also be a capital 'X'.  Complete specs for ISBN available here:\nhttp://www.isbn.org/standards/home/isbn/international/html/usm4.htm.  An enhancement would be to allow exactly 3 or 0 hyphens or 3 or 0 spaces, since these are also valid formats."
    },
    {
        "Pattern": "^(\\d{4}[- ]){3}\\d{4}|\\d{16}$",
        "MatchingText": "1234-1234-1234-1234|||1234 1234 1234 1234|||1234123412341234",
        "NonMatchingText": "Visa|||1234|||123-1234-12345",
        "Description": "Credit card validator.  Just checks that the format is either 16 numbers in groups of four separated by a &quot;-&quot; or a &quot; &quot; or nothing at all."
    },
    {
        "Pattern": "^((4\\d{3})|(5[1-5]\\d{2})|(6011))-?\\d{4}-?\\d{4}-?\\d{4}|3[4,7]\\d{13}$",
        "MatchingText": "6011-1111-1111-1111|||5423-1111-1111-1111|||341111111111111",
        "NonMatchingText": "4111-111-111-111|||3411-1111-1111-111|||Visa",
        "Description": "Matches major credit cards including:\nVisa (length 16, prefix 4), Mastercard (length 16, prefix 51-55), Discover (length 16, prefix 6011), American Express (length 15, prefix 34 or 37).  All 16 digit formats accept optional hyphens (-) between each group of four digits. "
    },
    {
        "Pattern": "^.{4,8}$",
        "MatchingText": "asdf|||1234|||asdf1234",
        "NonMatchingText": "asd|||123|||asdfe12345",
        "Description": "Matches any string between 4 and 8 characters in length.  Limits the length of a string.  Useful to add to password regular expressions."
    },
    {
        "Pattern": "^\\d*$",
        "MatchingText": "123|||000|||43",
        "NonMatchingText": "asbc|||-34|||3.1415",
        "Description": "Accepts an unsigned integer number.  Also matches empty strings."
    },
    {
        "Pattern": "^[-+]?\\d*$",
        "MatchingText": "123|||-123|||+123",
        "NonMatchingText": "abc|||3.14159|||-3.14159",
        "Description": "Matches any integer number or numeric string, including positive and negative value characters (+ or -).  Also matches empty strings."
    },
    {
        "Pattern": "^\\d*\\.?\\d*$",
        "MatchingText": "123|||3.14159|||.234",
        "NonMatchingText": "abc|||-3.14159|||3.4.2",
        "Description": "Matches any unsigned floating point number/numeric string.  Also matches empty strings."
    },
    {
        "Pattern": "^[-+]?\\d*\\.?\\d*$",
        "MatchingText": "123|||+3.14159|||-3.14159",
        "NonMatchingText": "abc|||3.4.5|||$99.95",
        "Description": "Matches any floating point numer/numeric string, including optional sign character (+ or -).  Also matches empty strings."
    },
    {
        "Pattern": "^[a-zA-Z]$",
        "MatchingText": "a|||B|||c",
        "NonMatchingText": "0|||&amp;|||AbC",
        "Description": "Matches any single upper- or lower-case letter."
    },
    {
        "Pattern": "^[a-zA-Z]+$",
        "MatchingText": "abc|||ABC|||aBcDeF",
        "NonMatchingText": "abc123|||mr.|||a word",
        "Description": "Matches any string of only upper- and lower- case letters (no spaces)."
    },
    {
        "Pattern": "^[a-zA-Z0-9]+$",
        "MatchingText": "10a|||ABC|||A3fg",
        "NonMatchingText": "45.3|||this or that|||$23",
        "Description": "Matches any alphanumeric string (no spaces)."
    },
    {
        "Pattern": "^\\d+$",
        "MatchingText": "123|||10|||54",
        "NonMatchingText": "-54|||54.234|||abc",
        "Description": "Positive integer value."
    },
    {
        "Pattern": "^(\\+|-)?\\d+$",
        "MatchingText": "-34|||34|||+5",
        "NonMatchingText": "abc|||3.1415|||-5.3",
        "Description": "Matches any signed integer."
    },
    {
        "Pattern": "^\\w+@[a-zA-Z_]+?\\.[a-zA-Z]{2,3}$",
        "MatchingText": "joe@aol.com|||ssmith@aspalliance.com|||a@b.cc",
        "NonMatchingText": "joe@123aspx.com|||joe@web.info|||joe@company.co.uk",
        "Description": "Simple email expression.  Doesn't allow numbers in the domain name and doesn't allow for top level domains that are less than 2 or more than 3 letters (which is fine until they allow more).  Doesn't handle multiple &quot;.&quot; in the domain (joe@abc.co.uk)."
    },
    {
        "Pattern": "^\\d{1,2}\\/\\d{1,2}\\/\\d{4}$",
        "MatchingText": "4/1/2001|||12/12/2001|||55/5/3434",
        "NonMatchingText": "1/1/01|||12 Jan 01|||1-1-2001",
        "Description": "This regular expressions matches dates of the form XX/XX/YYYY where XX can be 1 or 2 digits long and YYYY is always 4 digits long."
    },
    {
        "Pattern": "^[1-5]$",
        "MatchingText": "1|||3|||4",
        "NonMatchingText": "6|||23|||a",
        "Description": "This matches a single numeric digit between 1 and 5, and is the same as saying ^[12345]$."
    },
    {
        "Pattern": "^[12345]$",
        "MatchingText": "1|||2|||4",
        "NonMatchingText": "6|||-1|||abc",
        "Description": "This matches a single numeric digit between 1 and 5, and is the same as saying ^[1-5]$. "
    },
    {
        "Pattern": "^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$",
        "MatchingText": "joe@aol.com|||joe@wrox.co.uk|||joe@domain.info",
        "NonMatchingText": "a@b|||notanemail|||joe@@.",
        "Description": "This expression matches email addresses, and checks that they are of the proper form.  It checks to ensure the top level domain is between 2 and 4 characters long, but does not check the specific domain against a list (especially since there are so many of them now)."
    },
    {
        "Pattern": "^[2-9]\\d{2}-\\d{3}-\\d{4}$",
        "MatchingText": "800-555-5555|||333-444-5555|||212-666-1234",
        "NonMatchingText": "000-000-0000|||123-456-7890|||2126661234",
        "Description": "This expression matches a hyphen separated US phone number, of the form ANN-NNN-NNNN, where A is between 2 and 9 and N is between 0 and 9."
    },
    {
        "Pattern": "^\\d{5}-\\d{4}|\\d{5}|[A-Z]\\d[A-Z] \\d[A-Z]\\d$",
        "MatchingText": "44240|||44240-5555|||G3H 6A3",
        "NonMatchingText": "Ohio|||abc|||g3h6a3",
        "Description": "This expression matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code.  The first one must be 5 numeric digits.  The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits.  The Canadian postal code must be of the form ANA NAN where A is any uppercase alphabetic character and N is a numeric digit from 0 to 9."
    },
    {
        "Pattern": "^\\d$",
        "MatchingText": "1|||2|||3",
        "NonMatchingText": "a|||324|||num",
        "Description": "Matches exactly 1 numeric digit (0-9)."
    },
    {
        "Pattern": "^\\d{5}$",
        "MatchingText": "33333|||55555|||23445",
        "NonMatchingText": "abcd|||1324|||as;lkjdf",
        "Description": "Matches 5 numeric digits, such as a zip code."
    },
    {
        "Pattern": "^\\d{5}-\\d{4}$",
        "MatchingText": "22222-3333|||34545-2367|||56334-2343",
        "NonMatchingText": "123456789|||A3B 4C5|||55335",
        "Description": "Numeric and hyphen 5+4 ZIP code match for ZIP+4."
    },
    {
        "Pattern": "^\\d{5}$|^\\d{5}-\\d{4}$",
        "MatchingText": "55555-5555|||34564-3342|||90210",
        "NonMatchingText": "434454444|||645-32-2345|||abc",
        "Description": "This regular expression will match either a 5 digit ZIP code or a ZIP+4 code formatted as 5 digits, a hyphen, and another 4 digits.  Other than that, this is just a really really long description of a regular expression that I'm using to test how my front page will look in the case where very long expression descriptions are used."
    },
    {
        "Pattern": "((\\(\\d{3}\\) ?)|(\\d{3}-))?\\d{3}-\\d{4}",
        "MatchingText": "(123) 456-7890|||123-456-7890",
        "NonMatchingText": "1234567890",
        "Description": "US Phone Number -- doesn't check to see if first digit is legal (not a 0 or 1)."
    },
    {
        "Pattern": "[\\w-]+@([\\w-]+\\.)+[\\w-]+",
        "MatchingText": "joe@aol.com|||a@b.c",
        "NonMatchingText": "asdf|||1234",
        "Description": "Yet another simple email validator expression."
    },
    {
        "Pattern": "\\d{4}-?\\d{4}-?\\d{4}-?\\d{4}",
        "MatchingText": "1234-1234-1234-1234|||1234123412341234",
        "NonMatchingText": "1234123412345",
        "Description": "Major credit card validator.  Only checks that the format is 16 digits (optionally separated by hyphens), not the value of any of the digits."
    },
    {
        "Pattern": "[A-Z][a-z]+",
        "MatchingText": "strFirstName|||intAgeInYears|||Where the Wild Things Are",
        "NonMatchingText": "123|||abc|||this has no caps in it",
        "Description": "This expression was developed to match the Title cased words within a Camel cased variable name.  So it will match 'First' and 'Name' within 'strFirstName'."
    },
    {
        "Pattern": "^[-+]?\\d+(\\.\\d+)?$",
        "MatchingText": "123|||-123.45|||+123.56",
        "NonMatchingText": "123x|||.123|||-123.",
        "Description": "This matches any real number, with optional decimal point and numbers after the decimal, and optional positive (+) or negative (-) designation."
    },
    {
        "Pattern": "^(20|21|22|23|[0-1]\\d)[0-5]\\d$",
        "MatchingText": "1200|||1645|||2359",
        "NonMatchingText": "2400|||asbc|||12:45",
        "Description": "This regular expression will match a 24 hour time with no separators."
    },
    {
        "Pattern": "^( [1-9]|[1-9]|0[1-9]|10|11|12)[0-5]\\d$",
        "MatchingText": "1145|||933||| 801",
        "NonMatchingText": "0000|||1330|||8:30",
        "Description": "Matches a 12-hour time value expressed as either 4 numeric digits, 3 numeric digits, or a space and 3 numeric digits.  3 digit times (930) can be expressed with leading 0's (0930) or not.  AM/PM designation is not included in this expression."
    },
    {
        "Pattern": "^(|(0[1-9])|(1[0-2]))\\/((0[1-9])|(1\\d)|(2\\d)|(3[0-1]))\\/((\\d{4}))$",
        "MatchingText": "01/01/2001|||02/30/2001|||12/31/2002",
        "NonMatchingText": "1/1/02|||1/1/2002|||1/25/2002",
        "Description": "This expression matches dates formatted as MM/DD/YYYY where months and days must be 2 digits each, zero padded.  It is not perfect - it allows DD to be from 01 to 31 regardless of the month."
    },
    {
        "Pattern": "^((((0[13578])|(1[02]))[\\/]?(([0-2][0-9])|(3[01])))|(((0[469])|(11))[\\/]?(([0-2][0-9])|(30)))|(02[\\/]?[0-2][0-9]))[\\/]?\\d{4}$",
        "MatchingText": "01/01/2001|||02/29/2002|||12/31/2002",
        "NonMatchingText": "1/1/02|||02/30/2002|||1/25/2002",
        "Description": "Date expressions that matches MM/DD/YYYY where MM and DD must be two digits and zero padded.  Validates correctly for all months except February, which it assumes to always have 29 days.  The &quot;/&quot; separator is optional."
    },
    {
        "Pattern": "^DOMAIN\\\\\\w+$",
        "MatchingText": "DOMAIN\\ssmith|||DOMAIN\\a|||DOMAIN\\username",
        "NonMatchingText": "ssmith|||username|||DOMAIN\\",
        "Description": "In response to a question on the regex list at www.aspadvice.com, this expression should ensure that a login field's username includes a 'DOMAIN\\' prefix.  The latter part of the expression should probably be limited so that it only allows usernames of appropriate lengths, perhaps 3 to 20 characters (by replacing + with {3,20} for instance)."
    },
    {
        "Pattern": "\\.com/(\\d+)$",
        "MatchingText": "http://aspalliance.com/123|||www.aspalliance.com/123|||http://aspalliance.com/34",
        "NonMatchingText": "http://aspalliance.com/article.aspx?id=123|||http://aspalliance.com/|||http://aspalliance.com/articl",
        "Description": "This is a regex I wrote to capture requests to AspAlliance.com with an article id as the only thing after the domain.  So http://aspalliance.com/123 would go to article number 123.  It maps the URL to the actual aspx file that displays the article based on the ID."
    },
    {
        "Pattern": "^([\\s\\S]){1,20}([\\s\\.])",
        "MatchingText": "Any text of any length|||...but will only 'match' the first 20 characters at a period or space.",
        "NonMatchingText": "N/A",
        "Description": "This pattern returns as much of the first x characters of a string as full words or sentences as a match, where x is currently 20. Change x to adjust the length supported in your database field.\nI'm currently using this within a string shortening utility to shrink large text regions to word/sentance-boundary elements and appending an ellipsis as a text continuator."
    },
    {
        "Pattern": "\"<[ \\t]*[iI][mM][gG][ \\t]*[sS][rR][cC][ \\t]*=[ \\t]*['\\\"]([^'\\\"]+)\"",
        "MatchingText": "\"<html><iMG\t                   sRc\t\t= \\\"ricardo.gif\\\" alt=\\\"1\\\"/><img src=\\\"whatever.gif\\\" /><img src               =\\\"teste.gif\\\" alt=\\\"1\\\"/></html>\"",
        "NonMatchingText": "i don\u00B4t know",
        "Description": "Get all images in html string, ignore white space, tabs and is case insensitive. the result is iMG\tsRc\t\t=\"ricardo.gif, after this just split the string and Enjoy it!"
    },
    {
        "Pattern": "^([a-zA-Z][a-zA-Z\\&amp;amp;\\-\\.\\'\\s]*|)$",
        "MatchingText": "muk.dub'ey-j ava",
        "NonMatchingText": "muk_12 dubey`.ja",
        "Description": "This expression will allow Letters, periods, apostrophe, dashes. "
    },
    {
        "Pattern": "^\\s*\\(?((\\+0?44)?\\)?[ \\-]?(\\(0\\))|0)((20[7,8]{1}\\)?[ \\-]?[1-9]{1}[0-9]{2}[ \\-]?[0-9]{4})|([1-8]{1}[0-9]{3}\\)?[ \\-]?[1-9]{1}[0-9]{2}[ \\-]?[0-9]{3}))\\s*$",
        "MatchingText": "0208-123-4567  |  01234-567890  |  (01234) 567890   |  +44 (0)1234 567890  | +044(0)1234567890",
        "NonMatchingText": "208-123-4567  |  012345-67890  | (1234) 567890  |  44 (0)1234 567890  |   +034(0)1234567890",
        "Description": "UK phone number formats with optional international prefix, optional spaces, dashes and brackets. Brackets mandatory for regional/capital leading zero if included in international form. Based on \"Mh\" UK London & Regional. (Thanks Mh for the groundwork).  New to Regex so I'm sure it can be done more elegantly... but it works. "
    },
    {
        "Pattern": "(^\\d{5}\\-\\d{3}$)|(^\\d{2}\\.\\d{3}\\-\\d{3}$)|(^\\d{8}$)",
        "MatchingText": "12.345-678|||12345-678|||12345678",
        "NonMatchingText": "12.345678|||123456789|||12345",
        "Description": "This is a correction from regex by Fernando Cerqueira. It validates brazilian zip codes, aka CEP, with or without mask."
    },
    {
        "Pattern": "(?P<expo>public\\:|protected\\:|private\\:) (?P<ret>(const )*(void|int|unsigned int|long|unsigned long|float|double|(class .*)|(enum .*))) (?P<decl>__thiscall|__cdecl|__stdcall|__fastcall|__clrcall) (?P<ns>.*)\\:\\:(?P<class>(.*)((<.*>)*))\\:\\:(?P<method>(.*)((<.*>)*))\\((?P<params>((.*(<.*>)?)(,)?)*)\\)",
        "MatchingText": "public: void __thiscall myClass::method(int, class myOtherClass * )|||public: void __thiscall myNamespace::myClass::method(void)|||protected: class std::string __cdecl Library::Class::Method(class Param *, enum Type & const)",
        "NonMatchingText": "myfunc(3)|||object::myFunc(9, 4)|||object->method(var)",
        "Description": "Parses a C++ function, including return type, declaration type, namespace, class, method, exposure (public, private, protected) and params."
    },
    {
        "Pattern": "([0-0]{1}[1-9]{1}[0-9]{9})|[1-9]{1}[0-9]{9}",
        "MatchingText": "09242919240, 9242919240",
        "NonMatchingText": "009242919240 ,  0009256662",
        "Description": "it will help u to match valid mobile number with std (including zero) and local(excluding zero).including zero it will accept 11 digit and without zero it will accept 10 digit."
    },
    {
        "Pattern": "(src|href|action)\\s*=\\s*('|\"|(\"|'))((http:|ftp:|mailto:|https:|#))",
        "MatchingText": "href=\"  src = \"pa  href='../",
        "NonMatchingText": "href=\"mailto: href=\"mailto:  src='ftp:",
        "Description": "After hitting little snags through the years here is a  [WIP] for replacing relative links. Notice that it considers whitespace between the src,href and the equal sign, it also considers the  links may not have any quotes around them. It negates  urls that start with http,ftp,link anchors, https and mailto."
    },
    {
        "Pattern": "[0-9][0-9][0-9][0-9]-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])\\s{1}(0[0-9]|1[0-9]|2[0-3]):([0-5][0-9])",
        "MatchingText": "2007-01-01 00:00",
        "NonMatchingText": "2007-1-1   0:0",
        "Description": "Validation of date (YYYY-MM-DD format) and time (HH:MM format) with one space between both blocks. I'm not able (with this) to validate the correct last day of each month. Anyway, it helps :-)"
    },
    {
        "Pattern": "(?:(?:[123]|I{1,3})\\s*)?(?:[A-Z][a-zA-Z]+|Song of Songs|Song of Solomon).?\\s*(?:1?[0-9]?[0-9]):\\s*\\d{1,3}(?:[,-]\\s*\\d{1,3})*(?:;\\s*(?:(?:[123]|I{1,3})\\s*)?(?:[A-Z][a-zA-Z]+|Song of Songs|Song of Solomon)?.?\\s*(?:1?[0-9]?[0-9]):\\s*\\d{1,3}(?:[,-]\\s*\\d{1,3})*)*",
        "MatchingText": "Leviticus 3:3-4 | II Ki. 2:11; 3:12-22, 25 | 2Cor 3:16; Rom. 12:1-5,7,9",
        "NonMatchingText": "Lev chap 3 vv3-4 | 2nd Kings 2:11 | Romans 12",
        "Description": "This RE locates and/or validates standard Bible verse notation."
    },
    {
        "Pattern": "AT&T Customer Service",
        "MatchingText": "https://monktech.net/att-customer-service-phone-number.html",
        "NonMatchingText": "https://monktech.net/att-customer-service-phone-number.html",
        "Description": "Sometimes American Telephone and Telegraph customer might need some technical or nontechnical assistance for themselves like awaiting new digital phone service, billing & inquiries, and many other services. Then for all kind of issues, contact us at the customer service number which is available 24x7. There are no calling charges that is it is completely free and get AT&T Customer Service 1-844-659-2999 without any delay. the provided customer service is available round-the-clock to provide a solution to customers by our highly qualified and professionals. https://monktech.net/att-customer-service-phone-number.html"
    },
    {
        "Pattern": "AT&T Customer Service",
        "MatchingText": "https://monktech.net/att-customer-service-phone-number.html",
        "NonMatchingText": "https://monktech.net/att-customer-service-phone-number.html",
        "Description": "The AT&T is one of the most appropriate platforms to communicate, message and to stay in touch with your friends and family. Users can also set the American Telephone & Telegraph customer service for any kind of gadget that you are using with our AT&T Customer Service1-844-659-2999. And, there\u2019s no need to walk in at the customer center because now you get everything at home. They have a team of highly skilled experts who are there to support you to complete the activation service step by step. https://monktech.net/att-customer-service-phone-number.html"
    },
    {
        "Pattern": "AT&T Customer Service",
        "MatchingText": "https://monktech.net/att-customer-service-phone-number.html",
        "NonMatchingText": "https://monktech.net/att-customer-service-phone-number.html",
        "Description": "users will surely need our AT&T Customer Service 1-844-659-2999 if they\u2019re an American Telephone & Telegraph user. just make contact on the support number to get solutions for your problem instantly at pocket-friendly rates. And also we have clear terms and policies & the services which are available offered with no hidden charges.\nthey are available to support users for 24*7 round the clock to ensure that users won\u2019t be stuck in an inconvenient situation. Also, full process data is kept by keeping in mind of customers confidentiality. https://monktech.net/att-customer-service-phone-number.html\n"
    },
    {
        "Pattern": "AT&T Customer Service",
        "MatchingText": "https://monktech.net/att-customer-service-phone-number.html",
        "NonMatchingText": "https://monktech.net/att-customer-service-phone-number.html",
        "Description": "The AT&T is the most popular and largest telecommunication company and service provider of multichannel videos and also as of 2018 survey of fortune 500, it is on 9th position in largest united states corporations.\nBut for any kind of AT&T problems, come and take our experts\u2019 help and sort-out them vigorously. Users can also take AT&T Customer Service 1-844-659-2999 for some of these listed services: \n\u2022\tFor wireless customer service\n\u2022\tTo check out the ordering status of devices\n\u2022\tTo book a new wireless service https://monktech.net/att-customer-service-phone-number.html\n"
    },
    {
        "Pattern": "AT&T Customer Service",
        "MatchingText": "https://monktech.net/att-customer-service-phone-number.html",
        "NonMatchingText": "https://monktech.net/att-customer-service-phone-number.html",
        "Description": "If you have problems or problems with your AT&T net email account, or if you need advice or information about AT&T in general, you have come to the right place. The AT&T Customer Service 1-844-659-2999 is a customer-focused service operated by highly motivated and technically trained personnel and expects to resolve any AT&T errors with real-time solutions. Provide information and advice to all of the above, but also provide more than that. Whatever your problem, a team of expert help will find a quick solution. https://monktech.net/att-customer-service-phone-number.html"
    },
    {
        "Pattern": "SERVICE FOR AT&T",
        "MatchingText": "https://att-customer-support.blogspot.com/2019/02/what-is-at-18-446-592-999.html",
        "NonMatchingText": "https://att-customer-support.blogspot.com/2019/02/what-is-at-18-446-592-999.html",
        "Description": "AT&T offers unlimited choice plans!\nAT&T offers unlimited internet text and talk plans to billions of users worldwide. The AT&T network can work on any type of mobile phone devices. It offers wireless prepaid plans to its users which help cut down costs. There are various types of individual data plans which AT&T offers to its users. \nYou can talk to your friends and families for longer durations through the AT&T network. It is one of the largest used internet networks which offer fast-speed internet packs at reasonable costs. The packs are budget-friendly and easily affordable. \nYou should have an AT&T Customer Service Number \nAn AT&T customer might anytime experience certain problems which might create further severe issues if not solved within the stipulated time. Nevertheless, our AT&T Customer Service Phone Number is 18-446-592-999 which you can dial anytime in 24 hours. Our talented team of customer service executives are round the clock available to talk to you. \nWe provide an AT&T Phone Number\nOur AT&T Customer Service Number is 18-446-592-999 (toll-free). You can dial it and sort out any type of AT&T issues while talking to our professionals. They are quick in giving optimum answers for whatever queries you facing with the same.\nOur AT&T Customer Service has some exceptional talents sitting at one place who are ready to guide you every time. Whether your internet connection is slow or you are not able to set a wireless device at your home you can call us directly and let us help you.  https://att-customer-support.blogspot.com/2019/02/what-is-at-18-446-592-999.html\n"
    },
    {
        "Pattern": "SERVICE FOR AT&T",
        "MatchingText": "https://attcustomerservices.wordpress.com/2019/02/09/what-is-att-service-call-now-18-446-592-999/",
        "NonMatchingText": "https://attcustomerservices.wordpress.com/2019/02/09/what-is-att-service-call-now-18-446-592-999/",
        "Description": "AT&T offers unlimited choice plans!\nAT&T offers unlimited internet text and talk plans to billions of users worldwide. The AT&T network can work on any type of mobile phone devices. It offers wireless prepaid plans to its users which help cut down costs. There are various types of individual data plans which AT&T offers to its users. \nYou can talk to your friends and families for longer durations through the AT&T network. It is one of the largest used internet networks which offer fast-speed internet packs at reasonable costs. The packs are budget-friendly and easily affordable. \nYou should have an AT&T Customer Service Number \nAn AT&T customer might anytime experience certain problems which might create further severe issues if not solved within the stipulated time. Nevertheless, our AT&T Customer Service Phone Number is 18-446-592-999 which you can dial anytime in 24 hours. Our talented team of customer service executives are round the clock available to talk to you. \nWe provide an AT&T Phone Number\nOur AT&T Customer Service Number is 18-446-592-999 (toll-free). You can dial it and sort out any type of AT&T issues while talking to our professionals. They are quick in giving optimum answers for whatever queries you facing with the same.\nOur AT&T Customer Service has some exceptional talents sitting at one place who are ready to guide you every time. Whether your internet connection is slow or you are not able to set a wireless device at your home you can call us directly and let us help you. https://attcustomerservices.wordpress.com/2019/02/09/what-is-att-service-call-now-18-446-592-999/\n"
    },
    {
        "Pattern": "AT&T Customer Service Phone Number",
        "MatchingText": "https://att-customer-supportnumber.blogspot.com/2019/02/at-customer-service-1-855-431-6111-is.html",
        "NonMatchingText": "https://att-customer-supportnumber.blogspot.com/2019/02/at-customer-service-1-855-431-6111-is.html",
        "Description": "AT&T is the largest internet service provider in the United States\nAT&T is a popular internet service provider which offers unlimited internet access to all the users who use it as their preferred internet network. It is a wide telecom company which offers many services including TV, broadband, wireless devices etc. Our AT&T Customer Service Phone Number is round the clock running to address your problems with the most efficient and reliable answers. \nMoreover, AT&T is cheap and the videos can be streamed on smart phones, desktops, tablets etc. You can watch unlimited videos, play games and do a lot more fun activities without any hindrances in between. Are you facing problems with your AT&T internet? Call our talented techies right away and sort all the errors profoundly. \nWhy AT&T is popular?\n\u2022 Reliable and fast internet\n\u2022 Affordable and cheap\n\u2022 Stream HD videos \n\u2022 No extra equipment fees\n\u2022 Wi-Fi gateway router is available\n\u2022 Offers instant product deliveries\n\u2022 Keeps your browsing safe and secure\n\u2022 Easy to connect with your phones, laptops etc\nThere are many other added advantages which it offers to its users apart from fast internet speeds. If you want to solve your AT&T problems you can dial our AT&T Customer Service Phone Number 1 (855) 431-6111 and talk to our professionals. \nAT&T fixed wireless internet offers high-speed internet services to all the households and business people through a Wi-Fi gateway. The fixed wireless internet plus direct TV offer fast speeds with no extra monthly fee. You can also connect to multiple devices and the network is perfect for connecting with multiple social networks at a single time. \nAT&T Customer Service Number is handled by our experts who are working 24/7\nWe work via an AT&T Customer Service Number which runs round the clock. You can contact our customer care executives and get the most feasible outcomes for your problems. Since AT&T is a popular internet network provider it might face certain types of problems which are unknown to its users. \nThrough our AT&T Phone Number, you can contact our experts and talk to them as per your convenience. You can call us anytime and resolve your issues instantly. You can pay your AT&T bills by dialling our AT&T Phone Number through which our experts would look forward into the matter. \nAT&T Phone Number is 1 (855) 431-6111 which is toll-free\nAT&T Phone Number is a toll-free number which you can call anytime in the entire day. With 100% effective solutions our qualified technicians are very supportive and promise to guide you despite the nature of the issues. Our team of experts would handle all your AT&T problems and apply advanced tools and techniques to bring the most possible outcome. \nWhether you are experiencing network errors or problems with any of the AT&T services, you can call and get in touch with our customer support representatives. They are talented technicians who have in-depth knowledge of AT&T devices and services. You can dial our AT&T Phone Number 1 (855) 431-6111 and get in touch with the officials today!  https://att-customer-supportnumber.blogspot.com/2019/02/at-customer-service-1-855-431-6111-is.html\n"
    },
    {
        "Pattern": "AT&T Customer Service Phone Number",
        "MatchingText": "https://attcustomerphonesupport.wordpress.com/2019/02/13/att-customer-service-1-855-431-6111-is-24-7-available/",
        "NonMatchingText": "https://attcustomerphonesupport.wordpress.com/2019/02/13/att-customer-service-1-855-431-6111-is-24-7-available/",
        "Description": "AT&T is the largest internet service provider in the United States\nAT&T is a popular internet service provider which offers unlimited internet access to all the users who use it as their preferred internet network. It is a wide telecom company which offers many services including TV, broadband, wireless devices etc. Our AT&T Customer Service Phone Number is round the clock running to address your problems with the most efficient and reliable answers. \nMoreover, AT&T is cheap and the videos can be streamed on smart phones, desktops, tablets etc. You can watch unlimited videos, play games and do a lot more fun activities without any hindrances in between. Are you facing problems with your AT&T internet? Call our talented techies right away and sort all the errors profoundly. \nWhy AT&T is popular?\n\u2022 Reliable and fast internet\n\u2022 Affordable and cheap\n\u2022 Stream HD videos \n\u2022 No extra equipment fees\n\u2022 Wi-Fi gateway router is available\n\u2022 Offers instant product deliveries\n\u2022 Keeps your browsing safe and secure\n\u2022 Easy to connect with your phones, laptops etc\nThere are many other added advantages which it offers to its users apart from fast internet speeds. If you want to solve your AT&T problems you can dial our AT&T Customer Service Phone Number 1 (855) 431-6111 and talk to our professionals. \nAT&T fixed wireless internet offers high-speed internet services to all the households and business people through a Wi-Fi gateway. The fixed wireless internet plus direct TV offer fast speeds with no extra monthly fee. You can also connect to multiple devices and the network is perfect for connecting with multiple social networks at a single time. \nAT&T Customer Service Number is handled by our experts who are working 24/7\nWe work via an AT&T Customer Service Number which runs round the clock. You can contact our customer care executives and get the most feasible outcomes for your problems. Since AT&T is a popular internet network provider it might face certain types of problems which are unknown to its users. \nThrough our AT&T Phone Number, you can contact our experts and talk to them as per your convenience. You can call us anytime and resolve your issues instantly. You can pay your AT&T bills by dialling our AT&T Phone Number through which our experts would look forward into the matter. \nAT&T Phone Number is 1 (855) 431-6111 which is toll-free\nAT&T Phone Number is a toll-free number which you can call anytime in the entire day. With 100% effective solutions our qualified technicians are very supportive and promise to guide you despite the nature of the issues. Our team of experts would handle all your AT&T problems and apply advanced tools and techniques to bring the most possible outcome. \nWhether you are experiencing network errors or problems with any of the AT&T services, you can call and get in touch with our customer support representatives. They are talented technicians who have in-depth knowledge of AT&T devices and services. You can dial our AT&T Phone Number 1 (855) 431-6111 and get in touch with the officials today!  https://attcustomerphonesupport.wordpress.com/2019/02/13/att-customer-service-1-855-431-6111-is-24-7-available/\n"
    },
    {
        "Pattern": "^\\$[0-9]+(\\.[0-9][0-9])?$",
        "MatchingText": "$1.50|||$49|||$0.50",
        "NonMatchingText": "1.5|||$1.333|||this $5.12 fails",
        "Description": "Validates a dollar amount including a dollar sign and 2 decmals. The decimal and cents are optional."
    },
    {
        "Pattern": "^(0[1-9]{1}|[1-2]{1}[0-9]{1}|3[0-1]{1})([\\/])(0[1-9]{1}|1[0-2]{1})([\\/])([19|20]+[0-9]{2})$",
        "MatchingText": "O1/02/2012|||13/11/1918|||31/05/2067",
        "NonMatchingText": "1/2/2012|||32/11/1918|||31/13/2067|||04/09/1800|||06/01/2100",
        "Description": "French time between 1900 and 2099. format dd/mm/yyyy"
    },
    {
        "Pattern": "^[^']*?\\&lt;\\s*Assembly\\s*:\\s*AssemblyVersion\\s*\\(\\s*&quot;(\\*|[0-9]+.\\*|[0-9]+.[0-9]+.\\*|[0-9]+.[0-9]+.[0-9]+.\\*|[0-9]+.[0-9]+.[0-9]+.[0-9]+)&quot;\\s*\\)\\s*\\&gt;.*$",
        "MatchingText": "&lt;Assembly: AssemblyVersion(&quot;1.0.*&quot;)&gt; (all version formats, i.e.: * to 1.0.0.0)",
        "NonMatchingText": "'&lt;Assembly: AssemblyVersion(&quot;1.0.*&quot;)&gt; (commented lines)",
        "Description": "Matches the AssemblyVersion attribute in an Assembly.vb file. The version value is captured."
    },
    {
        "Pattern": "(?:(?:[a-zA-Z0-9/;\\?&=:\\-_\\$\\+!\\*'\\(\\|\\\\~\\[\\]#%\\.](www))+(?:\\.[Cc]om|\\.[Ee]du|\\.[gG]ov|\\.[Ii]nt|\\.[Mm]il|\\.[Nn]et|\\.[Oo]rg|\\.[Bb]iz|\\.[Ii]nfo|\\.[Nn]ame|\\.[Pp]ro|\\.[Aa]ero|\\.[cC]oop|\\.[mM]useum|\\.[Cc]at|\\.[Jj]obs|\\.[Tt]ravel|\\.[Aa]rpa|\\.[Mm]obi|\\.[Aa]c|\\.[Aa]d|\\.[aA]e|\\.[aA]f|\\.[aA]g|\\.[aA]i|\\.[aA]l|\\.[aA]m|\\.[aA]n|\\.[aA]o|\\.[aA]q|\\.[aA]r|\\.[aA]s|\\.[aA]t|\\.[aA]u|\\.[aA]w|\\.[aA]z|\\.[aA]x|\\.[bB]a|\\.[bB]b|\\.[bB]d|\\.[bB]e|\\.[bB]f|\\.[bB]g|\\.[bB]h|\\.[bB]i|\\.[bB]j|\\.[bB]m|\\.[bB]n|\\.[bB]o|\\.[bB]r|\\.[bB]s|\\.[bB]t|\\.[bB]v|\\.[bB]w|\\.[bB]y|\\.[bB]z|\\.[cC]a|\\.[cC]c|\\.[cC]d|\\.[cC]f|\\.[cC]g|\\.[cC]h|\\.[cC]i|\\.[cC]k|\\.[cC]l|\\.[cC]m|\\.[cC]n|\\.[cC]o|\\.[cC]r|\\.[cC]s|\\.[cC]u|\\.[cC]v|\\.[cC]x|\\.[cC]y|\\.[cC]z|\\.[dD]e|\\.[dD]j|\\.[dD]k|\\.[dD]m|\\.[dD]o|\\.[dD]z|\\.[eE]c|\\.[eE]e|\\.[eE]g|\\.[eE]h|\\.[eE]r|\\.[eE]s|\\.[eE]t|\\.[eE]u|\\.[fF]i|\\.[fF]j|\\.[fF]k|\\.[fF]m|\\.[fF]o|\\.[fF]r|\\.[gG]a|\\.[gG]b|\\.[gG]d|\\.[gG]e|\\.[gG]f|\\.[gG]g|\\.[gG]h|\\.[gG]i|\\.[gG]l|\\.[gG]m|\\.[gG]n|\\.[gG]p|\\.[gG]q|\\.[gG]r|\\.[gG]s|\\.[gG]t|\\.[gG]u|\\.[gG]w|\\.[gG]y|\\.[hH]k|\\.[hH]m|\\.[hH]n|\\.[hH]r|\\.[hH]t|\\.[hH]u|\\.[iI]d|\\.[iI]e|\\.[iI]l|\\.[iI]m|\\.[iI]n|\\.[iI]o|\\.[iI]q|\\.[iI]r|\\.[iI]s|\\.[iI]t|\\.[jJ]e|\\.[jJ]m|\\.[jJ]o|\\.[jJ]p|\\.[kK]e|\\.[kK]g|\\.[kK]h|\\.[kK]i|\\.[kK]m|\\.[kK]n|\\.[kK]p|\\.[kK]r|\\.[kK]w|\\.[kK]y|\\.[kK]z|\\.[lL]a|\\.[lL]b|\\.[lL]c|\\.[lL]i|\\.[lL]k|\\.[lL]r|\\.[lL]s|\\.[lL]t|\\.[lL]u|\\.[lL]v|\\.[lL]y|\\.[mM]a|\\.[mM]c|\\.[mM]d|\\.[mM]g|\\.[mM]h|\\.[mM]k|\\.[mM]l|\\.[mM]m|\\.[mM]n|\\.[mM]o|\\.[mM]p|\\.[mM]q|\\.[mM]r|\\.[mM]s|\\.[mM]t|\\.[mM]u|\\.[mM]v|\\.[mM]w|\\.[mM]x|\\.[mM]y|\\.[mM]z|\\.[nN]a|\\.[nN]c|\\.[nN]e|\\.[nN]f|\\.[nN]g|\\.[nN]i|\\.[nN]l|\\.[nN]o|\\.[nN]p|\\.[nN]r|\\.[nN]u|\\.[nN]z|\\.[oO]m|\\.[pP]a|\\.[pP]e|\\.[pP]f|\\.[pP]g|\\.[pP]h|\\.[pP]k|\\.[pP]l|\\.[pP]m|\\.[pP]n|\\.[pP]r|\\.[pP]s|\\.[pP]t|\\.[pP]w|\\.[pP]y|\\.[qP]a|\\.[rR]e|\\.[rR]o|\\.[rR]u|\\.[rR]w|\\.[sS]a|\\.[sS]b|\\.[sS]c|\\.[sS]d|\\.[sS]e|\\.[sS]g|\\.[sS]h|\\.[Ss]i|\\.[sS]j|\\.[sS]k|\\.[sS]l|\\.[sS]m|\\.[sS]n|\\.[sS]o|\\.[sS]r|\\.[sS]t|\\.[sS]v|\\.[sS]y|\\.[sS]z|\\.[tT]c|\\.[tT]d|\\.[tT]f|\\.[tT]g|\\.[tT]h|\\.[tT]j|\\.[tT]k|\\.[tT]l|\\.[tT]m|\\.[tT]n|\\.[tT]o|\\.[tT]p|\\.[tT]r|\\.[tT]t|\\.[tT]v|\\.[tT]w|\\.[tT]z|\\.[uU]a|\\.[uU]g|\\.[uU]k|\\.[uU]m|\\.[uU]s|\\.[uU]y|\\.[uU]z|\\.[vV]a|\\.[vV]c|\\.[vV]e|\\.[vV]g|\\.[vV]i|\\.[vV]n|\\.[vV]u|\\.[wW]f|\\.[wW]s|\\.[yY]e|\\.[yY]t|\\.[yY]u|\\.[zZ]a|\\.[zZ]m|\\.[zZ]w))",
        "MatchingText": "webmail.ifi.lmu.de",
        "NonMatchingText": "kis.hajnalka",
        "Description": "here are specified all the top level domains. In fact, this expression gets the urls only till the TLD. "
    },
    {
        "Pattern": "(?:(?:w{3}\\.)(?:[a-zA-Z0-9/;\\?&=:\\-_\\$\\+!\\*'\\(\\|\\\\~\\[\\]#%\\.])+[\\.com|\\.edu|\\.gov|\\.int|\\.mil|\\.net|\\.org|\\.biz|\\.info|\\.name|\\.pro|\\.aero|\\.coop|\\.museum|\\.cat|\\.jobs|\\.travel|\\.arpa|\\.mobi|\\.ac|\\.ad|\\.ae|\\.af|\\.ag|\\.ai|\\.al|\\.am|\\.an|\\.ao|\\.aq|\\.ar|\\.as|\\.at|\\.au|\\.aw|\\.az|\\.ax|\\.ba|\\.bb|\\.bd|\\.be|\\.bf|\\.bg|\\.bh|\\.bi|\\.bj|\\.bm|\\.bn|\\.bo|\\.br|\\.bs|\\.bt|\\.bv|\\.bw|\\.by|\\.bz|\\.ca|\\.cc|\\.cd|\\.cf|\\.cg|\\.ch|\\.ci|\\.ck|\\.cl|\\.cm|\\.cn|\\.co|\\.cr|\\.cs|\\.cu|\\.cv|\\.cx|\\.cy|\\.cz|\\.de|\\.dj|\\.dk|\\.dm|\\.do|\\.dz|\\.ec|\\.ee|\\.eg|\\.eh|\\.er|\\.es|\\.et|\\.eu|\\.fi|\\.fj|\\.fk|\\.fm|\\.fo|\\.fr|\\.ga|\\.gb|\\.gd|\\.ge|\\.gf|\\.gg|\\.gh|\\.gi|\\.gl|\\.gm|\\.gn|\\.gp|\\.gq|\\.gr|\\.gs|\\.gt|\\.gu|\\.gw|\\.gy|\\.hk|\\.hm|\\.hn|\\.hr|\\.ht|\\.hu|\\.id|\\.ie|\\.il|\\.im|\\.in|\\.io|\\.iq|\\.ir|\\.is|\\.it|\\.je|\\.jm|\\.jo|\\.jp|\\.ke|\\.kg|\\.kh|\\.ki|\\.km|\\.kn|\\.kp|\\.kr|\\.kw|\\.ky|\\.kz|\\.la|\\.lb|\\.lc|\\.li|\\.lk|\\.lr|\\.ls|\\.lt|\\.lu|\\.lv|\\.ly|\\.ma|\\.mc|\\.md|\\.mg|\\.mh|\\.mk|\\.ml|\\.mm|\\.mn|\\.mo|\\.mp|\\.mq|\\.mr|\\.ms|\\.mt|\\.mu|\\.mv|\\.mw|\\.mx|\\.my|\\.mz|\\.na|\\.nc|\\.ne|\\.nf|\\.ng|\\.ni|\\.nl|\\.no|\\.np|\\.nr|\\.nu|\\.nz|\\.om|\\.pa|\\.pe|\\.pf|\\.pg|\\.ph|\\.pk|\\.pl|\\.pm|\\.pn|\\.pr|\\.ps|\\.pt|\\.pw|\\.py|\\.qa|\\.re|\\.ro|\\.ru|\\.rw|\\.sa|\\.sb|\\.sc|\\.sd|\\.se|\\.sg|\\.sh|\\..si|\\.sj|\\.sk|\\.sl|\\.sm|\\.sn|\\.so|\\.sr|\\.st|\\.sv|\\.sy|\\.sz|\\.tc|\\.td|\\.tf|\\.tg|\\.th|\\.tj|\\.tk|\\.tl|\\.tm|\\.tn|\\.to|\\.tp|\\.tr|\\.tt|\\.tv|\\.tw|\\.tz|\\.ua|\\.ug|\\.uk|\\.um|\\.us|\\.uy|\\.uz|\\.va|\\.vc|\\.ve|\\.vg|\\.vi|\\.vn|\\.vu|\\.wf|\\.ws|\\.ye|\\.yt|\\.yu|\\.za|\\.zm|\\.zw](?:[a-zA-Z0-9/;\\?&=:\\-_\\$\\+!\\*'\\(\\|\\\\~\\[\\]#%\\.])*)",
        "MatchingText": "www.google.com",
        "NonMatchingText": "http://www.google.com",
        "Description": "So, that's it. Gets url-s with \"www\", BUT without the protocols. If you need one regEx with the protocols, search for it in this database, I've added one"
    },
    {
        "Pattern": "^[0][1-9]{2}(-)[0-9]{8}$  and  ^[0][1-9]{3}(-)[0-9]{7}$  and  ^[0][1-9]{4}(-)[0-9]{6}$",
        "MatchingText": "021-23456789,0221-2345678 and 02221-234567 respectively",
        "NonMatchingText": "none..u can change it according to you need..",
        "Description": "India phone(landline) number, accept 0 for prefix and - (hifen) after the STD code."
    },
    {
        "Pattern": "\\w+([-+.']\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*",
        "MatchingText": "123@123.com,000@00.com., abc_abc@abc.abc..any type it wii do validation",
        "NonMatchingText": "none..",
        "Description": "This can check the email of any kind.."
    },
    {
        "Pattern": "^((\\+){1}91){1}[1-9]{1}[0-9]{9}$",
        "MatchingText": "+919123456789",
        "NonMatchingText": "+91 9123456789,+91-9123456789.. like this",
        "Description": "In this Pattern +91 will be the prefix in the Mobile number(of 10 digits)."
    },
    {
        "Pattern": "^(((Ctrl\\+Shift\\+Alt\\+|Ctrl\\+Shift\\+|Ctrl\\+Alt\\+|Shift\\+Alt\\+|Ctrl\\+|Alt\\+){1}(F1[0-2]|F[1-9]|[A-Za-z0-9\\-\\=\\[\\]\\\\\\;\\'\\,\\.\\/]){1}){1}|(Shift\\+)?(F1[0-2]|F[1-9]){1})$",
        "MatchingText": "Ctrl+Alt+K, Shift+F10",
        "NonMatchingText": "Ctrl+Ctrl+K, Shift+K, AnyKey",
        "Description": "Hot key combinations for Windows.  Has some restrictions and limitations, can probably be improved."
    },
    {
        "Pattern": "^(((Ctrl\\+Alt\\+Shift\\+Cmd\\+|Ctrl\\+Shift\\+Cmd\\+|Ctrl\\+Alt\\+Shift\\+|Ctrl\\+Alt\\+Cmd\\+|Alt\\+Shift\\+Cmd\\+|Shift\\+Cmd\\+|Ctrl\\+Shift\\+|Ctrl\\+Cmd\\+|Ctrl\\+Alt\\+|Alt\\+Shift\\+|Alt\\+Cmd\\+|Cmd\\+|Alt\\+)(F1[0-2]|F[1-9]|[A-Za-z0-9\\-\\=\\[\\]\\\\\\;\\'\\,\\.\\/]))|(Shift\\+)?(F1[0-2]|F[1-9]))$",
        "MatchingText": "Cmd+R, F9, Shift+F7, Ctrl+Alt+K",
        "NonMatchingText": "R, Shift+4, Ctrl+Ctrl+T",
        "Description": "Hot key combinations for Mac.  Has some limitations and restrictions, could probably be improved."
    },
    {
        "Pattern": "^[1-9]{1}$|^[1-9]{1}[0-9]{1}$|^[1-3]{1}[0-6]{1}[0-5]{1}$|^365$",
        "MatchingText": "25|||363|||110",
        "NonMatchingText": "2.5|||0|||400",
        "Description": "This expression allows you to select 1-365 as a numeric value for the days of the year.  Must be between 1 and 365 and must be numeric"
    },
    {
        "Pattern": "^(GIR\\\\s{0,1}0AA|[A-PR-UWYZ]([0-9]{1,2}|([A-HK-Y][0-9]|[A-HK-Y][0-9]([0-9]|[ABEHMNPRV-Y]))|[0-9][A-HJKS-UW])\\\\s{0,1}[0-9][ABD-HJLNP-UW-Z]{2})$",
        "MatchingText": "GIR 0AA, GIR0AA, M1 1AA, EC1A 1BB",
        "NonMatchingText": "E14 5LQH",
        "Description": "This regex have been created as per the information provided on http://www.govtalk.gov.uk/gdsc/html/noframes/PostCode-2-1-Release.htm. This expression will allow the postcodes with space or without space."
    },
    {
        "Pattern": "^[-+]?(?:\\d+\\.?|\\.\\d)\\d*(?:[Ee][-+]?\\d+)?$",
        "MatchingText": "23 ||| -17.e23 ||| +.199E-19 ||| 10. ||| 10e10",
        "NonMatchingText": "+.e2 ||| 23.17.5 ||| 10e2.0 ||| 22e",
        "Description": "Validates that a string represents a javascript number (as defined by ECMAScript 3 Specs): integer (base-10) or floating\npoint including in the exponential notation. Doesn't match the empty string."
    },
    {
        "Pattern": "^([\\+]|0)[(\\s]{0,1}[2-9][0-9]{0,2}[\\s-)]{0,2}[0-9][0-9][0-9\\s-]*[0-9]$",
        "MatchingText": "044 123-456  +2 12-12456   +(234) 56-56-452",
        "NonMatchingText": "1 562 234-2343 +425-12 +(44) 1514- ",
        "Description": "allows only spaces and dashes in the national number.  parantheses are allowed around the national prefix.  no us and canada numbers (+1) are allowed.  can start with 0 instead of +.  no extensions."
    },
    {
        "Pattern": "([+(]?\\d{0,2}[)]?)([-/.\\s]?\\d+)+",
        "MatchingText": "+91.123.456.7890",
        "NonMatchingText": "symbols other than '/' '.' '(' ')' '-' will not be allowed",
        "Description": "it will validate phone number formats like -\n1. (91)123-456-7890\n2. +91-123-456-7890\n3. 911234567890\n4. 1234567890\n5. (91)123/456/7890\n6. +91/123/456/7890\n7. (91)123.456.7890\n8. +91.123.456.7890\nThere is no limitation on the repeating pattern"
    },
    {
        "Pattern": "[({]?(0x)?[0-9a-fA-F]{8}([-,]?(0x)?[0-9a-fA-F]{4}){2}((-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{12})|(,\\{0x[0-9a-fA-F]{2}(,0x[0-9a-fA-F]{2}){7}\\}))[)}]?",
        "MatchingText": "ca761232ed4211cebacd00aa0057b223|||CA761232-ED42-11CE-BACD-00AA0057B223|||{CA761232-ED42-11CE-BACD-00AA0057B223}|||(CA761232-ED42-11CE-BACD-00AA0057B223)|||{0xCA761232,0xED42,0x11CE,{0xBA,0xCD,0x00,0xAA,0x00,0x57,0xB2,0x23}}",
        "NonMatchingText": "Invalid guids",
        "Description": "It matches all strings that the .NET Framework API \"new Guid(string guid)\" can recognize. A String that contains a GUID in one of the following formats ('d' represents a hexadecimal digit whose case is ignored): "
    },
    {
        "Pattern": "~ ! @ # $ % ^ & * _ - + = ` | \\ ( ) { } [ ] : ; \" ' <> , . ? / \u00A3",
        "MatchingText": "#Sudoroot SecAptget ",
        "NonMatchingText": "345708",
        "Description": "\n\nCan start with or include any of the following special characters:\n~ ! @ # $ % ^ & * _ - + = ` | \\ ( ) { } [ ] : ; \" ' <> , . ? / \u00A3\n"
    },
    {
        "Pattern": "^p(ost)?[ |\\.]*o(ffice)?[ |\\.]*(box)?[ 0-9]*[^[a-z ]]*",
        "MatchingText": "po box 4353",
        "NonMatchingText": "pollo St.|||P. O. Box d3f12s|||BOX 23",
        "Description": "This expression is useful for determining if an address is a PO Box type address. This can be useful in shipping systems as well as other systems that need to  make determinations based on the type of address imputed."
    },
    {
        "Pattern": "^-?\\d+([.,]?\\d+)?$",
        "MatchingText": "43|||-43|||43.56|||-43.56|||43,56|||-43,56",
        "NonMatchingText": "ABC|||A43|||43A|||43.A3|||-43.A3|||43.,56|||43.|||43,|||,56|||.56",
        "Description": "It just accepts negative and positive numeric entries. Dot (.) or comma (,) signs accepted only once."
    },
    {
        "Pattern": "^\\d+([.,]?\\d+)?$",
        "MatchingText": "43|||43.56|||43,56",
        "NonMatchingText": "ABC|||A43|||43A|||43.A3|||43.|||43,|||,56|||.56",
        "Description": "It just accepts only positive numbers. Also accepts Dot (.) and comma (,) signs only once."
    },
    {
        "Pattern": "^-?\\d+([^.,])?$",
        "MatchingText": "34|||-34|||1|||-1|||1000000000 |||-1000000000",
        "NonMatchingText": "34.5|||-34.5|||34,5|||-34,5|||34.|||34,|||.5|||,5",
        "Description": "Accepts positive and negative integers."
    },
    {
        "Pattern": "^\\d+([^.,])?$",
        "MatchingText": "34 ||| 1 ||| 1000000000",
        "NonMatchingText": "-34||| -1||| -1000000000||| 34.5 ||| -34.5 ||| 34,5 ||| -34,5 ||| 34. ||| 34, ||| .5 ||| ,5",
        "Description": "Accepts positive integers."
    },
    {
        "Pattern": "(^([0-9]*[.][0-9]*[1-9]+[0-9]*)$)|(^([0-9]*[1-9]+[0-9]*[.][0-9]+)$)|(^([1-9]+[0-9]*)$)",
        "MatchingText": "1.234 ||| 1234 ||| 0.123 ||| 01.2345",
        "NonMatchingText": "0 ||| 0.0 ||| -123.45 || -12345 ||| abc123 ||| 12..34",
        "Description": "If you want to check for positive and nonzero real numbers (both integer and decimal are supported)."
    },
    {
        "Pattern": "^(GIR|[A-Z]\\d[A-Z\\d]?|[A-Z]{2}\\d[A-Z\\d]?)[ ]??(\\d[A-Z]{0,2})??$",
        "MatchingText": "W1A1AB",
        "NonMatchingText": "WWW1AB",
        "Description": "This will validate a partial postcode beginning with the postal district on up to the whole postcode, returning the two halves in sub-expressions.  The main purpose is to return a valid postal district from a partial or whole postcode. The real value in this regex lies in the fact that it will process the postcode correctly regardless of whether or not the space in present after the district. So the accepted formats are A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (and the same 6 formats without the space are also accepted). Requires postcodes to be upper-case."
    },
    {
        "Pattern": "^(GIR|[A-Z]\\d[A-Z\\d]??|[A-Z]{2}\\d[A-Z\\d]??)[ ]??(\\d[A-Z]{2})$",
        "MatchingText": "GIR0AA",
        "NonMatchingText": "WWW1AB",
        "Description": "Validates a complete UK postcode. Returns the two halves in sub-expressions. Supports the following 7 formats: A1 1AA, A11 1AA, A1A 1AA, AA1 1AA, AA11 1AA, AA1A 1AA GIR 0AA (** And the same 7 formats without the space are also accepted).  (requires postcodes to be upper-case)"
    },
    {
        "Pattern": "(\\s(\\bon[a-zA-Z][a-z]+)\\s?\\=\\s?[\\'\\\"]?(javascript\\:)?[\\w\\(\\),\\' ]*;?[\\'\\\"]?)+",
        "MatchingText": "onPaste onBlur onClick ... ; onblur onclick onpaste ...",
        "NonMatchingText": "<div id=\"TSelect_TD_value_911\" class=\"TSel\" style=\"width:250px; padding:2px;\">",
        "Description": "No idea whether anyone would ever need this, but I had to work half a day on this pattern, so I decided to share it. :) It was never meant for productive use at all; it was rather to filter out all that annoying event handling stuff to find a bug in my DHTML table-generating script. Give it a try with this string (see details): \n\n<div id=\"TSelect_TD_value_911\" class=\"TSel\" onpaste=\"\" onblur=\"TSelectClose(this);\" onClick=\"TSelectOpen(this);\" style=\"width:250px; padding:2px;\">"
    },
    {
        "Pattern": "^((0[1-9])|(1[0-2]))\\/(\\d{4})$",
        "MatchingText": "12/2002|||11/1900|||02/1977",
        "NonMatchingText": "1/1977|||00/000|||15/2002",
        "Description": "This regular expressions matches dates in the format MM/YYYY where MM can be 01 to 12 and YYYY is always 4 digits long. "
    },
    {
        "Pattern": "(href=|url|import).*[\\'\"]([^(http:)].*css)[\\'\"]",
        "MatchingText": "import url(\"some.css\"), import(\"some.css\"),  <link rel=\"STYLESHEET\" type=\"text/css\" href=\"some.css\">",
        "NonMatchingText": "import url(\"http://domain.com/some.css\"), import(\"http://domain.com/some.css\"),  <link rel=\"STYLESHEET\" type=\"text/css\" href=\"http://domain.com/some.css\">",
        "Description": "get all css links, tags ect without http,  i needed this to my web crawler, maybe somebody need this to ;)_"
    },
    {
        "Pattern": "^(([a-h,A-H,j-n,J-N,p-z,P-Z,0-9]{9})([a-h,A-H,j-n,J-N,p,P,r-t,R-T,v-z,V-Z,0-9])([a-h,A-H,j-n,J-N,p-z,P-Z,0-9])(\\d{6}))$",
        "MatchingText": "abcDEFghp3t123456|||A1C3E5G6Y98123456|||A1C3E5G6FFF123456",
        "NonMatchingText": "AIC3E5G6FFF123456|||A8C3E5G6FQF123456|||A8C3E5G6F9F12345H",
        "Description": "Tests Vehicle Identification Numbers (VINs).  This works for a Mitsubishi cars in the UK - but I have been unable to determine whether the format is for UK vehicles or applies only to this make.  The requirements are that the first 9 characters and the 11th character are alpha-numeric excluding i, I, o or O.  The 10th character is the chassis year, and is alpha-numeric excluding i, I, o, O, q, Q, u, and U.  The final 6 characters are numeric.  The string is 17 characters in length.  Any refinements would be greatly appreciated!"
    },
    {
        "Pattern": "^[a-zA-Z]{1,2}[0-9][0-9A-Za-z]{0,1} {0,1}[0-9][A-Za-z]{2}$",
        "MatchingText": "G1 1AA|||EH10 2QQ|||SW1 1ZZ",
        "NonMatchingText": "G111 1AA|||X10 WW|||DDD 5WW",
        "Description": "Matches UK postcodes according to the following rules\n\n1. LN NLL     eg N1 1AA \n2. LLN NLL    eg SW4 0QL \n3. LNN NLL    eg M23 4PJ \n4. LLNN NLL  eg WS14 0JT \n5. LLNL NLL   eg SW1N 4TB \n6. LNL NLL     eg W1C 8LQ\n\nThanks to Simon Bell for informing me of LNL NLL rule for postcodes which I had omitted in an earlier version.\n\n"
    },
    {
        "Pattern": "^\\$?(\\d{1,3},?(\\d{3},?)*\\d{3}(\\.\\d{0,2})?|\\d{1,3}(\\.\\d{0,2})?|\\.\\d{1,2}?)$",
        "MatchingText": "$1.99|||1.99|||.99",
        "NonMatchingText": "$10.999|||100,00.99|||blank",
        "Description": "This expression will validate for US Currency with a wide range of input.  Using other exps found on this site, I built this one to fix 2 main problems I was finding:\n1-a space or blank entry is non-matching\n2-use of .9 in place of .90 will match (this is for those people like me who hate to type and if I put .9 I mean .90\nHope this helps others save a little time.  I feel I was pretty thorough in testing, but if you find something wrong, please post it.  -Thanks"
    },
    {
        "Pattern": "^((6011)((-|\\s)?[0-9]{4}){3})$",
        "MatchingText": "6011-0000-0000-0000 ||| 6011000000000000 ||| 6011 0000 0000 0000",
        "NonMatchingText": "Anything not starting with 6011",
        "Description": "Validates Discover Card numbers starting with 6011 and allows for spaces and -'s."
    },
    {
        "Pattern": "^((5[1-5])([0-9]{2})((-|\\s)?[0-9]{4}){3})$",
        "MatchingText": "5144-0000-0000-0000 ||| 5343 0000 0000 0000 ||| 5400000000000000",
        "NonMatchingText": "5600.... ||| 4100....",
        "Description": "Validates all Mastercard numbers starting with 51-55 with a total of 16 digits. Allows for spaces and -'s."
    },
    {
        "Pattern": "^([a-zA-Z0-9!@#$%^&amp;*()-_=+;:'&quot;|~`&lt;&gt;?/{}]{1,5})$",
        "MatchingText": "ilove|||$%*!_|||it",
        "NonMatchingText": "123456|||This is great",
        "Description": "This Regular expression validates a string that contains all printable characters with a minimum length of 1 and maximum length of 5.\n\nObviously the min and max can be changed to meet the users needs.\n\n^([a-zA-Z0-9!@#$%^&amp;*()-_=+;:'&quot;|~`&lt;&gt;?/{}]{1,5})$ This is the string, I keep getting &amp;amp;lt and other characters when I save it."
    },
    {
        "Pattern": "^([^\\.]+).([^\\.]+).([^\\.]+).([^\\.]+)$",
        "MatchingText": "city.state.domain.com",
        "NonMatchingText": "asdasd.domain.com",
        "Description": "This expression will match city.state.domain.com\n\nInto 4 capture groups."
    },
    {
        "Pattern": "^\\$?\\d{1,3}(,?\\d{3})*(\\.\\d{1,2})?$",
        "MatchingText": "$1,000,000.00",
        "NonMatchingText": "43,3.245",
        "Description": "Just a small pattern to make sure commas are in the rite place (if present).  Only allows one decimal to be suffixed with with 1 or 2 digits.  Also optional dollar sign may proceed value."
    },
    {
        "Pattern": "^\\d{1,8}$|^\\d{1,3},\\d{3}$|^\\d{1,2},\\d{3},\\d{3}$",
        "MatchingText": "1000|||12,345|||12,345,678",
        "NonMatchingText": "1.1|||1,10|||123,888,888",
        "Description": "Validates numeric input of 99,999,999 to 0 with or without commas. but no decimal places. Very simple, but not bad for a novice."
    },
    {
        "Pattern": "^(?:(?:(?:0?[1-9]|1\\d|2[0-8])\\/(?:0?[1-9]|1[0-2]))\\/(?:(?:1[6-9]|[2-9]\\d)\\d{2}))$|^(?:(?:(?:31\\/0?[13578]|1[02])|(?:(?:29|30)\\/(?:0?[1,3-9]|1[0-2])))\\/(?:(?:1[6-9]|[2-9]\\d)\\d{2}))$|^(?:29\\/0?2\\/(?:(?:(?:1[6-9]|[2-9]\\d)(?:0[48]|[2468][048]|[13579][26]))))$",
        "MatchingText": "29/02/2004|||15/3/1824|||31/01/2001",
        "NonMatchingText": "29/02/2000|||21/10/92|||31/02/2001",
        "Description": "This expression validates dates in the Brazilian d/m/y format from 1/1/1600 - 12/31/9999. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999. Days and months must be 1 or 2 digits and may have leading zeros. Years must be 4 digit years, between 1600 and 9999. Date separator must be a slash (/)"
    },
    {
        "Pattern": "^(?:\\([2-9]\\d{2}\\)\\ ?|[2-9]\\d{2}(?:\\-?|\\ ?))[2-9]\\d{2}[- ]?\\d{4}$",
        "MatchingText": "5305551212|||(530) 555-1212|||530-555-1212",
        "NonMatchingText": "0010011212|||1991991212|||123) not-good",
        "Description": "US Phone Number: This regular expression for US phone numbers conforms to NANP A-digit and D-digit requirments (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. Format validation accepts 10-digits without delimiters, optional parens on area code, and optional spaces or dashes between area code, central office code and station code. Acceptable formats include 2225551212, 222 555 1212, 222-555-1212, (222) 555 1212, (222) 555-1212, etc. You can add/remove formatting options to meet your needs."
    },
    {
        "Pattern": "^(?:\\([2-9]\\d{2}\\)\\ ?|(?:[2-9]\\d{2}\\-))[2-9]\\d{2}\\-\\d{4}$",
        "MatchingText": "(234) 555-1212|||(234)555-1212|||234-555-1212",
        "NonMatchingText": "(234)5551212|||234 555 1212|||234) 555-1212",
        "Description": "This US phone number edit with restricted format options: Accepts optional parens on area code with or without following space, and dashes between area code, central office code and station code. Formats include only (222) 555-1212 (with or without a space) and 222-555-1212. Conforms to NANP A-digit and D-digit requirements (ANN-DNN-NNNN). Area Codes 001-199 are not permitted; Central Office Codes 001-199 are not permitted. "
    },
    {
        "Pattern": "^[-+]?[0-9]+[.]?[0-9]*([eE][-+]?[0-9]+)?$",
        "MatchingText": "123|||-123.35|||-123.35e-2",
        "NonMatchingText": "abc|||123.32e|||123.32.3",
        "Description": "This matches floating point expression in a more rigorous way - accepts both exponent as well as non exponent notations."
    },
    {
        "Pattern": "^[_a-zA-Z0-9-]+(\\.[_a-zA-Z0-9-]+)*@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*\\.(([0-9]{1,3})|([a-zA-Z]{2,3})|(aero|coop|info|museum|name))$",
        "MatchingText": "example@example.com|||foo@bar.info|||blah@127.0.0.1",
        "NonMatchingText": "broken@@example.com|||foo@bar.infp|||blah@.nospam.biz",
        "Description": "Matches e-mail addresses, including some of the newer top-level-domain extensions, such as info, museum, name, etc.  Also allows for emails tied directly to IP addresses."
    },
    {
        "Pattern": "^((([a-z]|[0-9]|!|#|$|%|&|'|\\*|\\+|\\-|/|=|\\?|\\^|_|`|\\{|\\||\\}|~)+(\\.([a-z]|[0-9]|!|#|$|%|&|'|\\*|\\+|\\-|/|=|\\?|\\^|_|`|\\{|\\||\\}|~)+)*)@((((([a-z]|[0-9])([a-z]|[0-9]|\\-){0,61}([a-z]|[0-9])\\.))*([a-z]|[0-9])([a-z]|[0-9]|\\-){0,61}([a-z]|[0-9])\\.(af|ax|al|dz|as|ad|ao|ai|aq|ag|ar|am|aw|au|at|az|bs|bh|bd|bb|by|be|bz|bj|bm|bt|bo|ba|bw|bv|br|io|bn|bg|bf|bi|kh|cm|ca|cv|ky|cf|td|cl|cn|cx|cc|co|km|cg|cd|ck|cr|ci|hr|cu|cy|cz|dk|dj|dm|do|ec|eg|sv|gq|er|ee|et|fk|fo|fj|fi|fr|gf|pf|tf|ga|gm|ge|de|gh|gi|gr|gl|gd|gp|gu|gt| gg|gn|gw|gy|ht|hm|va|hn|hk|hu|is|in|id|ir|iq|ie|im|il|it|jm|jp|je|jo|kz|ke|ki|kp|kr|kw|kg|la|lv|lb|ls|lr|ly|li|lt|lu|mo|mk|mg|mw|my|mv|ml|mt|mh|mq|mr|mu|yt|mx|fm|md|mc|mn|ms|ma|mz|mm|na|nr|np|nl|an|nc|nz|ni|ne|ng|nu|nf|mp|no|om|pk|pw|ps|pa|pg|py|pe|ph|pn|pl|pt|pr|qa|re|ro|ru|rw|sh|kn|lc|pm|vc|ws|sm|st|sa|sn|cs|sc|sl|sg|sk|si|sb|so|za|gs|es|lk|sd|sr|sj|sz|se|ch|sy|tw|tj|tz|th|tl|tg|tk|to|tt|tn|tr|tm|tc|tv|ug|ua|ae|gb|us|um|uy|uz|vu|ve|vn|vg|vi|wf|eh|ye|zm|zw|com|edu|gov|int|mil|net|org|biz|info|name|pro|aero|coop|museum|arpa))|(((([0-9]){1,3}\\.){3}([0-9]){1,3}))|(\\[((([0-9]){1,3}\\.){3}([0-9]){1,3})\\])))$",
        "MatchingText": "john+nospam@house.com john-doe@room.house.com bill@[207.46.130.108] bill@204.46.130.108 john@mycountry-is.fr",
        "NonMatchingText": "john-doe@room.house-.com bill@[207.46.130.108 bill@204.46.130.108.241 john@fakecountry.zz",
        "Description": "This is a robust email validation: the username part conforms with RFC 2822 (for instance, emails with tags (\"+\") are validated).\n\nThe host part is checked for valid subdomains and its TLD is checked against all the 243 countries codes and the 14 ICANN'sTLDs. The host part also accepts IP with or without brackets."
    },
    {
        "Pattern": "^[a-zA-Z0-9._\\-]+@[a-z0-9\\-]+(\\.[a-z]+){1,}$",
        "MatchingText": "me@test.com|me@test.co.uk|me@test.asdf",
        "NonMatchingText": "@test.com|@.com|@.",
        "Description": "Matches simple e-mail addresses such as me@domain.com, me@domain.co.uk, but does not place any restrictions on TLDs other than they must be lower case and alphabetic.  a-z, A-Z, 0-9, ., _, and - are all allowed on the left side of @."
    },
    {
        "Pattern": "(?P<Element>((\\*|\\w+)?)) (?P<Complement>((\\.|\\#|\\-|\\w|\\:)*)) (?P<FamilySeparator>([\\s\\>\\+\\~]|[\\,\\{]))",
        "MatchingText": "body>p.test>p#test2",
        "NonMatchingText": "body>p.test>p#test2,td",
        "Description": "to select single selector name of css including id, class name, descendants ,child, direct and indirect siblings.also it's captured into 3 catpuring names"
    },
    {
        "Pattern": "<\\/?(tag1|tag2)[^>]*\\/?>",
        "MatchingText": "&lt;tag1 name=\"input\" id=\"input\"&gt; ||| &lt;tag2&gt; ||| &lt;tag1 src=\"/home.jpg\" /&gt; ||| &lt;/tag1&gt;",
        "NonMatchingText": "&lt;tag1 ||| tag2&gt;",
        "Description": "This is expression is good if you need to clean up some code (like from using DW Design View or Front Page). Just  the \"tag1\" and \"tag2\" with the tags you want, and you can add more by putting a | inbetween each tag."
    },
    {
        "Pattern": "(src|href|action)=\"(http://|#|mailto:|&)([^/#\"])",
        "MatchingText": "src=\"images\" ||| href=\"index.html\" ||| action=\"process.php\"",
        "NonMatchingText": "src=\"/images\" ||| href=\"/index.html\" ||| action=\"/process.php\" || href=\"http://www.google.com\" ||| href=\"mailto:ceo@ceo.com\" ||| href=\"#\" ||| href=\"\" ||| href=\"&name=test\"",
        "Description": "If when making a website you need to find your relative paths, this regex will find them. You can use the follow to make them absolute:\n\\1=\"/\\2"
    },
    {
        "Pattern": "<a((?:( title=)[^\">]*\"[^\">]*\")+)>([^<]+)<\\/a>",
        "MatchingText": "&lt;a href=\"/\"&gt;Home&lt;/a&gt; ||| &lt;a href=\"/\" style=\"font-size: 30px\"&gt;Home&lt;/a&gt;",
        "NonMatchingText": "&lt;a href=\"/\"&gt;&lt;span style=\"font-size: 30px\"&gt;Home&lt;/span&gt;&lt;/a&gt;",
        "Description": "Use the above pattern with this replacement pattern: \"<a\\1 title=\"\\2\">\\2</a>\" and it will put title tags in all of your anchors that don't have a title tag."
    },
    {
        "Pattern": "\\b(000)(666)(9)[0-9]{3}[ -]?(00)[0-9]{2}[ -]?(0000)[0-9]{4}\\b",
        "MatchingText": "123-45-6789, 123 45 6789, 123456789, 123-45 6789, 123-456789, 123 456789, etc.",
        "NonMatchingText": "000-45-6789, 666-45-6789, 123-00-6789, 123-45-0000, 900-45-6789 through 999-45-6789",
        "Description": "Finds 9 digit numbers within word boundaries, not separated or separated by - or space, not starting with 000, 666, or 900-999, not containing 00 or 0000 in the middle or at the end of SSN (in compliance with current SSN rules)."
    },
    {
        "Pattern": "((?:Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Sept|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?))(\\s+)[0-9]{2,4}",
        "MatchingText": "Apr 2003 January 2019 Jun       1992",
        "NonMatchingText": ".",
        "Description": "Matches month and year in the specified format."
    },
    {
        "Pattern": "^(.*)",
        "MatchingText": "The car is speeding at 190mph.",
        "NonMatchingText": ".",
        "Description": "The above expression pulls the first line of any large text or sentence.\n\nEg. \nThe car is speeding at 190mph.<br or \\n or nextline>\nThe car got crashed.\n\n"
    },
    {
        "Pattern": "start\\s*([^$]*)\\s*(.*?)",
        "MatchingText": "start with a hello world program !!",
        "NonMatchingText": ".",
        "Description": "Matches a string and grabs all data till the end of the string/text/sentence.\n\nEg.\n\nI wonder why all programming languages start with a hello world program !!\n\n\n"
    },
    {
        "Pattern": "wonder\\s*([^$]*)\\s*with",
        "MatchingText": "wonder why all programming languages start with",
        "NonMatchingText": ".",
        "Description": "Matches and returns the text provided the match string and the end string. Eg. I wonder why all programming languages start with a hello world program !!"
    },
    {
        "Pattern": "^(\\$\\ |\\$)?((0|00|[1-9]\\d*|([1-9]\\d{0,2}(\\,\\d{3})*))(\\.\\d{1,4})?|(\\.\\d{1,4}))$",
        "MatchingText": "$ 123.4|||$00.5|||200,000",
        "NonMatchingText": "$012,234.44|||-39.05|||$45,23,330.00",
        "Description": "Allows for a dollar sign with no space after, a dollar sign with a space after, and no dollar sign.  Also makes sure theres no more than 4 decimal places.  Takes out leading zeros if the number isn't 0, and protects against blank entries."
    },
    {
        "Pattern": "^\\s*[a-zA-Z0-9,\\s]+\\s*$",
        "MatchingText": "Valid Text, 1 ||| 2nd Text is valid ||| Comma , is valid",
        "NonMatchingText": "asd#!#@|||asdfasd_asdf|||2323_SDF_sdf",
        "Description": "This regular expression allows user to add string spaces and numbers."
    },
    {
        "Pattern": "^(([a-zA-Z0-9]+([\\-])?[a-zA-Z0-9]+)+(\\.)?)+[a-zA-Z]{2,6}$",
        "MatchingText": "www.domain.com|||your-domain.com|||www.sub-domain.your-domain.museum",
        "NonMatchingText": ".domain.com|||your---domain.com|||www.-sub-.com",
        "Description": "Checks domain names. This will match all of the valid domains. It will accept TLD's that are from 2 to 6 characters. You can not have more then one dash or period next to each other. Also it will not let you have dashes at end of the words."
    },
    {
        "Pattern": "{.*}",
        "MatchingText": "{User}, thank you for submitting a new project request!",
        "NonMatchingText": "Thank you for submitting a new project request!",
        "Description": "Simple, but it gave me trouble in the c#..."
    },
    {
        "Pattern": "^(?:-([0-9]{1,2})|([0-9]{4}))?(?:-?(?:([0-9]{2})?(?:-?([0-9]{2}))?|W([0-9]{2})(?:-?([1-7]))?|([0-9]{3})))?(?:T([0-9]{2})(?::?([0-9]{2})(?::?([0-9]{2}))?)?(?:[,\\.]([0-9]+))?(?:(Z)|([+-])([0-9]{2})(?::?([0-9]{2}))?)?)?$",
        "MatchingText": "19850412T232050Z|||1985-04-12T10:15:30+0400|||1985102|||1985-102|||1985W155|||1985-W15-5|||T23:20:50|||T23,347",
        "NonMatchingText": "11111|||23,5|||23:20",
        "Description": "Validate and parse date/time string in ISO8601 format. Works with complete representation in both with basic and extended formats. Some of turncated representations and most of representations with reduced precision are also supported. It does not validate range of date/time fields in any way.\nCaptured fields may be empty depending on what kind of representation is used.\nYear: $1 two-digit year with implicit century or $2 full 4-digit year.\nCalendar date: $3 month, $4 day of the month.\nWeek date: $5 week of the year, $6 day of the week.\nOrdinal date: $7 day of the year.\nTime: $8 hours, $9 minutes, $10 seconds, $11 fractional part of last non-empty time field.\nTime zone: if $12 is Z then it's UTC zone, otherwise offset may be given as $13 direction (+/-), $14 hours and $15 minutes."
    },
    {
        "Pattern": "([A-Za-z0-9.]+\\s*)+,",
        "MatchingText": "|||bob robertson, peter k knobbly, Dr. P. Crumble\n",
        "NonMatchingText": null,
        "Description": "Matches comma separated names in a row based list of names.  Submatches retrieve name parts, e.g. first name, middle name, initial, surname."
    },
    {
        "Pattern": "^[0-9]*\\/{1}[1-9]{1}[0-9]*$",
        "MatchingText": "1/2|||12/325",
        "NonMatchingText": "-1/2|||2se/4rf",
        "Description": "This regular expression checks if the given string is a fraction. This does not allow 0 either in the numerator or the denominator."
    },
    {
        "Pattern": "^(ht|f)tp(s?)\\:\\/\\/(([a-zA-Z0-9\\-\\._]+(\\.[a-zA-Z0-9\\-\\._]+)+)|localhost)(\\/?)([a-zA-Z0-9\\-\\.\\?\\,\\'\\/\\\\\\+&amp;%\\$#_]*)?([\\d\\w\\.\\/\\%\\+\\-\\=\\&amp;\\?\\:\\\\\\&quot;\\'\\,\\|\\~\\;]*)$",
        "MatchingText": "http://regexlib.com   |   http://www.google.com   |  ftp://teach.me.regex/checkpattern/o   |   http://www.google.com/search?hl=en&source=hp&q=asp.net   |   https://secure.mailserver.com   |   http://localhost/mypage.html   |   http://localhost:89783/mypage.aspx   |   http://go.com   |   http://forum.whoisyourdaddy.org/index.html?RegID=7449046&Daddy=dontknow&son=me",
        "NonMatchingText": "http:// | http://whoisyourdaddy | httpOrhttpsOrftp.com",
        "Description": "Validates URL to see if the input pattern is a valid URL (ftp, http, https, etc); can be easily modified to support others such as file:/// | Pattern has been tested using .NET runtime engine | localhost literal support for windows IIS server and visal studio (2005 or later) built-in asp.net web-server"
    },
    {
        "Pattern": "^(?P<line1>(\\s+)[^\\n]+)\\n(?:(?P<line2>(\\s+)[^\\n]+)\\n)?(?P<city>[^,\\n]+), +(?P<state>-i:A[LKSZRAEP]|C[AOT]|D[EC]|F[LM]|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEHINOPST]|N[CDEHJMVY]|O[HKR]|P[ARW]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY]) +(?P<zip>(?P<zip5>\\d{5})(?:[ -]?(?P<zip4>\\d{4}))?)$",
        "MatchingText": "Cannot enter multi-line example, you'll just have to try it",
        "NonMatchingText": "101 South Park Drive",
        "Description": "Validates the format of a US mailing address that includes a maximum of three lines.\n\nline1 (cannot be whitespace)\nline2 (optional; if present, cannot be whitespace)\ncity, ST 00000-0000 (hyphen and last four digits of zip are optional)\n\nCaptures line1, line2 (if present), city, state, and zip to groups similarly named for further processing."
    },
    {
        "Pattern": "^(?-i:A[LKSZRAEP]|C[AOT]|D[EC]|F[LM]|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEHINOPST]|N[CDEHJMVY]|O[HKR]|P[ARW]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$",
        "MatchingText": "CA|||FL|||HI",
        "NonMatchingText": "Ca|||NK|||CAL",
        "Description": "Validates US state abbreviations used by the Post Office."
    },
    {
        "Pattern": "^(?P<field1>[^,]+),(?P<field2>[^,]+),(?P<field3>[^,]+)$",
        "MatchingText": "Fred,Barnie,Wilma|||Bob,1/1/2003,222-3333|||100,200,300",
        "NonMatchingText": "Fred,Barnie,Wilma,Betty|||Bob;1/1/2003;222-3333|||Tom Dick Harry",
        "Description": "Example of a regular expression that can be used to parse a comma delimited string into constituent, named sub-strings. Add or remove regex subfield definitions (?&lt;field1&gt;[^,]+) and corresponding delimiting characters in the regular expression as necessary to accommodate the string and subfields you intend to parse. Optionally, rename the subfield names in the regular expression to more meaningful names if you are using the parsed sub-strings in a program. Replace all occurrences of the comma in the regular expression with any required alternative delimiting character. As long as the delimiting character used does not occur naturally in any of the sub-strings, you should be good-to-go. NOTE: To change the delimiter character you must replace all occurrences of the comma in the current regex (of which there are 5) with the new delimiter character. e.g. (?&lt;field1&gt;[^;]+); changes the delimiter character to a semi-colon for the first field."
    },
    {
        "Pattern": "^((\\d|[1-9]\\d|2[0-4]\\d|25[0-5]|1\\d\\d)(?:\\.(\\d|[1-9]\\d|2[0-4]\\d|25[0-5]|1\\d\\d)){3})$",
        "MatchingText": "0.0.0.0|||255.255.255.255|||168.129.2.255",
        "NonMatchingText": "02.234.2.1|||168.192.0.256|||1233.0.0.1",
        "Description": "validates a simple ip v4 address. including 0.0.0.0 or 255.255.255.255. leading 0 is and numbers above 255 are forbitten."
    },
    {
        "Pattern": "^((?P<dir>[\\-ld])(?P<permission>([\\-r][\\-w][\\-xs]){3})\\s+(?P<filecode>\\d+)\\s+(?P<owner>\\w+)\\s+(?P<group>\\w+)\\s+(?P<size>\\d+)\\s+(?P<timestamp>(?P<year>\\d{4})-(?P<month>\\d{2})-(?P<day>\\d?\\d)\\s+(?P<hour>\\d{2}):(?P<minute>\\d{2}))\\s+(?P<name>\\w.+))$",
        "MatchingText": "lrwxrwxrwx    1 root   root     13 2005-02-18 18:25 K20xfs -> ../init.d/xfs",
        "NonMatchingText": "-rwxrwwrx   1 root   root     13 2005-02-18 18:25 K20xfs -> ../init.d/xfs",
        "Description": "parsing a linux ftp list string. result is a list of several groups like :\ndir (-,l,d)\npermission (lrwxrwxrwx)\nfilecode (any number)\nowner (what it says - number or text)\ngroup (same as owner)\ntimestamp (what it says, including groups like day, month, hour, minute)\nname (the file, directory or linkname)\n"
    },
    {
        "Pattern": "^((?P<dir>[\\-ld])(?P<permission>([\\-r][\\-w][\\-xs]){3})\\s+(?P<filecode>\\d+)\\s+(?P<owner>\\w+)\\s+(?P<group>\\w+)\\s+(?P<size>\\d+)\\s+(?P<timestamp>(?P<month>[a-z|A-Z]{3})\\s+(?P<day>(\\d?\\d))\\s+(?P<hour>\\d?\\d):(?P<minute>\\d{2}))\\s+(?P<name>\\w.+))$",
        "MatchingText": "drwxr-xr-x    1 501    501    4096 Mar 29     08:16 archive",
        "NonMatchingText": "drwxr-xxww   1 501    501    4096 Mar 29     08:16 archive",
        "Description": "parsing a linux ftp list string. result is a list of several groups like : dir (-,l,d) permission (lrwxrwxrwx) filecode (any number) owner (what it says - number or text) group (same as owner) timestamp (what it says, including groups like day, month, hour, minute) name (the file, directory or linkname)"
    },
    {
        "Pattern": "^((0*[0-1]?[0-9]{1,2}\\.)|(0*((2[0-4][0-9])|(25[0-5]))\\.)){3}((0*[0-1]?[0-9]{1,2})|(0*((2[0-4][0-9])|(25[0-5]))))$",
        "MatchingText": "172.18.200.101 ||| 00172.18.200.001 ||| 172.255.255.255",
        "NonMatchingText": "172.256.255.255 ||| 1072.255.255.255 ||| 172.255.255.1.1",
        "Description": "Matches ip addresses. Takes into account trailing left zeros."
    },
    {
        "Pattern": "^\\b\\d{2,3}-*\\d{7}\\b$",
        "MatchingText": "03-1234567 ||| 050-1234567 ||| 0771234567",
        "NonMatchingText": "1-800-1234567 ||| 04-123456 ||| 9-1234567 ||| 1234567",
        "Description": "Matches almost all Israel phone numbers (without 1800). Generic means it doesn't have a list of allowed prefix (i.e 050,03) because it changes frequently. Instead it accepts any 2-3 digits prefix, with or without hyphen.\n"
    },
    {
        "Pattern": "^[\\d]{1,}?\\.[\\d]{2}$",
        "MatchingText": "1234.56 | 1.50 | 0.50",
        "NonMatchingText": "X23.50 | 23.5 | .50",
        "Description": "This will check that the string is made of up numbers in a D.XX with at least on number for D"
    },
    {
        "Pattern": "(^[+]?\\d*\\.?\\d*[1-9]+\\d*$)|(^[+]?[1-9]+\\d*\\.\\d*$)",
        "MatchingText": "01.23|||0.15|||0.1568",
        "NonMatchingText": "0|||-0.18|||.0",
        "Description": "Accepts only positive decimal values. Zero and negative numbers are non-matching.Allows zeros after last non-zero numeric value after decimal place for significant digits"
    },
    {
        "Pattern": "^((\\d{5}-\\d{4})|(\\d{5})|([AaBbCcEeGgHhJjKkLlMmNnPpRrSsTtVvXxYy]\\d[A-Za-z]\\s?\\d[A-Za-z]\\d))$",
        "MatchingText": "00501|||84118-3423|||n3a 3B7",
        "NonMatchingText": "501-342|||123324|||Q4B 5C5",
        "Description": "Regular expression for US (ZIP and ZIP+4) and Canadian postal codes.  It allows 5 digits for the first US postal code and requires that the +4, if it exists, is four digits long.  Canadain postal codes can contain a space and take form of A1A 1A1.  The letters can be upper or lower case, but the first letter must be one of the standard Canadian zones: A,B,C,E,G,H,J,K,L,M,N,P,R,S,T,V,X,Y."
    },
    {
        "Pattern": "([0-9][0-9])((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\\-([0-9][0-9])\\-([0-9][0-9][0-9][0-9])",
        "MatchingText": "900120-01-5567",
        "NonMatchingText": "909020-01-5567;900120-0A-5567;900120-01-55",
        "Description": "Simple Malaysian New IC Number Validation.\n\nLength: 8 characters.\nFormat: YYMMDD-99-9999"
    },
    {
        "Pattern": "\\(([0-9]{2}|0{1}((x|[0-9]){2}[0-9]{2}))\\)\\s*[0-9]{3,4}[- ]*[0-9]{4}",
        "MatchingText": "(12) 123 1234|||(01512) 123 1234|||(0xx12) 1234 1234",
        "NonMatchingText": "12 123 1234|||(012) 123/1234|||(012) 123 12345",
        "Description": "Match diferent styles for brazilian Phone number code.\nOnly DDD (12), complete DDD (012), complete DDD + Telephony Company (0xx12) plus 3 or 4 digits (city code) plus 4 digits (phone number)."
    },
    {
        "Pattern": "^([a-z0-9]+([\\-a-z0-9]*[a-z0-9]+)?\\.){0,}([a-z0-9]+([\\-a-z0-9]*[a-z0-9]+)?){1,63}(\\.[a-z0-9]{2,7})+$",
        "MatchingText": "800-med-alert.com|||jump.to|||archive-3.www.regexlib.com",
        "NonMatchingText": "example|||a-.domain.com|||http://regexlib.com/",
        "Description": "[Note: this regex was tested with Macromedia's ColdFusion MX.  I'm sure it'll need some massaging to work with other regex engines.]  Of the few domain validating regular expressions I found in my search I didn't find a single one that reliably handled multiple levels of subdomains or TLDs.  So, I wrote one and thoroughly tested it.  There are a ton of matching and non-matching examples that need to be included to show the completeness of this regex.\n\nNon-matching:  -.domain.com, -a.domain.com, -domain.com, domain-.com, any domain where the portion before the tld is greater than 63 characters.\n\nMatching: a.domain.com, a-a.domain.com, a--a.domain.com, a--defg.com, domain.co.uk."
    },
    {
        "Pattern": "((xmlns:.*?=[&quot;,'].*?[&quot;,'])|(xmlns=[&quot;,'].*?[&quot;,']))",
        "MatchingText": "&lt;Registry xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:xsi=&quot;http://www.w3.or",
        "NonMatchingText": "&lt;Registry someattrib=&quot;test&quot; /&gt;",
        "Description": "XML Namespace ( xmlns ) matcher.  Properly matches one or more of either xmlns=&quot;blah&quot; or xmlns:blah=&quot;blooey&quot; .\n\n(for c#, make sure to escape the double-quotes.)\n"
    },
    {
        "Pattern": "<\\s*?[^>]+\\s*?>",
        "MatchingText": "< html > |||  < div style=\"title_1\" class='number'> ||| < div style=\"title_1\" class='number' > ||| < img src=\"img.gif\" / >",
        "NonMatchingText": "Plain text",
        "Description": "This simple pattern is useful for removing all HTML tags with or without atributes. It has no removing white spaces"
    },
    {
        "Pattern": "^(((\\d{4})(0[13578]|10|12)(0[1-9]|[12][0-9]|3[01]))|((\\d{4})(0[469]|11)([0][1-9]|[12][0-9]|30))|((\\d{4})(02)(0[1-9]|1[0-9]|2[0-8]))|(([02468][048]00)(02)(29))|(([13579][26]00) (02)(29))|(([0-9][0-9][0][48])(02)(29))|(([0-9][0-9][2468][048])(02)(29))|(([0-9][0-9][13579][26])(02)(29))|(00000000)|(88888888)|(99999999))?$",
        "MatchingText": "20041212|||20040229|||88888888",
        "NonMatchingText": "20040230|||20041330",
        "Description": "it's for date in the format: &quot;yyyymmdd&quot; and it validates the empty string and some special values (00000000,88888888,99999999) but you can delete these last values. It works with leap years."
    },
    {
        "Pattern": "[()+-.0-9]*",
        "MatchingText": "(123)(123)(456789),+91-9898898982,91.11.45644785,(+125.(456)-45477895 etc",
        "NonMatchingText": "Not allow special caracter exclude(+ - . ( ) ) and alpha(a-z) .",
        "Description": "Phone numbers validation for all country and allow all format for phone no ,contact no ."
    },
    {
        "Pattern": "^(?:[a-zA-Z]\\.?){1,4}$",
        "MatchingText": "J.W.R. ||| JwR ||| j.r. ||| jwre ||| JWWR ||| J.er.e",
        "NonMatchingText": "j..r. ||| jwers ||| jw2 ||| .j.w.r",
        "Description": "This expression will allow someone to place 1-4 Lower case or Upper case letters with optional periods after each letter for a total of up to 8 possible characters."
    },
    {
        "Pattern": "^(((0|128|192|224|240|248|252|254).0.0.0)|(255.(0|128|192|224|240|248|252|254).0.0)|(255.255.(0|128|192|224|240|248|252|254).0)|(255.255.255.(0|128|192|224|240|248|252|254)))$",
        "MatchingText": "255.255.192.0 | 240.0.0.0 | 255.255.255.0",
        "NonMatchingText": "255.0.192.0 |  240.128.0.0 | 240.255.255.0",
        "Description": "netmask address. I know this is nod good enough :)"
    },
    {
        "Pattern": "(^(((([1-9])|([0][1-9])|([1-2][0-9])|(30))\\-([A,a][P,p][R,r]|[J,j][U,u][N,n]|[S,s][E,e][P,p]|[N,n][O,o][V,v]))|((([1-9])|([0][1-9])|([1-2][0-9])|([3][0-1]))\\-([J,j][A,a][N,n]|[M,m][A,a][R,r]|[M,m][A,a][Y,y]|[J,j][U,u][L,l]|[A,a][U,u][G,g]|[O,o][C,c][T,t]|[D,d][E,e][C,c])))\\-[0-9]{4}$)|(^(([1-9])|([0][1-9])|([1][0-9])|([2][0-8]))\\-([F,f][E,e][B,b])\\-[0-9]{2}(([02468][1235679])|([13579][01345789]))$)|(^(([1-9])|([0][1-9])|([1][0-9])|([2][0-9]))\\-([F,f][E,e][B,b])\\-[0-9]{2}(([02468][048])|([13579][26]))$)",
        "MatchingText": "29-Feb-2000|||1-jan-2007|||31-dEC-1770",
        "NonMatchingText": "32-Jan-2001|||30-Feb-2004|||0-nov-2004",
        "Description": "I have written this regular expression for use in javascript. It sould work for other languages directly or with minor changes. The parsing logic in this regular expression works like this : Imagine a tree structure, input at the root, Level 1 : two branches one-non Feb months two-Feb month. In the Feb month again two branches one-leap year Feb and two-non leap year Feb. In the non-Feb branch, we have two branches again, one-30 days month and two-31 days month. Once you get this, I think it will be easier to figure out the rest. "
    },
    {
        "Pattern": "^[^']*$",
        "MatchingText": "asljas|||%/&amp;89uhuhadjkh|||&quot;hi there!&quot;",
        "NonMatchingText": "'hi there!'|||It's 9 o'clock|||'''''",
        "Description": "This one matches all strings that do not contain the single quotation mark (')."
    },
    {
        "Pattern": "(\\b([A-Z]\\s?[A-Z]\\s?[- .:]*[A-Z0-9]\\s?[A-Z0-9][- .:]*[0-9]\\s?[0-9]?\\s?)\\b)",
        "MatchingText": "YY.AA-36|JN89.36|FA22-80",
        "NonMatchingText": "99AA.36|JN*89*36|FAR-22",
        "Description": "Placas Patentes en Chile."
    },
    {
        "Pattern": "\\b(([A-H]|[J-Z])\\s?([A-L]|[N-Z])[-_ :.]*[0-9]\\s?[0-9][-_ :.]*[0-9]\\s?[0-9])\\b|\\b(([B-D]|[F-H]|[J-K]|[L]|[P]|[R-T]|[V-Z])\\s?([B-D]|[F-H]|[J-K]|[L]|[P]|[R-T]|[V-Z])[-_ :.]*([B-D]|[F-H]|[J-K]|[L]|[P]|[R-T]|[V-Z])\\s?([B-D]|[F-H]|[J-K]|[L-N]|[P]|[R-T]|[V-Z])[-_ :.]*[1-9]\\s?[0-9])\\b",
        "MatchingText": "MX-2167 CYHH.19",
        "NonMatchingText": "CYMO-26",
        "Description": "Para PPUS formato AA.0000 y BBBB.00"
    },
    {
        "Pattern": "^(((((0?[1-9])|(1\\d)|(2[0-8]))\\.((0?[1-9])|(1[0-2])))|((31\\.((0[13578])|(1[02])))|((29|30)\\.((0?[1,3-9])|(1[0-2])))))\\.((20[0-9][0-9]))|(29\\.0?2\\.20(([02468][048])|([13579][26]))))$",
        "MatchingText": "1.1.2000|||29.02.2004|||31.12.2099",
        "NonMatchingText": "1.1.1999|||29.02.2003|||01.01.2100",
        "Description": "Regular expression to evaluate a date in German date format (DD.MM.YYYY). Leading zeros for days and months are valid. Period from 1.1.2000 until 31.12.2099 is valid. Leap years are checked."
    },
    {
        "Pattern": "^((((0[13578])|([13578])|(1[02]))[\\/](([1-9])|([0-2][0-9])|(3[01])))|(((0[469])|([469])|(11))[\\/](([1-9])|([0-2][0-9])|(30)))|((2|02)[\\/](([1-9])|([0-2][0-9]))))[\\/]\\d{4}$|^\\d{4}$",
        "MatchingText": "01/01/2001|||1/01/2001|||2002",
        "NonMatchingText": "2/30/2002|||13/23/2002|||12345",
        "Description": "The following validates dates with and without leading zeros in the following formats: MM/DD/YYYY and it also takes YYYY (this can easily be removed).  All months are validated for the correct number of days for that particular month except for February which can be set to 29 days. date day month year"
    },
    {
        "Pattern": "(\\d{1,2})\\W+(\\d{1,2})\\W*(\\d{2,4})?|(\\d{4})\\W(\\d{1,2})\\W(\\d{1,2})|([a-zA-Z]+)\\W*(\\d{1,2})\\W+(\\d{2,4})|(\\d{4})\\W*([a-zA-Z]+)\\W*(\\d{1,2})|(\\d{1,2})\\W*([a-zA-Z]+)\\W*(\\d{2,4})|(\\d{1,2})\\W*([a-zA-Z]+)|([a-zA-Z]+)\\W*(\\d{1,2})|(\\d{2})(\\d{2})(\\d{2,4})?",
        "MatchingText": "05.20.1990, 05201990, 0520, may 5 1990, 5-may-1990",
        "NonMatchingText": "520",
        "Description": "This will return the 3 parts of a date for you.  Splice out the empty array portions and use the 3 parts to build/verify the date."
    },
    {
        "Pattern": "^(.{0,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{4,})|(.{1,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{3,})|(.{2,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{2,})|(.{3,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{1,})|(.{4,}(([a-zA-Z][^a-zA-Z])|([^a-zA-Z][a-zA-Z])).{0,})$",
        "MatchingText": "12345a|||abcde*|||ABC123",
        "NonMatchingText": "12ab|||abcdef|||123456",
        "Description": "Passwords with at least 1 letter, at least 1 non-letter, and at least 6 characters in length.  It is lenthy with a repeating pattern so that I could validate all three conditions in one expression without using a lookahead, \"?=\", which are not handled correctly in Internet Explorer."
    },
    {
        "Pattern": "^\\d[0-9]*[-/]\\d[0-9]*$",
        "MatchingText": "101/",
        "NonMatchingText": "AB111/",
        "Description": "\\d[0-9]*\n1)start should be from 0 to 9, any digit number, should not be blank.\n\n[-/]\n2)- or / compulsary.\n\n\\d[0-9]*\n3)start should be from 0 to 9, any digit number, should not be blank.\n\n4)Blank not allowed"
    },
    {
        "Pattern": "^(?:(A[KLRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY]))$",
        "MatchingText": "CO|||GA|||TX",
        "NonMatchingText": "A|||ZZ|||Florida",
        "Description": "Just a simple US State regex.  Requires valid 2 letter abbreviations."
    },
    {
        "Pattern": "^(19[0-9]{2}|[2-9][0-9]{3})-((0(1|3|5|7|8)|10|12)-(0[1-9]|1[0-9]|2[0-9]|3[0-1])|(0(4|6|9)|11)-(0[1-9]|1[0-9]|2[0-9]|30)|(02)-(0[1-9]|1[0-9]|2[0-9]))\\x20(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$",
        "MatchingText": "2004-07-12 14:25:59|||1900-01-01 00:00:00|||9999-12-31 23:59:59",
        "NonMatchingText": "04-07-12 14:25:59|||20004-07-12 14:25|||2004/07/12 14:25:59",
        "Description": "Checks for the format yyyy-MM-dd HH:mm:ss\nalso known as SortableDateTimePattern (conforms to ISO 8601) using local time. From 1900-01-01 00:00:00 to 9999-12-31 23:59:59. No check for leap year."
    },
    {
        "Pattern": "(^[a-zA-Z][a-zA-Z0-9_]*)|(^[_][a-zA-Z0-9_]+)",
        "MatchingText": "var|||_withunder_score99|||TeSt",
        "NonMatchingText": "_|||123abc|||9",
        "Description": "This pattern can be used for validating a string as a valid element name (e.g. variable or class name) in Microsoft .NET. See also http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vbcn7/html/vbconelementnames.asp"
    },
    {
        "Pattern": "(((0*[1-9]|[12][0-9]|3[01])([-./])(0*[13578]|10|12)([-./])(\\d{4}))|((0*[1-9]|[12][0-9]|30)([-./])(0*[469]|11)([-./])(\\d{4}))|((0*[1-9]|1[0-9]|2[0-8])([-./])(02|2)([-./])(\\d{4}))|((29)(\\.|-|\\/)(02|2)([-./])([02468][048]00))|((29)([-./])(02|2)([-./])([13579][26]00))|((29)([-./])(02|2)([-./])([0-9][0-9][0][48]))|((29)([-./])(02|2)([-./])([0-9][0-9][2468][048]))|((29)([-./])(02|2)([-./])([0-9][0-9][13579][26])))",
        "MatchingText": "01/06/2008,1/1/2008",
        "NonMatchingText": "32/13/2008,00/00/2005",
        "Description": "Date in DD/MM/YYYY or D/M/YYYY format."
    },
    {
        "Pattern": "([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})",
        "MatchingText": "2002-11-03|||2007-17-08|||9999-99-99",
        "NonMatchingText": "2002/17/18|||2002.18.45|||18.45.2002",
        "Description": "Checks for Date in the typical MySQL DB Format. Not mutch but simple to for converting to German date format:\n\n$date = &quot;2003-12-03&quot;;\nif (ereg (&quot;([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})&quot;, $date, $regs)) \n{\n    echo &quot;$regs[3].$regs[2].$regs[1]&quot;; // prints 03.12.2003\n}"
    },
    {
        "Pattern": "#<a\\s*(?:href=[\\'\"]([^\\'\"]+)[\\'\"])?\\s*(?:title=[\\'\"]([^\\'\"]+)[\\'\"])?.*?>((?:(</a>).)*)</a>#i",
        "MatchingText": "<a id='a' class=''b' href='c' title='d'>innerHTML</a>; <a></a>",
        "NonMatchingText": "non a tags",
        "Description": "Returns array of full A tag [0], href [1], title [2] and innerHTML [3]. href, title and innerHTML are optional in tag; will return empty if missing.\nTest will only work using PHP preg_match_all or similar; I ask this site\n to add that option.\nCredit goes to user prometheuzz. "
    },
    {
        "Pattern": "^(http|https|ftp)\\://([a-zA-Z0-9\\.\\-]+(\\:[a-zA-Z0-9\\.&amp;%\\$\\-]+)*@)?((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])|([a-zA-Z0-9\\-]+\\.)*[a-zA-Z0-9\\-]+\\.[a-zA-Z]{2,4})(\\:[0-9]+)?(/[^/][a-zA-Z0-9\\.\\,\\?\\'\\\\/\\+&amp;%\\$#\\=~_\\-@]*)*$",
        "MatchingText": "http://www.sysrage.net|||https://64.81.85.161/site/file.php?cow=moo's|||ftp://user:pass@host.com:123",
        "NonMatchingText": "sysrage.net",
        "Description": "None of the other URL regex's seemed to work right for me, so i threw this together. works well with PHP's ereg()."
    },
    {
        "Pattern": "^(http|https|ftp)\\://([a-zA-Z0-9\\.\\-]+(\\:[a-zA-Z0-9\\.&amp;%\\$\\-]+)*@)*((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])|localhost|([a-zA-Z0-9\\-]+\\.)*[a-zA-Z0-9\\-]+\\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))(\\:[0-9]+)*(/($|[a-zA-Z0-9\\.\\,\\?\\'\\\\\\+&amp;%\\$#\\=~_\\-]+))*$",
        "MatchingText": "http://site.com/dir/file.php?var=moo|||https://localhost|||ftp://user:pass@site.com:21/file/dir",
        "NonMatchingText": "site.com|||http://site.com/dir//",
        "Description": "Ok here's an updated URL regex for you folks. It allows localhost and all TLDs. Feel free to add each country code individually if you want a tighter match."
    },
    {
        "Pattern": "&lt;select(.|\\n)*?selected(.|\\n)*?&gt;(.*?)&lt;/option&gt;(.|\\n)*?&lt;/select&gt;",
        "MatchingText": "&lt;select&gt;&lt;option selected&gt;returned text&lt;/option&gt;&lt;/select&gt;",
        "NonMatchingText": "&lt;select&gt;&lt;option&gt;returned text&lt;/option&gt;&lt;/select&gt;",
        "Description": "All useful examples are multi-line, so not displayed.\n\nthis will match any &lt;select&gt;&lt;/select&gt; block in an HTML document, and the return $3 will contain the displayed text (NOT the value of the displayed option)\n\n"
    },
    {
        "Pattern": "&lt;textarea(.|\\n)*?&gt;((.|\\n)*?)&lt;/textarea&gt;",
        "MatchingText": "&lt;textarea&gt;return&lt;/textarea&gt;",
        "NonMatchingText": "&lt;textarea&gt;returned &lt;/improperTextareaEndTag&gt;",
        "Description": "Matches any textarea block, and returns the text inside it."
    },
    {
        "Pattern": "^(9,)*([1-9]\\d{2}-?)*[1-9]\\d{2}-?\\d{4}$",
        "MatchingText": "9,5143393044|||9,514-339-3044|||339-3044",
        "NonMatchingText": "9,339 3044|||514 440 2009|||(514) 440-2009",
        "Description": "Validates US or Canadian phone numbers with the use of &quot;-&quot; or numbers stuck together. No parantheses allowed as well as spaces. Area code is optional. The &quot;9,&quot; is optional as well, which on some phone systems is needed to dial out."
    },
    {
        "Pattern": "^(\\s(SUN|MON|TUE|WED|THU|FRI|SAT)\\s+(JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)\\s+(0?[1-9]|[1-2][0-9]|3[01])\\s+(2[0-3]|[0-1][0-9]):([0-5][0-9]):((60|[0-5][0-9]))\\s+(19[0-9]{2}|[2-9][0-9]{3}|[0-9]{2}))$",
        "MatchingText": " MON NOV 16 16:06:02 2009",
        "NonMatchingText": "Mon Nov November Monday 16-06-02",
        "Description": "To parse the above type of detailed date and time format."
    },
    {
        "Pattern": "^100$|^100.00$|^\\d{0,2}(\\.\\d{1,2})? *%?$",
        "MatchingText": "0|0.00|50.25|100|100.00",
        "NonMatchingText": "100.01|-1|5.005",
        "Description": "Allows percent values from 0 to 100 without the % sign.  Can be used with up to 2 decimal places or without any.  Also works in ASP.NET regular expression validator control."
    },
    {
        "Pattern": "^(([1-9])|(0[1-9])|(1[0-2]))\\/((0[1-9])|([1-31]))\\/((\\d{2})|(\\d{4}))$",
        "MatchingText": "01/01/2001|||1/1/2001|||01/1/01",
        "NonMatchingText": "13/01/2001|||1/2/100|||09/32/2001",
        "Description": "Matches U.S. dates with leading zeros and without and with 2 or four digit years"
    },
    {
        "Pattern": "^[0-9]*[1-9]+[0-9]*$",
        "MatchingText": "1 | 12 | 124 | 01 | 0012 | 000124",
        "NonMatchingText": "-1 | a | 1.0 | 0000",
        "Description": "Allows only positive integers that are greater than 0.  Also allows for infinite zeros leading the integer\n\nBased on William Powell's Pattern Title, but modified to allow for leading zeros. "
    },
    {
        "Pattern": "^(([1-9]?\\d|1\\d\\d|2[0-4]\\d|25[0-5]).){3}([1-9]?\\d|1\\d\\d|2[0-4]\\d|25[0-5])$",
        "MatchingText": "0.0.0.0   255.255.255.255     192.168.1.1",
        "NonMatchingText": "02.168.1.1   1234.123.123.123      256.1.1.1",
        "Description": "Regex for IP Address validation. "
    },
    {
        "Pattern": "\\(?(\\d{3})(?:\\)*|\\)\\s*-*|\\.*|\\s*|/*|)(\\d{3})(?:\\)*|-*|\\.*|\\s*|/*|)(\\d{4})(?:\\s?|,\\s?)",
        "MatchingText": "9405551234, (940) 555-1234, 940.555.1234, 940-555-1234, 940-555-1234 x5000, 940-555-1234, ext. 5000, 940-555-1234 8-5pm",
        "NonMatchingText": "94055512345, 9401-546-5468, or any other non-10-digit, non-standard pattern",
        "Description": "Fairly universal regex for matching any US Phone number in .net.  It basically matches the 10 digit phone number using the common US patterns, and allows for any text after the fact.  I use it with the .replace method and pull out \"$1$2$3\" to get the pure 10-digit phone number, and anything after that is just stored as additional text.  this additional text could be an extension, daytime information, hours, etc."
    },
    {
        "Pattern": "^[0-9]{5}([\\s-]{1}[0-9]{4})?$",
        "MatchingText": "12345-1234|||12345|||12345 1234",
        "NonMatchingText": "123451234|||12345 a345|||a2345-1234",
        "Description": "My first Expression. This will match US postal codes (zip codes) using simple 5 digit format with optional 4 digit extention seperated by a space or hyphen. Will not accept letters.\nexample: 12345 or 12345-1234 or 12345 1234."
    },
    {
        "Pattern": "^http://([a-zA-Z0-9_\\-]+)([\\.][a-zA-Z0-9_\\-]+)+([/][a-zA-Z0-9\\~\\(\\)_\\-]*)+([\\.][a-zA-Z0-9\\(\\)_\\-]+)*$",
        "MatchingText": "http://www.jonas.no/~webs(i)der/jon_as.php|||http://www.yahoo.com/net//ore",
        "NonMatchingText": "http://www./no/good|||imap://www.com/",
        "Description": "A very crude url pattern."
    },
    {
        "Pattern": "^((?:\\*)|(?:[0-5]?[0-9])|(?:(?:(?:[0-5]?[0-9])-(?:[0-5]?[0-9]))(?:,(?:(?:[0-5]?[0-9])-(?:[0-5]?[0-9])))*)|(?:(?:[0-5]?[0-9])(?:,(?:[0-5]?[0-9]))*))\\s+((?:\\*)|(?:[0-9]|0[0-9]|1[0-9]|2[0-3])|(?:(?:(?:[0-9]|0[0-9]|1[0-9]|2[0-3])-(?:[0-9]|0[0-9]|1[0-9]|2[0-3]))(?:,(?:(?:[0-9]|0[0-9]|1[0-9]|2[0-3])-(?:[0-9]|0[0-9]|1[0-9]|2[0-3])))*)|(?:(?:[0-9]|0[0-9]|1[0-9]|2[0-3])(?:,(?:[0-9]|0[0-9]|1[0-9]|2[0-3]))*))\\s+((?:\\*)|(?:[1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1])|(?:(?:(?:[1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1])-(?:[1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1]))(?:,(?:(?:[1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1])-(?:[1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1])))*)|(?:(?:[1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1])(?:,(?:[1-9]|0[1-9]|1[0-9]|2[0-9]|3[0-1]))*))\\s+((?:\\*)|(?:[1-9]|0[1-9]|1[0-2])|(?:(?:(?:[1-9]|0[1-9]|1[0-2])-(?:[1-9]|0[1-9]|1[0-2]))(?:,(?:(?:[1-9]|0[1-9]|1[0-2])-(?:[1-9]|0[1-9]|1[0-2])))*)|(?:(?:[1-9]|0[1-9]|1[0-2])(?:,(?:[1-9]|0[1-9]|1[0-2]))*)|(?:\\*)|(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)|(?:(?:(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)-(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec))(?:,(?:(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)-(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)))*)|(?:(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)(?:,(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec))*))\\s+((?:\\*)|(?:[0-6]|0[0-6])|(?:(?:(?:[0-6]|0[0-6])-(?:[0-6]|0[0-6]))(?:,(?:(?:[0-6]|0[0-6])-(?:[0-6]|0[0-6])))*)|(?:(?:[0-6]|0[0-6])(?:,(?:[0-6]|0[0-6]))*)|(?:\\*)|(?:sun|mon|tue|wed|thu|fri|sat)|(?:(?:(?:sun|mon|tue|wed|thu|fri|sat)-(?:sun|mon|tue|wed|thu|fri|sat))(?:,(?:(?:sun|mon|tue|wed|thu|fri|sat)-(?:sun|mon|tue|wed|thu|fri|sat)))*)|(?:(?:sun|mon|tue|wed|thu|fri|sat)(?:,(?:sun|mon|tue|wed|thu|fri|sat))*))$",
        "MatchingText": "15,45 4-5 2 feb *|||00 06,08 * * mon,wed|||00 * * 4 02|||00 * * 4 mon-tue,thu-fri",
        "NonMatchingText": "*****|||0 1 3 * * *|||0 1 * * 7|||60 * * * *|||* 24 * * *|||* * 32 * *|||* * 0 * *|||* * * 13 *|||* * * 0 *|||* * * * mon-tue-wed|||* * * jan-feb-mar *|||* * * jan-fed *",
        "Description": "Validates a cron schedule.\n\nSupports:\n- single values (zero-padded or not)\n- comma-separated lists of values (e.g. '2,14,17')\n- value ranges (e.g. '4-10')\n- list of ranges (e.g. '1-3,5-7')\n- days of the week and months specified as digits or strings (e.g. 'mon-tues', 'feb', '07', '3')\n\nDoes not support non-standard formats:\n- step values (e.g. '5/2')\n- @yearly, @annually, @monthly etc\n- Sunday specified as '7' (instead of '0')\n- 6th field (year)\n\nCapturing groups:\n1: minute\n2: hour\n3: day of the month\n4: month\n5: day of the week"
    },
    {
        "Pattern": "^((\\d[-. ]?)?((\\(\\d{3}\\))|\\d{3}))?[-. ]?\\d{3}[-. ]?\\d{4}$",
        "MatchingText": "1(555)444-3333|||202.555.3333|||555-4444",
        "NonMatchingText": "555-222-33334|||1(303)5a4-5555|||1 202) 111-3333",
        "Description": "This is a pretty flexable phone number validator for US numbers.  Allows optional country code and area code.  Allows separation of numbers with &quot; &quot;, &quot;-&quot;, &quot;.&quot; or nothing to seperate.  Area codes can be in parenthesis or not.  Validates that you'll get 7, 10, or 11 digits in the way the most number of people option when writing them."
    },
    {
        "Pattern": "^[a-zA-Z]\\w{0,30}$",
        "MatchingText": "ABC1_1 ||| ABcdef ||| abc_def_123",
        "NonMatchingText": "1A || _ABC ||| a1234567890123456789012345678901",
        "Description": "A simple expression to verify a FORTRAN variable name to within 31 chars."
    },
    {
        "Pattern": "^[ABCEGHJKLMNPRSTVXY][0-9][A-Z]\\s?[0-9][A-Z][0-9]$",
        "MatchingText": "J0E 1S0, X0E 1W0, N0G1L0",
        "NonMatchingText": "I0W 2X9, 123456 ",
        "Description": "Complies with the Canadian Postal Code requirements as described at http://www.infinitegravity.ca/postalcodeformat.htm\n\nAllows for optional center space."
    },
    {
        "Pattern": "^((0[0-9])|(1[0-2])|(2[1-9])|(3[0-2])|(6[1-9])|(7[0-2])|80)([0-9]{7})$",
        "MatchingText": "614321634, 114000900, 703452098",
        "NonMatchingText": "1145329, 491212012, banana",
        "Description": "Ensures a given string matches the basic pattern of a bank routing transit number (RTN), used to identify financial institutions on instruments such as checks. Ensures number is nine digits long and has first two digits that comply with American Bankers Association rules."
    },
    {
        "Pattern": "(\\[url=?\"?)([^\\]\"]*)(\"?\\])([^\\[]*)(\\[/url\\])",
        "MatchingText": "[url=http://www.web.com]link text[/url], [url=\"http://www.web.com\"]link text[/url], [url=banana]link text[/url]",
        "NonMatchingText": "[url=http://www.web.com]link text, [url=http://www.web.com\"][/url], [url][/url], [url=\"http:www.web.com\"]some text[url]",
        "Description": "This expression locates all BBCode style hyperlinks and breaks out the URL and linked text components. The URL attribute can be double-quoted or not, or not present at all. URL attributes (if present) are at $2, linked text is at $4."
    },
    {
        "Pattern": "^[1-9][0-9]{0,2}$",
        "MatchingText": "1|||561|||999",
        "NonMatchingText": "-1|||0|||1000",
        "Description": "All positive non-zero integers between 1 and 999.  You can adjust the upper range of this expression by changing the second number (ie 2) in the {0,2} part of the expression."
    },
    {
        "Pattern": "^((0[1-9]|[12][0-9]|3[01])([/])(0[13578]|[1][02])([/])(19[0-9][0-9]|20[0-9][0-9]))|((0[1-9]|[12][0-9]|30)([/])(0[469]|11)([/])(19[0-9][0-9]|20[0-9][0-9]))|((0[1-9]|[1][0-9]|[2][0-8])([/])(02)([/])(19[0-9][0-9]|20[0-9][0-9]))|((29)([/])(02)([/])(190[48]|19[13579][26]|19[2468][048]|20[02468][048]|20[13579][26]))$",
        "MatchingText": "01/01/1900|||05/12/2014|||31/12/2099",
        "NonMatchingText": "41/01/1900|||21/31/2014|||21/12/1899|||21/12/2100",
        "Description": "This pattern validates dates with slash (/) separator and with years between 1900 and 2099."
    },
    {
        "Pattern": "(SELECT\\s(?:DISTINCT)?[A-Za-z0-9_\\*\\)\\(,\\s\\.'\\+\\|\\:=]+?)\\s(?:FROM\\s[\\w\\.]+)",
        "MatchingText": "SELECT * FROM table",
        "NonMatchingText": "INSERT (t,a,r) VALUES (1,2,3)",
        "Description": "This finds the SELECT part of a SQL select statement.  It does not find the entire FROM statement.  That is a different RegEx I will post later."
    },
    {
        "Pattern": "^((\\+)?(\\d{2}[-])?(\\d{10}){1})?(\\d{11}){0,1}?$",
        "MatchingText": "+91-9764544544 | 09764544544 | 01087656444 | +91-1087656444",
        "NonMatchingText": "+91-01087656444 | +91-09764544544 | +9178786765652",
        "Description": "India phone number, accept with optional +91 national code and 0 for land and mobile number prefix . Allows optional - after national code"
    },
    {
        "Pattern": "(http|ftp|https)://[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,4}(/\\S*)?$",
        "MatchingText": "http://domain-1.us|||ftp://www.domain.co.uk|||https://domain.info|||https://subdomain.domain.info|||http://subdomain.domain.info/\u0627\u0644\u062C\u0632\u0627\u0626\u0631.html",
        "NonMatchingText": "http://domain.infor|||http://domain_1.com",
        "Description": "This Regex check protocol (ftp, http, https), extension should be between 2 and 4 chars example (.co.uk, .com, .us and .info), domain or subdomain name between protocol and extension should contain the following chars\na-z, A-Z, 0-9, \"-\", and \".\"\nThe rest of URL after \"/\" contain unicode char"
    },
    {
        "Pattern": "[URL=[a-zA-Z0-9.:/_\\-]+\\][a-zA-Z0-9._/ ]+\\[/URL\\]",
        "MatchingText": "[URL=http://www.luvs.org]Luvs.org[/URL]",
        "NonMatchingText": "http://www.luvs.org",
        "Description": "A simple match for BBCode type strings.  I had to code my own BBCode scheme for a project that I had taken up and really this is my first RegEx so I thought that I would share.  You could modify this to work with any BBCode type of string that has the [TAG=VALUE]Desc[/TAG] syntax."
    },
    {
        "Pattern": "[B\\][a-zA-Z0-9._/ ]+\\[/B\\]",
        "MatchingText": "[B]Bold[/B]",
        "NonMatchingText": "[Bold]Not Bold[/Not Bold]",
        "Description": "The second type of BBCode that I had to write.  This one is an example of Bolding what is between the blocks though it can easily modified to match other Tags such as Underline or li.  Really anything that would match the BBCode that does not need a value in the first tag (ie. [TAG]Desc[/TAG])."
    },
    {
        "Pattern": "^([\\!#\\$%&'\\*\\+/\\=?\\^`\\{\\|\\}~a-zA-Z0-9_-]+[\\.]?)+[\\!#\\$%&'\\*\\+/\\=?\\^`\\{\\|\\}~a-zA-Z0-9_-]+@{1}((([0-9A-Za-z_-]+)([\\.]{1}[0-9A-Za-z_-]+)*\\.{1}([A-Za-z]){1,6})|(([0-9]{1,3}[\\.]{1}){3}([0-9]{1,3}){1}))$",
        "MatchingText": "sample@domain1.domain2.domain3.museum s?a=m^p!l#e@ola.com ip_address_test@192.168.1.1",
        "NonMatchingText": ".sample@domain.com .sample.@domain.com sample.@domain.com sample@192.168.1.1234 sample@domain..dom sample@.domain.dom",
        "Description": "The following is a powerful regular expression for e-mail address's validation. It was wrote respecting the e-mail addresses' syntax reported in the RFCs and supports both hostnames with multiple sub domains and IP addresses."
    },
    {
        "Pattern": "(((\\[?(?P<Database>[\\w]+)\\]?)?\\.)?(\\[?(?P<Owner>[\\w]+)\\]?)?\\.)?\\[?(?P<Object>[\\w]+)\\]?",
        "MatchingText": "[Table], Table, [Db].[Owner].[Table], [owner].[Table], ..[Table], or any combination there of...",
        "NonMatchingText": "None",
        "Description": "This returns the different parts of an Object Name (Database.Owner.Object).  This can be used for matching or pulling out the different pieces."
    },
    {
        "Pattern": "((?P<Owner>\\[?[\\w\\d]+\\]?)\\.{1})?(?P<Column>\\[?[\\w\\d]+\\]?)(\\s*(([><=]{1,2})|(Not|In\\(|Between){1,2})\\s*)(?P<Value>[\\w\\d\\']+)",
        "MatchingText": "Select ... Where (T.Column1 = @Value) ...Update Table1 Set Col1 = @Value",
        "NonMatchingText": "None",
        "Description": "This expression finds all Column within a Select, Update, or Delete query (ex. Column1 = 2, Column2 = 3).  This is useful if you need to refactor a SQL Statement to include a owner prefix before all columns but you aren't sure how many columns there are in the statement."
    },
    {
        "Pattern": "^\\d{5}(-\\d{4})?$",
        "MatchingText": "98121|||00988|||12345-6789",
        "NonMatchingText": "98121-|||12345-678|||1234",
        "Description": "Zip+4 Zipcode RegEx. You may ommit the +4 digits but you must also then ommit the hyphen/dash as well. In 1983, the Postal Service\u2122 began using an expanded ZIP Code\u2122 number called called the &quot;ZIP+4&#174;&quot; Code. The nine digits of a ZIP+4 code (e.g., 12345-6789) is broken down as follows: [123]Sectional Center or Large City. [45]Post Office\u2122 facility or Delivery Area. [-]Required &quot;dash&quot; or &quot;hyphen&quot;. [67]Sector or Several Blocks. [89]Segment or One Side of a Street. Also just FYI, ZIP codes in the northeast US frequently start with '0' or '00'. [00988-Carolina, PR] [03110-Bedford, NH].  Thanks, Ryan v-"
    },
    {
        "Pattern": "([0]{1}[6]{1}[-\\s]*([1-9]{1}[\\s]*){8})|([0]{1}[1-9]{1}[0-9]{1}[0-9]{1}[-\\s]*([1-9]{1}[\\s]*){6})|([0]{1}[1-9]{1}[0-9]{1}[-\\s]*([1-9]{1}[\\s]*){7})",
        "MatchingText": "06 539 439 99|||023-123 1233|||023 121 12 12",
        "NonMatchingText": "06-539-439-99|||05-75 46 30 50",
        "Description": "Matches dutch telephone numbers WITHOUT country code prefix\n\nTests on mobile numbers, 3 digits prefix city-codes and 4 digit prefix city codes.\n* Disallows a 0 directly after a prefix\n* Allows space or a - between prefix and telephonenumber\n* Also allows space between telephone digits to compensate the nasty habit of making telphone numbers more readable"
    },
    {
        "Pattern": "\\d+,?\\d+\\$?",
        "MatchingText": "1212,12112 | 123132123,1231231,212",
        "NonMatchingText": ",13213213,1231231,23123,",
        "Description": "It allow number and comma. But on start and end it does not allow comma."
    },
    {
        "Pattern": "^(/w|/W|[^<>+?$%{}&])+$",
        "MatchingText": "John Doe Sr.|||100 Elm St., Suite 25|||Valerie's Gift Shop",
        "NonMatchingText": "<h1>Hey</h1>",
        "Description": "simple expression for excluding a given list of characters.  simply change the contents of [^] to suite your needs.  for example ^(/w|/W|[^&lt;&gt;])+$ would allow everything except the characters &lt; and &gt;."
    },
    {
        "Pattern": "^(((0[1-9]{1})|(1[0-2]{1}))\\/?(([0-2]{1}[1-9]{1})|(3[0-1]{1}))\\/?(([12]{1}[0-9]{1})?[0-9]{2}) ?(([01]{1}[0-9]{1})|(2[0-4]{1}))\\:?([0-5]{1}[0-9]{1}))$",
        "MatchingText": "01/15/07 1745|||011507 1745|||01/15/2007 17:45|||0115071745",
        "NonMatchingText": "13/15/07 1745|||013207 1745|||01/15/2007 25:45|||0115071762",
        "Description": "This will validate any date (does not check for number of days in month, just 31 days or less) in almost any format as long as the order follows month, day, year, hour, minute, and each part has at least 2 digits."
    },
    {
        "Pattern": "((\\(\\d{3}\\) ?)|(\\d{3}[- \\.]))?\\d{3}[- \\.]\\d{4}(\\s(x\\d+)?){0,1}$",
        "MatchingText": "(123) 456-7890|||(123) 456-7890 x123",
        "NonMatchingText": "(123) 456-7890 x123x|||(123) 456-7890 x123 x123|||(123) 456-7890 x",
        "Description": "This will match US most common telephones format with extension or with out extension.  Works with both Java and .NET."
    },
    {
        "Pattern": "\\d{3}-\\d{6}",
        "MatchingText": "040-244648",
        "NonMatchingText": "04-2446474",
        "Description": " this is about land line number in AP ."
    },
    {
        "Pattern": "^((?:(?:(?:[a-zA-Z0-9][\\.\\-\\+_]?)*)[a-zA-Z0-9])+)\\@((?:(?:(?:[a-zA-Z0-9][\\.\\-_]?){0,62})[a-zA-Z0-9])+)\\.([a-zA-Z0-9]{2,6})$",
        "MatchingText": "abc@def.gh|||a+b_c@d-e_f.gh|||abc@def.ghijkl",
        "NonMatchingText": "__@__.__|||-a-@-b-.cd|||a--b@c__d.ef",
        "Description": "Captures Submatches, problem:domainname length can be longer than 64 chars, because every [a-zA-Z0-9][\\.\\-_] is only countet as one char."
    },
    {
        "Pattern": "^((?:(?:(?:\\w[\\.\\-\\+]?)*)\\w)+)\\@((?:(?:(?:\\w[\\.\\-\\+]?){0,62})\\w)+)\\.(\\w{2,6})$",
        "MatchingText": "a-b-c@d-e-f.com|||a@b.ce|||Me@my.museum",
        "NonMatchingText": "abc@def.g|||a--b@c--d.fe|||-abc@-def-.def",
        "Description": "Not a 100% email validation. It doesn't work with IP-Adresses, but it's good for most common cases. At least I hope so."
    },
    {
        "Pattern": "^(([a-zA-Z]{3})?([0-9]{4}))$",
        "MatchingText": "HHH1234 ||| hhh1234",
        "NonMatchingText": "H1H432A",
        "Description": "formata\u00E7\u00E3o de placas de carros brasileiros.\n************************\nFormatting of license plates Brazilian\n"
    },
    {
        "Pattern": "\\[link=\"(?P<link>((.|\\n)*?))\"\\](?P<text>((.|\\n)*?))\\[\\/link\\]",
        "MatchingText": "[link=\"http://www.yahoo.com\"]Yahoo[/link]",
        "NonMatchingText": "[link]http://www.yahoo.com[/link]|||[link=http://www.yahoo.com]Yahoo[/link]",
        "Description": "This can be used in conjunction with the replace method to provide pseudo-code support without having to enable HTML. The replacement string (in ASP.NET, use RegExp.Replace(SourceString, RegularExpressionPattern, ReplacementString) is &lt;a href=&quot;${link}&quot;&gt;${text}&lt;/a&gt;."
    },
    {
        "Pattern": "^(((((0[13578])|([13578])|(1[02]))[\\-\\/\\s]?((0[1-9])|([1-9])|([1-2][0-9])|(3[01])))|((([469])|(11))[\\-\\/\\s]?((0[1-9])|([1-9])|([1-2][0-9])|(30)))|((02|2)[\\-\\/\\s]?((0[1-9])|([1-9])|([1-2][0-9]))))[\\-\\/\\s]?\\d{4})(\\s(((0[1-9])|([1-9])|(1[0-2]))\\:([0-5][0-9])((\\s)|(\\:([0-5][0-9])\\s))([AM|PM|am|pm]{2,2})))?$",
        "MatchingText": "11/30/2003 10:12:24 am|||2/29/2003 08:14:56 pm|||5/22/2003",
        "NonMatchingText": "11/31/2003 10:12:24 am|||2/30/2003 08:14:56 pm|||5/22/2003 14:15",
        "Description": "Following expression can be used to validate a datetime column from SQL Server.  This expression is an enhanced version of Scott Watermasysk's date/time submission.  It now accepts leading zeros in months, days, and hours.  In addition, this expression properly handles the 11th hour.   Watermasysk's would take the 10th and 12th hour but not the 11th.  This regex has been tweaked to do so.  Does not handle the February 29th problem on non-leap years yet.  Will learn a little more about RegEx and do so in later submission.\n"
    },
    {
        "Pattern": "(\\w+([-+.']\\w+)*@(gmail.com))",
        "MatchingText": "tester@gmail.com",
        "NonMatchingText": "tester@gmail.net   tester@bob.com",
        "Description": "This expression will fail if the host/domain does not end with @gmail.com"
    },
    {
        "Pattern": "^([0]?\\d|1\\d|2[0-3]):([0-5]\\d):([0-5]\\d)$",
        "MatchingText": "1:01:01||||01:01:01||||12:23:33:||||22:09:59",
        "NonMatchingText": "1:23||||24:00:00",
        "Description": "Matches U.S. military time with option leading zero and required seconds."
    },
    {
        "Pattern": "(?P<dice>\\d*)(?P<dsides>(?P<separator>[\\d\\D])(?P<sides>\\d+))(?P<modifier>(?P<sign>[\\+\\-])(?P<addend>\\d))?",
        "MatchingText": "2d6+4|||2d6|||d6+4",
        "NonMatchingText": "6-|||d|||2d",
        "Description": "D&amp;D dice:\nIf no dice are entered, 1 can be assumed.\nd or D is required to indicate sides, and cannot exist without a sides digit.\nThe modifier is optional.  However, if there is a modifier, a sign and an addend must be included."
    },
    {
        "Pattern": "^([0])([1])([1,2,3,4,6,7,8,9])([0-9][0-9][0-9][0-9][0-9][0-9][0-9])",
        "MatchingText": "0171234567|||0141234567|||0167791990",
        "NonMatchingText": "0151234567|||0211234567|||1011234567",
        "Description": "accepts malaysian mobile number example (011,012,013...) plus 7 additional numbers"
    },
    {
        "Pattern": "'(?P<document>.*)'\\)(?P<path>.*)",
        "MatchingText": "('storage=xmlcs:doc.xml;username=admin;password=nothing;')//node[@id='222']",
        "NonMatchingText": "(storage=xmlcs:doc.xml;username=admin;password=nothing;)//node",
        "Description": "Very easy expression for using with arachnoWare XmlDbelt for obtaining information about data store connection string and XPath based query over the store."
    },
    {
        "Pattern": "^[a-zA-Z0-9]+$",
        "MatchingText": "adad1213|||1231dfadfa|||dfad123dfasdfs",
        "NonMatchingText": "dfa@#12313|||*(*sdfasdfadfd|||$fffsdg121ddd#$f1q",
        "Description": "it will check for alphanumeric (Alpha Numeric) values."
    },
    {
        "Pattern": "<a[a-zA-Z0-9 =\"'.:;?]*(href=[\\\"\\'](http:\\/\\/|\\.\\/|\\/)?\\w+(\\.\\w+)*(\\/\\w+(\\.\\w+)?)*(\\/|\\?\\w*=\\w*(&\\w*=\\w*)*)?[\\\"\\'])*(>[a-zA-Z0-9 =\"'<>.:;?]*</a>)",
        "MatchingText": "<a href=\"http://www.google.co.in/hi\">Hindi</a>",
        "NonMatchingText": "href=\"http://www.google.co.in/hi\"",
        "Description": "i've merged two regular expression those i found on this site. thanks to the owners &quot;Ale\u0161 Potocnik and \nAndrew Lee &quot;. i used their expression to make mine. this expression finds the URL/Hyperlink with the HTML tags."
    },
    {
        "Pattern": "&lt;a [a-zA-Z0-9 =&quot;'.:;?]*href=*[a-zA-Z0-9 =&quot;'.:;&gt;?]*[^&gt;]*&gt;([a-zA-Z0-9 =&quot;'.:;&gt;?]*[^&lt;]*&lt;)\\s*/a\\s*&gt;",
        "MatchingText": "&lt;a href=/language_tools?hl=en&gt;Language Tools&lt;/a&gt;|||&lt;a href=&quot;http://www.google.co",
        "NonMatchingText": "&lt;a name=&quot;Lucky&quot;&gt;Lucky&lt;/a&gt;",
        "Description": "you can find all the hyperlinks with their caption and attributes. in other words you can find anchors with their attributes and label or value."
    },
    {
        "Pattern": "(\\d{5})[-.$_ +]?(\\d{7})[-.$_ +]?(\\d{1})",
        "MatchingText": "12345-1234567-8|||12345.1234567_8|||12345$1234567*8",
        "NonMatchingText": "1234-12345678-9",
        "Description": "I use this pattern to match Pakistani CNIC numbers from strings.  "
    },
    {
        "Pattern": "^[1]$|^[3]$|^[4]$|^[6]$|^[1]0$",
        "MatchingText": "1|||4|||10",
        "NonMatchingText": "13|||2|||0",
        "Description": "This will match single numbers,the first block [1346] checks for single digits of 1, 3, 4 or 6, could easily by [1-5] as well. The second block [10] checks for 10 only.\nThis matches inclusively."
    },
    {
        "Pattern": "^[0-9,+,(), ,]{1,}(,[0-9]+){0,}$",
        "MatchingText": "0091(22) 31544|||+1 (116) 23314|||+91(22)311545",
        "NonMatchingText": "91 (22) abc21|||+91 (abc) 23321|||00111623314abc",
        "Description": "It could be used to validate local as well as International Phone nos where the number my be preceeding by + sign for(00) and may have brackets to accept the city code like (22).It will also accept space in between like 001 116 23314"
    },
    {
        "Pattern": "^[a-zA-Z][a-zA-Z0-9_]+$",
        "MatchingText": "MyVariable|||intWhatever|||Blah_Blah",
        "NonMatchingText": "1stVariable|||654|||_asdasd_234",
        "Description": "Validate that the string contains only alphanumeric characters or an underscore. The first character cannot be anything else than alphabetic character.\n\nWe use that to make sure the provided string can be a variable/entity name."
    },
    {
        "Pattern": "^(http(s?)\\:\\/\\/)*[0-9a-zA-Z]([-.\\w]*[0-9a-zA-Z])*(:(0-9)*)*(\\/?)([a-zA-Z0-9\\-\\.\\?\\,\\'\\/\\\\\\+&amp;%\\$#_]*)?$",
        "MatchingText": "http://www.domainname.com |  https://www.domainname.com | http://domainname.com | https://domainname.com | www.domainname.com | domainname.com | http://bit.ly | bit.ly",
        "NonMatchingText": "ftp://www.domainname.com | email@mail.com ",
        "Description": "Matches internet web address."
    },
    {
        "Pattern": "^(([A-Za-z]+[^0-9]*)([0-9]+[^\\W]*)([\\W]+[\\W0-9A-Za-z]*))|(([A-Za-z]+[^\\W]*)([\\W]+[^0-9]*)([0-9]+[\\W0-9A-Za-z]*))|(([\\W]+[^A-Za-z]*)([A-Za-z]+[^0-9]*)([0-9]+[\\W0-9A-Za-z]*))|(([\\W]+[^0-9]*)([0-9]+[^A-Za-z]*)([A-Za-z]+[\\W0-9A-Za-z]*))|(([0-9]+[^A-Za-z]*)([A-Za-z]+[^\\W]*)([\\W]+[\\W0-9A-Za-z]*))|(([0-9]+[^\\W]*)([\\W]+[^A-Za-z]*)([A-Za-z]+[\\W0-9A-Za-z]*))$",
        "MatchingText": "test22!!|||!!test22|||22!!test",
        "NonMatchingText": "test22|||!!test|||22!!",
        "Description": "Password with minimum 1 Letter (A-Za-z), 1 Number (0-9) and Special Character (\\W). It doesn't matter the charaters position. See the Mathching Examples.\n\nQuestion? Write an Email to me."
    },
    {
        "Pattern": "<title>+(.*?)</title>",
        "MatchingText": "<title>this title</title>",
        "NonMatchingText": "any other tags",
        "Description": "This pattern could intercept the value of the tag title in every web pages, it could be found in $1."
    },
    {
        "Pattern": "<meta[\\s]+[^>]*?name[\\s]?=[\\s\\\"\\']+(.*?)[\\s\\\"\\']+content[\\s]?=[\\s\\\"\\']+(.*?)[\\\"\\']+.*?>",
        "MatchingText": "<meta name=\"Author\" content=\"xxxxxx\"> <meta name=\"description\" content=\"xxxxxxxxx\"> <meta name=\"keywords\" content=\"xxxxxxxxx\"> <meta name=\"country\" content=\"IT\">",
        "NonMatchingText": "any other tags",
        "Description": "This pattern intercept meta tags, the name can be found in $1 the content value in $2."
    },
    {
        "Pattern": "<img[\\s]+[^>]*?((alt*?[\\s]?=[\\s\\\"\\']+(.*?)[\\\"\\']+.*?)|(src*?[\\s]?=[\\s\\\"\\']+(.*?)[\\\"\\']+.*?))((src*?[\\s]?=[\\s\\\"\\']+(.*?)[\\\"\\']+.*?>)|(alt*?[\\s]?=[\\s\\\"\\']+(.*?)[\\\"\\']+.*?>)|>)",
        "MatchingText": "< img src=\"src 1\" alt=\"alt 1\"> or < img src=\"src 2\"> or < img src=\"src 3\" alt=\"alt 3\" width=2 height=3>",
        "NonMatchingText": "any other tag",
        "Description": "This pattern can intercept img like < img src=\"src1\" alt=\"alt1\"> or < img alt=\"alt1\" src=\"src1\"> or < img src=\"src1\"> or < img src=\"src1\" width=3 height=4> then values of src can be found in $5 or $8, the value of tag alt can be found in $3 or $10."
    },
    {
        "Pattern": "^(([0]?[1-9]|1[0-2])/([0-2]?[0-9]|3[0-1])/[1-2]\\d{3})? ?((([0-1]?\\d)|(2[0-3])):[0-5]\\d)?(:[0-5]\\d)? ?(AM|am|PM|pm)?$",
        "MatchingText": "12/30/2002|||12/30/2002 9:35 pm|||12/30/2002 19:35:02",
        "NonMatchingText": "18/22/2003|||8/12/99|||8/22/2003 25:00",
        "Description": "Matches variations on date/time/AM-PM. Must have 4 digit year, but everything else is open. Restrictions are: 4 digit year, months 1-12, hours 1-23, minutes and seconds 1-59, any case of AM and PM. If this don't woik, I wrote it, lemmy know."
    },
    {
        "Pattern": "^[1-9]{1}$|^[1-4]{1}[0-9]{1}$|^50$",
        "MatchingText": "1|||23|||50",
        "NonMatchingText": "0|||111|||xyz",
        "Description": "Match any number between 1 and 50, no characters, no empty sets, and not zero. Match numbers greater than 1 and less than 51, no spaces, no characters."
    },
    {
        "Pattern": "\\[(?P<GroupName>.*)\\](?P<GroupContent>[^\\[]+)       --------        [\\s]*(?P<Key>.+)[\\s]*=[\\s]*(?P<Value>[^\\r]+) ",
        "MatchingText": "[FirstGroup] First = First1",
        "NonMatchingText": "asdfg",
        "Description": "Once , use first regex to find groups. and then use the second regex. first results to second regex source."
    },
    {
        "Pattern": "^\\\\([^\\\\]+\\\\)*[^\\/:*?&quot;&lt;&gt;|]?$",
        "MatchingText": "\\temp\\|||\\temp\\content\\|||\\Program Files\\",
        "NonMatchingText": "a:\\Temp\\|||\\Temp\\Content|||c:\\Program Files\\",
        "Description": "Orginally on this site search for Path, go to next page\nyou see a reg expression for ^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&quot;&lt;&gt;|]+\\.htm(l)?$\n\nwhich I modified with this one to disallow drive specification."
    },
    {
        "Pattern": "^[_a-z0-9-]+(\\.[_a-z0-9-]+)*@[a-z0-9]+(-?[a-z0-9]+)?(\\.[a-z0-9]+(-?[a-z0-9]+)?)*\\.([a-z]{2}|xn\\-{2}[a-z0-9]{4,18}|arpa|aero|asia|biz|cat|com|coop|edu|gov|info|int|jobs|mil|mobi|museum|name|net|org|pro|tel|travel|xxx)$",
        "MatchingText": "name@domain.com|||first.last@abc.d-e.fg|||first.middle.last@a-b.c-d.xxx|||name-surname@foreign.xn--h2brj9c",
        "NonMatchingText": "name@abc-.de|||first.last@-abc.defg.hij|||first.last@123.123.123.123",
        "Description": "Validates email addresses (except those using IP) according to list of TLD's http://data.iana.org/TLD/tlds-alpha-by-domain.txt ."
    },
    {
        "Pattern": "^([0-9a-f]{0,4}:){2,7}(:|[0-9a-f]{1,4})$",
        "MatchingText": "2001:db8:abc:1400::|||::|||0000::",
        "NonMatchingText": ":|||0000:|||5678::",
        "Description": "Matches compressed and uncompressed IPv6."
    },
    {
        "Pattern": "\\b[P|p]*(OST|ost)*\\.*\\s*[O|o|0]*(ffice|FFICE)*\\.*\\s*[B|b][O|o|0][X|x]\\b",
        "MatchingText": "P.O. Box, Po Box, Post Office Box, Box, P0 Box",
        "NonMatchingText": "Controller's Office",
        "Description": "This expression will match almost all variations of PO Box."
    },
    {
        "Pattern": "^(900[0-9][0-9]|902[0-9][0-9]|9030[1-5]|9040[1-5]|9050[1-6]|9060[1-6]|90608|90631|90638|90639|90640|90650|90660|90670|90680|9070[1-4]|90706|90710|90712|90713|90715|90716|90717|90723|9073[1-3]|9074[4-6]|90747|90755|9080[2-8]|90810|9081[3-5]|90822|9083[1-2]|90840|90846|910[0-4][0-9]|91101|9110[3-8]|9112[5-6]|9120[1-8]|91214|913[0-6][0-9]|91372|91381|91384|9140[1-3|5-6]|91411|91423|91436|9150[1-2|4|6]|91510|91523|9160[1-2|4-8]|91702|91706|91711|9172[2-4]|9173[1-3]|9174[0-1|4-6|8]|9175[0|4-6]|9176[5-8]|9177[0|3|5-6]|9178[0-1|3]|91789|92621|93510|93523|9353[2|4-6]|93543|93544|9355[0-3]|93563|93591)(-[0-9]{4})?$",
        "MatchingText": "91020",
        "NonMatchingText": "94201",
        "Description": "Finds all the zips in Los Angeles County.  This regex is useful in Ubercart if you have a business presence in L.A. County but not elsewhere in CA.\nList of ZIPS is from http://www.laalmanac.com/communications/cm02_communities.htm"
    },
    {
        "Pattern": "(\\+91(-)?|91(-)?|0(-)?)?(9)[0-9]{9}",
        "MatchingText": "+919123456789 ||| +91-9123456789 ||| 919123456789 ||| 09123456789 ||| 9123456789",
        "NonMatchingText": "8123456789 ||| +91-912345678 ||| +9191234567890",
        "Description": "This expression will be useful to check mobile \nnumber of India. This expression will check \nvarious types of number like number in local \nformat or international number separated by \nhyphen(-) or not.\n"
    },
    {
        "Pattern": "([0-9]{6}|[0-9]{3}\\s[0-9]{3})",
        "MatchingText": "360311 ||| 360 311 ||| 360 001",
        "NonMatchingText": "36 0311 ||| 3603111 ||| 360 31 ||| 36031",
        "Description": "This expression will be useful to check postal code or pin code of India. This expression will check postal code or pin code in two format. One is code is separated by space after 3 digit and another is code is written in 6 digit."
    },
    {
        "Pattern": "^(0)44[\\s]{0,1}[\\-]{0,1}[\\s]{0,1}2[\\s]{0,1}[1-9]{1}[0-9]{6}$",
        "MatchingText": "044-26320244 | 04426320244",
        "NonMatchingText": "044-12345678 | 123-12345678 ",
        "Description": "This expression will help you to match chennai telephone numbers. chennai bsnl telephone numbers will start from 2."
    },
    {
        "Pattern": "^[1-9][0-9]{0,6}(|.[0-9]{1,2}|,[0-9]{1,2})?",
        "MatchingText": "9,99   |  9.99  |  9         |  9999999,99",
        "NonMatchingText": "9,9.9  |  9.      |  9,999  | 099999999999",
        "Description": "It allows separators ',' & '.', max. 2 decimals, value must be between 1 & 9999999,99"
    },
    {
        "Pattern": "^[:*:]",
        "MatchingText": "*, *Asdf",
        "NonMatchingText": "a*, asdf",
        "Description": "This checks whether the string is equals to \"*\" i.e., contains only \"*(Asterisk)\" or begins with Asterisk."
    },
    {
        "Pattern": "^1000([.][0]{1,3})?$|^\\d{1,3}$|^\\d{1,3}([.]\\d{1,3})$|^([.]\\d{1,3})$",
        "MatchingText": ".123|||0.126|||1000.000",
        "NonMatchingText": ".1234|||0.1b6|||1000.001",
        "Description": "allows positive none-to-3-decimal values between 0.000 and 1000.000"
    },
    {
        "Pattern": "^(\\-)?1000([.][0]{1,3})?$|^(\\-)?\\d{1,3}$|^(\\-)?\\d{1,3}([.]\\d{1,3})$|^(\\-)?([.]\\d{1,3})$",
        "MatchingText": "123.456|||-0.125|||-1000.000",
        "NonMatchingText": "123.4567|||-0.1b5|||-1000.001",
        "Description": "allows positive and negative none-to-3-decimal values between -1000.000 and 1000.000"
    },
    {
        "Pattern": "^\\$?\\-?([1-9]{1}[0-9]{0,2}(\\,\\d{3})*(\\.\\d{0,2})?|[1-9]{1}\\d{0,}(\\.\\d{0,2})?|0(\\.\\d{0,2})?|(\\.\\d{1,2}))$|^\\-?\\$?([1-9]{1}\\d{0,2}(\\,\\d{3})*(\\.\\d{0,2})?|[1-9]{1}\\d{0,}(\\.\\d{0,2})?|0(\\.\\d{0,2})?|(\\.\\d{1,2}))$|^\\(\\$?([1-9]{1}\\d{0,2}(\\,\\d{3})*(\\.\\d{0,2})?|[1-9]{1}\\d{0,}(\\.\\d{0,2})?|0(\\.\\d{0,2})?|(\\.\\d{1,2}))\\)$",
        "MatchingText": "($4,000.00)|||-$4000.00|||-$400.00",
        "NonMatchingText": "4,00.000|||abc|||$",
        "Description": "currency format that allows optional $, optional &quot;-&quot;(MinusSignNegative) OR &quot;()&quot; (ParenNegative) but not both, optional cents, and optional commas separating thousands. Minus sign can be before or after $, but parens must be outside the $. UPDATED: now fails to match a &quot;$&quot; without any further numbers"
    },
    {
        "Pattern": "^([a-z]{1,6}[ ']){0,3}([\u00C9\u00C8\u00CA\u00CB\u00DC\u00DB\u00CE\u00D4\u00C4\u00CF\u00D6\u00C4\u00C5\u00C7A-Z]{1}[\u00E9\u00E8\u00EB\u00EA\u00FC\u00FB\u00E7\u00EE\u00F4\u00E2\u00EF\u00F6\u00E4\u00E5a-z]{2,}[- ']){0,3}[A-Z]{1}[\u00E9\u00E8\u00EB\u00EA\u00FC\u00FB\u00E7\u00EE\u00F4\u00E2\u00EF\u00F6\u00E4\u00E5a-z]{2,}$",
        "MatchingText": "\"Houbart\", \"Dupont\", \"de Bonhomme\", \"della Faille d'Huisse\", \"Preud'homme\",\" van Wield\"",
        "NonMatchingText": "\"123\", \"DUPONT\", \"dupont\", \"de (...more than one space...)   Bonhomme\",...",
        "Description": "Pattern for user name input form validation <br />Expression pour tester la validit\u00E9 des noms propres lors de la validation des formulaires.  <br />Syntaxe: <br />Les particules (de della, von, op, \u2026..) peuvent \u00EAtre en minuscule  <br />Apr\u00E8s les particules doit appara\u00EEtre un nom, \u00E9crit en minuscule, mais avec la premi\u00E8re lettre en majuscule. <br />Les \u00E9l\u00E9ments du nom peuvent \u00EAtre s\u00E9par\u00E9s par un seul espace, un moins ou une apostrophe"
    },
    {
        "Pattern": "^[1]?[-\\.\\s]?(\\(\\d{3}\\)|\\d{3}){1}[-\\.\\s]?\\d{3}[-\\.\\s]?\\d{4}(\\s+|\\s*[-\\.x]{1}\\d{1,6})?$",
        "MatchingText": "(800) 555-1212  |  999.555.1212 x1234  |  19995551212x123456",
        "NonMatchingText": "555-1212  |  (800 555-1212  |  888...555-1212",
        "Description": "This expression will match a 10 or 11 digit US phone number with optional area code parenthesis, non-standard seperators such as spaces or dot's (.), and an extension up to 6 digits long"
    },
    {
        "Pattern": "^(([$])?((([0-9]{1,3},)+[0-9]{3})|[0-9]+)(\\.[0-9]{2})?)$",
        "MatchingText": "$123,123.00,$ 123,123,123.00",
        "NonMatchingText": "12,1234  , 123.1234",
        "Description": "This expression validation for price."
    },
    {
        "Pattern": "^(([0]\\d)|([1][0-2])|(\\d))[/](([0-2]\\d)|([3][0-1])|(\\d))[/][2][0]\\d{2}[,]\\s(([0]\\d)|([1][0-2])|(\\d))[:][0-5]\\d\\s[AP][M]",
        "MatchingText": "1/31/2086, 9:50 AM ||| 08/04/2082, 09:13 PM ||| 1/2/2000, 1:12 PM",
        "NonMatchingText": "1/31/2086 9:50 AM ||| 08/04/2082, 09:13 ||| 1/2/1900, 1:12 PM",
        "Description": "This is basic datetime validator that does bother with seconds and enforces slashes, a comma after the date, as well as a year that must start with \"20\". Morning and evening are represented by \"AM\" or \"PM\" only."
    },
    {
        "Pattern": "([0]{1}[6]{1}[-\\s]*[1-9]{1}[\\s]*([0-9]{1}[\\s]*){7})|([0]{1}[1-9]{1}[0-9]{1}[0-9]{1}[-\\s]*[1-9]{1}[\\s]*([0-9]{1}[\\s]*){5})|([0]{1}[1-9]{1}[0-9]{1}[-\\s]*[1-9]{1}[\\s]*([0-9]{1}[\\s]*){6})",
        "MatchingText": "06 12345678|||010-1234560|||0111-101234",
        "NonMatchingText": "05-43021212|||123-4567890|||1234567890",
        "Description": "Meets dutch phone number requirements.. One posted here before didn't allow the 0 after the first digit of the call ID (so the second number or later after the prefix), which should be allowed. I modified that one to meet full requirements now..\n\nEnjoy!!"
    },
    {
        "Pattern": "^[0-9]*[1-9]+$|^[1-9]+[0-9]*$",
        "MatchingText": "1|||00000428123|||1230000",
        "NonMatchingText": "0|||00000000|||any text or +, - or any other character",
        "Description": "This Expression checks if the value is an integer, positive, not zero and not a decimal.\n\nVery handy for use when people need to fill in whole numbers, like when ordering car parts on a website (you dont want your customers to order -10 tires or 0.7 mirrors.."
    },
    {
        "Pattern": "([0-1][0-9]|[1-2][0-9]|[1-3][0-1])\\/([0][0-9]|[1][0-2])\\/(\\d{4})",
        "MatchingText": "31/12/1987|||10/10/2010|||21/02/2019",
        "NonMatchingText": "2/5/1981|||21/6/213|||01/13/1900",
        "Description": "Simple regex that matches european date format with slashes.\nIt doesn\u00B4t validate the different number of days of each month."
    },
    {
        "Pattern": "^([\\w-_.]+)[@]([\\w-_.]+)[.](\\w{2,5})$",
        "MatchingText": "Jason87_Culler@yahoo.world|||Emil-Mayers@tech.support.net|||example_of.email@clien.custom.nz",
        "NonMatchingText": "@yahoo.es|||jason-Mayer@jason.corps|||michael_mamfred.es",
        "Description": "Very simple regular expression that validates email format.\nDesigned to capture user, email client and domain."
    },
    {
        "Pattern": "^(?:m|M|man|Man|v|V|vrouw|Vrouw)$",
        "MatchingText": "m, M, man, Man, v, V, vrouw and Vrouw",
        "NonMatchingText": "a, A, aaa, Female",
        "Description": "Classic gender descriptor regex in Dutch."
    },
    {
        "Pattern": "^0[6]{1}(\\-)?[^0\\D]{1}\\d{7}$",
        "MatchingText": "0612345678, 06-12345678",
        "NonMatchingText": "05-12345678, 06-123456789",
        "Description": "Regular expression to validate a mobile phonenumber inside The Netherlands. "
    },
    {
        "Pattern": "^(alfa|alpha|beta|b\u00E8ta|chi|delta|epsilon|eta|\u00E8ta|gamma|iota|kappa|lambda|mu|nu|omega|omicron|omikron|phi|pi|psi|rho|sigma|tau|theta|th\u00E8ta|xi|ypsilon|zeta|z\u00E8ta)$",
        "MatchingText": "alfa, alpha, beta, b\u00E8ta",
        "NonMatchingText": "betha, meta",
        "Description": "Validate the name of a Greek letter. Supports Dutch and diacritics for European languages."
    },
    {
        "Pattern": "^[0-9]{9}$",
        "MatchingText": "012345678, 123456789",
        "NonMatchingText": "01234567, 1234567890",
        "Description": "Vaildate a 'BurgerServiceNummer' or BSN number (Dutch)."
    },
    {
        "Pattern": "^NL\\d{2}[A-Z]{4}0\\d{9}$",
        "MatchingText": "NL91ABNA0417164300",
        "NonMatchingText": "91ABNA0417164300, NL91 ABNA 0417164300",
        "Description": "Validate an International Bank Account Number (IBAN) without formatting. The first two characters represent the country code, coded according ISO 3166-1.\n\nISO 3166-1"
    },
    {
        "Pattern": "/rapidshare\\.com\\/files\\/(\\d+)\\/([^\\'^\\\"^\\s^>^<^\\\\^\\/]+)/",
        "MatchingText": "http://rapidshare.com/files/61674290/somefile.rar | http://rapidshare.com/files/61674290/somefile2.rar | http://rapidshare.com/files/61674290/Shrek.The.Third_GG_SG_.part1.rar",
        "NonMatchingText": "--",
        "Description": "matches all rapidshare.com links /files / 8 numbers / filename"
    },
    {
        "Pattern": "^\\+[0-9]{1,3}\\.[0-9]+\\.[0-9]+$",
        "MatchingText": "+1.800.555|||+32.50.123456",
        "NonMatchingText": "(800)555|||050/123456",
        "Description": "Matches international formated phonenumber. More info on http://maartendeblock.blogspot.com"
    },
    {
        "Pattern": "&quot;.*?&quot;|&quot;.*$|'.*?'|'.*$",
        "MatchingText": "One &quot;two&quot; three 'fwo' finve 'six|||One &quot;highlighted still 'all highlighted'&quot;|||O",
        "NonMatchingText": "Come on now",
        "Description": "\nThis pattern highlights any characters in double or single quotes, single line only .For the reason that  refreshing the whole document every keystroke would send the application to a crawl. Only Dreamweaver achieve parsing the whole document fast enough. Other application can only achieve refreshing a line dynamically. \nnote: open quotes are highlighted until the end, as they are with most syntax highlighting applications. \n"
    },
    {
        "Pattern": "#^([a-z0-9+\\-.]+):([/]{0,2}([a-z0-9\\-._~%!\\$&'\\(\\)\\*+,;=:]+@)?([\\[\\]a-z0-9\\-._~%!\\$&'\\(\\)\\*+,;=:]+(:[0-9]+)?))([a-z0-9\\-._~%!\\$&'\\(\\)\\*+,;=:@/]*)(\\?[\\?/a-z0-9\\-._~%!\\$&'\\(\\)\\*+,;=:@]+)?(\\#[a-z0-9\\-._~%!\\$&'\\(\\)\\*+,;=:@/\\?]+)?#i",
        "MatchingText": "ftp://ftp.is.co.za/rfc/rfc1808.txt|||http://www.ietf.org/rfc/rfc2396.txt|||ldap://[2001:db8::7]/c=GB?objectClass?one|||mailto:John.Doe@example.com|||news:comp.infosystems.www.servers.unix|||tel:+1-816-555-1212|||telnet://192.0.2.16:80/|||urn:oasis:names:specification:docbook:dtd:xml:4.1.2",
        "NonMatchingText": "asdf?fdjdf:blah|||dskjf:///////blah|||google.com",
        "Description": "This is a Perl regular expression which matches any valid URI. I've extensively tested it (with the help of Wikipedia, and the actual URI specification written by Sir Tim Burners Lee himself), and it seems to work in all cases. Whether it will actually work to validate a URI is questionable... But any URI that is valid, will match. Including those with IPv6 addresses."
    },
    {
        "Pattern": "Akku hp Pavilion dv6000 Series,Kompatibler Ersatz akku f\u00FCr Li-ion hp Pavilion dv6000 Series Laptop Akkus",
        "MatchingText": "hp Pavilion dv6000 Akku",
        "NonMatchingText": "Akku hp Pavilion dv6000 ",
        "Description": "http://www.pcbatterie.de/hp/hp-Pavilion-dv6000-Series-battery.html\n\nHier ist ein neuer Ersatz akku f\u00FCr hp Pavilion dv6000 Series wiederaufladbarer hp Pavilion dv6000 Series Li-ion 8800mAh Laptop Akkus, Akku mit hoher Qualit\u00E4t und g\u00FCstigem Preis. Alle unsere Ersatz akkus und Akkupacks f\u00FCr hp Pavilion dv6000 Series Akku sind ganz neu"
    },
    {
        "Pattern": "^[a-zA-Z]([a-zA-Z0-9])*([\\.][a-zA-Z]([a-zA-Z0-9])*)*$",
        "MatchingText": "java.lang.Object paCKage.myClass99",
        "NonMatchingText": "package.5Class",
        "Description": "Matches any legal java class (inclusive package name)."
    },
    {
        "Pattern": "(^\\-?[0-9]*\\.?[0-9]+$)",
        "MatchingText": "-55.5|||.55|||5.5555555",
        "NonMatchingText": "5..5|||5.5.",
        "Description": "Hi, this is my first try at regular expressions. I was having trouble understanding the syntax and finally I got it work!"
    },
    {
        "Pattern": "[^A-Za-z0-9 ]",
        "MatchingText": "#This Is $$## Where Your Main String Goes",
        "NonMatchingText": "This is a test",
        "Description": "search special character form a given sting space is ignored."
    },
    {
        "Pattern": "((\\/\\*(\\r|\\n|(.(\\*/)))*)\\s\\*\\/|\\/\\/.*$)([\\r\\n\\s]+)?",
        "MatchingText": "/* this matches */|||/** so does this */|||// this too",
        "NonMatchingText": "this does not match",
        "Description": "Matches block comments or line comments, and all whitespace until the next uncommented character."
    },
    {
        "Pattern": "^([A-Z|a-z|&amp;]{3}\\d{2}((0[1-9]|1[012])(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|([02468][048]|[13579][26])0229)(\\w{2})([A|a|0-9]{1})$|^([A-Z|a-z]{4}\\d{2}((0[1-9]|1[012])(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|([02468][048]|[13579][26])0229)((\\w{2})([A|a|0-9]{1})){0,3}$",
        "MatchingText": "ABCD790419|||ABC790419aa1|||ABCD790419AB1",
        "NonMatchingText": "AB790419|||A12790419|||ABC791332",
        "Description": "Registro Federal de Contribuyentes (RFC) , used in Mexico as a unique set of caracters for a person or corporation registration .\n\nRegistro Federal de Contribuyentes utilizado en Mexico para el registro en hacienda."
    },
    {
        "Pattern": "^(?:(([+]|00)92)|0)((3[0-6][0-9]))(\\d{7})$",
        "MatchingText": "+923343751446, 00923343751446, 03343751446",
        "NonMatchingText": "3343751446, 33437514467, 2343751446",
        "Description": "Verify all Pakistan mobile numbers."
    },
    {
        "Pattern": "([(]?\\d{3}[)]?(-| |.)?\\d{3}(-| |.)?\\d{4})",
        "MatchingText": "(305) 555-1212, 305.555.1212, 305-555-1212, 305 555-1212,3055551212",
        "NonMatchingText": "305/555-1212",
        "Description": "Can handle a variety of standard phone formats."
    },
    {
        "Pattern": "^[89]\\d{7}$",
        "MatchingText": "81234532 | 92837465 ",
        "NonMatchingText": "8abec123",
        "Description": "To allow for checking of Singapore mobile numbers. Numbers are 8 digits starting with an 8 or 9 in Singapore."
    },
    {
        "Pattern": "^((\\\\\\\\[a-zA-Z0-9-]+\\\\[a-zA-Z0-9`~!@#$%^&(){}'._-]+([ ]+[a-zA-Z0-9`~!@#$%^&(){}'._-]+)*)|([a-zA-Z]:))(\\\\[^ \\\\/:*?\"\"<>|]+([ ]+[^ \\\\/:*?\"\"<>|]+)*)*\\\\?$",
        "MatchingText": "C:\\Program Files\\Test, \\\\server\\share\\directory",
        "NonMatchingText": "c:?Program Files\\Lab, \\\\$erver\\sh*re\\directory, a:\\di:::r",
        "Description": "This expression was written for C#, and as such you should just be able to drop it in.\nIt matches Windows paths, be they the drive letter version or the UNC version. It was not written to specifically match filenames, but it will in most cases anyway.\nBe aware that Windows has a maximum path+filename length (260 chars on XP) and this regular expression does not check for this. \nThis has been tested against large datasets."
    },
    {
        "Pattern": "^[^ \\\\/:*?\"\"<>|]+([ ]+[^ \\\\/:*?\"\"<>|]+)*$",
        "MatchingText": "bla, file.txt, !@#$",
        "NonMatchingText": "bla , file:txt, /\\*?",
        "Description": "This was written for C# and so you should just be able to drop it into your C# program.\nAlthough you can create files with leading and trailing spaces through non-GUI means, the Windows GUI itself eats those spaces if you try to rename the file. For this reason I made the decision to consider file names with leading and trailing spaces invalid.\nThis has been tested against large data sets."
    },
    {
        "Pattern": "^(?:(?:0?[13578]|1[02])|(?:0?[469]|11)(\\/31)|(?:0?2)(?:(\\/3[01]|\\/29\\/(?:(?:0[^48]|[13579][^26]|[2468][^048])00|(?:\\d{2}(?:0[^48]|[13579][^26]|[2468][^048]))))))\\/(?:0?[1-9]|[12][0-9]|3[01])\\/\\d{4}$",
        "MatchingText": "2/29/2004|||07/16/1492|||12/31/1999",
        "NonMatchingText": "2/29/2003|||2/29/2100|||11/31/2003",
        "Description": "will match all dates in mm/dd/yyyy format. takes into account leap-years and months without 31 days."
    },
    {
        "Pattern": "^(\\d{5}-\\d{4}|\\d{5})$",
        "MatchingText": "12345|||12345-1234",
        "NonMatchingText": "12345-12345|||123|||12345-abcd",
        "Description": "this works with ASP.net regular expression valiadtors, ecma script compliant"
    },
    {
        "Pattern": "^(([0-9]{2,4})([-\\s\\/]{0,1})([0-9]{4,8}))?$",
        "MatchingText": "02/583725|||3471231231|||02 12345678",
        "NonMatchingText": "+3902/583725|||0 2998765|||02 996 876",
        "Description": "validate mobile and land phone numbers.\nAllow space - / or nothing number and area codes"
    },
    {
        "Pattern": "^[0-9]{4}-(((0[13578]|(10|12))-(0[1-9]|[1-2][0-9]|3[0-1]))|(02-(0[1-9]|[1-2][0-9]))|((0[469]|11)-(0[1-9]|[1-2][0-9]|30)))$",
        "MatchingText": "2004-04-30|||2004-02-29",
        "NonMatchingText": "2004-04-31|||2004-02-30",
        "Description": "Matches the date format &quot;YYYY-mm-dd&quot; and also validates month and number of days in a month. All leap year dates &quot;YYYY-02-29&quot; passes trough. Could easily be changed to another format."
    },
    {
        "Pattern": "^(((\\d{4}-((0[13578]-|1[02]-)(0[1-9]|[12]\\d|3[01])|(0[13456789]-|1[012]-)(0[1-9]|[12]\\d|30)|02-(0[1-9]|1\\d|2[0-8])))|((([02468][048]|[13579][26])00|\\d{2}([13579][26]|0[48]|[2468][048])))-02-29)){0,10}$",
        "MatchingText": "2013-01-14 | 2000-02-29 | 0000-12-12",
        "NonMatchingText": "2012-02-29 | 966-04-30 | 2013-01-32 ",
        "Description": "This expression mathes dates formatted as YYYY-MM-DD from 0000-01-01 to 9999-12-31. It checks leap year including all modulo 400, modulo 100 and modulo 4 rules."
    },
    {
        "Pattern": "(^[0-9 ]*$)(^[a-zA-Z ]*$)^([a-zA-Z0-9 ]{6,15})$",
        "MatchingText": "1DAV100",
        "NonMatchingText": "asdfgh,asd.123 etc.,",
        "Description": "This expression validates alphanumeric with one alphabet compulsory and one numeric compulsory and accepts minimum 6 characters and max 15 characters irrespective of the order and case.It doesnt accept special characters"
    },
    {
        "Pattern": "^((http|HTTP|https|HTTPS|ftp|FTP?)\\:\\/\\/)?((www|WWW)+\\.)+(([0-9]{1,3}){3}[0-9]{1,3}\\.|([\\w!~*'()-]+\\.)*([\\w^-][\\w-]{0,61})?[\\w]\\.[a-z]{2,6})(:[0-9]{1,4})?((\\/*)|(\\/+[\\w!~*'().;?:@&=+$,%#-]+)+\\/*)$",
        "MatchingText": "HTTP://www.Rediff.Com",
        "NonMatchingText": "HttP://Www.Rediff.Com etc",
        "Description": "This expression validates urls that starts with http/HTTP/https/HTTPS/ftp/FTP/www/WWW.Its accepts either capital letters or small letters.Address is not case sensitive"
    },
    {
        "Pattern": "^1[34][0-9][0-9]\\/((1[0-2])|([1-9]))\\/(([12][0-9])|(3[01])|[1-9])$",
        "MatchingText": "1377/12/4 1388/4/31 1390/6/14 1389/03/1",
        "NonMatchingText": "1290/12/2 1388/0/8 ",
        "Description": "a simple expression to validate Persian dates."
    },
    {
        "Pattern": " (mailto\\:|(news|(ht|f)tp(s?))\\://)(([^[:space:]]+)|([^[:space:]]+)( #([^#]+)#)?) ",
        "MatchingText": " http://www.domain.com ||| http://www.domain.com/index%20page.htm #linktext# ||| mailto://user@domai",
        "NonMatchingText": "&lt;a href=&quot;http://www.domain.com&quot;&gt;real html link&lt;/a&gt;|||http://www.without_space_",
        "Description": "this is a very little regex for use within a content management software.  links within textfields has not to be written in html.  the editor of the cms is instructed to use it like this:  1. mention spaces in front and behind the url  2. start url with http://, mailto://, ftp:// ...  3. use optional linktext within #linktext# (separated with single space)  4. if there is no linktext the url/email will show up as linktext  5. avoid url with spaces in filename (use %20 urldecode)   replace pattern (space in front):   &lt;a href=&quot;\\\\1\\\\3\\\\4&quot; target=&quot;_blank&quot;&gt;\\\\3\\\\6&lt;/a&gt;"
    },
    {
        "Pattern": "^\\s*(?P<Last>[-A-Za-z ]+)[.](?P<First>[-A-Za-z ]+)(?:[.](?P<Middle>[-A-Za-z ]+))?(?:[.](?P<Ordinal>[IVX]+))?(?:[.](?P<Number>\\d{10}))\\s*$",
        "MatchingText": "SMITH.JOHN.Q.0123456789|||SMITH.JANE.9876543210|||FILCH-TEMPLETON.GEORGE.FILIGREE-WHITE.XXVII.0192837465",
        "NonMatchingText": "JOHN.1234567890|||SMITH.HENRY.123|||A.B.C.D.5647382910",
        "Description": "Matches the Common Name (CN) of the subject of a US Department of Defense (DoD) Common Access Card (CAC). In the plain-text part of the client certificate stored on a CAC, a subject, or the person named as the user of the certificate is represented by their Common Name. This regex identifies CNs and groups the parts that represent first and last name and the unique 10-digit identifying number at the end. I optionally matches the middle name or initial and ordinal (or generation) (II,III,IV, etc), if present.\nIt also accounts for both leading and trailing spaces as well as spaces and dashes within the name parts. It works for all common names I have ever had to deal with, though I do not know where the standard is stated to confirm compliance.\nIt is formatted for use specifically as validation, but could be modified for search."
    },
    {
        "Pattern": "^([1-9]{0,1})([0-9]{1})((\\.[0-9]{0,1})([0-9]{1})|(\\,[0-9]{0,1})([0-9]{1}))?$",
        "MatchingText": "89.56|||14.69|||56,23",
        "NonMatchingText": "100.56|||25.365|||125,56",
        "Description": "Vat percentage format for Indian and Germany.Maximum two digit before decimal and after decimal"
    },
    {
        "Pattern": "^([012346789][0-9]{4})$",
        "MatchingText": "32575|||96543|||56754",
        "NonMatchingText": "987452|||A5632|||A4 432",
        "Description": "Validate Germany postcode contains only 5 digits and starting with 0 to 9."
    },
    {
        "Pattern": "^([012346789][0-9]{4})$",
        "MatchingText": "12545|||58987|||98745",
        "NonMatchingText": "HA7 4EB|||4532222|||700021 ",
        "Description": "Validate Germany pincode only.It Contains 5 digits only starting with any digit from 0 to 9."
    },
    {
        "Pattern": "jquery\\-(\\d|\\.)*\\.min\\.js",
        "MatchingText": "jquery-1.4.2.min.js",
        "NonMatchingText": "jquery.js, jquery-1.3.2.js",
        "Description": "Checks for filename of any version of minified jquery in string."
    },
    {
        "Pattern": "([A-Z]:\\\\[^/:\\*\\?<>\\|]+\\.\\w{2,6})|(\\\\{2}[^/:\\*\\?<>\\|]+\\.\\w{2,6})",
        "MatchingText": "C:\\temp\\this allows spaces\\web.config|||\\\\Andromeda\\share\\file name.123",
        "NonMatchingText": "tz:\\temp\\ fi*le?na:m<e>.doc|||\\\\Andromeda\\share\\filename.a",
        "Description": "This regular expression pattern can be used to check the validity of paths for file upload controls. The uploaded file can be either stored locally or accessible through UNC. It cannot contain illegal characters for the windows OS - that may be supported e.g. on Mac OS \u2013 and cannot be a URL (Yes, as weird as it may seem, some users enter URLs in the file upload box, even though there is a browse button...)"
    },
    {
        "Pattern": "^(\\+(1\\-)?\\d{1,3})?(\\s|\\-)?(\\s|\\-)?((\\(\\d{2}\\)|\\d{2})(\\s|\\-)?\\d{4}|(\\(\\d{3}\\)|\\d{3})(\\s|\\-)?\\d{3})(\\s|\\-)?\\d{4}(\\s)?(x|ext|ext.)?(\\d{1,6})?,?(\\d{1,6})?,?(\\d{1,6})?$",
        "MatchingText": "(55) 1234-5678 x123456,123,12|||5512345678|||+1 (510) 123-5678 x1234",
        "NonMatchingText": "+1 510 (55 1234-5678|||12345678 x123|||+1 (510) 1234-5678 x1234567",
        "Description": "Match mexican local or international numbers with optional area code parentheses and optional max 3 extensions with 6 chars length."
    },
    {
        "Pattern": "(?P<key>\\w+?)\\s*?=\\s*?(?P<value>\\w+)\\s*",
        "MatchingText": "key=KAKI&n=789,index=12 type=7",
        "NonMatchingText": "14788,654",
        "Description": "Get key=value pair, no mater where they are."
    },
    {
        "Pattern": "^({{(\\s+)?v)[\\.-:_](\\w+(\\s+)?}})$",
        "MatchingText": "{{v.input1}}, {{v:a2}}",
        "NonMatchingText": "v.input1, v.:a2, {v.input1}",
        "Description": "Match some varibles names starting with {{v. en ended with }}"
    },
    {
        "Pattern": "^[A-Z\u00D1&]{3,4}\\d{6}(?:[A-Z\\d]{3})?$",
        "MatchingText": "XAXX010101000",
        "NonMatchingText": "XA010101000",
        "Description": "A simple mexican RFC format check."
    },
    {
        "Pattern": "^([987]{1})(\\d{1})(\\d{8})",
        "MatchingText": "9848012345,804812345,7000000000",
        "NonMatchingText": "6897895648,+919848012345",
        "Description": "indian mobile number perfect validation for three number series's that start with 9,8,7. if you want you can easily add one more series that you want in feature. it validates 10 digit number starting with 9,8,7 and followed by 9 digits 0-9 in any order."
    },
    {
        "Pattern": "[1-2][0|9][0-9]{2}[0-1][0-9][0-3][0-9][-][0-9]{4}",
        "MatchingText": "19740609-7845|||19811116-7845|||20010913-7598",
        "NonMatchingText": "21003612-9999|||18790505-4545|||19740641-5559",
        "Description": "Swedish person number. Don't work on persons older then 100 years, but they are so few that it shouldn't be a problem. Easy to fix, but I choose not to accept oldies..."
    },
    {
        "Pattern": "<a\\s+(?:(?:\\w+\\s*=\\s*)(?:\\w+|\"[^\"]*\"|'[^']*'))*?\\s*href\\s*=\\s*(?P<url>\\w+|\"[^\"]*\"|'[^']*')(?:(?:\\s+\\w+\\s*=\\s*)(?:\\w+|\"[^\"]*\"|'[^']*'))*?>[^<]+</a>",
        "MatchingText": "The entire &lt;a href=\"\"&gt;&lt;/a&gt; tag",
        "NonMatchingText": "Links that include any html within the tag.",
        "Description": "This will match an entire HTML tag and will capture the href portion into the named capture \"url\". It will match any anchor tag with any number of attributes."
    },
    {
        "Pattern": "<a\\s+(?:(?:\\w+\\s*=\\s*)(?:\\w+|\"[^\"]*\"|'[^']*'))*?\\s*href\\s*=\\s*(?P<url>\\w+|\"[^\"]*\"|'[^']*')(?:(?:\\s+\\w+\\s*=\\s*)(?:\\w+|\"[^\"]*\"|'[^']*'))*?>.+?</a>",
        "MatchingText": "Any html link (anchor) tag with any content between the opening and closing link tags",
        "NonMatchingText": "all other html tags, link tags without an href section.",
        "Description": "This regex will match all html link tags and captures the url into a named capture \"url\". There can be any html code between the opening and closing link tags. You must use this with the multiline and ignore case options selected."
    },
    {
        "Pattern": "^(0[7-9]|1[012])[/](0[1-9]|[12][0-9]|3[01])[/](19)$",
        "MatchingText": "07/01/19 | 09/21/19 | 08/31/19",
        "NonMatchingText": "02/01/19 | 13/52/65 | 06/30/19",
        "Description": "I needed an expression that would capture the current date and at least future dates. Since I needed users to be honest and to pick the present, I adjusted the expression to only read for the following months of the year and the year 2019 specifically. It's not foolproof or particularly sophisticated, but it is easy to read and edit. The input follows: mm/dd/yy."
    },
    {
        "Pattern": "(^[0-9]*$)(^[a-zA-Z]*$)^([a-zA-Z0-9]{6,8})$",
        "MatchingText": "123456s | abc123 | 123abc",
        "NonMatchingText": "1234567 | +_()'675 | abcdefgh",
        "Description": "It Required Input of a combination of Numbers & Strings also length must be greater than 6..."
    },
    {
        "Pattern": "^([\\w\\.\\-]+)@([\\w\\-]+)((\\.(\\w){2,3})+)$",
        "MatchingText": "example@email.com | exam@e.co | exm@e4u.com",
        "NonMatchingText": "example @ e4u . comm | example @ e4u . comm | example @ e4u . comm",
        "Description": "Email Validator as per Standard all validations are included, check and rate please."
    },
    {
        "Pattern": "^([a-zA-Z][a-zA-Z0-9]{1,100})$",
        "MatchingText": "shailesh123,shailesh,s123ailesh",
        "NonMatchingText": "123shailesh,1Shailesh123",
        "Description": "This expression shows result for the alphanumeric value starts with only alpha bates."
    },
    {
        "Pattern": "/&(\\w+;|#\\d+;)\\S*/g",
        "MatchingText": "&|||&eu|||&;|||&#|||&#83",
        "NonMatchingText": "&euro;|||&#8364;",
        "Description": "Removes invalid or broken HEX and HTML entities from string.\n\nThese will not be matched since they are valid:\n\n&euro;\n&#8364;\n\nThese will be matched since they are invalid entities:\n\n&\n&eu\n&;\n&#\n&#83\n\nEspecially handy in case a string is being manipulated using e.g. substring, which may break entities in either the beginning or end of the string.\nOne might consider using ^ and $ to make it match only beginning and/or end of string.\n\nhttp://regex101.com/r/pM9dE5/16"
    },
    {
        "Pattern": "Need solution for QuickBooks Payroll Service?",
        "MatchingText": "https://www.quickbooks-customerservice.com/quickbooks-payroll-support.html",
        "NonMatchingText": "https://www.quickbooks-customerservice.com",
        "Description": "As a client, you may face some types of QuickBooks issues while Driver installation, you don\u2019t need to worry about this. Contact our committed team specialists who will give you right solution to fix all types of your QuickBooks problems. They are always available at QuickBooks Payroll support +1-800-449-0204 phone number to help you for QuickBooks Payroll related queries. for more info visit https://www.quickbooks-customerservice.com/quickbooks-payroll-support.html"
    },
    {
        "Pattern": "^[2-9]{2}[0-9]{8}$",
        "MatchingText": "2035551212",
        "NonMatchingText": "1035551212 | 555-1212 | (123) 456-7890",
        "Description": "Will not validate numbers starting with 0 or 1.  Only validates digits.\nI cannot take credit for this.  I do not remember where I found it."
    },
    {
        "Pattern": "^[^ ,0]*$",
        "MatchingText": "1,a, 123",
        "NonMatchingText": "' ', 0",
        "Description": "Used for a dropdown list that might have a couple of default selections you want to include."
    },
    {
        "Pattern": "^[^0-9]*(?:(\\d)[^0-9]*){10}$",
        "MatchingText": "1234567890|||585-737-8899|||(324)blah225-foo2587",
        "NonMatchingText": "1234567|||12345678901",
        "Description": "Recently I've been forced to validate phone numbers in a variety of formats, with all sorts of whitespace, dashes, parenthesis, etc. I didn't want to hassel with matching all that junk, I just wanted the 10 numbers!\n\nSo I wrote this expression which captures 10 digits in a string if there are exactly 10 digits. Anything else is allowed so long as there are 10 numbers.\n\nIn .Net, You just loop through the Captures collection of Groups[1] of your Regex.Match object and concatenate the Capture.Value strings to get a simple, pure 10 digit phone number. ( myMatch.Groups[1].Captures )"
    },
    {
        "Pattern": "^(000)\\d{3,4}$",
        "MatchingText": "123|||1234",
        "NonMatchingText": "1|||12|||12345",
        "Description": "This is a bit shorter than the first CVV2/CVC2/CID regex found on the site. It matches any 3 or 4 character number.\n\nNow featuring change per suggestion in comments. Thanks!"
    },
    {
        "Pattern": "^((4(\\d{12}|\\d{15}))|(5\\d{15})|(6011\\d{12})|(3(4|7)\\d{13}))$",
        "MatchingText": "4111111111111|||4111111111111111|||5111111111111111|||6011111111111111|||341111111111111|||371111111111111",
        "NonMatchingText": "411111111111|||51111111111111111|||6111111111111111|||321111111111111|||381111111111111",
        "Description": "Matches Visa, American Express, Discover, and Mastercard only."
    },
    {
        "Pattern": "^100(\\.0{0,2}?)?$|^\\d{0,2}(\\.\\d{0,2})?$",
        "MatchingText": "0|||100|||100.00|||45.45",
        "NonMatchingText": "101|||-5|||45.456",
        "Description": "Matches percentages from 0-100 inclusive with two decimal places."
    },
    {
        "Pattern": "^(?P<national>\\+?(?:86)?)(?P<separator>\\s?-?)(?P<phone>(?P<vender>13[0-4])(?P<area>\\d{4})(?P<id>\\d{4}))$",
        "MatchingText": "+8613012345678|||86 13012345678|||13245679087",
        "NonMatchingText": "+86130123456781231434352|||13560012513|||++8613012345678",
        "Description": "Just test in C#.\n\nValidates a China Unicom mobile phone number with (or without) the International code.\n"
    },
    {
        "Pattern": "^([a-zA-Z1-9]*)\\.(((a|A)(s|S)(p|P)(x|X))|((h|H)(T|t)(m|M)(l|L))|((h|H)(t|T)(M|m))|((a|A)(s|S)(p|P)))",
        "MatchingText": "pagename.html,pagename.aspx,pagename.asp,pagename.htm",
        "NonMatchingText": "pagename.txt,",
        "Description": "Validate  HTM/HTML/ASP/ASPX \ne.g. PageName.html"
    },
    {
        "Pattern": "(((ht|f)tp(s?):\\/\\/)(www\\.[^ \\[\\]\\(\\)\\n\\r\\t]+)|(([012]?[0-9]{1,2}\\.){3}[012]?[0-9]{1,2})\\/)([^ \\[\\]\\(\\),;&quot;\\'&lt;&gt;\\n\\r\\t]+)([^\\. \\[\\]\\(\\),;&quot;\\'&lt;&gt;\\n\\r\\t])|(([012]?[0-9]{1,2}\\.){3}[012]?[0-9]{1,2})",
        "MatchingText": "http://www.sample.com,http://61.61.67.123/test.html",
        "NonMatchingText": "yahoo.com,www.yahoo.com,http://yahoo.com",
        "Description": "Validate URL\ne.g. \nhttp://www.sample.com,\nhttp://61.61.67.123/test.html"
    },
    {
        "Pattern": "^(((0|((\\+)?91(\\-)?))|((\\((\\+)?91\\)(\\-)?)))?[7-9]\\d{9})?$",
        "MatchingText": "9876543210|||09876543210|||919876543210|||+919876543210|||91-9876543210|||+91-9876543210|||(91)9876543210|||(+91)9876543210|||(91)-9876543210|||(+91)-9876543210",
        "NonMatchingText": "9198279|||6789123456|||0-9876543210|||+(91)-9876543210",
        "Description": "First digit can be 7 or 8 or 9.\n\nNo. can have any of the following prefixes\n\n0\n91\n91-\n(91)-\n+91\n(+91)\n(+91)-"
    },
    {
        "Pattern": "^\\$?(([1-9],)?([0-9]{3},){0,3}[0-9]{3}|[0-9]{0,16})(\\.[0-9]{0,3})?$",
        "MatchingText": "1234.23||1,234.245||1.",
        "NonMatchingText": "12,12,0.00||0,123.99",
        "Description": "Currency expression, accepts 4 commas and 4 groups of 3 numbers and 1 number before the first comma, this first number will have to be different from zero. It accepts a number of, two or three decimal. It accepts zero numbers after the point. You can change the number of groups and numbers accespts before and after the point."
    },
    {
        "Pattern": "^((?:[A-Z](?:('|(?:[a-z]{1,3}))[A-Z])?[a-z]+)|(?:[A-Z]\\.))(?:([ -])((?:[A-Z](?:('|(?:[a-z]{1,3}))[A-Z])?[a-z]+)|(?:[A-Z]\\.)))?$",
        "MatchingText": "O'Grady-Smith|||Rachel Ann|||McDonald T.",
        "NonMatchingText": "Timothy J|||James Earl Jones|||@#$!*!",
        "Description": "I wrote this regex to validate first names or last names separately.  Allows for 2 names separated by space or hyphen.  Will accept an abbreviated second name with period.  Has to start with a letter and end with a letter or capital letter with period.\n\nUpdated 3/24/2005: Now, names like McDonald work.  Also, several convenient parts of the match are stored, for example: the Name MacDonald-O'Brian will yield the following: $1=&quot;MacDonald&quot; $2=&quot;ac&quot; $3=&quot;-&quot; $4=&quot;O'Brian&quot; $5=&quot;'&quot;"
    },
    {
        "Pattern": "s/\\b(\\w+)\\b/ucfirst($1)/ge",
        "MatchingText": "THE JIM THOMAS FAMILY",
        "NonMatchingText": "!@#$%",
        "Description": "I had some mailing contacts in a text file in mailing lable layout, and needed to extract them to database I used this regex to fix capitalization for name and address. THE JIM thomas FAMILY becomes The Jim Thomas Family"
    },
    {
        "Pattern": "\\s*([a-z\\. ]+)\\s*\\n\\s*([a-z0-9\\. #]+)\\s*\\n\\s*([a-z \\.]+)\\s*,\\s*([a-z \\.]+)\\s*\\n?(?:\\s*(\\d{1,15}(?:-\\d{1,4})?)\\s*\\n)?(?:\\s*(\\+?(?:1\\s*[-\\/\\.]?)?(?:\\((?:\\d{3})\\)|(?:\\d{3}))\\s*[-\\/\\.]?\\s*(?:\\d{3})\\s*[-\\/\\.]?\\s*(?:\\d{4})(?:(?:[ \\t]*[xX]|[eE][xX][tT])\\.?[ \\t]*(?:\\d+))*))?",
        "MatchingText": "See Description",
        "NonMatchingText": "Won't match most non-word characters in name line, Fairly Permissive with phone number",
        "Description": "View the description correctly formatted here: \nhttp://www.perlmonks.org/?viewmode=public;node_id=471216"
    },
    {
        "Pattern": "(REM [\\d\\D]*?[\\r\\n])|(?P<SL>\\'[\\d\\D]*?[\\r\\n])",
        "MatchingText": "REM comment | 'comment | ''' XML comment",
        "NonMatchingText": "REMA | text='test'",
        "Description": "Filters out VB.NET and VB6.0 comments."
    },
    {
        "Pattern": "(/\\*[\\d\\D]*?\\*/)|(\\/\\*(\\s*|.*?)*\\*\\/)|(\\/\\/.*)|(/\\\\*[\\\\d\\\\D]*?\\\\*/)|([\\r\\n ]*//[^\\r\\n]*)+",
        "MatchingText": "/* multi-line */ | // comment | /// XML Comment",
        "NonMatchingText": "/* multi-line /*",
        "Description": "This regex searches multi-line, single-line, and XML comments present in C# file."
    },
    {
        "Pattern": "\\d{3}[.-]?\\d{3}[.-]?\\d{4}",
        "MatchingText": "555-555-1234",
        "NonMatchingText": "555-55-1234",
        "Description": "Phone number United States (555-555-1234) . From http://tools.twainscanning.com/getmyregex ."
    },
    {
        "Pattern": "(?:2[0-3]|[01]?[0-9])[:.][0-5]?[0-9]",
        "MatchingText": "23:30|||23.30",
        "NonMatchingText": "23-30",
        "Description": "Time  HH:MM (23:30). From http://tools.twainscanning.com/getmyregex ."
    },
    {
        "Pattern": "(?:1[0-2]|0?[1-9])[:.][0-5]?[0-9][\\t ]+(?:AM|PM)",
        "MatchingText": "11:30 PM",
        "NonMatchingText": "11:61",
        "Description": "Time  HH:MM AM/PM (11:30 PM) . From http://tools.twainscanning.com/getmyregex ."
    },
    {
        "Pattern": "(?:2[0-3]|[01]?[0-9])[:.][0-5]?[0-9][:.][0-5]?[0-9]",
        "MatchingText": "23:30:55",
        "NonMatchingText": "23:30:65",
        "Description": "Time HH:MM:SS (23:30:55) . From http://tools.twainscanning.com/getmyregex ."
    },
    {
        "Pattern": "https?://[\\d.A-Za-z-]+\\.[A-Za-z]{2,6}/?",
        "MatchingText": "http://twainscanning.com",
        "NonMatchingText": "ftp://twainscanning.com",
        "Description": "URL http or https (http://twainscanning.com). From http://tools.twainscanning.com/getmyregex ."
    },
    {
        "Pattern": "(?:https?://|www\\.)[\\d.A-Za-z-]+\\.[A-Za-z]{2,6}/?",
        "MatchingText": "www.twainscanning.com",
        "NonMatchingText": "twainscanning.com",
        "Description": "URL http, https or www (www.twainscanning.com). From http://tools.twainscanning.com/getmyregex ."
    },
    {
        "Pattern": "^([0-1]?[0-9]{1}|2[0-3]{1}):([0-5]{1}[0-9]{1})$",
        "MatchingText": "1:59|01:59|23:59",
        "NonMatchingText": "24:00|01:60|01:234",
        "Description": "This expression will validate if a string represents a time in 24 hour format. \nThe expression will evaluate the string from start to finish. It will not accept 24:00, use 00:00 instead."
    },
    {
        "Pattern": "^([A-Z]{2}?(\\d{7}))$",
        "MatchingText": "AB1234567 ,CF5462782",
        "NonMatchingText": "12344555, A12344555,ab1234,Ac143265644,",
        "Description": "To maintain both uppercase letters and the digits in the expression."
    },
    {
        "Pattern": "^((((0[13578]|10|12)([-./])(0[1-9]|[12][0-9]|3[01])([-./])(\\d{4}))|((0[469]|1\u00AD1)([-./])([0][1-9]|[12][0-9]|30)([-./])(\\d{4}))|((2)([-./])(0[1-9]|1[0-9]|2\u00AD[0-8])([-./])(\\d{4}))|((2)(\\.|-|\\/)(29)([-./])([02468][048]00))|((2)([-./])\u00AD(29)([-./])([13579][26]00))|((2)([-./])(29)([-./])([0-9][0-9][0][48]))|((2)\u00AD([-./])(29)([-./])([0-9][0-9][2468][048]))|((2)([-./])(29)([-./])([0-9][0-9\u00AD][13579][26]))))$",
        "MatchingText": "29/12/2006 ||| 29.12.2006 ||| 29-12-2006 ||| 1/1/2006 ||| 01/01/2006 ||| 29/2/2004",
        "NonMatchingText": "29.12/2006 ||| 12/29/2006 ||| 29/2/2006",
        "Description": "A\u00F1o con formato dd/mm/yyyy permitiendo tambi\u00E9n d/m/yyyy o dd/m/yyyy y d/mm/yyyy. Adem\u00E1s controla los meses con 31 y 30 d\u00EDas y si es a\u00F1o bisiesto o no para el mes de febrero."
    },
    {
        "Pattern": "&lt;[^&gt;]+&gt;",
        "MatchingText": "&lt;html&gt;|||&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;&gt;|||&lt;",
        "NonMatchingText": "Any plain old text|||http://www.regexlib.com/Add.aspx|||xml&gt;",
        "Description": "This expression finds all opening and closing tags.  Good for stripping out tags in an XML or HTML document.\n\nI used it to clean-up HTML documents that had XML mixed in.  It found all the tags, then I just deleted the ones that weren't standard.  I used it in HOMESITES extended find."
    },
    {
        "Pattern": "^((((0?[13578]|1[02])\\/([0-2]?[1-9]|20|3[0-1]))|((0?[469]|11)\\/([0-2]?[1-9]|20|30))|(0?2\\/([0-1]?[1-9]|2[0-8])))\\/((19|20)?\\d{2}))|(0?2\\/29\\/((19|20)?(04|08|12|16|20|24|28|32|36|40|44|48|52|56|60|64|68|72|76|80|84|88|92|96)|2000))$",
        "MatchingText": "2/28/1990 2/29/1992 03/1/10",
        "NonMatchingText": "2/29/90 11/31/2010",
        "Description": "Check that a valid date has been entered. Uses mm/dd/yyyy or m/d/yy format or various combinations. Checks for valid leap years."
    },
    {
        "Pattern": "^((([a-z0-9])+([\\w.-]{1})?)+([^\\W_]{1}))+@((([a-z0-9])+([\\w-]{1})?)+([^\\W_]{1}))+\\.[a-z]{2,3}(\\.[a-z]{2,4})?$",
        "MatchingText": "aa@bb.cc a-a.a@bb.cc a-a_a@b_b.cc.dddd",
        "NonMatchingText": "u@d a@b.c a-a_@bb.cc a..a@b_-.cc aa@bb.c-c -a@b-.c- aa@bb.cc.dd.ee",
        "Description": "A simple email checking regex . Works with all regular email addresses . Allows only 'a-z' '-' '_' and '.'  to be included withing the user name which must to be started and teminated with 'a-z' and could not have any symbol sequence (like '-_' '._') in it's body .\n\nMust have at least 1 and max 2 sub-domains and 1 TLD (2-4 letters long a must). \n\nUse tolower() before this regex or just add A-Z or ?i flag within the pattern in order to match both cases .\n\nPlease see the examples ."
    },
    {
        "Pattern": "((A[FGIKLMNPRSUZ]S?X?|DAL?L?A?E?S?|DE|DE[LNRST]L?A?E?H?I?O?S?|DI[AE]?|DOS?|DU|EIT?N?E?|ELS?|EN|ETT?|HAI?|HE[NT]|HIN?A?I?N?R?|HOI|IL|IM|ISA|KA|KE|LAS|LES?|LH?IS?|LOS?|LO?U|MA?C|N[AIY]|O[IP]|SI|T[AEO]N?R?|U[MN][AEOS]?|VAN|VE[LR]|VO[MN]|Y[ENR]|ZU[MR]?) )?((LAS?|LOS?|DEN?R?|ZU) )?[A-Z0/'\\.-]+( |$)(SR|JR|II+V?|VI+|[1-9][STRDH]+)?",
        "MatchingText": "DE LA SALLE SR|VON TROTT 2ND",
        "NonMatchingText": "DE LA SALLE V|DE LA SALLE I",
        "Description": "This syntax matches most surname prefixes and suffixes with the surname appropriately placed.  Assumes all caps.  Useful if you want a precise match of surname prefixes and suffixes."
    },
    {
        "Pattern": "^[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}$",
        "MatchingText": "BFDB4D31-3E35-4DAB-AFCA-5E6E5C8F61EA|||BFDB4d31-3e35-4dab-afca-5e6e5c8f61ea",
        "NonMatchingText": "qqqBFDB4D31-3E35-4DAB-AFCA-5E6E5C8F61EA|||BFDB4D31-3E-4DAB-AFCA-5E6E5C8F61EA|||BFDB4D31-3E35-4DAB-AF",
        "Description": "GUID Tester.\n\nThis is a modification from the regular expression submitted by James Bray (james@jamesbray.com). It allows the use of mixed upper and lowercase letters in the GUID string."
    },
    {
        "Pattern": "&lt;table&gt;(&lt;tr&gt;((&lt;td&gt;([A-Za-z0-9])*&lt;/td&gt;)+)&lt;/tr&gt;)*&lt;/table&gt;",
        "MatchingText": "&lt;table&gt;&lt;tr&gt;&lt;td&gt;Hello&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;|||&lt;table&gt;&lt;/table",
        "NonMatchingText": "&lt;table&gt;&lt;tr&gt;&lt;/tr&gt;",
        "Description": "This accepts html's tables, with rows and colums.\nAcepta tablas Html, con sus respectivas filas y columnas."
    },
    {
        "Pattern": "^(958([0-9])+([0-9])+([0-9])+([0-9])+([0-9])+([0-9])+)|(958-([0-9])+([0-9])+([0-9])+([0-9])+([0-9])+([0-9])+)$",
        "MatchingText": "958467898|||958475777|||958321177",
        "NonMatchingText": "956457878|||984575757|||987787898",
        "Description": "it accepts Granada's numbers telephone. \nAcepta n&#250;meros de tel&#233;fono de Granada (espa&#241;a)"
    },
    {
        "Pattern": "(\\s)*(int|void|float|char|double|string)((\\s)|(\\*))*(\\&?)(\\s)+([a-z])([a-z0-9])*(\\s)*(\\()(\\s)*((int|void|float|char|double|string)((\\s)|(\\*))*(\\&?)(\\s)+([a-z])([a-z0-9])*((\\s)*[,](\\s)*(int|void|float|char|double|string)((\\s)|(\\*))*(\\&?)(\\s)+([a-z])([a-z0-9])*)*)?(\\s)*(\\))(\\s)*;",
        "MatchingText": "int * suma(int & x, float *  p, string cad) ;  )|||char one();|||float * poo(int o);",
        "NonMatchingText": "string *p();",
        "Description": "C++ prototipes.\nIt is necessary to write a \\s before a variable or function\nidentifier."
    },
    {
        "Pattern": "^(?:(?:1\\d{0,2}|[3-9]\\d?|2(?:[0-5]{1,2}|\\d)?|0)\\.){3}(?:1\\d{0,2}|[3-9]\\d?|2(?:[0-5]{1,2}|\\d)?|0)$",
        "MatchingText": "192.168.1.92 | 172.16.4.0 | 255.255.255.255",
        "NonMatchingText": "1923.0.1.2 | 256.1.1.2 ",
        "Description": "Valiadation IP RegExp."
    },
    {
        "Pattern": "(private|public|protected)\\s\\w(.)*\\((.)*\\)[^;]",
        "MatchingText": "public void SQLSelect(Form fo)",
        "NonMatchingText": "private G G = new G();",
        "Description": "Finds all public or private C# methods with a return type, with or without parameters. Excludes private and public members which may look like a method.  Private and public members that can be confused with methods typically have a semicolon after the closing parentheses.\n\nNOTE: Visual Studio uses a non-standard regular expression syntax for Find and Replace. The eqivalent pattern is: (private|public|protected):b:w(.)*\\((.)*\\)$"
    },
    {
        "Pattern": "^(([0-9])|([0-1][0-9])|([2][0-3])):?([0-5][0-9])$",
        "MatchingText": "0959|||959|||9:59",
        "NonMatchingText": "90|||960|||24:00",
        "Description": "For testing 24H based time entry.  Tests if there is a colon to separate the hours from the minutes"
    },
    {
        "Pattern": "^([1-9]{1}[0-9]{3}[,]?)*([1-9]{1}[0-9]{3})$",
        "MatchingText": "1999,2001,1988|||1999",
        "NonMatchingText": "0199,1997|||0199|||1999,",
        "Description": "Matches a comma-seperated list of year(s)."
    },
    {
        "Pattern": "^([a-zA-Z].*|[1-9].*|[:./].*)\\.(((a|A)(s|S)(p|P)(x|X)))$",
        "MatchingText": ". /oldpage.aspx |  http://www.newsite.com/newpage.aspx | www.abc.com/aspx ",
        "NonMatchingText": "abc.asp | abc | abc.xxx",
        "Description": "Regular expression to limit types of files accepted. This example matches .aspx files only. \nThis is the extended virsion of Ramon Hildreth  for asp.net files. "
    },
    {
        "Pattern": "^([A-Z]{2}[9]{3}|[A-Z]{3}[9]{2}|[A-Z]{4}[9]{1}|[A-Z]{5})[0-9]{6}([A-Z]{1}[9]{1}|[A-Z]{2})[A-Z0-9]{3}[0-9]{2}$",
        "MatchingText": "tom99808275m99sc23 sugar654155a98lw59",
        "NonMatchingText": "tom89808275m99sc23 9ugar654155a98lw59",
        "Description": "Matches the UK Drivers License format as laid down by the DVLA / dvla. See http\n://www.govtalk.gov.uk/gdsc/html/frames/default.htm Matches: "
    },
    {
        "Pattern": "^[0][5][0]-\\d{7}|[0][5][2]-\\d{7}|[0][5][4]-\\d{7}|[0][5][7]-\\d{7}|[0][7][7]-\\d{7}|[0][2]-\\d{7}|[0][3]-\\d{7}|[0][4]-\\d{7}|[0][8]-\\d{7}|[0][9]-\\d{7}|[0][5][0]\\d{7}|[0][5][2]\\d{7}|[0][5][4]\\d{7}|[0][5][7]\\d{7}|[0][7][7]\\d{7}|[0][2]\\d{7}|[0][3]\\d{7}|[0][4]\\d{7}|[0][8]\\d{7}|[0][9]\\d{7}$",
        "MatchingText": "03-1234567, 031234567, 050-1234567, 0501234567",
        "NonMatchingText": "03-12345678, 0312345678, 050-12345678, 05012345678",
        "Description": "This is a pattern for Regular and Cell Phone Numbers of israel,\nallow using with or without dash (-)."
    },
    {
        "Pattern": "^(\\d{5}\\-\\d{3})|(\\d{8})$",
        "MatchingText": "12345-678|||12345678",
        "NonMatchingText": "12345-67|||1234567|||123456789",
        "Description": "Matches the CEP (address code in Brazil) formatted or not."
    },
    {
        "Pattern": "(^\\d{5}-\\d{3}|^\\d{2}.\\d{3}-\\d{3}|\\d{8})",
        "MatchingText": "12.345-678|||12345-678|||12345678",
        "NonMatchingText": "12.345678|||12345-1|||123",
        "Description": "Validar o do CEP Brasileiro com 8 posicoes podendo usar\nmascara . e - ou somente numeros"
    },
    {
        "Pattern": "^[a-zA-Z0-9\\040]+$",
        "MatchingText": "Website Users",
        "NonMatchingText": "Website Users!",
        "Description": "It will allow for alphanumeric characters only, with the exception of spacing."
    },
    {
        "Pattern": "([\\(]?(?P<AreaCode>[0-9]{3})[\\)]?)?[ \\.\\-]?(?P<Exchange>[0-9]{3})[ \\.\\-](?P<Number>[0-9]{4})",
        "MatchingText": "(602) 555-3696|||555-2069|||213.555.8954",
        "NonMatchingText": "225-582|||11000",
        "Description": "This was used to process a bunch of lines of information to determine if a line was a North American phone number or not.  It accepts numbers with or without area code with or without parenthesis and sepearated by space, dash or period."
    },
    {
        "Pattern": "/class\\s+([a-z0-9_]+)(?:\\s+extends\\s+[a-z0-9_]+)?(?:\\s+implements\\s+(?:[a-z0-9_]+\\s*,*\\s*)+)?\\s*\\{/Usi",
        "MatchingText": "class A {}|||class A extends B {}|||class A extends B implements C {}|||class A extends B implements C,D {}|||class A implements B {}|||class A implements B,C {}",
        "NonMatchingText": "class A implements B extends C (invalid PHP syntax)",
        "Description": "This expression extract all class names from a php source code. E.g. it will extract A from the following declarations\n"
    },
    {
        "Pattern": "(^[0-9]*[1-9]+[0-9]*\\.[0-9]*$)|(^[0-9]*\\.[0-9]*[1-9]+[0-9]*$)|(^[0-9]*[1-9]+[0-9]*$)",
        "MatchingText": "0.01|||010001.011010|||.234",
        "NonMatchingText": "0.00 OR .|||010001.011010E|||1.234.5",
        "Description": "Positive real number greater than zero."
    },
    {
        "Pattern": "(\".+\"\\s)?<?[a-z\\._0-9]+[^\\._]@([a-z0-9]+\\.)+[a-z0-9]{2,6}>?;?",
        "MatchingText": "\"Test User\" test@user.com|||test.user@test.com|||test_user@test.com|||test@test.info|||test@test.user.com|||123@123.com;",
        "NonMatchingText": "test@test@test.com|||test.@user.com|||test_@user.com|||\"Test User\"test@test.com|||te$t@test.com",
        "Description": "Simple email matching expression, that allows for a friendly name string similar to what you see in outlook 2007.\n\nExample: \"Test User\" test@user.com"
    },
    {
        "Pattern": "[\\+]?[\\s]?(\\d(\\-|\\s)?)?(\\(\\d{3}\\)\\s?|\\d{3}\\-?)\\d{3}(-|\\s-\\s)?\\d{4}(\\s(ex|ext)\\s?\\d+)?",
        "MatchingText": "+12345678910|||+1 (234)567-8910|||(234)567-8910|||2345678910|||234-567-8910|||1-888-666-1111 ext 123|||1-999-555-3333 ex 123",
        "NonMatchingText": "1234567891011|||555-(123)-4567|||123-4567",
        "Description": "My goal with this was to have a pretty loose and flexible validation, accept a number of different input strings, but still inforce the core of what a phone number is. Country Code optional, Area Code required, with optional extension as well for business numbers.\n\nI'm still fairly new to Regex's so any suggestions for improvement are great."
    },
    {
        "Pattern": "([^\\w]+)|([^A-Za-z])|(\\b[^aeiouy]+\\b)|(\\b(\\w{2})\\b)",
        "MatchingText": "'re | 's | is |  t5 | 2015 | @#$ | stt",
        "NonMatchingText": "you | john | are | sit",
        "Description": "I needed a clean string of keywords submitted in a form. This expression will select every word that doesn't have a vowel, every word that is shorter than 2 characters. It will select all non alphabetical characters."
    },
    {
        "Pattern": "^\\+(?:[0-9] ?){6,14}[0-9]$",
        "MatchingText": "+44 207 100 200 \u00AC\u00AC\u00AC +44 7890 100 200 \u00AC\u00AC\u00AC +1 555 100 200",
        "NonMatchingText": "00 44 207 100 200 \u00AC\u00AC\u00AC 00 44 7890 100 200 \u00AC\u00AC\u00AC  555 100 200",
        "Description": "International Phone Number conventions are really difficult to get a one-size-fits-all regex for. This version forces numbers to start with a plus sign (international dialling symbol), then a country code and then the phone number"
    },
    {
        "Pattern": "/\\*[^\\/]+/",
        "MatchingText": "/* Commentary */ ||| /* CSS */ ||| /* text:padding */",
        "NonMatchingText": "/* CSS;* :: / */ || / no comment / ||| *comment*",
        "Description": "With this regex you can find or replace any CSS commentary in your stylesheets in once. Build for use with dreamweaver. Probably works also fine in any other circumstances."
    },
    {
        "Pattern": "(((s*)(ftp)(s*)|(http)(s*)|mailto|news|file|webcal):(\\S*))|((www.)(\\S*))",
        "MatchingText": "ftp://domain.com ||| sftp://subdomain.domain.com ||| mailto:yourname@rommel.com ||| www.domain.be",
        "NonMatchingText": "gopher://anything.com ||| subdomain.domain.com ||| http//somethingforgotten.com",
        "Description": "Matches all kind of URIs: mailto's, http(s), (s)ftp(s), ..., or just www addresses without protocol prefix."
    },
    {
        "Pattern": "^[0-9]{10}GBR[0-9]{7}[U,M,F]{1}[0-9]{9}$",
        "MatchingText": "7086493126GBR6510204M150224602 ||| 1234567890GBP1234567F123456712 ||| 6098475322GBR6911225F140517400",
        "NonMatchingText": "7086493126USD6510204M150224602 ||| 1234567890GBP1234567A123456712 ||| 60984753GBR6911225F1405174",
        "Description": "The first field consist of 10 numbers, then 3 characters (GBP as its for UK passports), 7 numbers, 1 character and 7 numbers. The final field is for the 2 numbers at the right-hand end of the <<<<< symbols."
    },
    {
        "Pattern": "^[A-Z0-9<]{9}[0-9]{1}[A-Z]{3}[0-9]{7}[A-Z]{1}[0-9]{7}[A-Z0-9<]{14}[0-9]{2}$",
        "MatchingText": "1234567890ABC1234567A1234567<<<<<<<<<<<<<<12 ||| 0123456781USD5656564M0812120AS34560<<<<<<<36 ||| G0308084<<1ITY9999999Q0410056<<<<<<<<<<<<<<39",
        "NonMatchingText": "ASDFER123AQWE!\"%^<<<<<<<<<<<12 ||| QASASW3<<1WER3as12232<<AS ||| ABCDEF123AQQQ123456789A1<<<<<AS14",
        "Description": "\u2022 9 characters made up of a combination of numbers and/or letters. Where less than 9 characters it will be padded out to the right with chevrons (<).\n\u2022 1 number\n\u2022 3 letters\n\u2022 7 numbers\n\u2022 1 letter\n\u2022 7 numbers\n\u2022 An international passport will have up to 14 characters in this field (numbers and/or letters). If none exist or where less than 14 characters exist, the field will be padded out, but only to the right, with chevrons (<). You should input the data exactly as it is shown on the actual passport field, i.e. input all chevrons to the left of the characters and do not ignore or leave these as blank spaces. Where less than 14 characters, the field will be padded out to the right with chevrons (<), i.e. Z1234567<<<<<\n\u2022 1 number\n\u2022 1 number"
    },
    {
        "Pattern": "(((0[123456789]|10|11|12)(([1][9][0-9][0-9])|([2][0-9][0-9][0-9]))))",
        "MatchingText": "052000|||122008|||101972|||041903",
        "NonMatchingText": "12/2003|||131997||| 51988|||111899|||04.2004|||10-1965",
        "Description": "Validates dates that are in month/year (MMYYYY) format without slashes, periods, dashes, or spaces.  No special characters or letters allowed.  MM values allowed are 01 thru 12.  YYYY values allowed are 1900 - 2999.\n\nThis is an adaptation of Felipe Albacete's MM/YYYY regular expression."
    },
    {
        "Pattern": "(^0*\\.0*$)^\\d{1,10}(\\.\\d{1,2})?$",
        "MatchingText": "0|||2.50|||9999999999.99|||1.1",
        "NonMatchingText": ".50|||999999999999|||1000000.369",
        "Description": "1 to 10 digits are allowed before the decimal.  1 to 2 digits are allowed after decimal.   Zero is allowed.  Whole numbers allowed."
    },
    {
        "Pattern": "<blockquote>(?:\\s*([^<]+)<br>\\s*)+</blockquote>",
        "MatchingText": "<blockquote>string1<br>string2<br>string3<br></blockquote>",
        "NonMatchingText": "..",
        "Description": "Use this regular expression pattern to get the string1, string2, string3 .... from &lt;blockquote&gt;string1&lt;br&gt;string2&lt;br&gt;string3&lt;br&gt;&lt;/blockquote&gt;\n\n"
    },
    {
        "Pattern": "^([-]?[0-9]?(\\.[0-9]{0,2})?)$|^([-]?([1][0-1])(\\.[0-9]{0,2})?)$|^([-]?([1][0-3](\\.[0]{0,2})))$",
        "MatchingText": "5|||-11.99|||12.00",
        "NonMatchingText": "13|||-11.999|||12.01",
        "Description": "This was made for specifying GMT offsets with 2 decimal places.  It will validate any number from -12 to 13 with 2 decimal places."
    },
    {
        "Pattern": "24*7+365 Days",
        "MatchingText": "Pogo game",
        "NonMatchingText": "usa",
        "Description": "The team will assist in managing the credentials in context to the video games, help in fixing the online issues connected with house circle or about web in hardly few minutes. Call at the suggested contact number as soon as possible and it will be so easy for catching best of the solutions in just a while.As a resolution to the severe most issues with the Pogo Games, make sure for availing Pogo Technical Support Number and get reliable solutions in few minutes.For More Info:-pogocustomercare.com"
    },
    {
        "Pattern": "Pogo customer service 24*7 \n\nhttp://pogocustomercare.com/",
        "MatchingText": "Pogo Technical support number ",
        "NonMatchingText": "club pogo help disk for usa",
        "Description": "At Pogo client support telephone number you'll talk to our representatives directly. All customer\u2019s issues will be heard by our Pogo support telephone number representative plus they'll explain the solution over the telephone or by e-mail in the mutual instructions so that you can resolve the issues by yourself. Occasionally users of Pogo support telephone number unable to solve the problems themselves then our Pogo client support telephone number team takes the remote access of the devices and fix the issues and also educate the clients about the prevention of upcoming and ongoing issues. "
    },
    {
        "Pattern": "Pogo customer care 24*7 ",
        "MatchingText": "pogo customer service phone number ",
        "NonMatchingText": "usa",
        "Description": "The availability of 24x7 Pogo Customer Service Phone Number will help you in gaining abundance of help and support. The team will assist in managing the credentials in context to the video games, help in fixing the online issues connected with house circle or about web in hardly few minutes. Call at the suggested contact number as soon as possible and it will be so easy for catching best of the solutions in just a while. Consult the helpdesk as soon as possible and soon avail ease to play pogo games. You can email at the platform as well other than just calling there.For More Info:- Pogocustomercare.com"
    },
    {
        "Pattern": "24*7 customer service number",
        "MatchingText": "Pogo game",
        "NonMatchingText": "usa",
        "Description": "There are many games available in Pogo that requires Java platform. So, before starting playing on it, just check the requirement of game as well as the system configuration. Also, you can make a call to pogo game customer service phone number to get specific information about the same. For More Info:- pogocustomercare.com"
    },
    {
        "Pattern": "24*7+365 Days",
        "MatchingText": "Pogo Technical number ",
        "NonMatchingText": "los angeles",
        "Description": "Let\u2019s get Introduce to pogo.com: Electronic arts discovered pogo.com 17 years ago on September 1st, 1999 that is established in redwood shores, CA. It is free online gaming USA Company. Along side of entertainment if any tech issue persist pogo technical solution helpline number is furnished. Pogo help specialists are available at your door step with complete help support. It is authentic in terms of the 10 digit pogo tech help guru number supplied to all pogo junkies over the world. Let your self in peace by seeking help from pogo technical guru help assistance number for any kinda of tech or non technical offbeat. As a result pogo buddy is always oriented towards pogo help guru obtainable at pogo official 24/ 7 help support cell number.For More Info-:pogocustomercare.com"
    },
    {
        "Pattern": "24*7+365 Days",
        "MatchingText": "Pogo tech support",
        "NonMatchingText": "usa",
        "Description": "Welcome to pogo games ki duniya: Come let\u2019s play pogo! The Disney land of pogo games is adorned with more than 100 of games. Pogo.com is fun place for kids to every age of group of people. Note: If you come across technical bizarre such as downloading issue, playable disruption etc kindly step to pogo help technician approachable at pogo official tech concern help number. Pogo help expert follow policy of \u2018equality\u2019 i.e. treats each and every pogo caller without any discrimination feeling. Thus, pogo junkie can wheel the EA 10 digit help centre family number anytime, anywhere. Whether you are pogo member or non member, you can call to pogo help connoisseur support toll free number.For More Info:-pogocustomercare.com"
    },
    {
        "Pattern": "24*7+365 Days",
        "MatchingText": "Pogo game",
        "NonMatchingText": "usa",
        "Description": "Hello pogo buddy! EA welcomes every age group of people at poog.com that is the great gusto platform for every body to bask in pogo games. CHALLENGE EVERYTHING! EA slogan! It is worldwide recognized free online gaming site. Moreover, when any technological oddball arises pogo help expert are hired at pogo customer care executive helpdesk number to shot all those oddballs. Therefore, pogo caller can register their technical issue at help desk of pogo troubleshot concern help cell number. It is toll free number serving cost less help assistance to every pogo caller across the world. Whence, pogo lover call us within 24 hours and 7 days of week to get done your trouble solved."
    },
    {
        "Pattern": "24*7 customer support number",
        "MatchingText": "Pogo game phone number",
        "NonMatchingText": "usa",
        "Description": "How to connect to EA help centre? Well, pogo player can visualize the 10 digit pogo toll free number that is flashed on your computer screen. It is very handy to carry the pogo help centre number. One can feed this number in his phone and keep it safe beside, if you lack contact in your phone then you can briskly Google the number and place call. So pogo lover play, rock and roll in pogo games and under any tech trouble wheel the pogo tech official help department number.For More Info:-pogocustomercare.com "
    },
    {
        "Pattern": "^([a-z]{2,3}(\\.[a-zA-Z][a-zA-Z_$0-9]*)*)\\.([A-Z][a-zA-Z_$0-9]*)$",
        "MatchingText": "foo.Bar ||| foo.bar.IFBar1 ||| wo.w_1.Ffo$o.Bar",
        "NonMatchingText": "Bar ||| Foo.Bar ||| foo.bar ||| foo/Bar ||| fooo.Bar",
        "Description": "Regular Expression for validating fully qualified Java Class Names that follows the Java Naming Conventions for widely available classes (see: http://java.sun.com/docs/books/jls/third_edition/html/names.html#6.8).\n\nGroup 1 gives the package name, group 3 gives the class name."
    },
    {
        "Pattern": "^(([a-zA-Z][a-zA-Z_$0-9]*(\\.[a-zA-Z][a-zA-Z_$0-9]*)*)\\.)?([a-zA-Z][a-zA-Z_$0-9]*)$",
        "MatchingText": "Bar ||| f.B1 ||| fo_$1.bar.Foo.bar",
        "NonMatchingText": "1Bar ||| foo-.Bar ||| foo/Bar",
        "Description": "Regular Expression for validating fully qualified Java Class Names that follows the Java Naming Conventions for local classes (see: http://java.sun.com/docs/books/jls/third_edition/html/names.html#6.8).\n\nGroup 2 gives the package name, group 4 gives the class name.\n"
    },
    {
        "Pattern": "^(\\+?36)?[ -]?(\\d{1,2}|(\\(\\d{1,2}\\)))/?([ -]?\\d){6,7}$",
        "MatchingText": "+3611234567 ||| +3676123456 ||| +36301234567 ||| +36 1 1234567 ||| +36 76 123456 +36 30 1234567 ||| +36(1)1234567 ||| +36(76)123456 ||| +36(30)1234567 ||| 1/123-4567 ||| 76/123-456 ||| 30/123-45-67",
        "NonMatchingText": "+0011234567",
        "Description": "Regex for validating format of Hungarian phone numbers."
    },
    {
        "Pattern": "^[A-Z]{2}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[0-9]{2}-[A-Z]{2}|[0-9]{2}-[A-Z]{2}-[0-9]{2}|[A-Z]{2}-[0-9]{2}-[A-Z]{2}|[A-Z]{2}-[A-Z]{2}-[0-9]{2}|}|[0-9]{2}-[A-Z]{2}-[A-Z]{2}|[0-9]{2}-[A-Z]{3}-[0-9]{1}|[0-9]{1}-[A-Z]{3}-[0-9]{2}$",
        "MatchingText": "MX-09-TT|||9-VGS-10|||08-45-TT",
        "NonMatchingText": "0M-TT-MM|||mx-09-tt|||10-VGS-99",
        "Description": "Test a valid dutch licenceplate. Uppercase and with hyphens"
    },
    {
        "Pattern": "<[^>]*?>",
        "MatchingText": "<html><head></head><body><body/></html>",
        "NonMatchingText": "html, head, body",
        "Description": "Paseo de Tag html."
    },
    {
        "Pattern": "^\\d* \\d*\\/{1}\\d*$|^\\d*$",
        "MatchingText": "100|||1 1/2|||1232 5/8",
        "NonMatchingText": "a 1/2|||abc|||a b/c",
        "Description": "This expression is used to validate fractions (entered as strings). It will also accept non-fractional entries. Simple, but effective."
    },
    {
        "Pattern": "[-+]?((\\.[0-9]+|[0-9]+\\.[0-9]+)([eE][-+][0-9]+)?|[0-9]+)",
        "MatchingText": "10.2 ||| .0 ||| 3.9265e+2 ||| 5",
        "NonMatchingText": "-one ||| . ||| whatever",
        "Description": "Used in my SVG parser. \n\nExplanation:\n\nMay start with + or -. This is followed by either an integer, or a float (\"dot numbers\", \"numbers dot numbers\" or \"numbers dot\" followed by an optional scientific postfix (+ or - followed by numbers) )\n\nI'm using it to parse lists of floats, add ^$ boundaries if you want it to match whole lines."
    },
    {
        "Pattern": "^[+-]?\\d+(\\.\\d{1,4})? *%?$",
        "MatchingText": "123||256.89||2%||0.2%||25%||0.1||0||+1.9%||-2",
        "NonMatchingText": ".1||%1||1.0||2,345",
        "Description": "An expression for .NET regular expression validation controls intended to facilitate the entry of percentage values both a whole numbers or as their decimal representations. Also compatible with the default US format for string formatting for percentages. Recommend that if you intended accept a value passing this express that you strip the percentage signs and take measures to ensure that any whole values are converted to percentages. "
    },
    {
        "Pattern": "(^(000)\\d{3}) ([- ]?) ((00)\\d{2}) ([- ]?) ((0000)\\d{4})",
        "MatchingText": "123-45-6789",
        "NonMatchingText": "000-00-0000",
        "Description": "This RegularExpression is used to validate the US - SSN. This regular expression wont allow characters as well as all zeros"
    },
    {
        "Pattern": "(^(00)\\d{2}) ([- ]?) ((0000000)\\d{7})",
        "MatchingText": "12-3456789",
        "NonMatchingText": "00-0000000",
        "Description": "This Regular Expression is used to validate the EIN of Employer in US."
    },
    {
        "Pattern": "^([a-z0-9]+[.+-])*([a-z0-9]+)+@(([a-z0-9]+[.-])+([a-z]{2,})$|(([0-9]|[1-9][0-9]|1[0-9]{1,2}|2[0-4][0-9]|25[0-5])(\\.|$)){4})",
        "MatchingText": "j-ohn.smith@example.com|||j.smith+account@sub-domain.domain.tld|||1@4.144.0.255|||a+a@0.0.0.0",
        "NonMatchingText": ".s@example.com|||name.+tag@domain.tld|||aaa+@domain.tld|||john@125.122.1|||a@a|||a@a.255|||a@a.com1",
        "Description": "Validates most common varieties of email addresses.\nWill accept domain with character-valid TLD, and also will accept an IPv4 address.\nIt doesn't support validation of IPv6 address.\nWill also accept a valid username with tags."
    },
    {
        "Pattern": "target[ ]*[=]([ ]*)([&quot;]|['])*([_])*([A-Za-z0-9])+([&quot;])*",
        "MatchingText": "target = &quot;_top&quot;|||target   =    _top|||target = &quot;foo&quot;",
        "NonMatchingText": "target foo|||target &quot;foo&quot;|||target = &quot;&quot;",
        "Description": "Matches the HTML &quot;target&quot; attribute.  I had an editor that edited pages but whe wysiwyg editor would break on link that had a target to say &quot;_top&quot; or another window.  So I needed an expression to match the target attribute on links in HTML."
    },
    {
        "Pattern": "^((((H|h)(T|t)|(F|f))(T|t)(P|p)((S|s)?))\\://)?(www.|[a-zA-Z0-9].)[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,6}(\\:[0-9]{1,5})*(/($|[a-zA-Z0-9\\.\\,\\;\\?\\'\\\\\\+&amp;%\\$#\\=~_\\-]+))*$",
        "MatchingText": "hTtP://3iem.net/|||http://3iem.museum:1337/|||plik.co.uk",
        "NonMatchingText": "http://foobar|||lameurl.toolongtld",
        "Description": "Matches URLS that start with numbers and  any TLD that is 2 to 6 characters long. Matches most URLs.  Thanks to eveyone for suggesting modifications!\n\nUPDATES::[Nov. 11, 2005] Now it matches uppercase and lower case protocols. \n\nUpdates::December 3,  2005  Added restriction to ports since they will only go up to 65535. (Thanks  lorello)\n\n\n\n\n\nKeep the suggestions coming! Thanks for the heads up!!"
    },
    {
        "Pattern": "^[1-9]\\d{3}\\s?(?i)((S[ADS]))([A-Z&&[^FIOQUY]]{2})$",
        "MatchingText": "1234 AB | 1234ab",
        "NonMatchingText": "1234 SS | 1234fq",
        "Description": "Java only postcodecheck for the Netherlands, case insensitive.\n\nCharacters not allowed: FIOQUY\n\nStrings not allowed: SA, SD, SS"
    },
    {
        "Pattern": "^\\d*((\\.\\d+)?)*$",
        "MatchingText": "1.1 | 10.4.59 | 10,3,55,6",
        "NonMatchingText": ".1 | 10.5.A | 34..56",
        "Description": "this expression identify application version. the input should contains one or more numbers separated by . (Dot) sign"
    },
    {
        "Pattern": "([0]|[-]?[0]\\.[0-9]+)|([-]?([1-9]+\\.[0-9]+))|([-]?[1-9]+)",
        "MatchingText": "0 0.1 -0.1 1.1 -1.1 1 ",
        "NonMatchingText": "000 00.1 a 1e100 ",
        "Description": "From left to right.\nAllow single 0 OR negative/positive 0.0-9 OR negative/positive 1-9.0-9 OR 1-9 whole numbers"
    },
    {
        "Pattern": "^[\\-]{0,1}[0-9]{1,}(([\\.\\,]{0,1}[0-9]{1,})|([0-9]{0,}))$",
        "MatchingText": "-1.0|||1234|||12,34",
        "NonMatchingText": "-1.|||12a4|||.34",
        "Description": "Simple checker for user's float types input."
    },
    {
        "Pattern": "(\\b)(\\w+(\\b|\\n|\\s)){3}",
        "MatchingText": "three blind mice|||see how they run",
        "NonMatchingText": "three blind|||they run",
        "Description": "This script attempts to return phrases from a string (Example above looks for {3} word phrases)  Combine this with some .Net code, you can display most popular X word phrases in a string.\n\n-If anyone can help me count &quot;Phrase and Phrase as 2 instances of Phrase please contact me"
    },
    {
        "Pattern": "/^[-+]?[1-9](\\d*|((\\d{1,2})?,(\\d{3},)*(\\d{3})))?([eE][-+]\\d+)?$/",
        "MatchingText": "+123 -678765 6,789 567,546,555 -67,897e+4",
        "NonMatchingText": "56,67 678,789, 086 ",
        "Description": "Integers with optional positive/negative sign, miles separator (,) and exponential notation\n\nValids integer numbers with optional support for:\n1.- positive/negative sign (123 -123 +123 are valid)\n2.- miles separator (,) (12345 12,345 +12,345 are valid)\n2.- exponential notation (+123E+4 -12,345E-4 are valid)"
    },
    {
        "Pattern": "/^[-+]?((\\d*|((\\d{1,3})?,(\\d{3},)*(\\d{3})))?)(\\.\\d*)?([eE][-+]\\d+)?$/",
        "MatchingText": "123.78 -123.09 +0.123  12345.789 12,345.099 +0.123E+4",
        "NonMatchingText": "56,88 12e3 09,98.99",
        "Description": "Valids decimal numbers with optional support for:\n1.- Use a positive/negative sign (123.78 -123.09 +0.123 are valid)\n2.- Use a miles separator (12345.789 12,345.099 +12,345  are valid)\n2.- Use a exponential notation (+0.123E+4 -12.345e-4 are valid)"
    },
    {
        "Pattern": "^\\(?\\+([9]{2}?[6])\\)?[-. ]?([0-9]{3})[-. ]?([0-9]{3})[-. ]?([0-9]{3})$",
        "MatchingText": "+996702068026 |  (+996)702068026  |  +(996)702-068-026",
        "NonMatchingText": "+991702068026 |  (996)702068026  |  +(99)702-068-026",
        "Description": "Kyrgyzstan Phone numbers: (+996)XXX-XXX-XXX."
    },
    {
        "Pattern": "^\\${1}[a-z]{1}[a-z\\d]{0,6}$",
        "MatchingText": "$System",
        "NonMatchingText": "system",
        "Description": "NonStop or Guardian OS process or disk volume name. Must start with a \"$\" and have an initial letter character with up to six more alpha numberic characters"
    },
    {
        "Pattern": "$",
        "MatchingText": "0,1,2...24,00,01,02....24",
        "NonMatchingText": "000,001,-1,+1,.1",
        "Description": "This Regular Expression Accept Hours in 24 Format.but this will not Accept Min/sec"
    },
    {
        "Pattern": "(((ht|f)tp(s?):\\/\\/)|(www\\.[^ \\[\\]\\(\\)\\n\\r\\t]+)|(([012]?[0-9]{1,2}\\.){3}[012]?[0-9]{1,2})\\/)([^ \\[\\]\\(\\),;&quot;'&lt;&gt;\\n\\r\\t]+)([^\\. \\[\\]\\(\\),;&quot;'&lt;&gt;\\n\\r\\t])|(([012]?[0-9]{1,2}\\.){3}[012]?[0-9]{1,2})",
        "MatchingText": "www.domain.com|||http://www.blah.ru|||https://192.168.0.2:80/users/~fname.lname/file.ext",
        "NonMatchingText": "imap://.com",
        "Description": "v2\nA general purpose expresion to find url's (improved).\nAdd heads to first part, example:\n((imap:|(ht|f)tp(s?):\\/\\/)|(www\\.\nto find url's like imap://www.com/, so ip's. No ipv6 (yet)"
    },
    {
        "Pattern": "^([a-zA-Z]+)[0-9]*\\.*[a-zA-Z0-9]+$|^[a-zA-Z]+[0-9]*$",
        "MatchingText": "vishal.mehta;vishal12.12;vishal08",
        "NonMatchingText": ".vishal;vishal_mehta09;Vishal Mehta;vishal.",
        "Description": "This Regex allows usernames with or without special char . "
    },
    {
        "Pattern": "^[a-zA-Z0-9._%-]+@[a-zA-Z0-9._%-]+\\.[a-zA-Z]{2,4}\\s*$",
        "MatchingText": "jeremiah@superman.cupcake.french.com | jeremiah.jeremiah@live.com | jeremiah@hotmail.com ... etc",
        "NonMatchingText": "bill(at)hotmail.com | john@hotmail.corndog",
        "Description": "This will validate all of the most common email addresses, and then others that are not so common. "
    },
    {
        "Pattern": "^([0-9]*\\,?[0-9]+|[0-9]+\\,?[0-9]*)?$",
        "MatchingText": "1234,50|||0,70|||,03",
        "NonMatchingText": "1.234,50|||-234,50",
        "Description": "Integer numbers with decimals. Only positives match. This expression doesn't match numbers with group separators"
    },
    {
        "Pattern": "^(\\()?(787|939)(\\)|-)?([0-9]{3})(-)?([0-9]{4}|[0-9]{4})$",
        "MatchingText": "(787)755-0114|||939-315-0112|||7879093849",
        "NonMatchingText": "(098)737-3942|||(89)893-2392|||939782721",
        "Description": "Filter US telephone numbers.  This particular one accepts only area code 939 or 787.  Area code parentesis or hyphens optional."
    },
    {
        "Pattern": "/^\\s+$|^$/gi",
        "MatchingText": "just spaces | just tabs | just spaces and tabs",
        "NonMatchingText": "spaces + letter | tabs + letter | letter + space | letter + tab",
        "Description": "Match if the string is just empties spaces or there is at least one letter.\n\nExtracted from: http://stackoverflow.com/questions/5063977/regex-empty-string-or-email\n\nOriginal author: http://stackoverflow.com/users/340688/thomasreggi"
    },
    {
        "Pattern": "[0-9]+|-[0-9]+",
        "MatchingText": "9, 0, -9, 1000, -1000",
        "NonMatchingText": "a1, 1.1",
        "Description": "MS ASP.NET 2010 \nAllows positive, negative whole numbers. Allows zero. Does not allow real (decimal) numbers nor anything containing alphabet characters. Simple and sweet"
    },
    {
        "Pattern": "(^0*$)(^0*\\.0*$)^\\d{1,5}(\\.\\d{1,5})?$",
        "MatchingText": "1, 0.11111, 10000.1,",
        "NonMatchingText": "0.111111, 2a, 1/8, -1, 0, 1000000.1",
        "Description": "I was searching for an Exchange rate expression.\nNice thing about this is that it is less sensitive for large numbers and more sensitive (more decimal places) for small decimals to 5 decimal places."
    },
    {
        "Pattern": "(([0-2]{1}[0-9]{1})|([3-3]{1}[0-1]))/[1-12]{2}/[1900-2999]{4}\\s(([0-0]{1}[0-9]{1})|([1-1]{1}[0-9]{1})|([2-2]{1}[0-3]{1})):[0-5]{1}[0-9]{1}:[0-5]{1}[0-9]{1}",
        "MatchingText": "18/12/2012 09:52:07 31/02/2012 09:52:07",
        "NonMatchingText": "32/12/3000 09:52:07",
        "Description": "UK Data and Time\nUse an 'onupdated' method to correct '31/02/2012' to 28/02/2012, for example. \nMS Visual Studio 2010\n\n"
    },
    {
        "Pattern": "^\\w+.*$",
        "MatchingText": "user name|||o)(=-&amp;r443*/",
        "NonMatchingText": "=stuff|||.username",
        "Description": "Validates any line begining with an alpha-numeric. If you need a regular expression that fails only for a zero length string.  Remove the \\w+. I originally attempted to post was ^.*$ but the input form would not allow it."
    },
    {
        "Pattern": "([.])([a-z,1-9]{3,4})(\\/)",
        "MatchingText": ".com/ .net/ .biz/ .123/ .mobi/",
        "NonMatchingText": ".co.uk/  .org.uk/",
        "Description": "Returns the TLD from a URL."
    },
    {
        "Pattern": "(\\d*)'*-*(\\d*)/*(\\d*)&quot;",
        "MatchingText": "5'-3/16&quot;|||1'-2&quot;|||5/16&quot;",
        "NonMatchingText": "1 3/16",
        "Description": "This regular expression is for parsing feet and inches measurements."
    },
    {
        "Pattern": "^(?:=?(?:(?:\\[(?P<book>[^\\\\\\:\\?\\*/]+)\\])(?:(?P<sheet>[^\\*\\:\\?\\\\\\[\\]/]{1,31})\\!)|(?:(?P<sheet>[^=!\\[\\]\\:\\?]{1,31})\\!))?(?:(?:(?:(?:\\$(?:\\$)?(?P<col1>(?:(?:[A-Z]{1,2})|(?:(?:[A-W][A-Z][A-Z])|(?:[A-X][A-E][A-Z])|(?:[A-X][A-F][A-D])))))|(?P<col1>(?:(?:[A-Z]{1,2})|(?:(?:[A-W][A-Z][A-Z])|(?:[A-X][A-E][A-Z])|(?:[A-X][A-F][A-D])))))(?:(?:\\$(?:\\$)?(?P<row1>(?:(?:[1-9][0-9]{0,5})|(?:10[0-3][0-9]{1,4})|(?:104[0-7][0-9]{1,3})|(?:1048[0-4][0-9]{1,2})|(?:10485[0-6][0-9])|(?:104857[0-6]))))|(?P<row1>(?:(?:[1-9][0-9]{0,5})|(?:10[0-3][0-9]{1,4})|(?:104[0-7][0-9]{1,3})|(?:1048[0-4][0-9]{1,2})|(?:10485[0-6][0-9])|(?:104857[0-6]))))|(?P<name1>[A-Za-z][^\\\\\\:\\^\\$\\[\\]\\{\\}\\*\\+;,=]{0,249}))(?:\\:(?:(?:(?:\\$(?:\\$)?(?P<col2>(?:(?:[A-Z]{1,2})|(?:(?:[A-W][A-Z][A-Z])|(?:[A-X][A-E][A-Z])|(?:[A-X][A-F][A-D])))))|(?P<col2>(?:(?:[A-Z]{1,2})|(?:(?:[A-W][A-Z][A-Z])|(?:[A-X][A-E][A-Z])|(?:[A-X][A-F][A-D])))))(?:(?:\\$(?:\\$)?(?P<row2>(?:(?:[1-9][0-9]{0,5})|(?:10[0-3][0-9]{1,4})|(?:104[0-7][0-9]{1,3})|(?:1048[0-4][0-9]{1,2})|(?:10485[0-6][0-9])|(?:104857[0-6]))))|(?P<row2>(?:(?:[1-9][0-9]{0,5})|(?:10[0-3][0-9]{1,4})|(?:104[0-7][0-9]{1,3})|(?:1048[0-4][0-9]{1,2})|(?:10485[0-6][0-9])|(?:104857[0-6]))))|(?P<name2>[A-Za-z][^\\\\\\:\\^\\$\\[\\]\\{\\}\\*\\+;,=]{0,249})))?))$",
        "MatchingText": "A1|||A10:B12|||$A$1|||$A$10:XFD1000|||Sheet1!$XF$80|||Sheet1!D10:A23|||[Book1]Sheet1!BB18|||[Book1]Sheet1!BB18:TT34",
        "NonMatchingText": "[Book1]AB1|||ZZZ10|||A1048577",
        "Description": "Matching valid MS Excel range and parse it into named groups [including Workbook, Worksheet and named range. Also including column and row validation]."
    },
    {
        "Pattern": "^[01]?[- .]?\\(?(\\d[1]{2})[2-9]\\d{2}\\)?[- .]?(\\d[1]{2})\\d{3}[- .]?\\d{4}$",
        "MatchingText": "222.818.1818|||(222)818 1818|||(222) 221-1111",
        "NonMatchingText": "(122)818.1818|||911-456-9494|||(436)911-9494",
        "Description": "A combination of W. D. and JP Honeywell's U.S./Canada phone expressions, but this does allow the legal (but rare) 555 exchange number and forces an area code."
    },
    {
        "Pattern": "^((?:2[0-5]{2}|1\\d{2}|[1-9]\\d|[1-9])\\.(?:(?:2[0-5]{2}|1\\d{2}|[1-9]\\d|\\d)\\.){2}(?:2[0-5]{2}|1\\d{2}|[1-9]\\d|\\d)):(\\d|[1-9]\\d|[1-9]\\d{2,3}|[1-5]\\d{4}|6[0-4]\\d{3}|654\\d{2}|655[0-2]\\d|6553[0-5])$",
        "MatchingText": "127.0.0.1:80|||255.255.255.0:21|||1.0.0.0:1",
        "NonMatchingText": "0.0.0.0:1|||256.1.1.1:20|||127.0.0.1:65536",
        "Description": "IPv4 ip:port checker, I hope it will help you. $1 - IP, $2 - port. More to come, maybe :)"
    },
    {
        "Pattern": "^[a-zA-Z][a-zA-Z0-9_\\.\\-]+@([a-zA-Z0-9-]{2,}\\.)+([a-zA-Z]{2,4}|[a-zA-Z]{2}\\.[a-zA-Z]{2})$",
        "MatchingText": "name@website.com ||| first_second@website.co.uk ||| blah.blah.007@website.se",
        "NonMatchingText": "0name@website.com ||| name&@website.net ||| blahblah@website",
        "Description": "This will validate most legal e-mail adresses with the correct syntax."
    },
    {
        "Pattern": "^((http|https|ftp):\\/\\/(www\\.)?|www\\.)[a-zA-Z0-9\\_\\-]+\\.([a-zA-Z]{2,4}|[a-zA-Z]{2}\\.[a-zA-Z]{2})(\\/[a-zA-Z0-9\\-\\._\\?\\&=,'\\+%\\$#~]*)*$",
        "MatchingText": "http://www.website.com ||| www.website.co.uk ||| ftp.stuff.org ||| http://website.com/directory/directory/file.php?question=answer",
        "NonMatchingText": "abc://www.name.com ||| www.website ||| http//www.website.com ||| website.com",
        "Description": "This will validate most legal websites, including ftp."
    },
    {
        "Pattern": "^(([0-9]{3})[-]?)*[0-9]{6,7}$",
        "MatchingText": "031-3224562 ||| 0737234264 ||| 073-5647829",
        "NonMatchingText": "34348abc ||| 452643242343432432435643623432 ||| 532",
        "Description": "This validates most telephone numbers in Sweden."
    },
    {
        "Pattern": "replace(MobileNo,' ',''),'^(\\+44|0044|0)(7)[4-9][0-9]{8}$'",
        "MatchingText": "07909192930, +447909192930",
        "NonMatchingText": "+440790919293, +44790919293A",
        "Description": "It matches all the valid UK mobile numbers that  have spaces/no spaces, +44/0044/0 excluding personal numbering (070) that charges a lot and is vastly used for scamming."
    },
    {
        "Pattern": "replace(MobileNo,' ',''),'^(\\+44|0044|0)(7)[4-9][0-9]{8}$'",
        "MatchingText": "07909192930, +447909192930",
        "NonMatchingText": "+440790919293, +44790919293A",
        "Description": "It matches all the valid UK mobile numbers that  have spaces/no spaces, +44/0044/0 excluding personal numbering (070) that charges a lot and is vastly used for scamming."
    },
    {
        "Pattern": "^[1-9][0-9][0-9][0-9]$",
        "MatchingText": "1000 | 1200 | 8200 | 8048 | 9999",
        "NonMatchingText": "a-z | aaaa | 123 | 0000 ",
        "Description": "Zip code validation for Switzerland.\nForces 4-digits only zipcode starting at 1000"
    },
    {
        "Pattern": "(t|T)(o|O)\\s\\d{4}($|\\D)",
        "MatchingText": "to 9373H|tO 0934|TO 6266|To 0937|to 9347.|to 9837|to 8933 |to 8937",
        "NonMatchingText": "to 82799",
        "Description": "Catch text containing \"to \" followed by 4 digit number. Not more than 4 digits, ie 5 or 8 digits."
    },
    {
        "Pattern": "^([Vv]+(erdade(iro)?)?|[Ff]+(als[eo])?|[Tt]+(rue)?|0|[\\+\\-]?1)$",
        "MatchingText": "False|||verdadeiro|||0",
        "NonMatchingText": "+0|||1-1",
        "Description": "This RegEx will match boolean values, either numeric or literal. It will accept MS Access &quot;-1&quot; values for &quot;true&quot;,\nand recognizes English and Brazilian Portuguese."
    },
    {
        "Pattern": "(02\\d\\s?\\d{4}\\s?\\d{4})|(01\\d{2}\\s?\\d{3}\\s?\\d{4})|(01\\d{3}\\s?\\d{5,6})|(01\\d{4}\\s?\\d{4,5})",
        "MatchingText": "020 1234 5678|||0123 4567890|||01234 456789",
        "NonMatchingText": "02476 123456|||0845 123456|||07712 345678",
        "Description": "Validates UK domestic landline phone numbers.\nValid formats are:\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999. These formats are taken from the official guidelines from Ofcom, the organisation responsible for UK telecoms issues. Brackets are not valid and STD code must be entered."
    },
    {
        "Pattern": "(077|078|079)\\s?\\d{2}\\s?\\d{6}",
        "MatchingText": "07713 345678|||078 12345678|||079 12345678",
        "NonMatchingText": "02344 123456|||0121 292929|||012345 6789",
        "Description": "Validates UK mobile phone numbers. Valid formats are `077', `078' or `079' followed by another 8 digits, with an optional space after the dialling code and/or between the 4th and 5th characters of the remainder of the number. These formats are taken from the official guidelines from Ofcom, the organisation responsible for UK telecoms issues. Brackets are not valid and STD code must be entered."
    },
    {
        "Pattern": "/^([a-z0-9])(([\\-.]|[_]+)?([a-z0-9]+))*(@)([a-z0-9])((([-]+)?([a-z0-9]+))?)*((.[a-z]{2,3})?(.[a-z]{2,6}))$/i",
        "MatchingText": "Any Valid E-Mail",
        "NonMatchingText": "Any Non-Valid E-Mail",
        "Description": "Matches any valid e-mail... Kind of large, but worth it to those who really care............email, e-mail, e mail"
    },
    {
        "Pattern": "[\\x01-\\x08,\\x0A-\\x1F,\\x7F,\\x81,\\x8D,\\x8F,\\x90,\\x9D]",
        "MatchingText": "__modified__",
        "NonMatchingText": "|001194|000000|000001|0900|050617|7*|",
        "Description": "We had a need to cleanse webservice replies where the call behind the webmethod went to a legacy mainframe through a thunked middle tier. The escaped chars being in the reply broke the reply stream.  This exp when used in regex.replace within the webmethod will replace the garbage with chars of your choice. "
    },
    {
        "Pattern": "^(([a-zA-Z]:)|((\\\\|/){1,2}\\w+)\\$?)((\\\\|/)(\\w[\\w ]*.*))+\\.([a-zA-Z0-9]+)$",
        "MatchingText": "/asdjd/jhsdh.ajsd ||| E:\\drive.txt ||| \\\\usr\\home\\docs.jpg ||| \\users\\assassin\\home/yp.r15",
        "NonMatchingText": "//home/boo/ ||| foo/bar.bmp",
        "Description": "Matches file paths to any valid format. Matches both \"\\\" and \"/\" as valid separators in file path. Extension (\"[a-zA-Z0-9]+\") can be changed to any specific extension like (txt|jpg|png) and so on.Does NOT match relative file paths.\nFeel free to write any comments about bugs or anything, since this is my first contribution to regexlib"
    },
    {
        "Pattern": "^([L|U]{1})([0-9]{5})([A-Za-z]{2})([0-9]{4})([A-Za-z]{3})([0-9]{6})$",
        "MatchingText": "U12345AA1234AAA123456, L12345AA1234AAA123456, u12345aa1234aaa123456",
        "NonMatchingText": "X12345AA1234AAA123456",
        "Description": "The correspective VAT code for indian companies is the CIN Number.\n\nIt is a composition of:\n- First char( U or L)\n- 5 numbers\n- 2 chars (province code)\n- 4 numbers (company registration year)\n- 3 chars (company type like LTD)\n- 6 numbers"
    },
    {
        "Pattern": "^([A-Za-z]{5})([0-9]{4})([A-Za-z]{1})$",
        "MatchingText": "AAAAA1111A, aaaaa0000a",
        "NonMatchingText": "A1A, AAAA11111A, AAAAA1A, AAAAA11111",
        "Description": "Pan is composed by 5 letters, 4 number, 1 letter. Its length is always of 10 alphanumeric chars."
    },
    {
        "Pattern": "^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,6}$",
        "MatchingText": "regexlib.com|||this.is.a.museum|||3com.com",
        "NonMatchingText": "notadomain-.com|||helloworld.c|||.oops.org",
        "Description": "Checks domain names. This validates domains based on latest specifications (RFCs 952 and 1123 dealing with hostnames and RFC 1035 dealing with domain name system requirements) except that it only includes realistic fully-qualified domains: 1. requires at least one subdomain 2. allows shortest top-level domains like &quot;ca&quot;, and &quot;museum&quot; as longest. \n\nOther validation rules: 1. Labels/parts should be seperated by period. 2. Each label/part has maximum of 63 characters. 3. First and last character of label must be alphanumeric, other characters alphanumeric or hyphen. 4. Does not check maxlength of domain which incidentally is 253 characters of text (255 binary representation). \n\nFor a regular expression that matches ALL domains: \n^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)*[a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?$ \n"
    },
    {
        "Pattern": "^07([\\d]{3})[(\\D\\s)]?[\\d]{3}[(\\D\\s)]?[\\d]{3}$",
        "MatchingText": "07976444333|||07956-514333|||07988-321-213",
        "NonMatchingText": "+44 07976444333|||08956-444-444",
        "Description": "UK Mobile phone regular expression.\n\nI usually run this against a telephone field to split out landlines and mobile numbers."
    },
    {
        "Pattern": "\\<img ((src|height|width|border)=:q:Wh*)*/\\>",
        "MatchingText": "<ol><li>&lt;img src=\"pic.gif\" width=\"84\" height=\"119\" border=\"0\" /&gt;</li><li>&lt;img src=\"pic.gif\" width=\"84\" height=\"119\"/&gt;</li><li>&lt;img src=\"pic.gif\" width=\"84\" border=\"0\" /&gt;</li><li>&lt;img src=\"pic.gif\" height=\"119\" border=\"0\" /&gt;</li><li>&lt;img src=\"pic.gif\" border=\"0\" /&gt;</li><li>&lt;img src=\"pic.gif\" height=\"119\" /&gt;</li><li>&lt;img width=\"84\" height=\"119\" border=\"0\" src=\"pic.gif\" /&gt;</li><li>&lt;img src=\"pic.gif\"/&gt;</li><li>&lt;img src=\"pic.gif\"  /&gt;</li></ol>",
        "NonMatchingText": "Any img tag with:<br><ol><li>An alt attribute</li><li>Javascript event function</li><li>Unquoted attributes</li><li>The ending / missing</li></ol>",
        "Description": "This regex is good for finding image tags without alt tags.  I used this for working on Section 508 compliance.  This is a M$ flavored regex and probably won't work with anything else."
    },
    {
        "Pattern": "^([0-1](?:\\.\\d)|[0-1](?:\\,\\d)|(2\\.0)|(2\\,0))$",
        "MatchingText": "0,0 | 0.0 | 1,9 | 2.0",
        "NonMatchingText": "2,1 | 1 | 3 | a",
        "Description": "Had to handle both \",\" and \".\" as separator in a validationscript where values are between 0.0 and 2.0 like in results of Swedish H\u00F6gskoleprov (SAT)."
    },
    {
        "Pattern": "^(5[1-5]\\d{2})\\d{12}|(4\\d{3})(\\d{12}|\\d{9})$",
        "MatchingText": "5555555555554444 | 5105105105105100 | 4012888888881881 | 4222222222222",
        "NonMatchingText": "123412341234 | 4222-2222-2222-2222 | visa | 41231234123412345",
        "Description": "A simple regex to check for only Visa and MasterCard with no dashes or spaces. Visa starts with a 4 and is 13 or 16 digits long, MasterCard starts with a 51 through 55 and is 16 digits long. I noticed that some of the other formulas don't account for Visa being valid with only 13 digits. I used this for a PayPal processor (which doesn't allow dashes or spaces) and modified it from others on this site. Enjoy."
    },
    {
        "Pattern": "/^(([01]?\\d?\\d|2[0-4]\\d|25[0-5])\\.){3}([01]?\\d?\\d|2[0-4]\\d|25[0-5])\\/(\\d{1}|[0-2]{1}\\d{1}|3[0-2])$/",
        "MatchingText": "192.168.100.1/24 | 0.0.0.0/0",
        "NonMatchingText": "192.168.100.1/33 | 0.0.0.0/90",
        "Description": "Validates subnet specified by CIDR notation. A valid CIDR notation begins with the IP address followed by a '/' character and a decimal number specifying the length, in bits, of the subnet mask or routing prefix (number from 0 to 32)."
    },
    {
        "Pattern": "^\\D?(\\d{3})\\D?\\D?(\\d{3})\\D?(\\d{4})$",
        "MatchingText": "(111) 222-3333|||1112223333|||111-222-3333",
        "NonMatchingText": "11122223333|||11112223333|||11122233333",
        "Description": "This RegEx requires a US phone number WITH area code. It is written to all users to enter whatever delimiters they want or no delimiters at all (i.e. 111-222-3333, or 111.222.3333, or (111) 222-3333, or 1112223333, etc...)."
    },
    {
        "Pattern": "^([\\w\\d\\-\\.]+)@{1}(([\\w\\d\\-]{1,67})|([\\w\\d\\-]+\\.[\\w\\d\\-]{1,67}))\\.(([a-zA-Z\\d]{2,4})(\\.[a-zA-Z\\d]{2})?)$",
        "MatchingText": "foo@foo.com|||foo@foo-foo.com.au|||foo@foo.foo.info",
        "NonMatchingText": "foo@.com|||foo@foo..com|||foo@me@.com",
        "Description": "This pattern allows standard e-mail addresses (e.g. user@domain.com), sub domains (e.g. user@foo.domain.com), the new two- and four-letter domains (e.g. user@domain.tv and user@domain.name) and country codes (e.g. user@foo.com.us). Also, this patter follows the Network Solutions standard length of 67 characters for top-level domains. The reason I allow numbers to be entered in the domain suffix is for future planning. If you do not want numbers to be able to be added as a domain suffix (e.g. user@domain.123), simply delete the last two occurrences of &quot;\\d&quot;."
    },
    {
        "Pattern": "^([a-zA-z]:((\\\\([-*\\.*\\w+\\s+\\d+]+)|(\\w+)\\\\)+)(\\w+.zip)|(\\w+.ZIP))$",
        "MatchingText": "C:\\Downloads\\AtlasPlayground.zip | C:\\Documents and Settings\\name\\My Documents\\Asdfasdfasdf.zip | Z:\\Program Files\\asdf\\a.d.f.controlsQ1 23213\\NET1\\LiveExamplesCS.zip",
        "NonMatchingText": "Z:\\Downloads\\A@#@tlasPlayground.zip | AtlasPlayground.zip ",
        "Description": "I used this regex to check to make sure the file type being uploaded through an input tag was a zip file. Changing the '.zip' to another extension will change the file extension being verified. "
    },
    {
        "Pattern": "^(?:\\(\\+?44\\)\\s?|\\+?44 ?)?(?:0|\\(0\\))?\\s?(?:(?:1\\d{3}|7[1-9]\\d{2}|20\\s?[78])\\s?\\d\\s?\\d{2}[ -]?\\d{3}|2\\d{2}\\s?\\d{3}[ -]?\\d{4})$",
        "MatchingText": "02081234567, 0208 123 4567, 0208 123-4567, +44 208 123 4567, +44 (0) 208 123 4567, 01234 567 890,  +44 0 1234 567-890,  07712 123 456",
        "NonMatchingText": "020812345678, 123456789, 07612 123 4567",
        "Description": "Matches valid UK residential telephone numbers in all expected formats, including international."
    },
    {
        "Pattern": "^(?:[0-1][0-9]|[2][0-3]):?(?:[0-5][0-9]):?(?:[0-5][0-9]|60)|2400|24:00$",
        "MatchingText": "01:01:01 11:01:01 21:01:01 24:00",
        "NonMatchingText": "25:01:00 240000 ",
        "Description": "Matches HH:MM:SS and HHMMSS as well as the special 24:00 and 2400 - check http://en.wikipedia.org/wiki/ISO_8601#Times for more data."
    },
    {
        "Pattern": "((20)[0-9]{2})-((0[1-9])|(1[0-2]))-((3[0-1])|([0-2][1-9]|([1-2][0-9])))\\s((2[0-3])|[0-1][0-9]):[0-5][0-9]",
        "MatchingText": "2000-12-29 10:00 2014-10-20 23:59 2001-01-01 00:00",
        "NonMatchingText": "1999-12-29 09:00 2014-01-02 9:00 2000-1-1 23:10",
        "Description": "Date and hour with fixed format, only accepting year >= 2000. If you want more flexibility on the year, you could replace the first expression (20)[0-9]{2} with only [0-9]{4}, that would allow years from 0000 to 9999."
    },
    {
        "Pattern": "^((\\+)?(\\d{2}[-]))?([0])?(\\d{10}){1}?$",
        "MatchingText": "+91-xxxxxxxxxx|9xxxxxxxxx|07xxxxxxxx",
        "NonMatchingText": "+09xxxxxxxxx|+918xxxxxxxxx|+xxxxxxxxxx",
        "Description": "This regular expression is to validate indian mobile number`s of any mobilbe operator start with any series likes 9xxxxxxxxx,8xxxxxxxxx,7xxxxxxxxx,6xxxxxxxxx etc"
    },
    {
        "Pattern": "(((0[1-9]|[12][0-9]|3[01])([-./])(0[13578]|10|12)([-./])(\\d{4}))|(([0][1-9]|[12][0-9]|30)([-./])(0[469]|11)([-./])(\\d{4}))|((0[1-9]|1[0-9]|2[0-8])([-./])(02)([-./])(\\d{4}))|((29)(\\.|-|\\/)(02)([-./])([02468][048]00))|((29)([-./])(02)([-./])([13579][26]00))|((29)([-./])(02)([-./])([0-9][0-9][0][48]))|((29)([-./])(02)([-./])([0-9][0-9][2468][048]))|((29)([-./])(02)([-./])([0-9][0-9][13579][26])))",
        "MatchingText": "29/02/2000|||31/01/2000|||30-01-2000",
        "NonMatchingText": "29/02/2002|||32/01/2002|||10/2/2002",
        "Description": "Jason West (jason.west@mail.state.ky.us) date validator with leap years using a strict dd/mm/yyyy  (ITALIAN) format"
    },
    {
        "Pattern": "\\(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\)",
        "MatchingText": "(8.8.8.8) ||| (127.0.0.1)",
        "NonMatchingText": "(a.sg.af.) ||| 8.8.8.8",
        "Description": "This regex finds the IPs in its route. This uses the UNIX Bash 'traceroute' command's IP format"
    },
    {
        "Pattern": "^-?[0-9]{0,2}(\\.[0-9]{1,2})?$|^-?(100)(\\.[0]{1,2})?$",
        "MatchingText": "12.34|||100.00|||-2.1",
        "NonMatchingText": "101.1|||10.123|||100.10",
        "Description": "Matches a negative or positive percentage between 0 and 100 (inclusive). Accepts up to 2 decimal places."
    },
    {
        "Pattern": "^([\\w-\\.]+)@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.)|(([\\w-]+\\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\\]?)$",
        "MatchingText": "sunil.rathore@yahoo.com||sun1programmer@gmail.com",
        "NonMatchingText": "sun1programmer.com || sun1programmer@com.com.com",
        "Description": "This regular expression is used to validate any supportable email ID over the Internet."
    },
    {
        "Pattern": "/^[1-9][0-9][0-9][0-9][0-9][0-9]$/",
        "MatchingText": "400023||200021 etc",
        "NonMatchingText": "034562||00342",
        "Description": "I know this is very simple but this is the indian zip code and will allow only 6 digits."
    },
    {
        "Pattern": "/^[0-9]\\d{2,4}-\\d{6,8}$/",
        "MatchingText": "0222-8345622||09786-567567",
        "NonMatchingText": "11-567567||114490-56756744",
        "Description": "This is indian phone number. where it will take a format of std code 3 to 4 digits, hypen and rest of the 6 to 8 digits, "
    },
    {
        "Pattern": "^(([1-9]{1}(\\d+)?)(\\.\\d+)?)|([0]\\.(\\d+)?([1-9]{1})(\\d+)?)$",
        "MatchingText": "1 | 25 | 25.0 | 25.001 | 0.001 | 0.234",
        "NonMatchingText": "0 | 0.0 | -12",
        "Description": "Regular expression that accepts positive numbers with or with decimal places, but will not allow zero or 0.000"
    },
    {
        "Pattern": "urn:[a-z0-9]{1}[a-z0-9\\-]{1,31}:[a-z0-9_,:=@;!'%/#\\(\\)\\+\\-\\.\\$\\*\\?]+",
        "MatchingText": "urn:vrml:umel:/some/dir/file.ext|||urn:schemas-microsoft-com:xml-data|||URN:foo:a123,456",
        "NonMatchingText": "urn:11111.345:12|||http://www.example.org/|||urn:a#-12:555",
        "Description": "Matches canonical Uniform Resource Names (URNs) as defined in RFC 2141."
    },
    {
        "Pattern": "^(?:[^@<>;:,.()\\s\\[\\]\\\\]+(?:\\.(@))?)+@(?:[\\w\\-]+(?:\\.(\\.))?)+\\.[A-Za-z]{2,6}$",
        "MatchingText": "aa.bb@cc.dd, ?_9+3=12!/-@pi.co.uk, \u00E7\u00E8r\u00E9&p\u00E2t\u00FCk\u00F5@far-away.net",
        "NonMatchingText": "aaa@127.0.0.1, (<aaa>)@bb.cc, .a..a@bb.cc, aaa.@bb.cc",
        "Description": "Email validation intended for javascript: use of lookahead ('.' not followed by '@') instead of lookbehind ('@' not preceded by '.'). It doesn't allow ip addresses."
    },
    {
        "Pattern": "^[A-Z]-\\d{3}(\\d|-[A-Z])$|^[A-Z]{2,3}-\\d{3}$|^\\d{3}-[A-Z]{3}$",
        "MatchingText": "452-FGH | DAG-175 | KJ-398 | W-9485 | J-154-L",
        "NonMatchingText": "456FGK | 456 FGK | 36-KTR",
        "Description": "Matches all 5 formats for Belgian cars. Only hyphens will match as separators between groups"
    },
    {
        "Pattern": "^([1-9]|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])$",
        "MatchingText": "1|||108|||255",
        "NonMatchingText": "01|||256",
        "Description": "This validates a number between 1 and 255. Could be modified to IP, or just to verify a number in a range."
    },
    {
        "Pattern": "^([0]?[1-9]|[1|2][0-9]|[3][0|1])[./-]([0]?[1-9]|[1][0-2])[./-]([0-9]{4}|[0-9]{2})$",
        "MatchingText": "10/03/1979|||1-1-02|||01.1.2003",
        "NonMatchingText": "10/03/197|||09--02--2004|||01 02 03",
        "Description": "Validate brazilian date formats: dd/mm/yyyy or d/m/yy or d.m.yyyy\nwith separators: . - /\nValid dates only! d (1-31)/ m (1-12)/ y (0..)\n(rizzipereira.com.br)\nFor American date format: http://www.regexlib.com/REDetails.aspx?regexp_id=932"
    },
    {
        "Pattern": "^([0]?[1-9]|[1][0-2])[./-]([0]?[1-9]|[1|2][0-9]|[3][0|1])[./-]([0-9]{4}|[0-9]{2})$",
        "MatchingText": "10.03.1979|||12/30/2004|||01/01/2004",
        "NonMatchingText": "09--02--2004|||15-15-2004|||13/12/2004",
        "Description": "Validate american date formats: mm/dd/yyyy or m/d/yy or m.d.yyyy with separators: . - /\nValid dates only! m (1-12)/ d (1-31)/ y (0..)\n(rizzipereira.com.br)\nFor Brazilian date format: http://www.regexlib.com/REDetails.aspx?regexp_id=250"
    },
    {
        "Pattern": "^((http|https|ftp|ftps)+(:\\/\\/))?(www\\.)?\n(([a-z0-9\\.-]{2,})\\.(ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cs|cu|cv|cx|cy|cz|dd|de|dj|dk|dm|do|dz|ec|ee|eg|eh|er|es|et|eu|fi|fj|fk|fm|fo|fr|fx|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|um|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|aero|asia|cat|coop|edu|gov|jobs|mil|mobi|museum|tel|travel|pro|post|biz|com|info|int|name|net|org|pro|arpa)\n|((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])))\n(:([1-9][0-9]?[0-9]?[0-9]?|[1-5][0-9][0-9][0-9][0-9]|6[0-4][0-9][0-9][0-9]|65[0-4][0-9][0-9]|655[0-2][0-9]|6553[0-5]|))?\n(((\\/(([a-zA-Z0-9_\\-\\%\\~\\+\\&\\;]{1,})+)*)*)|\\/$)?\n(\\.(php|html|htm|zip$|arj$|rar$|sit$|pdf$|gif$|jpg$|jpeg$|jpe$|tif$|tiff$))?\n(\\?([a-zA-Z0-9_\\-]+\\=[a-z-A-Z0-9_\\-\\%\\~\\+]+)?(\\&([a-zA-Z0-9_\\-]+\\=[a-z-A-Z0-9_\\-\\%\\~\\+]+))*)?\n(\\=\\?([a-zA-Z0-9_\\-])*)?(((\\+([a-zA-Z0-9_])*)?(\\-([a-zA-Z0-9_])*)?)*)?\n(\\#([a-z-A-Z0-9_\\-\\%\\~\\+\\&\\;]*$))?$",
        "MatchingText": "www.test.com|www.test.com#anker|http://www.test.info|242.240.12.24:65535|sub.test.6x.to/dir/file.php?test=test&test2=test2|www.mytest.com/sleep&search=?good+fine etc.",
        "NonMatchingText": " www.mytest.xxx|242.240.12.24:65536",
        "Description": "A regular expression which allows to find most of valid URL's and it is including some picture or packing-format prefixes at the end of an URL.\nsorry but www.test.com.php is working too, maybe someone could give me a tip for a workaround."
    },
    {
        "Pattern": "[_\\w-]+(?:\\.[_\\w-]+)*@(?:[\\w-]+\\.)+(?:[\\w-]{2,4})([\\w]+)",
        "MatchingText": "a.a@w3.org|||b@sohu.com|||s-s@33.cc",
        "NonMatchingText": "a@b|||a@b.commmm|||a.@b.cc|||a@.cc|||dd@g.netfooooooooo...ooo",
        "Description": "matches the most of the email addresses."
    },
    {
        "Pattern": "^((\\+){1}[1-9]{1}[0-9]{0,1}[0-9]{0,1}(\\s){1}[\\(]{1}[1-9]{1}[0-9]{1,5}[\\)]{1}[\\s]{1})[1-9]{1}[0-9]{4,9}$",
        "MatchingText": "+91 (22) 24440444",
        "NonMatchingText": "+91(22)21312321",
        "Description": "This is a bit strict validation format for a telephone number. It has been tested and used on live server and it works fine without any error. +91 indicates ISD code for India. Numbers inside brackets() indicates STD code and at last the is the phone number. It works with all the indian STD codes and phone numbers existing till date."
    },
    {
        "Pattern": "^([0-9]{0,2})-([0-9]{0,2})-([0-9]{0,4})$",
        "MatchingText": "25-01-1990",
        "NonMatchingText": "25-01-90",
        "Description": "I needed to have a birthday regular expression in dutch format with full year (1900) so i wrote this one."
    },
    {
        "Pattern": "(?P<Protocol>\\w+):\\/\\/(?P<Domain>[\\w@][\\w.:\\-@]+)\\/(?P<Container>[\\w= ,@-]+)*",
        "MatchingText": "LDAP://machinename:636/OU=OrgUnit,O=Org,DC=domain,DC=Com",
        "NonMatchingText": "LDAP:machinename:636/OU=OrgUnit,O=Org,DC=domain,DC=Com",
        "Description": "matches the Protocol, Domain  with port and the distinguishedName of the directory container."
    },
    {
        "Pattern": "^[^iIoOqQ'-]{10,17}$",
        "MatchingText": "12345awertasfggr",
        "NonMatchingText": "12345qwertasfggr",
        "Description": "Validates US VIN. It could be between 10 and 17 character in length and should never contain i, l, o, O, q, Q, ' or -."
    },
    {
        "Pattern": "^(?P<Code>([^\"']|\"[^\"]*\")*)'(?P<Comment>.*)$",
        "MatchingText": "a = b ' Comment|||a = \"xy'z\" ' Comment",
        "NonMatchingText": "a = b|||rem not supported",
        "Description": "This expression separates a Visual Basic (VB) source code line into the code part and the comment part (if any, following an apostrophe character not enclosed in quote marks)."
    },
    {
        "Pattern": "^((\\+)?[1-9]{1,2})?([-\\s\\.])?((\\(\\d{1,4}\\))|\\d{1,4})(([-\\s\\.])?[0-9]{1,12}){1,2}$",
        "MatchingText": "2155552527|(215) 555 2527|215.555.2527|+1 215-555-2527|+1.215.555.2527",
        "NonMatchingText": "+1215.555.2527|321654|+11+27 215-555-2527",
        "Description": "Allows for all kinds of generic international phone numbers, including that of the USA, may include () around area code as well as period, dash, space or nothing seperating numbers. International code needs to be seperated from rest by period, space or dash and my be prefixed with plus. Not overly restrictive but limits size and repetition of codes"
    },
    {
        "Pattern": "(?:#|0x)?(?:[0-9A-F]{2}){3}",
        "MatchingText": "#FF006C",
        "NonMatchingText": "99AAB7FF",
        "Description": "24 bit hex color preceding with 0x or # . From http://tools.twainscanning.com/getmyregex ."
    },
    {
        "Pattern": "(?:#|0x)?(?:[0-9A-F]{2}){4}",
        "MatchingText": "0xF0F73611",
        "NonMatchingText": "#FF006C",
        "Description": "32 bit hex color preceding with 0x or # . From http://tools.twainscanning.com/getmyregex ."
    },
    {
        "Pattern": "3[47]\\d{13}",
        "MatchingText": "371449635398431",
        "NonMatchingText": "37144935398431",
        "Description": "American Express credit card number . From http://tools.twainscanning.com/getmyregex ."
    },
    {
        "Pattern": "3(?:0[012345]|[68]\\d)\\d{11}",
        "MatchingText": "36438936438936",
        "NonMatchingText": "3643836438936",
        "Description": "Diners Club Card credit card number. From http://tools.twainscanning.com/getmyregex"
    },
    {
        "Pattern": "6(?:011|5\\d{2})\\d{12}",
        "MatchingText": "6011016011016011",
        "NonMatchingText": "60116011016011",
        "Description": "Discover Card credit card number. From http://tools.twainscanning.com/getmyregex"
    },
    {
        "Pattern": "(?:2131|1800|35\\d{3})\\d{11}",
        "MatchingText": "3566003566003566",
        "NonMatchingText": "356600356003566",
        "Description": "JCB Card credit card number. From http://tools.twainscanning.com/getmyregex"
    },
    {
        "Pattern": "5[12345]\\d{14}",
        "MatchingText": "5500005555555559",
        "NonMatchingText": "55000055555559",
        "Description": "MasterCard credit card number. From http://tools.twainscanning.com/getmyregex"
    },
    {
        "Pattern": "62[0-9]{14,17}",
        "MatchingText": "6240008631401148",
        "NonMatchingText": "624000831401148",
        "Description": "UnionPay Card credit card number. From http://tools.twainscanning.com/getmyregex"
    },
    {
        "Pattern": "4\\d{12}(?:\\d{3})?",
        "MatchingText": "4110144110144115",
        "NonMatchingText": "411014410144115",
        "Description": "Visa credit card number. From http://tools.twainscanning.com/getmyregex"
    },
    {
        "Pattern": "(?:3[01]|[12][0-9]|0?[1-9])[/.-](?:1[0-2]|0?[1-9])[/.-][0-9]{4}",
        "MatchingText": "31/08/2015|||31-08-2015",
        "NonMatchingText": "2015-08-31",
        "Description": "Date Day/Month/Year. From http://tools.twainscanning.com/getmyregex"
    },
    {
        "Pattern": "[0-9]{4}[/.-](?:1[0-2]|0?[1-9])[/.-](?:3[01]|[12][0-9]|0?[1-9])",
        "MatchingText": "2015-08-31",
        "NonMatchingText": "31/08/2015",
        "Description": "Date Year-Month-Day. From http://tools.twainscanning.com/getmyregex"
    },
    {
        "Pattern": "\\d[\\d,]*(?:\\.\\d+)?",
        "MatchingText": "1,128.09",
        "NonMatchingText": "128F",
        "Description": "Decimal number. From http://tools.twainscanning.com/getmyregex"
    },
    {
        "Pattern": "[\\w!#$%&amp;&apos;*+./=?`{|}~^-]+@[\\d.A-Za-z-]+",
        "MatchingText": "hello.me_1@email.com|||Jean+Francois@anydomain.museum",
        "NonMatchingText": "foo.bar#gmail.co.uk",
        "Description": "Email (your-name@example.com). From http://tools.twainscanning.com/getmyregex"
    },
    {
        "Pattern": "(facebook|twitter|youtube)",
        "MatchingText": "facebook|||twitter|||youtube",
        "NonMatchingText": "imgur",
        "Description": "Google Analytics Segment by source social media. From http://tools.twainscanning.com/getmyregex ."
    },
    {
        "Pattern": "[0-1]+",
        "MatchingText": "10101010",
        "NonMatchingText": "10101012",
        "Description": "Number Binary (10101010) . From http://tools.twainscanning.com/getmyregex ."
    },
    {
        "Pattern": "[0-9]+",
        "MatchingText": "65535",
        "NonMatchingText": "65A35",
        "Description": "Number Decimal (65535) . From http://tools.twainscanning.com/getmyregex ."
    },
    {
        "Pattern": "[0-9a-fA-F]+",
        "MatchingText": "FFFF",
        "NonMatchingText": "FFFG",
        "Description": "Number Hexadecimal (FFFF) . From http://tools.twainscanning.com/getmyregex ."
    },
    {
        "Pattern": "[0-7]+",
        "MatchingText": "177777",
        "NonMatchingText": "177778",
        "Description": "Number  Octal (177777) . From http://tools.twainscanning.com/getmyregex ."
    },
    {
        "Pattern": "((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])",
        "MatchingText": "127.0.0.1",
        "NonMatchingText": "127-0-0-1",
        "Description": "IP address  IPv4 (127.0.0.1) . From http://tools.twainscanning.com/getmyregex ."
    },
    {
        "Pattern": "^(000)(666)(9)\\d{3}[- ]?(00)\\d{2}[- ]?(0000)\\d{4}$",
        "MatchingText": "123456789|||123-45-6789|||123 45 6789",
        "NonMatchingText": "000456789|||000-45-6789|||000 45 6789",
        "Description": "I am publishing this regex that was written by Stephen M. Redd and taken from the following URL:  http://www.reddnet.net/regular-expression-for-validating-a-social-security-number-ssn-issued-after-june-25-2011/.  It allows a dash or space separator and accounts for the new numbers that were previously restricted prior to June 25, 2011."
    },
    {
        "Pattern": "^ *(1[0-2]|[1-9]):[0-5][0-9] *(a|p|A|P)(m|M) *$",
        "MatchingText": "12:00am|||1:00 PM|||  12:59   pm",
        "NonMatchingText": "0:00|||0:01 am|||13:00 pm",
        "Description": "validate 12-hour time with am/pm after it, with optional spaces before or after, and optionally between time and am/pm."
    },
    {
        "Pattern": "^([a-zA-Z0-9]+([\\.+_-][a-zA-Z0-9]+)*)@(([a-zA-Z0-9]+((\\.|[-]{1,2})[a-zA-Z0-9]+)*)\\.[a-zA-Z]{2,6})$",
        "MatchingText": "abc@test.com ||| abc@test-test.info |||  abc.d-e_f+g@a.b-c.d--e.museum",
        "NonMatchingText": "a+@test.com ||| +a@test.com ||| a++a@test.com ||| abc@a---b.com ||| abc@a---b.test.com",
        "Description": "This pattern was based on this reference: http://www.remote.org/jochen/mail/info/chars.html\n\nThis expression allows only these symbols (+, -, _, or .) in the local part of the address, but no two consecutive symbols are allowed. The symbols behave like separators for alphanumeric atoms. The local part must begin and end with an atom. Therefore, local part cannot begin or end with a symbol.\n\nFor the domain name, I tested what was allowed at various domain registrars. While hyphens are allowed, domain names must abide by the following rules:\n-can't begin or end with hyphen\n-no more than two hyphens can appear consecutively"
    },
    {
        "Pattern": "^[0]*?(?P<Percentage>[1-9][0-9]?|100)%?$",
        "MatchingText": "1%|||99%|||00099%||99",
        "NonMatchingText": "101%|||0%",
        "Description": "it matches percentage from 1 to 100%. It ignores 0 or 0%. It only support integer matching."
    },
    {
        "Pattern": "^(([a-zA-Z]:|\\\\)\\\\)?(((\\.)|(\\.\\.)|([^\\\\/:\\*\\?\"\\|<>\\. ](([^\\\\/:\\*\\?\"\\|<>\\. ])|([^\\\\/:\\*\\?\"\\|<>]*[^\\\\/:\\*\\?\"\\|<>\\. ]))?))\\\\)*[^\\\\/:\\*\\?\"\\|<>\\. ](([^\\\\/:\\*\\?\"\\|<>\\. ])|([^\\\\/:\\*\\?\"\\|<>]*[^\\\\/:\\*\\?\"\\|<>\\. ]))?$",
        "MatchingText": "File.txt|||c:\\Blah\\..\\.\\Blah Blah.Blah\\File.txt|||\\\\server\\share\\file.txt",
        "NonMatchingText": " File.txt|||c:\\.File.txt|||c:\\.\\.Blah\\File.txt",
        "Description": "File Name Validator. Validates both UNC (\\\\server\\share\\file) and regular MS path (c:\\file)."
    },
    {
        "Pattern": "(^\\(\\)$|^\\(((\\([0-9]+,(\\((\\([0-9]+,[0-9]+,[0-9]+\\),)*(\\([0-9]+,[0-9]+,[0-9]+\\)){1}\\))+\\),)*(\\([0-9]+,(\\((\\([0-9]+,[0-9]+,[0-9]+\\),)*(\\([0-9]+,[0-9]+,[0-9]+\\)){1}\\))+\\)){1}\\)))$",
        "MatchingText": "((24,((1,2,3),(3,4,5))))|||((1,((2,3,4),(4,5,6),(96,34,26))),(12,((1,3,4),(4,5,6),(7,8,9))))|||()",
        "NonMatchingText": "(24,((1,2,3),(3,4,5)))|||(  )|||((23,(12,3,4),(4,5,6)))",
        "Description": "This checks for the specific syntax ((A,((b,c,d),(e,f,g))), ..).  No limit on number of occurances."
    },
    {
        "Pattern": "^((0[1-9])|(1[0-2]))[\\/\\.\\-]*((0[8-9])|(1[1-9]))$",
        "MatchingText": "01/08   |   01-08   |   01.08   |   12/10   |   12/19   |   0109",
        "NonMatchingText": "01/06   |   01/20   |   0a09   |   00/09   ",
        "Description": "Validates major credit card expiration dates in MM/YY, MM.YY, MM-YY, or MMYY. Year range is 08-19."
    },
    {
        "Pattern": "^(^N[BLSTU]$)|(^[AMN]B$)|(^[BQ]C$)|(^ON$)|(^PE$)|(^SK$)$",
        "MatchingText": "ON",
        "NonMatchingText": "ONT",
        "Description": "used to match standard province codes in upper case."
    },
    {
        "Pattern": "^(?:m|M|male|Male|f|F|female|Female)$",
        "MatchingText": "F, M, female, male, Female, Male",
        "NonMatchingText": "mail, femail, a, z, ",
        "Description": "Classic gender descriptor regex."
    },
    {
        "Pattern": "^[a-zA-Z]\\:\\\\.*|^\\\\\\\\.*",
        "MatchingText": "\\\\mypath\\mypath1\\myfile.aaa, C:\\mypath\\mypath\\mypath, \\\\otherpath\\otherpath, D:\\somepath\\somefile.file",
        "NonMatchingText": "http://www.mysite.com, \\\\\\badpath\\badpath, X::\\\\badpath",
        "Description": "Useful for determining whether a string constitutes a valid local or UNC path.  "
    },
    {
        "Pattern": "hg diff --nodates | egrep -e \"---\" -v | egrep -e \"^-\" -c\nhg diff --nodates | egrep -e \"\\+\\+\\+\" -v | egrep -e \"^\\+\" -c",
        "MatchingText": "- removed this line | - | - ...| + added this line",
        "NonMatchingText": "+++ | asdf | --- a/file/here.tt",
        "Description": "does a mercurial diff and counts the lines removed/added."
    },
    {
        "Pattern": "^[NS]([0-8][0-9](\\.[0-5]\\d){2}|90(\\.00){2})\\040[EW]((0\\d\\d|1[0-7]\\d)(\\.[0-5]\\d){2}|180(\\.00){2})$",
        "MatchingText": "N90.00.00 E180.00.00|||S34.59.33 W179.59.59|||N00.00.00 W000.00.00",
        "NonMatchingText": "N91.00.00 E181.00.00|||Z34.59.33 W179.59.59|||N00.00.00 W181.00.00",
        "Description": "Validate location, latitude and longitude separated by space, where latitude is expressed as compass direction (N or S),degrees,minutes,seconds and longitude is expressed as compassdirection (E or W) ,degrees,minutes,seconds.\nRange check for minutes and seconds (0-59),\nmax.latitude 90.00.00, max longitude 180.00.00\n"
    },
    {
        "Pattern": "(?P<FirstName>[A-Z]\\.?\\w*\\-?[A-Z]?\\w*)\\s?(?P<MiddleName>[A-Z]\\w*|[A-Z]?\\.?)\\s?(?P<LastName>[A-Z]\\w*\\-?[A-Z]?\\w*)(?:,\\s|)(?P<Suffix>Jr\\.|Sr\\.|IV|III|II|)",
        "MatchingText": "David F Walker|||J. S. Smith, Jr.|||Catherine Zeta-Jones",
        "NonMatchingText": "oscar peterson",
        "Description": "A regex that attempts to accurately parse the elements from a proper name where the format is in &lt;&lt;First, Last&gt;&gt; order or some permutation of that order.  Critiques and suggestions for improvement are welcome. "
    },
    {
        "Pattern": "(?P<FirstName>[A-Z]\\.?\\w*\\-?[A-Z]?\\w*)\\s?(?P<MiddleName>[A-Z]\\w+|[A-Z]?\\.?)\\s(?P<LastName>[A-Z]?\\w{0,3}[A-Z]\\w+\\-?[A-Z]?\\w*)(?:,\\s|)(?P<Suffix>Jr\\.|Sr\\.|IV|III|II|)",
        "MatchingText": "David Walker|||Bob MacDonald|||Yvonne DeCarlo",
        "NonMatchingText": "oscar peterson",
        "Description": "Fine-tuned the previous version to handle surnames with embedded caps like McCoy and DeCarlo."
    },
    {
        "Pattern": "(?P<FirstName>[A-Z]\\.?\\w*\\-?[A-Z]?\\w*)\\s?(?P<MiddleName>[A-Z]\\w+|[A-Z]?\\.?)\\s(?P<LastName>(?:[A-Z]\\w{1,3}|St\\.\\s)?[A-Z]\\w+\\-?[A-Z]?\\w*)(?:,\\s|)(?P<Suffix>Jr\\.|Sr\\.|IV|III|II|)",
        "MatchingText": "David F. Walker|||Norm MacDonald|||Jill St. John",
        "NonMatchingText": "oscar peterson",
        "Description": "Getting closer now...  this one has the functionality of the previous two and matches on names like &quot;Jill St. John&quot; as well."
    },
    {
        "Pattern": "(?P<LastName>[A-Z]\\w+\\-?[A-Z]?\\w*),\\s(?P<Suffix>Jr\\.|Sr\\.|IV|III|II)?,?\\s?(?P<FirstName>[A-Z]\\w*\\-?[A-Z]?\\w*\\.?)\\s?(?P<MiddleName>[A-Z]?\\w*\\.?)",
        "MatchingText": "Walker, David F|||Smith, Jr., J. S.|||DeCarlo, Yvonne",
        "NonMatchingText": "peterson, oscar",
        "Description": "Regex parses elements from a proper name in &lt;&lt;Last, First&gt;&gt; order and permutations.  Comments and critiques are welcome."
    },
    {
        "Pattern": "^(AT ?U[0-9]{7}|BE ?[0-9]{10}|BG ?[0-9]{9,10}|CY ?[0-9]{8}[A-Z]{1}|CZ ?[0-9]{8,10}|DE ?[0-9]{9}|DK ?[0-9]{8}|EE ?[0-9]{9}|EL ?[0-9]{9}|ES ?[0-9A-Z]{9}|FI ?[0-9]{8}|FR ?[0-9A-Z]{11}|HU ?[0-9]{8}|IE ?[0-9A-Z]{8}|IT ?[0-9]{11}|LT ?([0-9]{9}|[0-9]{12})|LU ?[0-9]{8}|LV ?[0-9]{11}|MT ?[0-9]{8}|NL ?[0-9B]{12}|PL ?[0-9]{10}|PT ?[0-9]{9}|RO ?[0-9]{2,10}|SE ?[0-9]{12}|SI ?[0-9]{8}|SK ?[0-9]{10})$",
        "MatchingText": "AT U1234567|||DE 123456789|||LU12345678",
        "NonMatchingText": "AT-U1234567|||OP12345|||xyz",
        "Description": "Pattern to match European VAT codes based on the formats described at http://www.hmrc.gov.uk/vat/managing/international/esl/country-codes.htm. The pattern is written long-hand and does not follow the character rules to the letter, but in the absence of a true VAT code checking service (the only accurate way to do this) it is pretty good."
    },
    {
        "Pattern": "^\\s*((?:(?:\\d+(?:\\x20+\\w+\\.?)+(?:(?:\\x20+STREET|ST|DRIVE|DR|AVENUE|AVE|ROAD|RD|LOOP|COURT|CT|CIRCLE|LANE|LN|BOULEVARD|BLVD)\\.?)?)|(?:(?:P\\.\\x20?O\\.|P\\x20?O)\\x20*Box\\x20+\\d+)|(?:General\\x20+Delivery)|(?:C[\\\\\\/]O\\x20+(?:\\w+\\x20*)+))\\,?\\x20*(?:(?:(?:APT|BLDG|DEPT|FL|HNGR|LOT|PIER|RM|S(?:LIP|PC|T(?:E|OP))|TRLR|UNIT|\\x23)\\.?\\x20*(?:[a-zA-Z0-9\\-]+))|(?:BSMT|FRNT|LBBY|LOWR|OFC|PH|REAR|SIDE|UPPR))?)\\,?\\s+((?:(?:\\d+(?:\\x20+\\w+\\.?)+(?:(?:\\x20+STREET|ST|DRIVE|DR|AVENUE|AVE|ROAD|RD|LOOP|COURT|CT|CIRCLE|LANE|LN|BOULEVARD|BLVD)\\.?)?)|(?:(?:P\\.\\x20?O\\.|P\\x20?O)\\x20*Box\\x20+\\d+)|(?:General\\x20+Delivery)|(?:C[\\\\\\/]O\\x20+(?:\\w+\\x20*)+))\\,?\\x20*(?:(?:(?:APT|BLDG|DEPT|FL|HNGR|LOT|PIER|RM|S(?:LIP|PC|T(?:E|OP))|TRLR|UNIT|\\x23)\\.?\\x20*(?:[a-zA-Z0-9\\-]+))|(?:BSMT|FRNT|LBBY|LOWR|OFC|PH|REAR|SIDE|UPPR))?)?\\,?\\s+((?:[A-Za-z]+\\x20*)+)\\,\\s+(A[LKSZRAP]|C[AOT]|D[EC]|F[LM]|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEHINOPST]|N[CDEHJMVY]|O[HKR]|P[ARW]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])\\s+(\\d+(?:-\\d+)?)\\s*$",
        "MatchingText": "P.O. Box 42        Huslia, AK 99746|||C/O John Paul, POBox 456, Motown, CA 96090",
        "NonMatchingText": "4321 East 40th Apt #3  Anchorage AK 99504|||Stockton, CA 95215",
        "Description": "Based on a regular expression from Michael Ash, this captures US street addresses and mailing addresses, single or multi-line (multi-line is more reliable), and breaks them into discrete parts for address line 1 and 2, city, state, and postal code.  This expression is not perfect - with the interpreter I am using, some addresses refuse to match correctly.  It should however work for most addresses, particularly when lines are delimited with carriage returns, tabs, or some other whitespace line delimiter that is not a space (\\x20).  Note: For improved compatibility, this expression does not use named groups.\n**Output** \n\\1 = Address 1,\n\\2 = Address 2,\n\\3 = City,\n\\4 = State,\n\\5 = Postal Code"
    },
    {
        "Pattern": "(^\\$(\\d{1,3},?(\\d{3},?)*\\d{3}(\\.\\d{1,3})?|\\d{1,3}(\\.\\d{2})?)$|^\\d{1,2}(\\.\\d{1,2})? *%$|^100%$)",
        "MatchingText": "$1000.00|||100%|||50%",
        "NonMatchingText": "%100|||.5%|||100",
        "Description": "Matches either an explicitly input percentage or dollar amount, variety of formats of currency borrowed from another example on this board. This is useful when you want to prompt the user to specify either dollars or percent using only one field, and want to validate the entered text is one or the other."
    },
    {
        "Pattern": "^\\d+(?:\\.\\d{0,2})?$",
        "MatchingText": "1|||1.23|||1234.45",
        "NonMatchingText": "a1.34|||1.23a|||a",
        "Description": "Matches positive whole numbers with exactly zero or two decimal points if a . is present. Useful for checking currency amounts, such 5 or 5.00 or 5.25. "
    },
    {
        "Pattern": "^([0-1]?[0-9]|[2][0-3])[:|.]([0-5][0-9])$",
        "MatchingText": "01.00 ||| 01:00 ||| 23.59 ||| 00:00",
        "NonMatchingText": "2400 ||| 0100 ||| 14.75",
        "Description": "Based on Morten Henriksen's expression, I just added the check for a . as well as a :"
    },
    {
        "Pattern": "^\\d+\\/?\\d*$",
        "MatchingText": "10 | 2/3 | 100/30",
        "NonMatchingText": "-10 | -2/3 | text | 10 / 1 | 42/7eok",
        "Description": "This simple expression is used to validate fractions or UK odds.\nIt will match integers, allowing 10/1 to be entered as 10, and fractions.\nIt will not match negative numbers or fractions, spaces or any alphabetical characters."
    },
    {
        "Pattern": "^([0-9A-F]{2}[:-]){5}([0-9A-F]{2})$",
        "MatchingText": "01:23:45:67:89:AB",
        "NonMatchingText": "01:23:45:67:89:X9",
        "Description": "This regular expression will validate against a valid MAC address. The 6 bytes are hexadecimal and separated by semi colon or dash caracters."
    },
    {
        "Pattern": "^([a-zA-z\\s]{2,})$",
        "MatchingText": "Amit Gupta|||Some Body",
        "NonMatchingText": "A|||Someplace23|||New-Jersey",
        "Description": "This pattern matches is for validating Names, Cities, States, Countries etc that require only alphabet inputs with white spaces. It requires atleast 2 characters &amp; there's no limit on maximum number of characters."
    },
    {
        "Pattern": "^([a-zA-z\\s]{4,32})$",
        "MatchingText": "some body|||hey there|||hello",
        "NonMatchingText": "hi|||hey 27|||hell?",
        "Description": "This is the simplest RegEx for validating someone's name. The name can contain only alphabets(in either case) &amp; should be of minimum length 4 &amp; maximum length 32. Only white spaces are allowed apart from alphabets."
    },
    {
        "Pattern": "(?P<protocol>http(s)?|ftp)://(?P<server>([A-Za-z0-9-]+\\.)*(?P<basedomain>[A-Za-z0-9-]+\\.[A-Za-z0-9]+))+((/?)(?P<path>(?P<dir>[A-Za-z0-9\\._\\-]+)(/){0,1}[A-Za-z0-9.-/]*)){0,1}",
        "MatchingText": "http://www.myserver.mydomain.com/myfolder/mypage.aspx",
        "NonMatchingText": "www.myserver.mydomain.com/myfolder/mypage.aspx",
        "Description": "This regex matches fully qualified external urls (http, https, or ftp).  It uses the ms specific group-naming structure to present friendly named groups back to the user. "
    },
    {
        "Pattern": "^((string).)*$",
        "MatchingText": "strin, tring, 123tring, strin123",
        "NonMatchingText": "string, 123string, string123, anythingwithstringinit",
        "Description": "This expression will NOT match any string that contains the word \"string\". You can replace \"string\" with any list of characters you would like to prevent matching on."
    },
    {
        "Pattern": "((\\(?(\\+420|00420|420)\\)? ?)?([0-9]{3} ?(([0-9]{3} ?[0-9]{3})|([0-9]{2} ?[0-9]{2} ?[0-9]{2}))))|([0-9]{4})",
        "MatchingText": "00420 111 222 333|||+420 777 888 999|||00420 111 333 555|||420222444666|||777999888|||125 83 18 83|||585245874|||4444",
        "NonMatchingText": "D25146E489|||111-222-333|||+974-584-5656|||(222) 333-4444|||4206045808235|||55555|||333",
        "Description": "Czech phone number expression. Including 4-numeric extension.\n(For use in XSD, no flags)"
    },
    {
        "Pattern": "(([\\w-]+://?|www[.])[^\\s()<>]+)",
        "MatchingText": "http://www.bbc.co.uk/news/world-us-canada-24375844",
        "NonMatchingText": "www.google.com/nothing(betweenbrackets)",
        "Description": "This regex will match a completly full URL. It filters everything that maybe a URL. \n\nVERY USEFUL for Pirni Pro tool too identify completly websites."
    },
    {
        "Pattern": "^<a[^>]*(http://[^\"]*)[^>]*>([ 0-9a-zA-Z]+)</a>$",
        "MatchingText": "<a href=\"http://www.google.com\">Google</a>",
        "NonMatchingText": "<a name=\"bookmark\">something</a>",
        "Description": "This pattern matches link tags in html and returns the contents of the href attribute and the text of the link."
    },
    {
        "Pattern": "(^0*$)(^0*\\.0*$)^\\d{1,16}(\\.\\d{1,2})?$",
        "MatchingText": "1234567890123456.12",
        "NonMatchingText": "12345678901234567.12",
        "Description": "Decimal 18,2 valid 16 digits before decimal place\ni.e. upto 16 digit without decimal place is valid. With decimal place 16digit and 2 digits after decimal place is valid"
    },
    {
        "Pattern": "^[^\\x00-\\x1f\\x21-\\x26\\x28-\\x2d\\x2f-\\x40\\x5b-\\x60\\x7b-\\xff]+$",
        "MatchingText": "Sir. Isaac Newton||Tom O'Leary",
        "NonMatchingText": "Mar!y Ann||Bob_1||~!@#$%^&*()_+=-0987654321`{}[]|\\;:\"<>?,/",
        "Description": "Matches common ASCII names without special characters."
    },
    {
        "Pattern": "^(\\d{1,})$|^(\\d{1,}\\.)$|^(\\d{0,}?\\.\\d{1,})$|^([+-]\\d{1,}(\\.)?)$|^([+-](\\d{1,})?\\.\\d{1,})$",
        "MatchingText": "-.2 | -2.3 | 2. | .33",
        "NonMatchingText": "-. | - | . | 2a",
        "Description": "Express\u00E3o Regular para valida\u00E7\u00E3o de n\u00FAmeros decimais."
    },
    {
        "Pattern": "^((?:4\\d{3})|(?:5[1-5]\\d{2})|(?:6011)|(?:3[68]\\d{2})|(?:30[012345]\\d))[ -]?(\\d{4})[ -]?(\\d{4})[ -]?(\\d{4}|3[4,7]\\d{13})$",
        "MatchingText": "6011567812345678|||6011 5678 1234 5678|||6011-5678-1234-5678",
        "NonMatchingText": "1234567890123456",
        "Description": "This just a minor mod to Steven Smith's credit card re to accept spaces as separators, as well as return the four parts of the card.  [Updated Oct-18-2002 to work with Diners Club/Carte Blanche (prefix must be 36, 38, or 300-305)]"
    },
    {
        "Pattern": "([^,0-9]\\D*)([0-9]*|\\d*\\,\\d*)$",
        "MatchingText": "123,5|||123|||,56|||0,56||| 123|||\u20AC123|||\u20AC 123,565|||,3424234",
        "NonMatchingText": "$ 012,12|||1.234|||1.234,56|||",
        "Description": "For currency: strips out leading non-numeric characters. Numbers may use a comma for the decimal place, but cannot use anything for the thousands separator."
    },
    {
        "Pattern": "(^\\-|\\+)?([1-9]{1}[0-9]{0,2}(\\,\\d{3})*|[1-9]{1}\\d{0,})$|^0?$",
        "MatchingText": "1,250|+235|-1|0",
        "NonMatchingText": "abc|-0|1,0",
        "Description": "Allows any integer, signed (+/-) or not, with or without commas, or zero (0), or blank."
    },
    {
        "Pattern": "^([a-zA-Z0-9@*#]{8,15})$",
        "MatchingText": "@12X*567|||1#Zv96g@*Yfasd4|||#67jhgt@erd",
        "NonMatchingText": "$12X*567|||1#Zv_96|||+678jhgt@erd",
        "Description": "Password matching expression. Match all alphanumeric character and predefined wild characters. Password must consists of at least 8 characters and not more than 15 characters. \n"
    },
    {
        "Pattern": "(([+]?34) ?)?(6(([0-9]{8})|([0-9]{2} [0-9]{6})|([0-9]{2} [0-9]{3} [0-9]{3}))|9(([0-9]{8})|([0-9]{2} [0-9]{6})|([1-9] [0-9]{7})|([0-9]{2} [0-9]{3} [0-9]{3})|([0-9]{2} [0-9]{2} [0-9]{2} [0-9]{2})))",
        "MatchingText": "952 566 009|||+34 615 977 911|||967 90 23 44",
        "NonMatchingText": "802 59 23 09|||677 90 23 44|||67 7 809 235",
        "Description": "This regular expression allows to verify mobile phone numbers (600) and telephone numbers (900). Not provide premium charging phones (line 800). The number may be separated by spaces in groups of three digits, or  one group of three number plus two groups of three numbers for fixed phones."
    },
    {
        "Pattern": "(0?[1-9]|[1-9][0-9])[0-9]{6}(-| )?[trwagmyfpdxbnjzsqvhlcke]",
        "MatchingText": "07456789-J|||25895325x|||07456789J",
        "NonMatchingText": "34123450o|||00567123G|||00654987 Z",
        "Description": "Allows to check a identity card (DNI) with a valid verification letter. Not all letters of the alphabet are valid"
    },
    {
        "Pattern": "^[A-Z]{1}[AEIOUX]{1}[A-Z]{2}((\\d{2}((0[13578]|1[02])(0[1-9]|[12][0-9]|3[01])|(0[13-9]|1[0-2])(0[1-9]|[12][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8])))|([02468][048]|[13579][26])0229)[HM]{1}(AS|BC|BS|CC|CS|CH|CL|CM|DF|DG|GT|GR|HG|JC|MC|MN|MS|NT|NL|OC|PL|QT|QR|SP|SL|SR|TC|TS|TL|VZ|YN|ZS|NE)[B-DF-HJ-NP-TV-Z]{3}[0-9A-Z]{1}[0-9]$",
        "MatchingText": "CUJM540331MZSNRX09|||SASD760229HDFNRV04|||PXTA920430HSLNRN02",
        "NonMatchingText": "FRJU450324HBSKJD09|||POLO530229MJCJWSD04|||LOOR540932MOCKLD00",
        "Description": "This regular expression is used to check the correct input of Mexican CURP, this regex has been modified over the years to correct some bugs.\n\nEsta expresi\u00F3n regular la uso para checar la captura de curp en un sistema donde es utilizada como llave universal y se ha actualizado para arreglar peque\u00F1os errores como X en el segundo caracter y que la fecha de nacimiento sea valida."
    },
    {
        "Pattern": "&lt;a[\\s]+[^&gt;]*?href[\\s]?=[\\s\\&quot;\\']+(.*?)[\\&quot;\\']+.*?&gt;([^&lt;]+|.*?)?&lt;\\/a&gt;",
        "MatchingText": "&lt;a href='http://www.regexlib.com'&gt;Text&lt;/a&gt;|||&lt;a href=&quot;...&quot;&gt;Text&lt;/a&gt",
        "NonMatchingText": "all other html tags",
        "Description": "This regex will extract the link and the link title for every a href in HTML source. Useful for crawling sites.\nNote that this pattern will also allow for links that are spread over multiple lines."
    },
    {
        "Pattern": "<img\\s((width|height|alt|align|style)=\"[^\"]*\"\\s)*src=\"(\\/?[a-z0-9_-]\\/?)+\\.(png|jpg|jpeg|gif)\"(\\s(width|height|alt|align|style)=\"[^\"]*\")*\\s*\\/>",
        "MatchingText": "<img width=\"80\" height=\"80\" style=\"border: none\" src=\"img/fluffy.jpg\" alt=\"cat\"/>",
        "NonMatchingText": "<img src=\"img/fluffy\" >",
        "Description": "Will match an image with the most common attributes. "
    },
    {
        "Pattern": "^([0]\\d|[1][0-2])\\/([0-2]\\d|[3][0-1])\\/([2][01]|[1][6-9])\\d{2}(\\s([0]\\d|[1][0-2])(\\:[0-5]\\d){1,2})*\\s*([aApP][mM]{0,2})?$",
        "MatchingText": "12/31/2002|||12/31/2002 08:00|||12/31/2002 08:00 AM",
        "NonMatchingText": "12/31/02|||12/31/2002 14:00",
        "Description": "This is a combination of a few regular expressions found on this site.  It allows for a flexible date and time combination, but requires a 12-hour clock (am/pm).  Many versions of the am/pm are supported."
    },
    {
        "Pattern": "^(((((0?[1-9]|[12]\\d|3[01])[-/]([0]?[13578]|1[02]))|((0?[1-9]|[12]\\d|30)[-/]([0]?[469]|11))|(([01]?\\d|2[0-8])[-/]0?2))[-/]((20|19)?\\d{2}|\\d{1,2}))|(29[-/]0?2[-/]((19)|(20))?([13579][26]|[24680][048])))$",
        "MatchingText": "1/1/1 01/1/1 11/1/1 1/01/1 1/12/01 1/1/2001 31/1/2001 30/4/1 29/2/00 29/02/2004",
        "NonMatchingText": "0/1/1 00/5/2001 40/5/2000 31/4/2000 29/2/2001 30/2/2000 1/14/2000 1/0/2000 1/00/2000 1/1/201 1/1/0001",
        "Description": "matches dates in the format day/month/year.\nsupports / and - charachters.\neasily modified to suit your needs.\nhandles leap years."
    },
    {
        "Pattern": "(?s)(?i)^(^.*(dont match me).*$).*$",
        "MatchingText": "almost anything at all ",
        "NonMatchingText": "please dont match me; dont match me at all",
        "Description": "will match anything EXCEPT  what you replace \"dont match me\" with.\nyou can replace the last .* with whatever criteria must be matched. example matches anything."
    },
    {
        "Pattern": "^(\\+?7{1}|8{1})[ -]?\\(?[0-9]{0,3}\\)?[ -]?[0-9]{3}[ -]?[0-9]{2}[ -]?[0-9]{2}$",
        "MatchingText": "+7-(916)-233-97-97 ||| +79152319694 ||| 8-917-2329675",
        "NonMatchingText": "+44-928-634-23-23 ||| 891723445678 ||| 8005553535",
        "Description": "Regex for russian phone numbers."
    },
    {
        "Pattern": "^((((([13578])|(1[0-2]))[\\-\\/\\s]?(([1-9])|([1-2][0-9])|(3[01])))|((([469])|(11))[\\-\\/\\s]?(([1-9])|([1-2][0-9])|(30)))|(2[\\-\\/\\s]?(([1-9])|([1-2][0-9]))))[\\-\\/\\s]?\\d{4})(\\s((([1-9])|(1[02]))\\:([0-5][0-9])((\\s)|(\\:([0-5][0-9])\\s))([AM|PM|am|pm]{2,2})))?$",
        "MatchingText": "3/3/2003|||3/3/2002 3:33 pm|||3/3/2003 3:33:33 am",
        "NonMatchingText": "13/1/2002|||3/3/2002 3:33|||31/3/2002",
        "Description": "This expression can be used validate a datetime column from SQL Server. Big parts of it where taken from other samples on RegexLib. Please feel free to take it apart and improve it."
    },
    {
        "Pattern": "([0-9a-zA-Z]([-.\\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\\w]*[0-9a-zA-Z]\\.)+[a-zA-Z]{2,9})$",
        "MatchingText": "san_z@asg.com,xy_z@123g.co.in, san@ss.com.in",
        "NonMatchingText": "ssaa_s@asg.c, a@a.com, san@s.co.in, san@apr.com.in.i",
        "Description": "This pattern validates email address. it allows (1)numeric characters and underscore(_) in an address.(2)numeric characters in domain name. it doesn't match user names with a dot(.). doesn;t allow username starting or ending with @ underscore."
    },
    {
        "Pattern": "(?P<Sedol>[B-Db-dF-Hf-hJ-Nj-nP-Tp-tV-Xv-xYyZz\\d]{6}\\d)",
        "MatchingText": "0067340|||B01HL06|||4155586",
        "NonMatchingText": "12345|||34A56B7|||456VGHY",
        "Description": "This regular expression accepts SEDOL (Stock Exchange Daily Official List number, a code used by the London Stock Exchange to identify foreign stocks).\nTo be more exact - it accepts POTENTIAL SEDOL's, since the last, 7th digit of a sedol is a kind of check-sum digit and this reg-ex doesn\u2019t check\u2019s its correctness. Also, despite following to the formal SEDOL definition - its first character should be a consonant character \u2013 there are actual sedol\u2019s with the first character, which is a number (e.g. 0067340 for BAA) and they are accepted by this reg-ex."
    },
    {
        "Pattern": "[AaEeIiOoUuYy]",
        "MatchingText": "a|||o|||e",
        "NonMatchingText": "z|||x|||w",
        "Description": "This simple reg-ex accepts any vowel letter."
    },
    {
        "Pattern": "^((\\d{2,4})/)?((\\d{6,8})|(\\d{2})-(\\d{2})-(\\d{2,4})|(\\d{3,4})-(\\d{3,4}))$",
        "MatchingText": "01/4444-555, 01/44-55-66, 042/333-999, 0800/556677, 1234567",
        "NonMatchingText": "(01) 3344556, 012233445, 042555666",
        "Description": "Croatian phone numbers (old style). Area code and phone number, area code optional. Area code in $2 (if specified) phone number is in $4 or $5+$6+$7 or $8+$9."
    },
    {
        "Pattern": "^(([1..9])|(0[1..9])|(1\\d)|(2\\d)|(3[0..1])).((\\d)|(0\\d)|(1[0..2])).(\\d{4})$",
        "MatchingText": "10.04.1985, 10.4.1985, 05.05,2007, 30.2.2000",
        "NonMatchingText": "33.13.2000, 1.19.12,10/04/1985, 0.0.2000",
        "Description": "This pattern can be used to match EU style dates of formad d.m.yyyy where d and m can be two digits d <= 31 and m <= 12"
    },
    {
        "Pattern": "^100$|^\\d{0,2}(\\.\\d{1,2})? *%?$",
        "MatchingText": "100 | 99.99 | 00 | 20.99",
        "NonMatchingText": "101 | 22.1111",
        "Description": "It matches % value from 0 - 100. The two decimal places are used."
    },
    {
        "Pattern": "<([^\\s>]*)(\\s[^<]*)>",
        "MatchingText": "<img src=\"truc\">|||<body background='...'>|||<p align='left'>",
        "NonMatchingText": "<br>|||</body>|||<p>",
        "Description": "grab all tags attributes...\n\n&lt;img src=&quot;truc&quot;&gt; returns :\n&lt;\n(1:img)\n(2: src=&quot;truc&quot;)\n&gt;\ni use it to clean html pages to grab infos...\n\nuse a RegEx Replace with &quot;&lt;$1&gt;&quot; to keep only tags codes..."
    },
    {
        "Pattern": "<([^<>\\s]*)(\\s[^<>]*)?>",
        "MatchingText": "<td class=\"TD2\">|||<!-- comment -->|||</table>",
        "NonMatchingText": "19-Fev-2002 - 19h00|||New Changes :|||...",
        "Description": "All tags in first submatche\nAll attributes in second one..."
    },
    {
        "Pattern": "^((([A-PR-UWYZ])([0-9][0-9A-HJKS-UW]?))|(([A-PR-UWYZ][A-HK-Y])([0-9][0-9ABEHMNPRV-Y]?))\\s{0,2}(([0-9])([ABD-HJLNP-UW-Z])([ABD-HJLNP-UW-Z])))|(((GI)(R))\\s{0,2}((0)(A)(A)))$",
        "MatchingText": "GIR 0AA|||SW1Y 1AA|||AB1  4BL",
        "NonMatchingText": "XVJ  P09|||GB7Z 1HQ|||Q1 1AA",
        "Description": "Validates UK postcodes  and aligns in parenthesized subpatterns according to standard UK postcode elements. Validation is according to guidelines outlined at http://www.govtalk.gov.uk/gdsc/html/noframes/PostCode-2-1-Release.htm\nPostcode elements are separated according to description at http://www.graticule.com/data/uk/pcdata.html\nExpression is not thoroughly tested, but seems to be doing ok so far!\nComments and improvements welcome."
    },
    {
        "Pattern": "^[a-zA-Z]{1}[\\w\\sa-zA-Z\\d_]*[^\\s]$",
        "MatchingText": "Dodol 123  |  Dodol_garut  |  dodol li pret 5 kali",
        "NonMatchingText": "23dodol     |  _dodol garut  | dodol . / d",
        "Description": "Username start only with alphabet, and then can combine with any digit, space, and underscore. Reject other special character and space in the begin and the end of characters."
    },
    {
        "Pattern": "(^0*$)(^0*\\.0*$)^\\d{1,5}(\\.\\d{1,3})?$",
        "MatchingText": "1|||12345.123|||0.5",
        "NonMatchingText": "0|||0.0|||123456.1234",
        "Description": "This regular expression validates a number NOT 0, with no more than 5 places ahead and 3 places behind the decimal point."
    },
    {
        "Pattern": "<[^/bp][^><]*>|<p[a-z][^><]*>|<b[^r][^><]*>|<br[a-z][^><]*>|</[^bp]+>|</p[a-z]+>|</b[^r]+>|</br[a-z]+>",
        "MatchingText": "All Markup tags",
        "NonMatchingText": "<p></p> <br> <br/>",
        "Description": "This regex will remove all markup tag except <p></p> and line break tag."
    },
    {
        "Pattern": "((^(10|12|0?[13578])([/])(3[01]|[12][0-9]|0?[1-9])([/])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(11|0?[469])([/])(30|[12][0-9]|0?[1-9])([/])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(0?2)([/])(2[0-8]|1[0-9]|0?[1-9])([/])((1[8-9]\\d{2})|([2-9]\\d{3}))$)|(^(0?2)([/])(29)([/])([2468][048]00)$)|(^(0?2)([/])(29)([/])([3579][26]00)$)|(^(0?2)([/])(29)([/])([1][89][0][48])$)|(^(0?2)([/])(29)([/])([2-9][0-9][0][48])$)|(^(0?2)([/])(29)([/])([1][89][2468][048])$)|(^(0?2)([/])(29)([/])([2-9][0-9][2468][048])$)|(^(0?2)([/])(29)([/])([1][89][13579][26])$)|(^(0?2)([/])(29)([/])([2-9][0-9][13579][26])$))",
        "MatchingText": "2/2/2000|||02/02/2000|||02/2/2000",
        "NonMatchingText": "2.2.2000|||2-2-2000",
        "Description": "This Validator Validates any date from 1800 - 9999. It takes special care of Leap years and validates any format of type mm/dd/yyyy , m/dd/yyyy , mm/d/yyyy , m/d/yyyy.\nSince SQL Server does not accept any date before 1/1/1753, so i hope it will meet Your Requirements.(Modified Version of Jason West's Date Validator.)"
    },
    {
        "Pattern": "(\\d+)([,|.\\d])*\\d",
        "MatchingText": "11 11.00 1,243,44.00 343.333",
        "NonMatchingText": "abcd 324bddf ",
        "Description": "Matches any integer, float or currency."
    },
    {
        "Pattern": "^[3|4|5|6]([0-9]{15}$|[0-9]{12}$|[0-9]{13}$|[0-9]{14}$)",
        "MatchingText": "370000000000002",
        "NonMatchingText": "270000000000002",
        "Description": "It is used for simple validation. This regular expression will match the all type of credit card patterns, like AMEX,VISA,MASTER, Dinnerclub, JCB, enRoute ,Discover "
    },
    {
        "Pattern": "(\\s*\\(?0\\d{4}\\)?(\\s*|-)\\d{3}(\\s*|-)\\d{3}\\s*)|(\\s*\\(?0\\d{3}\\)?(\\s*|-)\\d{3}(\\s*|-)\\d{4}\\s*)|(\\s*(7|8)(\\d{7}|\\d{3}(\\-|\\s{1})\\d{4})\\s*)",
        "MatchingText": "0208 993 5689|||0208-993-5689|||89935689",
        "NonMatchingText": "1608 123 456",
        "Description": "another uk telephone number regex.  This was adapted from another on this site http://www.regexlib.com/REDetails.aspx?regexp_id=297\nI added support for hyphens and for london shorthand numbers ie. 8234-1234 72341234  Still want to be permissive where possible....Still need to sort out the all zeros, also not sure if numbers with 4 digits followed by 7 used in london 0208-234-1234 is the area of the uk where this occurs, or all areas outside of london are in format 5 digits followed by 6 digits ie. 01608 123456.  If that is the case for the 4-7 pattern only 0208 or 0207 could be enforced."
    },
    {
        "Pattern": "(\\s*\\(?0\\d{4}\\)?(\\s*|-)\\d{3}(\\s*|-)\\d{3}\\s*)|(\\s*\\(?0\\d{3}\\)?(\\s*|-)\\d{3}(\\s*|-)\\d{4}\\s*)|(\\s*(7|8)(\\d{7}|\\d{3}(\\-|\\s{1})\\d{4})\\s*)",
        "MatchingText": "0208 993 5689|||0208-993-5689|||89935689",
        "NonMatchingText": "1608 123 456",
        "Description": "another uk telephone number regex.  This was adapted from another on this site http://www.regexlib.com/REDetails.aspx?regexp_id=297\nI added support for hyphens and for london shorthand numbers ie. 8234-1234 72341234  Still want to be permissive where possible....Still need to sort out the all zeros, also not sure if numbers with 4 digits followed by 7 used in london 0208-234-1234 is the area of the uk where this occurs, or all areas outside of london are in format 5 digits followed by 6 digits ie. 01608 123456.  If that is the case for the 4-7 pattern only 0208 or 0207 could be enforced."
    },
    {
        "Pattern": "^((http|https|ftp):\\/\\/)?((.*?):(.*?)@)?([a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])((\\.[a-zA-Z0-9][a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])*)(:([0-9]{1,5}))?((\\/.*?)(\\?(.*?))?(\\#(.*))?)?$",
        "MatchingText": "http://john:@www.domain.com:8080/index.html?param=value#Page1",
        "NonMatchingText": "http://www.domain.com:/|||www-.domain.com",
        "Description": "Validates and extracts URI components.\nProtocol is optional.\nUsername & Password is optional.\nHost regex was taken from Remi Sabourin and follows RFC1035 except that it allows hostnames greater than 253 chars.\nAlso TLD length is not restriced.\nPort number is optional.\nAbsolute Path is optional, and also extracts the optional querystring and optional anchor reference."
    },
    {
        "Pattern": "^[1-9]{3}\\s{0,1}[0-9]{3}$",
        "MatchingText": "234 234|||234675",
        "NonMatchingText": "asd343|||4567889|||3454 23",
        "Description": "Pattern for Indian Postal Code."
    },
    {
        "Pattern": "^[0-3][0-9][0-1]\\d{3}-\\d{4}?",
        "MatchingText": "010380-2343 || 120454-5467 || 390178-3434",
        "NonMatchingText": "1223876776 || 4023100923",
        "Description": "This regex performs a crude test on the given input string.\nThe danish cilvil registration number consists of 10 numeric characters and one special character '-'. The format is DDMMYY-XXXX."
    },
    {
        "Pattern": "^((https?|ftp)\\://((\\[?(\\d{1,3}\\.){3}\\d{1,3}\\]?)|(([-a-zA-Z0-9]+\\.)+[a-zA-Z]{2,4}))(\\:\\d+)?(/[-a-zA-Z0-9._?,'+&amp;%$#=~\\\\]+)*/?)$",
        "MatchingText": "http://207.68.172.254/home.ashx|||ftp://ftp.netscape.com/|||https://www.brinkster.com/login.asp",
        "NonMatchingText": "htp://mistake.com/|||http://www_address.com/|||ftp://www.files.com/file with spaces.txt",
        "Description": "Using other regular experssions from this page, combining others for email addresses, and mixing in my own ideas - I came up with this regular expression.  Can be used to validate input into a database."
    },
    {
        "Pattern": "^[+]?((\\d*[1-9]+\\d*\\.?\\d*)|(\\d*\\.\\d*[1-9]+\\d*))$",
        "MatchingText": "010|||010.|||.010|||010.010",
        "NonMatchingText": ".|||0|||0.|||.0|||0.0|||0.00|||00.0|||00.00|||-0|||-1|||a",
        "Description": "Matches any positive decimal number > 0 with optional leading '+' symbol and optional leading or trailing zeros on both sides of the decimal point. Decimal point is also optional and either side of the decimal is optional."
    },
    {
        "Pattern": "^(\\[a-zA-Z '\\]+)$",
        "MatchingText": "\\Network list\\Client",
        "NonMatchingText": "\\Networklist\\client",
        "Description": "This expression for validate \n\\network list\\client    this string. please comment is it right or anything wrong"
    },
    {
        "Pattern": "actionID=&url=&load_frameset=1&autologin=0&anchor_string=&server_key=imap&imapuser=(.*)&pass=(.*)&new_lang=pt_BR&select_view=imp",
        "MatchingText": "Mail|loging|pass|worksinanypcormac",
        "NonMatchingText": "Mobile|dosent|work",
        "Description": "Gives webmail website acount, login and password. Do not work for mobile browsers. "
    },
    {
        "Pattern": "^[ 1(]{0,3}?([02-9][0-9]{2})\\D{0,2}([0-9]{3})\\D?([0-9]{4})($|\\D+.+$)",
        "MatchingText": "2231231234 ||| 223.123.1234 ||| (223)123-1234 ||| 223#123#1234 ||| 1(223)123-1234 x12",
        "NonMatchingText": "123123123456 ||| 223 112",
        "Description": "Matches US phone numbers in just about any format which doesn't try to break the 3-3-4 number set. Captures anything after the 4 digit set, such as an extension, for use later. 3 digit area code (ignoring a leading 1), 3 digit prefix, 4 digit line number and any additional extension info are all separated in to different groups for easy formatting. This expression is designed for a replacement, where the replacement string is ($1)$2-$3$4"
    },
    {
        "Pattern": "^[a-zA-Z]+((\\s|\\-|\\')[a-zA-Z]+)?$",
        "MatchingText": "D'Souza|||D-Souza|||Dsouza",
        "NonMatchingText": "'Dsouza|||-Dsouza",
        "Description": "This is an extension of already existing expression submitted. It checks for characters, hyphen and single quotes. Single quote and hyphen cannot appear at the beginning or at the end."
    },
    {
        "Pattern": "^[0-9\\s\\(\\)\\+\\-]+$",
        "MatchingText": "+(044)-222222|||22222|||+44 22222",
        "NonMatchingText": "A1234|||[22222]",
        "Description": "Telephone number validation. Validates a telephone number which contains either 0-9,(,),+,- and space. Let me know if it works for you. :)"
    },
    {
        "Pattern": "^(?:(?:(?:0?[13578]|1[02])(\\/|-)31)|(?:(?:0?[1,3-9]|1[0-2])(\\/|-)(?:29|30)))(\\/|-)(?:[1-9]\\d\\d\\d|\\d[1-9]\\d\\d|\\d\\d[1-9]\\d|\\d\\d\\d[1-9])$|^(?:(?:0?[1-9]|1[0-2])(\\/|-)(?:0?[1-9]|1\\d|2[0-8]))(\\/|-)(?:[1-9]\\d\\d\\d|\\d[1-9]\\d\\d|\\d\\d[1-9]\\d|\\d\\d\\d[1-9])$|^(0?2(\\/|-)29)(\\/|-)(?:(?:0[48]00|[13579][26]00|[2468][048]00)|(?:\\d\\d)?(?:0[48]|[2468][048]|[13579][26]))$",
        "MatchingText": "01/01/1901, 10/31/2007",
        "NonMatchingText": "02/31/1901, 04/31/2007",
        "Description": "This expression validates dates in the mm/dd/yyyy format and ya..expression will take care of the leap year dates "
    },
    {
        "Pattern": "\\d{10,12}@[a-zA-Z].[a-zA-Z].*",
        "MatchingText": "3605551212@mobile.mycingular.com",
        "NonMatchingText": "360555121@mobile.mycingular.com, 3605551212@mobile",
        "Description": "This is a basic/simple  expression i have come out to check 10digit mobile number and then any valid email ...."
    },
    {
        "Pattern": "^[a-zA-Z]{4}\\d{7}$",
        "MatchingText": "ABCD1234567 ,abcd1236547",
        "NonMatchingText": "dsa5454,456546adg",
        "Description": "This Expression that accept combination of Alphanumeric.\nEg:ABCD1234567"
    },
    {
        "Pattern": "^\\D{0,2}[0]{0,3}[1]{0,1}\\D{0,2}([2-9])(\\d{2})\\D{0,2}(\\d{3})\\D{0,2}(\\d{3})\\D{0,2}(\\d{1})\\D{0,2}$",
        "MatchingText": "(234) 567-8901|||+1-234-567-890-1|||+001 2345678901|||+1/234/567/890-1|||0012345678901|||X234X567X890X1X|||(+001)(234)(5678901)|||+1(234)5678901|||+1 234 567 890-1|||[234][567][890(1)]|||234/567/890/1|||12345678901",
        "NonMatchingText": "12X345678901|||23456789X01|||5678901",
        "Description": "Very useful if you want to use ANY-NON-DIGIT as delimiter and return proper US-Phone-Number. Use \"($1) $2-$3$4\" to get Number in form: \"(234) 567-8901\". \nWill ignore starting 1, 01, 001, +1 etc. \nValidates and also captures AreaCode, Prefix and Suffix for reformatting.\nIn all matching examples, it will return the same result. I have not found any exception yet."
    },
    {
        "Pattern": "Are you looking for Tech Help?",
        "MatchingText": "Hotmail | Customer | Care",
        "NonMatchingText": "Yahoo | Customer | Care",
        "Description": "Creating a Hotmail account is easy and simple, but once error appears while creating or doing other stuff with Hotmail, it's very hard to get rid of. Dialing Hotmail customer service number is always wise and helpful in order to resolve undesirable Hotmail issues. It provides an immediate solution and rectifies all your issues within a minute.  The  Hotmail support phone number can be reached by calling +1-800-611-2573 or visiting http://customercarenumber.us/hotmail-customer-care-usa.html"
    },
    {
        "Pattern": "(UPDATE\\s+)(\\w+)\\s+(SET)\\s+([\\w+\\s*=\\s*\\w+,?\\s*]+)\\s+(WHERE.+)",
        "MatchingText": "UPDATE table1 SET field1=value1,field2=value WHERE field4=value4",
        "NonMatchingText": "UPDATE table1 SET field1=value1,field2=value",
        "Description": "Use with \"/i\" flag (case-insensitive) to match any valid SQL UPDATE statement, and to parse it into it's component parts.  Most useful will be group $2, the table name, group $4, the field=value list, and group $5, the WHERE clause."
    },
    {
        "Pattern": "(INSERT INTO\\s+)(\\w+)(\\s+\\()([\\w+,?\\s*]+)(\\)\\s+VALUES\\s+\\()(['?\\w+'?,?\\s*]+)(\\))",
        "MatchingText": "INSERT INTO table (field1, field2) VALUES (value1, value2)",
        "NonMatchingText": "INSERT INTO table VALUES (value1, value2)",
        "Description": "Use with \"/i\" flag (case-insensitive) to match a fully qualified SQL INSERT statement, and to parse it into it's component parts.  Group $2 will contain the table name, $4 the field list, and $6 the value list."
    },
    {
        "Pattern": "(INSERT INTO\\s+)(\\w+)(\\s+\\()([\\w+,?\\s*]+)(\\)\\s+VALUES\\s+)((\\(['?\\w+'?,?\\s*]+\\)\\,?;?\\s*)+)",
        "MatchingText": "INSERT INTO table (field1, field2) VALUES (value1, value2); (value3, value4) or INSERT INTO table (field1, field2) VALUES (value1, value2), (value3, value4)",
        "NonMatchingText": "INSERT INTO table VALUES (value1, value2)",
        "Description": "Use with \"/i\" flag (case-insensitive) to match a fully qualified SQL INSERT statement, and to parse it into it's component parts. Group $2 will contain the table name, $4 the field list, and $6 the all of the value lists."
    },
    {
        "Pattern": "^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\,*\\s\\s*\\d{4}$|^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\\,*\\s\\d{4}$|^(January|February|March|April|May|June|July|August|September|October|November|December)\\,*\\s\\d{4}$|^(january|february|march|april|may|june|july|august|september|october|november|december)\\,*\\s\\d{4}$",
        "MatchingText": "January 2004|||Jan, 2004|||january 2003",
        "NonMatchingText": "Janu 2004|||jAn, 2004|||January,2003",
        "Description": "Best Use validation to accept a valid &quot;MonthName(,) Year&quot;.\nIt can validate an entry with or without comma (,).\n"
    },
    {
        "Pattern": "src=(?:\\\"|\\')?(?P<imgSrc>[^>]*[^/].(?:jpg|bmp|gif|png))(?:\\\"|\\')?",
        "MatchingText": "src=\"http://www.thoughtlava.com/images/logo.gif\"|||src='http://www.thoughtlava.com/images/logo.gif'|||src=http://www.thoughtlava.com/images/logo.gif",
        "NonMatchingText": "src=\"http://www.thoughtlava.com/images/logo.wmf\"",
        "Description": "This pattern matches an image url attribute of an img html tag.  It searches for the src attribute and grabs the value as a grouped match - \"imgSrc\"."
    },
    {
        "Pattern": "^(((((0[1-9])|(1\\d)|(2[0-8]))-((0[1-9])|(1[0-2])))|((31-((0[13578])|(1[02])))|((29|30)-((0[1,3-9])|(1[0-2])))))-((20[0-9][0-9]))|(29-02-20(([02468][048])|([13579][26]))))$",
        "MatchingText": "05-01-2002|||29-02-2004|||31-12-2002",
        "NonMatchingText": "1-1-02|||29-02-2002|||31-11-2002",
        "Description": "This expression validates a date field in the European DD-MM-YYYY format. Days are validate for the given month and year. "
    },
    {
        "Pattern": "AT&T Customer Service Phone Number ",
        "MatchingText": "https://monktech.net/att-client benefit telephone number.html",
        "NonMatchingText": "https://monktech.net/att-client benefit telephone number.html",
        "Description": "AT&T Customer Service Phone Number1-844-659-2999 is a sans toll number which keeps running nonstop and clears every one of your questions inside minutes. Regardless of whether you are confronting system issues or stayed with any of its administration our client care agents have 100% dependable outcomes for you. Associate with our client agents and get moment arrangements every minute of every day. https://monktech.net/att-client benefit telephone number.html"
    },
    {
        "Pattern": "AT&T Customer Service Phone Number ",
        "MatchingText": "https://monktech.net/att-client benefit telephone number.html",
        "NonMatchingText": "https://monktech.net/att-client benefit telephone number.html",
        "Description": "AT&T Customer Service Phone Number1-844-659-2999 is a sans toll number which keeps running nonstop and clears every one of your questions inside minutes. Regardless of whether you are confronting system issues or stayed with any of its administration our client care agents have 100% dependable outcomes for you. Associate with our client agents and get moment arrangements every minute of every day. https://monktech.net/att-client benefit telephone number.html"
    },
    {
        "Pattern": "AT&T Customer Service Phone Number ",
        "MatchingText": "https://monktech.net/att-client benefit telephone number.html",
        "NonMatchingText": "https://monktech.net/att-client benefit telephone number.html",
        "Description": "AT&T Customer Service Phone Number1-844-659-2999 is a sans toll number which keeps running nonstop and clears every one of your questions inside minutes. Regardless of whether you are confronting system issues or stayed with any of its administration our client care agents have 100% dependable outcomes for you. Associate with our client agents and get moment arrangements every minute of every day. https://monktech.net/att-client benefit telephone number.html"
    },
    {
        "Pattern": "AT&T Customer Service Phone Number ",
        "MatchingText": "https://monktech.net/att-client benefit telephone number.html",
        "NonMatchingText": "https://monktech.net/att-client benefit telephone number.html",
        "Description": "AT&T offers wide-scope of broad administrations like quick speed web, broadband, remote gadgets, etc. Numerous clients use AT&T Customer service phone number1-844-659-2999 remote gadgets as they are truly agreeable to utilize. With a rich structure and continuous web, speed AT&T is broadly utilized administrations up until this point. Our client benefit specialists strive to give 100% viable outcomes which will help tackle your issues immediately. https://monktech.net/att-client benefit telephone number.html"
    },
    {
        "Pattern": "AT&T Customer Service Phone Number ",
        "MatchingText": "https://monktech.net/att-client benefit telephone number.html",
        "NonMatchingText": "https://monktech.net/att-client benefit telephone number.html",
        "Description": "AT&T is one of the most established network access suppliers which offer various administrations to its clients running from remote gadgets to broadband associations. AT&T Customer Service Phone Number1-844-659-2999 is a without toll number which handles every one of the inquiries of the clients relating AT&T administrations. Our client benefit masters manage each sort of AT&T issue and fathom them inside minutes. All your AT&T issues would be tended to inside minutes! https://monktech.net/att-client benefit telephone number.html"
    },
    {
        "Pattern": "AllAssignmenthelp.com\u00A0reviews",
        "MatchingText": "All Assignment help reviews",
        "NonMatchingText": "All Assignment help reviews",
        "Description": "Welcome to the review of AllAssignmenthelp\u00A0reviews, a writing service in Britain aimed at USA students. AllAssignmenthelp.com\u00A0reviews is best reviews website in US and Australia.\n"
    },
    {
        "Pattern": "^((([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}((\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b)\\.){3}(\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b))|(([0-9A-Fa-f]{1,4}:){0,5}:((\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b)\\.){3}(\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b))|(::([0-9A-Fa-f]{1,4}:){0,5}((\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b)\\.){3}(\\b((25[0-5])|(1\\d{2})|(2[0-4]\\d)|(\\d{1,2}))\\b))|([0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})|(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:))$",
        "MatchingText": "FEDC:BA98:7654:3210:FEDC:BA98:7654:3210|||1080::8:800:200C:417A|||::FFFF:129.144.52.38",
        "NonMatchingText": "FEDC::7654:3210::BA98:7654:3210|||FEDC:BA98:7654:3210|||::",
        "Description": "Matches full and compressed IPv6 addresses as defined in RFC 2373 (http://www.faqs.org/rfcs/rfc2373.html). No useful captures.\nVarious implementations require different terminators. (i.e. ^-$ or \\b-\\b)"
    },
    {
        "Pattern": "([0-9a-z_-]+[\\.][0-9a-z_-]{1,3})$",
        "MatchingText": "open_01.pdf, 00153._-, _abc_.--1",
        "NonMatchingText": "readme.e$e, save6^.doc, open_01., .txt, leisure.docx",
        "Description": "Will match a Windows filename containing alphanumerics, hyphens (-) and underscores (_). There is no length limit on the first part of the filename, but the extension must be between 1 and 3 characters."
    },
    {
        "Pattern": "^(([1-9]{1}\\d{0,2},(\\d{3},)*\\d{3})|([1-9]{1}\\d{0,}))$",
        "MatchingText": "10|||1000|||1,000|||10,000,000",
        "NonMatchingText": "01|||001,000|||1000,000",
        "Description": "Matches whole numbers only, including comma separated. Does not allow leading zeros. To match comma separated numbers only, change \"\\d{0,}\" to \"\\d{0,2}\". To match 0, add \"|([0])\" before \")$\". If you want to use it with Java's regexp match(), remove \"^(\" and \")$\" since they are not needed. "
    },
    {
        "Pattern": "^[A-Za-z]{1}[0-9]{7}$",
        "MatchingText": "M1234567, b1234567",
        "NonMatchingText": "c12345678",
        "Description": "If it is more then 7 numbers then it will not detect."
    },
    {
        "Pattern": "^(\\+?1(-|\\.|\\s)?)?((\\(((8(00|22|33|44|55|66|77|[8[0-9]))|900)\\)|((8(00|22|33|44|55|66|77|[8[0-9]))|900))(-|\\.|\\s)?\\d{3}(-|\\.|\\s)?\\d{4}|(\\([2-9]([02-9]\\d|1[02-9])\\)|[2-9]([02-9]\\d|1[02-9]))(-|\\.|\\s)?[2-9]([02-9]\\d|1[02-9](-|\\.|\\s)?\\d{4}))$",
        "MatchingText": "800-211-5555|||(800) 211-5555|||1-800-211-5555|||+1-800-211-5555|||555 212 1234|||555.212.1234 ",
        "NonMatchingText": "555-555-555|||555-211-5555|||2-555-555-5555|||555-123-1234",
        "Description": "This is a very detailed RegEx that only allows for valid phone number combinations in accordance with \"North American Numbering Plan\" as well as any combinations for toll (9XX) and toll-free (8XX) numbers.\n\nNumbers can contain parenthesis around the area code, can include 1 or +1, and can be delimited using \"-\", \".\", or space."
    },
    {
        "Pattern": "^(\\+27|27|0)[0-9]{2}( |-)?[0-9]{3}( |-)?[0-9]{4}( |-)?(x[0-9]+)?(ext[0-9]+)?",
        "MatchingText": "+2711 555 5555|||0835551234|||2712-111-3333",
        "NonMatchingText": "347/123/2345|||347 888 8921|||123456789012",
        "Description": "Matches a South African landline or cellphone number. Can use dashes or spaces. Can be prefexed with +27 or 27 or 0. With support for extensions."
    },
    {
        "Pattern": "^(?P<From>(JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|JULY|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER|[ ]|,|/|[0-9])+)(-|\u2013|:|TO)?(?P<To>(JANUARY|FEBRUARY|MARCH|APRIL|MAY|JUNE|JULY|AUGUST|SEPTEMBER|OCTOBER|NOVEMBER|DECEMBER|[ ]|,|/|[0-9]|PRESENT)+)+(:)*",
        "MatchingText": "JANUARY 2000|||19-01-2000|||12/11/2000",
        "NonMatchingText": "\"Hello it is ordinary text\"|||\"non -date text\"",
        "Description": "This regular expression will match date given in any format expcept (mmm). Its speciality is that it divides dates into &lt;from&gt; part and &lt;to&gt; part. Use Groups to access these parts.\ne.g.  JANUARY 1998 TO JUNE 2000\n&lt;From&gt;=&quot;JANUARY 1998&quot;\n&lt;to&gt;=&quot;JUNE 2000&quot;\n"
    },
    {
        "Pattern": "[\\s0-9a-zA-Z\\;\\\"\\,\\<\\>\\\\?\\+\\=\\)\\(\\\\*\\&\\%\\\\$\\#\\.]*",
        "MatchingText": "any between given two words",
        "NonMatchingText": "not check for new line ...etc .i think it work...",
        "Description": "[\\s0-9a-zA-Z\\;\\\"\\,]* match any text just add character or symbol to be matched  inside[ ] like [\\<] for  (<) symbol. if u want find between two word then just use  Eg : <div>[\\s0-9a-zA-Z\\;\\\"\\,]* </div> it will return the  content between <div> tags. Just add all  format  to match all .It is better than (.*) because (.*) is difficult to end at particular part  as we needed."
    },
    {
        "Pattern": "^((f|ht)tp(s)?)\\://([a-zA-Z0-9\\-]+\\.)*[a-zA-Z0-9\\-]+\\.[a-zA-Z]{2,6}((/|\\?)[a-zA-Z0-9\\.\\?=/#%&\\+-]+|/|)$",
        "MatchingText": "http://foo.com http://www.foo.bar.com https://foo.com?id=123",
        "NonMatchingText": "http://foo http://foo..bar",
        "Description": "Pattern test for general validity of a Url.  It is a little stricter than many others here, as I found they often passed obviously invalid strings like 'http://foo', but is still fairly concise."
    },
    {
        "Pattern": "^\\s*-?(\\d{0,7}|10[0-5]\\d{0,5}|106[0-6]\\d{0,4}|1067[0-4]\\d{0,3}|10675[0-1]\\d{0,2}|((\\d{0,7}|10[0-5]\\d{0,5}|106[0-6]\\d{0,4}|1067[0-4]\\d{0,3}|10675[0-1]\\d{0,2})\\.)?([0-1]?[0-9]|2[0-3]):[0-5]?[0-9](:[0-5]?[0-9](\\.\\d{1,7})?)?)\\s*$",
        "MatchingText": "00:00:15|||23:59:59|||23:59:59.9999999|||-00:00:00|||365|||-365|||7.00:00:00.0000000|||5:5:5|||10:10|||21:15|||19:1|||00:10|||0|||10675199.23:59:59.9999999|||-10675199.23:59:59.9999999|||10599999|||10669999|||10674999|||10675099",
        "NonMatchingText": "1.23:59:60|||24:00|||23:59:59.00000000|||00:00:60|||24:00:00|||25:00:00|||10675200|||10676000|||10680000|||10700000|||11000000",
        "Description": "Can be used to pre-validate strings before calling the TimeSpan.Parse() method in the .Net framework, to ensure that the string can be parsed without throwing an exception.  The regex uses capturing groups instead of non-capturing groups so that it can easily be used as a pattern in XML Schema by simply removing the ^$ from the beginning/end.\n\nThis expression fully checks or enforces the [ws][-]{d|[d.]hh:mm[:ss[.ff]] }[ws] format as described in the MSDN help.  It even checks the upper/lower boundaries on day values (10675199 days.)"
    },
    {
        "Pattern": "^[\\s]*(?:(Public|Private)[\\s]+(?:[_][\\s]*[\\n\\r]+)?)?(Function|Sub)[\\s]+(?:[_][\\s]*[\\n\\r]+)?([a-zA-Z][\\w]{0,254})(?:[\\s\\n\\r_]*\\((?:[\\s\\n\\r_]*([a-zA-Z][\\w]{0,254})[,]?[\\s]*)*\\))?",
        "MatchingText": "Sub Test()|||Public Sub Test(arg1, arg2)|||Public Sub _\\r\\nTest(arg1, arg2)",
        "NonMatchingText": "\"Function test()\"|||Sub 0815()|||Sub_Test()|||Sub Test(0815)",
        "Description": "Matches any VBScript method declaration (= no \"As [datatype]\" support), supports line wraps, only matches valid argument/method names, Public/Private and arguments are optional.\n\nFirst regex, please comment ;)"
    },
    {
        "Pattern": "^(N[BLSTU]|[AMN]B|[BQ]C|ON|PE|SK)$",
        "MatchingText": "ON|||PE|||NB",
        "NonMatchingText": "OB|||NM",
        "Description": "Matches Canadian provincial codes. Similar to the one already posted but smaller, faster, and will correctly return the results in one match group rather than using several so it's much friendlier."
    },
    {
        "Pattern": "(?:@[A-Z]\\w*\\s+)*(?:(?:public|private|protected)\\s+)?(?:(?:(?:abstract|final|native|transient|static|synchronized)\\s+)*(?:<(?:\\?|[A-Z]\\w*)(?:\\s+(?:extends|super)\\s+[A-Z]\\w*)?(?:(?:,\\s*(?:\\?|[A-Z]\\w*))(?:\\s+(?:extends|super)\\s+[A-Z]\\w*)?)*>\\s+)?(?:(?:(?:[A-Z]\\w*(?:<[A-Z]\\w*>)?|int|float|double|char|byte|long|short|boolean)(?:(?:\\[\\]))*)|void)+)\\s+(([a-zA-Z]\\w*)\\s*\\(\\s*(((?:[A-Z]\\w*(?:<(?:\\?|[A-Z]\\w*)(?:\\s+(?:extends|super)\\s+[A-Z]\\w*)?(?:(?:,\\s*(?:\\?|[A-Z]\\w*))(?:\\s+(?:extends|super)\\s+[A-Z]\\w*)?)*>)?|int|float|double|char|boolean|byte|long|short)(?:(?:\\[\\])|\\.\\.\\.)?\\s+[a-z]\\w*)(?:,\\s*((?:[A-Z]\\w*(?:<[A-Z]\\w*>)?|int|float|double|char|byte|long|short|boolean)(?:(?:\\[\\])|\\.\\.\\.)?\\s+[a-z]\\w*))*)?\\s*\\))",
        "MatchingText": "public static void main(String... args)",
        "NonMatchingText": "public static void Main(string... args)",
        "Description": "\\1 references the method signature (eg main(String[] args)), \\2 references the method name (eg main), \\3 references the args (eg String[] args), and \\4 and up reference each arg in turn (including type names). Supports @interfaces, java keywords/primitives, generic classes (including bounded and unbounded parameters), varargs, and array classes, but due to recursion limitations, generic types can only go one level deep (List<String> is ok, but List<List<String>> isn't).\n\nDoes not match Constructors."
    },
    {
        "Pattern": "^(([0]?[1-9]|1[0-2])(:)([0-5][0-9]))$",
        "MatchingText": "09:00|||9:00|||11:35",
        "NonMatchingText": "13:00|||9.00|||6:60",
        "Description": "This time validation expression accepts an hour between 1 and 9 (with optional leading zero) and minutes between 01 and 59.  This is primarily for use with an AM/PM drop down list or radio button."
    },
    {
        "Pattern": "^[+][0-9]\\d{2}-\\d{3}-\\d{4}$",
        "MatchingText": "+974-584-5656|||+000-000-0000|||+323-343-3453",
        "NonMatchingText": "974-584-5656|||+974 000 0000",
        "Description": "This is a basic telephone number vaildation which needs a compulsory prefix of a '+' sign with three digits and followed by a hipen, another three digits and finally followed by another hipen and four more digits. \nRegards,\nSenthil Gunabalan"
    },
    {
        "Pattern": "^((((0?[13578])|(1[02]))[\\/|\\-]?((0?[1-9]|[0-2][0-9])|(3[01])))|(((0?[469])|(11))[\\/|\\-]?((0?[1-9]|[0-2][0-9])|(30)))|(0?[2][\\/\\-]?(0?[1-9]|[0-2][0-9])))[\\/\\-]?\\d{2,4}$",
        "MatchingText": "1-31-02|||2-29-04|||08/1/2004",
        "NonMatchingText": "2-30-04|||6/31/04|||13-11-2004",
        "Description": "After looking for a date regular expression, I could not find one that meet my need, so I develop one that handles 1 or 2 digets in the month and day and also handle feb up to 29.  This will allow both / and - for separators, which is what I needed.  I hope this helps others too.  Thanks,\n\nCliff Schneide"
    },
    {
        "Pattern": "^([0-9]|[1-9][0-9]|[1-9][0-9][0-9])$",
        "MatchingText": "0,152,356,999",
        "NonMatchingText": "-0,12553,-56",
        "Description": "Matching 3 Digits Number :0..999: ^([0-9]|[1-9][0-9]|[1-9][0-9][0-9])$\n0 to 999"
    },
    {
        "Pattern": "^(1[0-2]|0?[1-9]):([0-5]?[0-9])( AM| PM)$",
        "MatchingText": "12:45 AM|2:30 PM",
        "NonMatchingText": "12:45AM|2:30PM",
        "Description": "You want to validate times in various traditional time formats, such as hh:mm tt 12-hour formats."
    },
    {
        "Pattern": "[a-zA-Z \u00C1-\u00DA\u00E1-\u00FA][^1234567890]+$",
        "MatchingText": "Fernando | Mart\u00EDnez | Ni\u00F1o",
        "NonMatchingText": "Luara123",
        "Description": "Mapea los nombres. Cualquier caracter, incluyendo la \u00F1 exeptuando los n\u00FAmeros."
    },
    {
        "Pattern": "^((l((ll)|(b)|(bb)|(bbb)))|(bb*))$",
        "MatchingText": "lll|||lb|||bbb",
        "NonMatchingText": "bbbl|||bbblll|||lbbbb",
        "Description": "Regular expression to recognise messages formed with &quot;beeps&quot; of IBM mainboards, when the computer makes the Power On Self Test. &quot;b&quot; means &quot;short beep&quot;, and &quot;l&quot; means &quot;long beep&quot;."
    },
    {
        "Pattern": "^([1-9]([0-9])?)(\\.(([0])?|([1-9])?|[1]([0-1])?)?)?$",
        "MatchingText": "1.0, 1.1 ..  1.11  ... 99.0, 99.1, 99.2, ... 99.11",
        "NonMatchingText": " 0, 0.0. 0.11, 99.12, 1.12, 100, 100.11",
        "Description": "Expression to match decimal number with 2 digits."
    },
    {
        "Pattern": "\\b[A-Z0-9]{5}\\d{1}[01567]\\d{1}([0][1-9]|[12][0-9]|[3][0-1])\\d{1}[A-Z0-9]{3}[A-Z]{2}\\b",
        "MatchingText": "SASAS701062AB8DD ASD12405315AA4AA ABCDE101010XY9AA",
        "NonMatchingText": "SASAS701062AB8D ASD12405315AA4A ABCDE101010XY9A ABD2A121010AM9FA ABCDE101010XY9A9 AbCdE711215GG9aa AFG98101010AM9Fa SSSSS841215SS9SS AFG98101000AM9FA AF\u00AC98101010AM9FA  ABC99808275m99sc  ABC99808275m99sca ABC99808275m99scsd ABCDE654321A98",
        "Description": "Matches the UK Drivers License format: \ni. Must be 16 characters \nii. First 5 characters are alphanumeric. \niii. Next 6 characters must be numeric \niv. Next 3 characters are alphanumeric \nv. Last 2 characters are alpha \nvi. Second character of numeric section can only be 0, 1, 5 or 6. 7. \n\tFourth and fifth characters of numeric section must be in the range 01 to 31."
    },
    {
        "Pattern": "^[9]9\\d{10}|^[5]\\d{10}",
        "MatchingText": "991234567890|||51234567890",
        "NonMatchingText": "99123456789|||91234567890",
        "Description": "This will make sure that if your number starts w. a 99 it will have 10 more digits after it and if it starts w. a 5 it will also have 10 digits after that. So if you have a number starting with 99 it must be 12 digits long if it starts with a 5 it must be 11."
    },
    {
        "Pattern": "/^(application|audio|example|image|message|model|multipart|text|video)\\/[a-zA-Z0-9]+([+.-][a-zA-z0-9]+)*$/",
        "MatchingText": "application/mpeg4-generic|||image/png|||video/my-video+format",
        "NonMatchingText": "x-world/x-3dmf|||text-javascript|||text/richtext rtx",
        "Description": "Checks for properly formatted Mime-Types. Checks that the Content-Type (before the '/') is one registered with IANA. No spaces allowed.\n"
    },
    {
        "Pattern": "(pwd|password)\\s*=\\s*(?P<pwd>('(([^'])|(''))+'|[^';]+))",
        "MatchingText": "server=(local);password='O''Brian';",
        "NonMatchingText": "invalid connection strings",
        "Description": "This pattern matches the password from a SQL Server connection string."
    },
    {
        "Pattern": "^((\\d{1,2})?([.][\\d]{1,2})?){1}[%]{1}$",
        "MatchingText": "99.99%|||9%|||.09%",
        "NonMatchingText": "99|||9.%",
        "Description": "for checking a value is between 99.99% and 00.00%"
    },
    {
        "Pattern": "^((0?[1-9]|1[012])(:[0-5]\\d){1,2}(\\ [AaPp][Mm]))$",
        "MatchingText": "1:45 am|||12:01 aM|||01:23 pm",
        "NonMatchingText": "13:34 am|||1:60 am|||13:45",
        "Description": "This is a simple expression used to match a normal 12 hour clock, requires AM/PM in any or mixed case and requires a space before the AM or PM and minutes are required."
    },
    {
        "Pattern": "(([2-9]{1})([0-9]{2})([0-9]{3})([0-9]{4}))$",
        "MatchingText": "2125551212 ||| 7875559090 ||| 4043005555",
        "NonMatchingText": "18011212345 ||| (801)555-1212 ||| 800-555-1212",
        "Description": "Basic expression to validate a 10 digit number. Does not allow for any delimiters between numbers. Specifies that numbers cannot start with a one."
    },
    {
        "Pattern": "^([A-Z]{1,2}[0-9]{1,2}|[A-Z]{3}|[A-Z]{1,2}[0-9][A-Z])( |-)[0-9][A-Z]{2}",
        "MatchingText": "AA11 1AA|||AA1A 1AA|||A11-1AA",
        "NonMatchingText": "111 AAA|||1AAA 1AA|||A1AA 1AA",
        "Description": "Checks whether the string specified is in the same format as the UK postcode format defined on:\nhttp://www.magma.ca/~djcl/postcd.txt\nIt allows:\nA = Letter\nN = Number\nAN NAA, ANA NAA, ANN NAA, AAN NAA, AAA NAA (rare), AANN NAA, AANA NAA\nIt gives the option to have the two parts of the uk postcode to be separated by a space or a hyphen.\n(restriction is set to all-capitals)"
    },
    {
        "Pattern": "((^([\\d]{1,3})(,{1}([\\d]{3}))*)|(^[\\d]*))((\\.{1}[\\d]{2})?$)",
        "MatchingText": "456161|||45622.22|||123,234,.22|||889,456",
        "NonMatchingText": "123,22|||123.221|||1,2,3|||123,21.2",
        "Description": "This re matches numbers with our without commas and with or without exactly two decimal places."
    },
    {
        "Pattern": "(?:(?:(?:04|06|09|11)\\/(?:(?:[012][0-9])|30))|(?:(?:(?:0[135789])|(?:1[02]))\\/(?:(?:[012][0-9])|30|31))|(?:02\\/(?:[012][0-9])))\\/(?:19|20|21)[0-9][0-9]",
        "MatchingText": "02/21/1972|||12/31/2199|||09/04/1901",
        "NonMatchingText": "02/31/1999|||02-21-1972|||06/31/2001",
        "Description": "Matches dates in mm/dd/yyyy format. Matches only valid dates -except is unable to test for a leapyear. Always allows February 29th. Allows years from 1901 to 2199."
    },
    {
        "Pattern": "-?[0-9]{4}-(((0(1|3|5|7|8)|1(0|2))-(0[1-9]|(1|2)[0-9]|3[0-1]))|((0(4|6|9)|11)-(0[1-9]|(1|2)[0-9]|30))|(02-(0[1-9]|(1|2)[0-9])))T([0-1][0-9]|2[0-4]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\\.[0-999])?((\\+|-)([0-1][0-9]|2[0-4]):(0[0-9]|[1-5][0-9])|Z)?",
        "MatchingText": "2012-01-31T10:00:00Z|||2012-02-28T10:00:00Z|||2012-02-29T10:00:00Z",
        "NonMatchingText": "2012-02-30T10:00:00Z|||2012-01-32T10:00:00Z|||2012-04-31T10:00:00Z",
        "Description": "Matches xs:dateTime values described in XML Schema 1.0. Handles correct days in each month.\nhttp://www.w3.org/TR/xmlschema-2/#dateTime"
    },
    {
        "Pattern": "-?[0-9]{4}-(((0(1|3|5|7|8)|1(0|2))-(0[1-9]|(1|2)[0-9]|3[0-1]))|((0(4|6|9)|11)-(0[1-9]|(1|2)[0-9]|30))|(02-(0[1-9]|(1|2)[0-9])))((\\+|-)([0-1][0-9]|2[0-4]):(0[0-9]|[1-5][0-9])|Z)?",
        "MatchingText": "2012-01-3Z|||2012-02-28+01:00|||2012-02-29-01:00",
        "NonMatchingText": "2012-02-30T10:00:00Z|||2012-01-32T10:00:00Z|||2012-04-31T10:00:00Z",
        "Description": "Matches xs:date values described in XML Schema 1.0. Handles correct days in each month. http://www.w3.org/TR/xmlschema-2/#date"
    },
    {
        "Pattern": "([0-1][0-9]|2[0-4]):(0[0-9]|[1-5][0-9]):(0[0-9]|[1-5][0-9])(\\.[0-999])?((\\+|-)([0-1][0-9]|2[0-4]):(0[0-9]|[1-5][0-9])|Z)?",
        "MatchingText": "10:00:00Z|||23:59:59.100+01:00|||10:00:00-01:00",
        "NonMatchingText": "25:00:00Z|||23:60:60.100+01:00|||10:00:00-25:00",
        "Description": "Matches xs:time values described in XML Schema 1.0. Handles correct days in each month. http://www.w3.org/TR/xmlschema-2/#time"
    },
    {
        "Pattern": "(((0[1-9]|(1|2)[0-9]|3[0-1])\\/(0(1|3|5|7|8)|1(0|2)))|((0[1-9]|(1|2)[0-9]|30)\\/(0(4|6|9)|11))|((0[1-9]|(1|2)[0-9])\\/02))\\/[0-9]{4}",
        "MatchingText": "01/01/2013|||30/04/2013|||29/01/2013",
        "NonMatchingText": "32/01/2013|||31/04/2013|||30/02/2013",
        "Description": "UK Date Format, using '/' as the separator character.\nHandles correct days in each month."
    },
    {
        "Pattern": "[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}",
        "MatchingText": "e9257dd5-d221-4293-88c3-93f7d3fada4f|||dd536276-4483-4c83-9901-2463f78c81cc|||b0a59123-bf86-4047-9760-8c968c6b52d7",
        "NonMatchingText": "e9257dd5-d221-1293-88c3-93f7d3fada4f|||dd536276-4483-4c83-7901-2463f78c81cc|||b0a59123-bf86-2047-9760-5c968c6b52d7",
        "Description": "Matches a Version 4 UUID as described here http://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_.28random.29"
    },
    {
        "Pattern": "[a-f0-9]{8}-[a-f0-9]{4}-3[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}",
        "MatchingText": "e9257dd5-d221-3293-88c3-93f7d3fada4f|||dd536276-4483-3c83-9901-2463f78c81cc|||b0a59123-bf86-3047-9760-8c968c6b52d7",
        "NonMatchingText": "e9257dd5-d221-4293-88c3-93f7d3fada4f|||dd536276-4483-4c83-9901-2463f78c81cc|||b0a59123-bf86-4047-9760-8c968c6b52d7",
        "Description": "Matches a Version 3 UUID as described here http://en.wikipedia.org/wiki/Uuid#Version_3_.28MD5_hash.29"
    },
    {
        "Pattern": "&quot;([^&quot;](?:\\\\.|[^\\\\&quot;]*)*)&quot;",
        "MatchingText": "&quot;This is a \\&quot;string\\&quot;.&quot;",
        "NonMatchingText": "&quot;This is a \\&quot;string\\&quot;.",
        "Description": "Matches C style strings allowing for escaped string delimiters to be included in the match.\n\nALTERED 13-Dec-2003\n-------------------\n\nPrevious pattern was : \n    &quot;([^&quot;](?:\\\\.|[^\\\\&quot;]*)*)&quot;\n\nChanged to: \n    &quot;([^&quot;]*(?:\\\\.|[^\\\\&quot;]*)*)&quot;\n\nMaking the first character after the opening quote optional allows the pattern to match on empty quotes: &quot;&quot;."
    },
    {
        "Pattern": "(\\w[-._\\w]*\\w@\\w[-._\\w]*\\w\\.\\w{2,3})",
        "MatchingText": "foo@bar.com|||foobar@foobar.com.au",
        "NonMatchingText": "foo@bar|||$$$@bar.com",
        "Description": "This is my all-time favourite e-mail validator.  I've used it for years and it's never failed me :-)"
    },
    {
        "Pattern": "^(\n    100(?:\\.0{1,2})?\n    |\n    0*?\\.\\d{1,2}\n    |\n    \\d{1,2}(?:\\.\\d{1,2})?\n)%\n$",
        "MatchingText": "0%|||100%|||.17%",
        "NonMatchingText": "101%|||-17|||99.006%",
        "Description": "Matches a percentage between 0 and 100 (inclusive).  Accepts up to 2 decimal places."
    },
    {
        "Pattern": "^(\\d+|[a-zA-Z]+)$",
        "MatchingText": "aaaaadddaaaaa|||1166633337",
        "NonMatchingText": "1n|||ppppp99",
        "Description": "Tests for all numbers OR all letters (upper or lower case)\n\n( posted from WebService - http://regexlib.com/webservices.asmx?op=Save )\n( updated from WebService - http://regexlib.com/webservices.asmx?op=Save )"
    },
    {
        "Pattern": "^(?P<BeforeLastCapital>([^\\s]*))(?P<LastCapital>[A-Z])(?P<AfterLastCapital>([^A-Z])*)$   #Last Capital",
        "MatchingText": "${BeforeLastCapital}",
        "NonMatchingText": "no match",
        "Description": "Gets all text before the last capital (no whitespace allowed)."
    },
    {
        "Pattern": "^(?:(?:(?:(?:[1-2][0-9]{3}) *(?:[\\/\\-\\., ]) *(?:1[0-2]|0?[1-9]) *(?:[\\/\\-\\., ]) *(?:[12][0-9]|3[01]|0?[1-9]))|(?:(?:1[0-2]|0?[1-9]) *(?:[\\/\\-\\., ]) *(?:[12][0-9]|3[01]|0?[1-9]) *(?:[\\/\\-\\., ]) *(?:(?:[0-9]{1,2})|(?:[1-2][0-9]{3})))|(?:(?:[12][0-9]|3[01]|0?[1-9]) *(?:[\\/\\-\\., ]) *(?:1[0-2]|0?[1-9]) *(?:[\\/\\-\\., ]) *(?:(?:[0-9]{1,2})|(?:[1-2][0-9]{3})))|(?:(?:(?i:(?:j(?:an(?:uary)?|u(?:ne?|ly?)))|a(?:pr(?:il)?|ug(?:ust)?)|ma(?:y|r(?:ch)?)|(?:nov|dec)(?:ember)?|feb(?:ruary)?|sep(?:tember)?|oct(?:ober)?)) *(?:[\\/\\-\\., ]) *(?:(?:[12][0-9]|3[01]|0?[1-9])|(?:(?i:[23]?1st|2?2nd|2?3rd|[4-9]th|1[0-9]th|20th|2[4-9]th|30th))) *(?:[\\/\\-\\., ]) *(?:(?:[0-9]{1,2})|(?:[1-2][0-9]{3})))|(?:(?:(?:[12][0-9]|3[01]|0?[1-9])|(?:(?i:[23]?1st|2?2nd|2?3rd|[4-9]th|1[0-9]th|20th|2[4-9]th|30th))) *(?:[\\/\\-\\., ]) *(?:(?i:(?:j(?:an(?:uary)?|u(?:ne?|ly?)))|a(?:pr(?:il)?|ug(?:ust)?)|ma(?:y|r(?:ch)?)|(?:nov|dec)(?:ember)?|feb(?:ruary)?|sep(?:tember)?|oct(?:ober)?)) *(?:[\\/\\-\\., ]) *(?:(?:[0-9]{1,2})|(?:[1-2][0-9]{3}))))|(?:(?:(?:(?:[1-2][0-9]{3}) *(?:[\\/\\-\\., ]) *(?:1[0-2]|0?[1-9]) *(?:[\\/\\-\\., ]) *(?:[12][0-9]|3[01]|0?[1-9]))|(?:(?:1[0-2]|0?[1-9]) *(?:[\\/\\-\\., ]) *(?:[12][0-9]|3[01]|0?[1-9]) *(?:[\\/\\-\\., ]) *(?:(?:[0-9]{1,2})|(?:[1-2][0-9]{3})))|(?:(?:[12][0-9]|3[01]|0?[1-9]) *(?:[\\/\\-\\., ]) *(?:1[0-2]|0?[1-9]) *(?:[\\/\\-\\., ]) *(?:(?:[0-9]{1,2})|(?:[1-2][0-9]{3})))|(?:(?:(?i:(?:j(?:an(?:uary)?|u(?:ne?|ly?)))|a(?:pr(?:il)?|ug(?:ust)?)|ma(?:y|r(?:ch)?)|(?:nov|dec)(?:ember)?|feb(?:ruary)?|sep(?:tember)?|oct(?:ober)?)) *(?:[\\/\\-\\., ]) *(?:(?:[12][0-9]|3[01]|0?[1-9])|(?:(?i:[23]?1st|2?2nd|2?3rd|[4-9]th|1[0-9]th|20th|2[4-9]th|30th))) *(?:[\\/\\-\\., ]) *(?:(?:[0-9]{1,2})|(?:[1-2][0-9]{3})))|(?:(?:(?:[12][0-9]|3[01]|0?[1-9])|(?:(?i:[23]?1st|2?2nd|2?3rd|[4-9]th|1[0-9]th|20th|2[4-9]th|30th))) *(?:[\\/\\-\\., ]) *(?:(?i:(?:j(?:an(?:uary)?|u(?:ne?|ly?)))|a(?:pr(?:il)?|ug(?:ust)?)|ma(?:y|r(?:ch)?)|(?:nov|dec)(?:ember)?|feb(?:ruary)?|sep(?:tember)?|oct(?:ober)?)) *(?:[\\/\\-\\., ]) *(?:(?:[0-9]{1,2})|(?:[1-2][0-9]{3})))) *(?:(?:(?:1[0-2]|0?[1-9])(?: *(?:\\:) *(?:[1-5][0-9]|0?[0-9]))?(?: *(?:\\:) *(?:[1-5][0-9]|0?[0-9]))? *(?:(?i:[ap]m)))|(?:(?:2[0-3]|[01]?[0-9])(?: *(?:\\:) *(?:[1-5][0-9]|0?[0-9]))(?: *(?:\\:) *(?:[1-5][0-9]|0?[0-9]))?))))$",
        "MatchingText": "1999-12-31 5:30 pm || 1-1-1999 22:30:25 || 01/01/99 || Feb    .01.99 || Feb 1, 99 || 01 feb 1999 || Jan 1st 99",
        "NonMatchingText": "13/31/99 || 12/32/99 || 1999-31-12 || 1st of Jan 1999 || first of jan 1999",
        "Description": "Updated: 5-15-2007 @ 2:30pm --- \n\nThis expression matches all kinds of possible date or timestamp formats.\n\nNo it dose not validate for leap years or months where the 31st day is not valid.\n\nI use it in my code so I can let my site users format a date in any way they please. I am basing it loosely on ISO, US and European standards found.\n\nThe reason why it works for me is that I use it along with some code I made that extracts the year, month, day, hour, minute and seconds from the string and use it to create a valid date in my code. This is why I don't care about leap year/Feb rules since, once I got the date parts I can validate for these variations within the language I'm using very easily without making my expression 10,000 chars long. Although that would be an awesome thing to see and if anybody can make it as flexible as this one is and check for leap/Feb rules I would love to see it. I did not want to add anything to my UI to educate my user on how I expect them to format it.\n\nThe expression assumes that the date is ISO then US and last European standard. This may not be good for some people but for me I think that if it is not a US date but it\u2019s a valid European date than Ill just take it since where I use this code is not that critical. I just want flexibility and ease of use for my users. Oh, and I really did not think of performance hit due to the length of the pattern. I ran it. It worked fast for me.\n\nIt\u2019s only for a small text string. I tested it in PHP and The Regex Coach (The coach was in pain afterward, hee hee). I hope I brake a record with this bad boy. This is the longest expression I have ever seen! Its 2,214 chars long, WOO HOO!"
    },
    {
        "Pattern": "(?i:(?:j(?:an(?:uary)?|u(?:ne?|ly?)))|a(?:pr(?:il)?|ug(?:ust)?)|ma(?:y|r(?:ch)?)|(?:nov|dec)(?:ember)?|feb(?:ruary)?|sep(?:tember)?|oct(?:ober)?)",
        "MatchingText": "sep || Sep || september",
        "NonMatchingText": "sept || sep.",
        "Description": "Matches month Full names and Abbreviations. If you can find anyway to optimize its performance, please do so and add a comment with it."
    },
    {
        "Pattern": "(?i:t(?:ue(?:sday)?|hu(?:rsday)?))|s(?:un(?:day)?|at(?:urday)?)|(?:wed(?:nesday)?|(?:mon|fri)(?:day)?)",
        "MatchingText": "tue || Tue || tuesday",
        "NonMatchingText": "tues || tue.",
        "Description": "Matches week Full names and Abbreviations. If you can find anyway to optimize its performance, please do so and add a comment with it."
    },
    {
        "Pattern": "(([\\w|\\.]*)\\s*={1}\\s*(.*?))$",
        "MatchingText": "view = View | view.list = List View",
        "NonMatchingText": "!#view = View | $\u00BDview.list = List View",
        "Description": "This pattern can parse the name and value."
    },
    {
        "Pattern": "^(?i)([\u00C0-\u00FFa-z\\-]{2,})\\x20([\u00C0-\u00FFa-z\\-']{2,})(?-i)",
        "MatchingText": "Thayn\u00E3 Sant'Anna ||| Bruno Moretti",
        "NonMatchingText": "Thayn\u00E3 C. ||| T. Moretti",
        "Description": "Validate full names (w/ accents). A first/last name needed, at least, 2 letters. See examples."
    },
    {
        "Pattern": "^([0-1][0-9]|[2][0-3]|[0-9]):([0-5][0-9])(?::([0-5][0-9]))?$",
        "MatchingText": "09:05 ||| 10:00 ||| 1:15 ||| 00:59:00 ||| 23:01:59",
        "NonMatchingText": "9:5 ||| 09:1 ||| 0:1 ||| 0:00:0 ||| 1:1:11",
        "Description": "Validate hours with seconds returning mirrors correctly."
    },
    {
        "Pattern": "^([0-2]\\d|3[0-1]|[1-9])\\/(0\\d|1[0-2]|[1-9])\\/(\\d{4})$",
        "MatchingText": "1/05/1990 ||| 01/1/2006 ||| 01/01/2008 ||| 5/5/2009 ||| 1/1/1990 ||| 29/05/2009",
        "NonMatchingText": "01/01/90 ||| 32/02/2009 ||| 1/13/1990 ||| 0/0/2009",
        "Description": "Validate a date format: d/m/Y. \nSee examples."
    },
    {
        "Pattern": "=(?m)^(LogName=(Security).*)\\n(SourceName=.*)\\n(EventCode=.*)\\n(EventType=.*)\\n(Type=(Success Audit|Information).*)\\n(ComputerName=(HOSTNAME1|HOSTNAME2|HOSTNAME3).*)\\n",
        "MatchingText": "01/30/13 04:02:41 PMLogName=SecuritySourceName=SecurityEventCode=529EventType=16Type=InformationComputerName=HOSTNAME1User=SYSTEMSid=S-1-5-18SidType=1|||01/30/13 04:02:41 PMLogName=SecuritySourceName=SecurityEventCode=529EventType=16Type=Success AuditComputerName=HOSTNAME1User=SYSTEMSid=S-1-5-18SidType=1||| 01/30/13 04:02:41 PMLogName=SecuritySourceName=SecurityEventCode=529EventType=16Type=InformationComputerName=HOSTNAME3.domain.comUser=SYSTEMSid=S-1-5-18SidType=1",
        "NonMatchingText": "01/30/13 04:02:41 PMLogName=SecuritySourceName=SecurityEventCode=529EventType=16Type=Failure AuditComputerName=HOSTNAME1User=SYSTEMSid=S-1-5-18SidType=1|||01/30/13 04:02:41 PMLogName=SecuritySourceName=SecurityEventCode=529EventType=16Type=InformationComputerName=HOSTNAME6User=SYSTEMSid=S-1-5-18SidType=1|||01/30/13 04:02:41 PMLogName=SecuritySourceName=SecurityEventCode=529EventType=16Type=Success AuditComputerName=HOSTNAME3User=SYSTEMSid=S-1-5-18SidType=1",
        "Description": "RE used by Splunk Forwarder in transforms.conf to select Win Security events from specified list of hostnames. Please note that matching examples do not show newlines between each name=value pair. These newlines are present in the RE input data and so are included in the RE as \\n"
    },
    {
        "Pattern": "^(^[0-9]*(^[0-9]*[\\.][0-9]+){0,1}$)",
        "MatchingText": "0.1 .1 988.089143",
        "NonMatchingText": "a1 32.a 32.",
        "Description": "Match numbers with or without a number before a decimal. If there is a decimal there must be a number after it though"
    },
    {
        "Pattern": "('.*$|Rem((\\t| ).*$|$)|&quot;(.|&quot;&quot;)*?&quot;)",
        "MatchingText": "' This is a comment|||Rem This is a comment|||&quot; This is a string with &quot;&quot; and ' &quot;",
        "NonMatchingText": "&quot; This is not a string|||RemThis is not a comment|||This is not a comment or a string",
        "Description": "Pulls out comments (both Rem and ') and string literals from VB or VBScript. Usefull for spell checking or review.\n\nNotes: The VBScript for &quot;Rem&quot; documentation says that it must be followed by a space but VBScript seems to accept tab characters as well.\n\nThe multiline flag is assumed for this search."
    },
    {
        "Pattern": "^(?:((?P<prov>(?:[1-9]|10))(?P<av>AV)?)|((?P<tipo>(?:E|N|PE))+))-(?P<tomo>\\d{1,4})-(?P<folio>\\d{1,5})",
        "MatchingText": "4-733-740, 10-45-748, 10AV-45-45, PE-465-4598, E-864-5464",
        "NonMatchingText": "X-465-546, 4 - 754 - 6564, 9PE-465-321",
        "Description": "RegEx to match all panamenian identification numbers, including special cases as AV (people born before the actual cedula system), PE (panamanian born abroad), E (foreigner) and N (naturalized).\n\nThe format of the cedula is:\n**[province code]-[tomo]-[folio]**\n\nAnd the format for special cases:\n**AV: [province code]AV-[tomo]-[folio] \n**PE: PE-[tomo]-[folio] \n**E: E-[tomo]-[folio] \n**N: N-[tomo]-[folio] \n\n**\nprovince code: 1-10\ntomo: 1-9999\nfolio: 1-99999"
    },
    {
        "Pattern": "^([1-9]|[1-9]\\d|100)$",
        "MatchingText": "1|||50|||100",
        "NonMatchingText": "0|||.5|||101",
        "Description": "This pattern matches whole numbers 1-100. "
    },
    {
        "Pattern": "^(X(-|\\.)?0?\\d{7}(-|\\.)?[A-Z]|[A-Z](-|\\.)?\\d{7}(-|\\.)?[0-9A-Z]|\\d{8}(-|\\.)?[A-Z])$",
        "MatchingText": "X01343567-D|||B-6116622G|||43544122-R",
        "NonMatchingText": "43.544.122-R",
        "Description": "Matches Spanish CIF, NIF and NIE formats. Recognises separation of letters with the hyphen or period.\n\nFormat CIF: [1 letter][7 numbers][1 number or letter]\nFormat NIF: [8 numbers][1 letter]\nFormat NIE: X[possible 0][7 numbers][1 letter]\n\nNote that this expression does not check for the validity of the NIF/CIF/NIE... there are some control characters in there and I don't know how they work.\n\nGenerally I always strip out any non-alphanumeric characters (hyphens, periods, etc.) and convert to upper case before checking validity and before saving to data storage.\n\nPlease post improvements or errors if you find them!"
    },
    {
        "Pattern": "^(.){0,20}$",
        "MatchingText": "I match|||I match 2",
        "NonMatchingText": "hey I don't match at all",
        "Description": "This limits an HTML textarea to only be 20 characters.  Built for an ASP:regularexpression tag to validate a textarea."
    },
    {
        "Pattern": "\\s(type|name|value)=(?:(\\w+)|(?:&quot;(.*?)&quot;)|(?:\\'(.*)\\'))",
        "MatchingText": "&lt;input type=&quot;text&quot; value='somevalue' name=fred&gt;",
        "NonMatchingText": "Any attributes that aren't &quot;type&quot;, &quot;name&quot;, or &quot;value&quot;",
        "Description": "Returns the three most important attributes from an HTML &lt;input&gt; tag: 'type', 'name' and 'value'. Supports attribute values that are double- or single-quoted or unquoted. Returns four references, the first being the name of the attribute, and the other three being the value, of which only one will be populated based on the way the value was quoted."
    },
    {
        "Pattern": "^[^\\\\\\./:\\*\\?\\\"<>\\|]{1}[^\\\\/:\\*\\?\\\"<>\\|]{0,254}$",
        "MatchingText": "abcd.jpg|||a b239.abcd ef12983 298|||a....23498",
        "NonMatchingText": ".abcde.jpg|||abcde?.jpg|||c:\\abcde.jpg",
        "Description": "Validates a long filename using Windows' rules.  Requires one valid filename character other than &quot;.&quot; for the first character and then any number of valid filename characters up to a total length of 255 characters.  Unresolved is how to prevent the last character from being a &quot;.&quot; while still meeting all the features that this regex does now."
    },
    {
        "Pattern": "^((((0031)|(\\+31))(\\-)?6(\\-)?[0-9]{8})|(06(\\-)?[0-9]{8})|(((0031)|(\\+31))(\\-)?[1-9]{1}(([0-9](\\-)?[0-9]{7})|([0-9]{2}(\\-)?[0-9]{6})))|([0]{1}[1-9]{1}(([0-9](\\-)?[0-9]{7})|([0-9]{2}(\\-)?[0-9]{6}))))$",
        "MatchingText": "0031612345678  |  0031-6123456789  |  0031-6-123456789  |  0031-50-1234567  |  0031-592-123456  |  +31612345678  |  0612345678  |  06-12345678  |  050-1234567 | 0592-123456",
        "NonMatchingText": "+31(0)612345678  |  06123456789  |  00310612345678  |  0031-6-123-45678",
        "Description": "Check Dutch phonenumber including 0031 or +31 and optional - characters.\nI know it can be shortened, but for readability (and shortage of time ;-)) I kept it like it is..."
    },
    {
        "Pattern": "^(((0[1-9]|[12]\\d|3[01])[\\s\\.\\-\\/](0[13578]|1[02])[\\s\\.\\-\\/]((19|[2-9]\\d)\\d{2}))|((0[1-9]|[12]\\d|30)[\\s\\.\\-\\/](0[13456789]|1[012])[\\s\\.\\-\\/]((19|[2-9]\\d)\\d{2}))|((0[1-9]|1\\d|2[0-8])[\\s\\.\\-\\/]02[\\s\\.\\-\\/]((19|[2-9]\\d)\\d{2}))|(29[\\s\\.\\-\\/]02[\\s\\.\\-\\/]((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "MatchingText": "20-02-1975  |  20.02.1975  |  20/02/1975  |  20 02 1975  |  20-12/1975",
        "NonMatchingText": "20-12-1899  |  29-02-2002  |  28-2-2008",
        "Description": "Checks date in format dd-mm-yyyy. Seperation characters can be -/. and space.\ndd and mm HAVE to be two characters. Year has to be four characters and minimum 1900.\nExpression handles leap year as well"
    },
    {
        "Pattern": "^(-?)(,?)(\\d{1,3}(\\.\\d{3})*|(\\d+))(\\,\\d{2})?$",
        "MatchingText": "22.123,00 | 9.222.238,00 | 99,00|,00 | -,00 | -0,00",
        "NonMatchingText": "222.123,00. | 222.123.00 | 222.1238,00 | 222.1.238,00 | +,00 | +9.222.238,00 | +0,00 | 222,000 | 222,000.00 | 99.00 | $99,00",
        "Description": "Allow Currencies of European origin in the format of \nxx.xxx.xxx,xx"
    },
    {
        "Pattern": "^(AT){0,1}[U]{0,1}[0-9]{8}$",
        "MatchingText": "ATU12345678|||ATU98752658|||ATU98765432",
        "NonMatchingText": "ATb12345678 ||| ATu12345678|||ATU 1234567",
        "Description": "Vat number for Austria.\nFormat is\nATU12345678"
    },
    {
        "Pattern": "^(BG){0,1}([0-9]{9}|[0-9]{10})$",
        "MatchingText": "BG123456789|||BG1234567890|||BG1587963587",
        "NonMatchingText": "BG12349|||Bg1234567890|||BG1587963587989",
        "Description": "Vat number for Bulgaria. Formats are \nBG123456789\nBG1234567890\n"
    },
    {
        "Pattern": "^(([a-zA-Z]{2})([0-9]{6}))$",
        "MatchingText": "SF746208|||dc459862|||gT459685",
        "NonMatchingText": "HT5635781|||dr56842|||PN 256894",
        "Description": "[en] Every number of Identification Card in SR contains two letters (begin) and six numbers (continue). Number is without spaces.\n[sk] Ka\u017Ed\u00E9 c\u00EDslo obcianskeho preukazu v SR sa mus\u00ED zac\u00EDnat dvoma p\u00EDsmenami a pokracuje \u0161iestimi c\u00EDslicami. Toto c\u00EDslo neobsahuje medzery."
    },
    {
        "Pattern": "^(([0-9]{5})|([0-9]{3}[ ]{0,1}[0-9]{2}))$",
        "MatchingText": "960 07|||84204",
        "NonMatchingText": "96 010|||9604|||689012",
        "Description": "[en] Postal Code in Slovak Republic contains five numbers. Between 3rd and 4th number can be space. [sk] Po\u0161tov\u00E9 smerov\u00E9 c\u00EDslo v Slovenskej Republike m\u00E1 p\u00E4t c\u00EDsel. Medzi 3. a 4. c\u00EDslicou m\u00F4\u017Ee byt medzera."
    },
    {
        "Pattern": "^([0-9]{2})(01|02|03|04|05|06|07|08|09|10|11|12|51|52|53|54|55|56|57|58|59|60|61|62)(([0]{1}[1-9]{1})|([1-2]{1}[0-9]{1})|([3]{1}[0-1]{1}))/([0-9]{3,4})$",
        "MatchingText": "760612/5689|||826020/5568|||500101/256",
        "NonMatchingText": "680645/256|||707212/1258|||260015/4598",
        "Description": "Law 301/1995 z. Z. SR from 14. december 1995. PIN from 1900 to 1953 have sufix with three digits, PIN beyond 1954 have four digits in sufix. In first part of woman PIN is month of birth  (3rd & 4th digit) increase +50."
    },
    {
        "Pattern": "^(((([\\*]{1}){1})|((\\*\\/){0,1}(([0-9]{1}){1}|(([1-5]{1}){1}([0-9]{1}){1}){1}))) ((([\\*]{1}){1})|((\\*\\/){0,1}(([0-9]{1}){1}|(([1]{1}){1}([0-9]{1}){1}){1}|([2]{1}){1}([0-3]{1}){1}))) ((([\\*]{1}){1})|((\\*\\/){0,1}(([1-9]{1}){1}|(([1-2]{1}){1}([0-9]{1}){1}){1}|([3]{1}){1}([0-1]{1}){1}))) ((([\\*]{1}){1})|((\\*\\/){0,1}(([1-9]{1}){1}|(([1-2]{1}){1}([0-9]{1}){1}){1}|([3]{1}){1}([0-1]{1}){1}))|(jan|feb|mar|apr|may|jun|jul|aug|sep|okt|nov|dec)) ((([\\*]{1}){1})|((\\*\\/){0,1}(([0-7]{1}){1}))|(sun|mon|tue|wed|thu|fri|sat)))$",
        "MatchingText": "*/15 */12 30 feb 7|||10 * * * */2|||* * * * *",
        "NonMatchingText": "62 * * */2 *|||* * * 0 *|||* * * Feb *",
        "Description": "SUPPORTED constructions: \n[*] - all five commands; \n[number] - minutes 0...59, hours 0...23, day in month 1...31, months 1...12, day in week 0...7 (0 & 7 is sun);   \n[*/nubmer] - see construction [number]; \n[word] - only months (4th command) and days in week (5th command), warning this regexp is case sensitive (lower letters).\n\nNON SUPPORTED constructions:\n[number-number] and\n[number,number]."
    },
    {
        "Pattern": "^([a-hA-H]{1}[1-8]{1})$",
        "MatchingText": "A1|||a8|||b3",
        "NonMatchingText": "i5|||F9|||AA",
        "Description": "Letter (a - h) + number (1 - 8). Case insensitive."
    },
    {
        "Pattern": "^(([0]{0,1})([1-9]{1})([0-9]{2})){1}([\\ ]{0,1})((([0-9]{3})([\\ ]{0,1})([0-9]{3}))|(([0-9]{2})([\\ ]{0,1})([0-9]{2})([\\ ]{0,1})([0-9]{2})))$",
        "MatchingText": "0955 12 34 56 - 0955 123 456 - 0955 123456 - 0955123456 - 955 12 34 56 - 955 123 456 - 955 123456 - 955123456",
        "NonMatchingText": "0955 123 4567 - 0055 123 456",
        "Description": "no comment"
    },
    {
        "Pattern": "^(A(D|E|F|G|I|L|M|N|O|R|S|T|Q|U|W|X|Z)|B(A|B|D|E|F|G|H|I|J|L|M|N|O|R|S|T|V|W|Y|Z)|C(A|C|D|F|G|H|I|K|L|M|N|O|R|U|V|X|Y|Z)|D(E|J|K|M|O|Z)|E(C|E|G|H|R|S|T)|F(I|J|K|M|O|R)|G(A|B|D|E|F|G|H|I|L|M|N|P|Q|R|S|T|U|W|Y)|H(K|M|N|R|T|U)|I(D|E|Q|L|M|N|O|R|S|T)|J(E|M|O|P)|K(E|G|H|I|M|N|P|R|W|Y|Z)|L(A|B|C|I|K|R|S|T|U|V|Y)|M(A|C|D|E|F|G|H|K|L|M|N|O|Q|P|R|S|T|U|V|W|X|Y|Z)|N(A|C|E|F|G|I|L|O|P|R|U|Z)|OM|P(A|E|F|G|H|K|L|M|N|R|S|T|W|Y)|QA|R(E|O|S|U|W)|S(A|B|C|D|E|G|H|I|J|K|L|M|N|O|R|T|V|Y|Z)|T(C|D|F|G|H|J|K|L|M|N|O|R|T|V|W|Z)|U(A|G|M|S|Y|Z)|V(A|C|E|G|I|N|U)|W(F|S)|Y(E|T)|Z(A|M|W))$",
        "MatchingText": "only country code (two upper letters)",
        "NonMatchingText": "others",
        "Description": "Table: \nhttp://en.wikipedia.org/wiki/ISO_3166-1"
    },
    {
        "Pattern": "^(A(BW|FG|GO|IA|L(A|B)|N(D|T)|R(E|G|M)|SM|T(A|F|G)|U(S|T)|ZE)|B(DI|E(L|N)|FA|G(D|R)|H(R|S)|IH|L(M|R|Z)|MU|OL|R(A|B|N)|TN|VT|WA)|C(A(F|N)|CK|H(E|L|N)|IV|MR|O(D|G|K|L|M)|PV|RI|UB|XR|Y(M|P)|ZE)|D(EU|JI|MA|NK|OM|ZA)|E(CU|GY|RI|S(H|P|T)|TH)|F(IN|JI|LK|R(A|O)|SM)|G(AB|BR|EO|GY|HA|I(B|N)|LP|MB|NQ|NB|R(C|D|L)|TM|U(F|M|Y))|H(KG|MD|ND|RV|TI|UN)|I(DN|MN|ND|OT|R(L|N|Q)|S(L|R)|TA)|J(AM|EY|OR|PN)|K(AZ|EN|GZ|HM|IR|NA|OR|WT)|L(AO|B(N|R|Y)|CA|IE|KA|SO|TU|UX|VA)|M(A(C|F|R)|CO|D(A|G|V)|EX|HL|KD|L(I|T)|MR|N(E|G|P)|OZ|RT|SR|TQ|US|WI|Y(S|T))|N(AM|CL|ER|FK|GA|I(C|U)|LD|OR|PL|RU|ZL)|OMN|P(A(K|N)|CN|ER|HL|LW|NG|OL|R(I|K|T|Y)|SE|YF)|QAT|R(EU|OU|US|WA)|S(AU|DN|EN|G(P|S)|HN|JM|L(B|E|V)|MR|OM|PM|RB|TP|UR|V(K|N)|W(E|Z)|Y(C|R))|T(C(A|D)|GO|HA|JK|K(L|M)|LS|ON|TO|U(N|R|V)|WN|ZA)|U(EN|GA|KR|MI|RY|SA|ZB)|V(AT|CT|GB|IR|NM|UT)|W(LF|SM)|YEM|Z(AF|MB|WE))$",
        "MatchingText": "only country code (three upper letters)",
        "NonMatchingText": "others",
        "Description": "Table: \nhttp://en.wikipedia.org/wiki/ISO_3166-1."
    },
    {
        "Pattern": "^(0(0(4|8)|1(0|2|6)|2(0|4|8)|3(1|2|6)|4(0|4|8)|5(0|1|2|6)|6(0|4|8)|7(0|2|4|6)|8(4|6)|9(0|2|6))|1(0(0|4|8)|1(2|6)|2(0|4)|3(2|6)|4(0|4|8)|5(2|6)|6(2|6)|7(0|4|5|8)|8(0|4|8)|9(1|2|6))|2(0(3|4|8)|1(2|4|8)|2(2|6)|3(1|2|3|4|8|9)|4(2|4|8)|5(0|4|8)|6(0|2|6|8)|7(0|5|6)|88|9(2|6))|3(0(0|4|8)|1(2|6)|2(0|4|8)|3(2|4|6)|4(0|4|8)|5(2|6)|6(0|4|8)|7(2|6)|8(0|4|8|9)|92)|4(0(0|4|8)|1(0|4|7|8)|2(2|6|8)|3(0|4|8)|4(0|2|6)|5(0|4|8)|6(2|6)|7(0|4|8)|8(0|4)|9(2|6|8|9))|5(0(0|4|8)|1(2|6)|2(0|4|8)|3(0|3)|4(0|8)|5(4|8)|6(2|6)|7(0|4|8)|8(0|1|3|4|5|6)|9(1|8))|6(0(0|4|8)|1(2|6)|2(0|4|6)|3(0|4|8)|4(2|3|6)|5(2|4|9)|6(0|2|3|6)|7(0|4|8)|8(2|6|8)|9(0|4))|7(0(2|3|4|5|6)|1(0|6)|24|3(2|6)|4(0|4|8)|5(2|6)|6(0|4|8)|7(2|6)|8(0|4|8)|9(2|5|6|8))|8(0(0|4|7)|26|3(1|2|3|4)|40|5(0|8)|6(0|2)|76|8(2|7)|94))$",
        "MatchingText": "only country code (three digits)",
        "NonMatchingText": "others",
        "Description": "Table:\nhttp://en.wikipedia.org/wiki/ISO_3166-1."
    },
    {
        "Pattern": "^([1-9]{1}|[1-9]{1}[0-9]{1,3}|[1-5]{1}[0-9]{4}|6[0-4]{1}[0-9]{3}|65[0-4]{1}[0-9]{2}|655[0-2]{1}[0-9]{1}|6553[0-6]{1})$",
        "MatchingText": "1|||80|||65536",
        "NonMatchingText": "0|||0999|||65537",
        "Description": "Communication ports in PC between 1 - 65536."
    },
    {
        "Pattern": "^([\\#]{0,1}([a-fA-F0-9]{6}|[a-fA-F0-9]{3})|rgb\\(([0-9]{1},|[1-9]{1}[0-9]{1},|[1]{1}[0-9]{2},|[2]{1}[0-4]{1}[0-9]{1},|25[0-5]{1},){2}([0-9]{1}|[1-9]{1}[0-9]{1}|[1]{1}[0-9]{2}|[2]{1}[0-4]{1}[0-9]{1}|25[0-5]{1}){1}\\)|rgb\\(([0-9]{1}%,|[1-9]{1}[0-9]{1}%,|100%,){2}([0-9]{1}%|[1-9]{1}[0-9]{1}%|100%){1}\\))$",
        "MatchingText": "FF0000 #ff0000 555 #123 rgb(0,64,128) rgb(25%,75%,100%)",
        "NonMatchingText": "ss00ff  AF00 #0000 rgb(0,256,12) rgb(110%,50%,0%)",
        "Description": "This reg. exp. is ignore color names. Supported only hexadecimal with 3 or 6 chars (with or only prefix #); rgb syntax (0-255) and rgb syntax with % (0-100)."
    },
    {
        "Pattern": "^(0|(([1-9]{1}|[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{2}){1}(\\ [0-9]{3}){0,})),(([0-9]{2})|\\-\\-)([\\ ]{1})(\u20AC|EUR|EURO){1}$",
        "MatchingText": "0,00 \u20AC ||| 1 234 567,89 EUR ||| 1,-- EURO",
        "NonMatchingText": "00,00 \u20AC ||| 1234567,89 EUR ||| 0 555,55 EURO ||| 2,2 EUR ||| 2,- EUR",
        "Description": "Supported symbols are \u20AC or EUR or EURO (all case sensitive)."
    },
    {
        "Pattern": "^(big5|euc(kr|jpms)|binary|greek|tis620|hebrew|ascii|swe7|koi8(r|u)|(u|keyb)cs2|(dec|hp|utf|geostd|armscii)8|gb(k|2312)|cp(8(5(0|2)|66)|932|125(0|1|6|7))|latin(1|2|5|7)|(u|s)jis|mac(ce|roman))$",
        "MatchingText": "utf8|||cp1251|||latin7",
        "NonMatchingText": "utf-8|||utf16|||cp1252|||LATIN1|||cp 850",
        "Description": "supported all charsets in MySQL 5.1, case sensitive (lower)"
    },
    {
        "Pattern": "^((ucs2|utf8)\\_(bin|(general|unicode|roman|slovak|czech|icelandic|(latv|pers)ian|(dan|pol|span|swed|turk)ish|spanish2|(esto|lithua|roma|slove)nian\\_ci)))|((mac(ce|roman)|cp(8(5(0|2)|66)|1256)|armscii8|geostd8|ascii|keybcs2|greek|hebrew|koi8(r|u))\\_(bin|general\\_ci))|((dec8|swe7)\\_(bin|swedish\\_ci))|((hp8|latin5)\\_(bin|english\\_ci))|((big5|gb(2312|k))\\_(bin|chinese\\_ci))|((cp932|eucjpms|(s|u)jis)\\_(bin|japanese\\_ci))|(euckr\\_(bin|korean\\_ci))|(tis620\\_(bin|thai\\_ci))|(latin1\\_(bin|(((dan|span|swed)ish|german(1|2))\\_ci)|general\\_(ci|cs)))|(cp1250\\_(bin|czech\\_cs|general\\_ci))|(latin2\\_(bin|czech\\_cs|(general|hungarian|croatian)\\_ci))|(cp1257\\_(bin|(general|lithuanian)\\_ci))|(latin7\\_(bin|general\\_(c(i|s))|estonian\\_cs))|(cp1251\\_(bin|(general|bulgarian|ukrainian)\\_ci|general\\_cs))$",
        "MatchingText": "utf8_bin|||latin1_swedish_ci",
        "NonMatchingText": "ucs2_roman_cs|||utf_bin_ci",
        "Description": "supported all collates for all charsets in MySQL 5.1, case sensitive (lower)"
    },
    {
        "Pattern": "^([0-1][0-9]|2[0-3]){1}:([0-5][0-9]){1}:([0-5][0-9]){1},([0-9][0-9][0-9]){1} --> ([0-1][0-9]|2[0-3]){1}:([0-5][0-9]){1}:([0-5][0-9]){1},([0-9][0-9][0-9]){1}(.*)$",
        "MatchingText": "00:12:35,126 --> 00:12:35,526",
        "NonMatchingText": "00:59:35,126 --> 00:60:20,500 ||| 00:16:20,200 --> 00:16:20,30 ||| 01:01:01.000 --> 01:01:01.900",
        "Description": "e. g. HH:MM:SS:ttt --> HH:MM:SS:ttt;\n$1 is start hour;\n$2 is start minute;\n$3 is start second;\n$4 is start s/1000;\n$5 is stop hour;\n$6 is stop minute;\n$7 is stop second;\n$8 is stop s/1000;"
    },
    {
        "Pattern": "^\\{([1-9]{1}|[1-9]{1}[0-9]{1,}){1}\\}\\{([1-9]{1}|[1-9]{1}[0-9]{1,}){1}\\}(.*)$",
        "MatchingText": "{100}{150}subtitle ||| {1234}{1234}subtitle ||| {1}{2}subtitle",
        "NonMatchingText": "{0100}{1000}subtitle ||| {}{100}subtitle ||| {500}{}subtitle",
        "Description": "e. g. {11510}{11810}Blah, blah, blah.;\n$1 is start;\n$2 is stop;"
    },
    {
        "Pattern": "^\\s*(((\\d*\\.?\\d*[0-9]+\\d*)|([0-9]+\\d*\\.\\d*) )\\s*[xX]\\s*){2}((\\d*\\.?\\d*[0-9]+\\d*)|([0-9]+\\d*\\.\\d*))\\s*$",
        "MatchingText": "1.1 x 4.35 x 5.0|||1 x 2 x 3|||4.75 x 300.25 x 0",
        "NonMatchingText": "z.56 x 6 x 7|||1 xx 2 x 3|||1 by 2 by 3",
        "Description": "This validates Length times Width times Height measurements, which consists of 3 whole or decimal numbers separated by an x."
    },
    {
        "Pattern": "^(((\\d|([a-f]|[A-F])){2}:){5}(\\d|([a-f]|[A-F])){2})$|^(((\\d|([a-f]|[A-F])){2}-){5}(\\d|([a-f]|[A-F])){2})$|^$",
        "MatchingText": "A0:B1:C2:D3:E4:F5|A0-B1-C2-D3-E4-F5|",
        "NonMatchingText": "A0-B1-C2-D3-E4:F5|A0 - B1 - C2 - D3 - E4 - F5|A0:B1:C2:D3:E4:G5",
        "Description": "Designed to verify a MAC address with no spaces allowed, hex values separated by linux style separator \":\" or by windows style separator \"-\". Also empty string entry is allowed."
    },
    {
        "Pattern": "^((0?[1-9])|((1)[0-1]))?((\\.[0-9]{0,2})?|0(\\.[0-9]{0,2}))$",
        "MatchingText": "11.99|||05.5|||5",
        "NonMatchingText": "12|||12.00|||2.587",
        "Description": "This Regular Expression allows the user to enter a value to represent the imperial measurement of Inches.\n\nThe expression won't allow and value of 12 or above (otherwise it would be a foot!), and has the option of having a decimal value upto 2 decimal places.\n\nMy first Regular Expression so go easy on me!! :)"
    },
    {
        "Pattern": "^\\+\\d{1,3}\\s\\d{3}\\s\\d{3}\\s\\d{4}",
        "MatchingText": "+1 982 234 2341  | +61 282 538 3812  | +52 811 799 6100 | +243 111 412 8900",
        "NonMatchingText": "1 982 234 2341 | +1 982-234-2341  | +1 (982) 234-2341",
        "Description": "ITU E.123  International Validation Phone. plus initial and only numbers and white spaces.\n"
    },
    {
        "Pattern": "\\b((?:0[1-46-9]\\d{3})|(?:[1-357-9]\\d{4})|(?:[4][0-24-9]\\d{3})|(?:[6][013-9]\\d{3}))\\b",
        "MatchingText": "12556|||01550|||80796",
        "NonMatchingText": "05234|||8973|||62980",
        "Description": "This is my attempt to find out valid german postal codes (PLZ or Postleitzahlen).\nAfter the German Unification the numbers were changed to a five digit system. The postal codes starts with the two digit &quot;Leitzahl&quot;. This is a number between 00 and 99 excluding the  not yet used numbers: 00, 05, 43 and 62! After that follows directly a three digit number, 000-999.\nComments welcome. This works for me, however I think it could be written more compact, but could not figure out how ;-)\n\nFor more information on german postal codes see:\nhttp://de.wikipedia.org/wiki/Liste_der_Postleitbereiche_Deutschland\nhttp://de.wikipedia.org/wiki/Postleitzahl_%28Deutschland%29\nhttp://en.wikipedia.org/wiki/List_of_postal_codes_in_Germany"
    },
    {
        "Pattern": "(^[0-9]*$)(^[a-zA-Z]*$)^([a-zA-Z0-9]{8,10})$",
        "MatchingText": "test1test",
        "NonMatchingText": "testtest",
        "Description": "Validates a strong password. It must be between 8 and 10 characters, contain at least one digit and one alphabetic character, and must not contain special characters"
    },
    {
        "Pattern": "\\w+[\\w-\\.]*\\@\\w+((-\\w+)|(\\w*))\\.[a-z]{2,3}$|^([0-9a-zA-Z'\\.]{3,40})\\*|([0-9a-zA-Z'\\.]+)@([0-9a-zA-Z']+)\\.([0-9a-zA-Z']+)$|([0-9a-zA-Z'\\.]+)@([0-9a-zA-Z']+)\\*+$|^$",
        "MatchingText": "jdh*|||jss.js*|||juan.sk@micro.com",
        "NonMatchingText": "j*|||js*",
        "Description": "This regular expression is for admitting wild card searches on Emails the wild card character is * and in my case will only allow to do the search when the * is place after the first 3 alphanumeric characters. If you need to modify this behavior change the {3,40} to {n,m} where n is how many characters before the * and m is the total number if characters."
    },
    {
        "Pattern": "^[0]{1}[19]{1}[0-9]{8,9}$",
        "MatchingText": "0909123456, 01231234567",
        "NonMatchingText": "0009123456, 0909123456111, 03231234567, 01231234567134",
        "Description": "\u00D0\u00E2y l\u00E0 b?n R.E cho d?u s? di?n tho?i di d?ng c?a Vi?t Nam. Trong bi?u th?c quy d?nh s? di?n tho?i ph?i:\n- B?t d?u l\u00E0 s? 0 \n(VD:091,092,0122,0186,099...)\n\n- S? ? v? tr\u00ED th? 2 ph?i l\u00E0 s? 1 ho?c 9 (m\u00ECnh nh? k l?m ch? c\u00F3 2 lo?i n\u00E0y\n(VD: 091,092,0122,0186...)\n\n- C\u00E1c s? c\u00F2n l?i th\u00EC c\u00F3 th? ch?y t? 0 d?n 9 nhung gi?i h?n t? 8 d?n 9 s? d? c?ng th\u00EAm 2 s? check l\u00FAc d?u tr? th\u00E0nh s? dt d?ng 10 s? (0909.123.456) hay 11 s? (0123.123.4567)\n\n=============================\n\nThis is the RE for the mobile phone number of Vietnam. In the expression specified telephone number to: \n- Starting with the number 0 \n(Eg 091,092,0122,0186,099 ...) \n\n- 2nd number is number from 1 or 9 (if I don't have mistakes for remember this one)\n(Eg 091,092,0122,0186 ...) \n\n- The remaining numbers can flow from 0 to 9 but limited to 8 to 9 numbers for plus a check at the first two numbers become 10-digit number DT (0909.123.456) or No. 11 (0123.123.4567)\n\nGood Luck...and discuss\n\n"
    },
    {
        "Pattern": "^[+-]?[0-9]*\\.?([0-9]?)*",
        "MatchingText": "0123456789 or +456 Or -56.782",
        "NonMatchingText": "A34569 Or 15.26H",
        "Description": "Any number."
    },
    {
        "Pattern": "background-image.[^<]*?;",
        "MatchingText": "<div style=\"overflow: hidden; background-image:url(https://d2img01/z/Badge/N8_5x2_75/Tall_buildings_lores.gif);",
        "NonMatchingText": "<div style=\"overflow: hidden; Background-image:url(https://d2img01/z/Badge/N8_5x2_75/Tall_buildings_lores.gif);",
        "Description": "returns the background-image property with its value. It will not return the uppercase property value like Background-image. "
    },
    {
        "Pattern": "(?:(?P<scheme>[a-zA-Z]+)://)?(?P<domain>(?:[0-9a-zA-Z\\-_]+(?:[.][0-9a-zA-Z\\-_]+)*))(?::(?P<port>[0-9]+))?(?P<path>(?:/[0-9a-zA-Z\\-_.]+)+)(?:[?](?P<query>.+))?",
        "MatchingText": "http://www.google.com/cgi/search?hl=en&q=RegEx+Library&btnG=Google+Search&meta=|||ftp://ftp.google.com:21/Files/Data.zip|||http://www.google.com:80/cgi/search?hl=en&q=RegEx+Library&btnG=Google+Search&meta=",
        "NonMatchingText": "http:/www.google.co.za:80/cgi/search?hl=en&q=RegEx+Library&btnG=Google+Search&meta=|||http://www.google.co.za?80/cgi/search?hl=en&q=RegEx+Library&btnG=Google+Search&meta=|||http://www.google.co.za:80/cgi/search/hl=en&q=RegEx+Library&btnG=Google+Search&meta=",
        "Description": "Separates a URL into components viz. schema, domain, port, path and query. Avoids unnecessary numbered groups caused by braces."
    },
    {
        "Pattern": "[A-Z0-9]{5}\\d[0156]\\d([0][1-9]|[12]\\d|3[01])\\d[A-Z0-9]{3}[A-Z]{2}",
        "MatchingText": "JOHNS711215GG9SY",
        "NonMatchingText": "JOHNS731215GG9SY",
        "Description": "Matches the UK Drivers License format as laid down by the DVLA / dvla.    See http://www.govtalk.gov.uk/gdsc/html/frames/default.htm    Matches:       1. Must be 16 characters  2. First 5 characters are alphanumeric.  3. Next 6 characters must be numeric  4. Next 3 characters are alphanumeric  5. Last 2 characters are alpha  6. Second character of numeric section can only be 0, 1, 5 or 6.  7. Fourth and fifth characters of numeric section must be in the range 01 to 31."
    },
    {
        "Pattern": "^[a-zA-Z]{1,3}\\[([0-9]{1,3})\\]",
        "MatchingText": "Fw[9]||Re[8]||re[12]||fw[3]",
        "NonMatchingText": "Fw:||abc||tuncay",
        "Description": "this spam kontrol Fw[number] blocked. "
    },
    {
        "Pattern": "([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\\.[a-zA-Z0-9._-]+)",
        "MatchingText": "abc@abc.com||aa@aa.com.tr gibi",
        "NonMatchingText": "abc.com||abc@aa",
        "Description": "i\u00E7inde @ isareti ve en az 1 tane \".\" olmayanlar kabul edilmez."
    },
    {
        "Pattern": "(([\\+]90?)|([0]?))([ ]?)((\\([0-9]{3}\\))|([0-9]{3}))([ ]?)([0-9]{3})(\\s*[\\-]?)([0-9]{2})(\\s*[\\-]?)([0-9]{2})",
        "MatchingText": "0(216) 472 15 30 | +90(216) 6721530 | 03126751530",
        "NonMatchingText": "(0312)8721530 | 0312 872 15.30",
        "Description": "Can be used for Turkey phone styles."
    },
    {
        "Pattern": "^\\d{5}(-\\d{3})?$",
        "MatchingText": "13165-000|||38175-000|||81470-276",
        "NonMatchingText": "13165-00|||38175-abc|||81470-2763",
        "Description": "Matches standard 5 digit Brazilian Postal Codes (CEP), or the CEP + 3 digits (distribution identifiers - suffix). \nFor more info refer to: http://www.correios.com.br/servicos/cep/Estrutura_CEP.cfm (in portuguese)."
    },
    {
        "Pattern": "^[A-Z\u00C4\u00D6\u00DC]{1,3}\\-[ ]{0,1}[A-Z]{0,2}[0-9]{1,4}[H]{0,1}",
        "MatchingText": "F-RM373, W\u00DC-Z1, K- 07333,HN-WK11H",
        "NonMatchingText": "MOS-AS",
        "Description": "This one checks if the value is a possible german License Plate. The trailing H stands for Historical cars."
    },
    {
        "Pattern": "^[1-9]+\\d*\\.\\d{2}$",
        "MatchingText": "25.97|||5.39|||1000.24|||10340.23",
        "NonMatchingText": "0.23|||01.45|||10,000.23|||1000.2",
        "Description": "Useful for matching monetary values formatted without commas, leading zeros, currency symbols."
    },
    {
        "Pattern": "^100$|^0$|^[1-9]{0,1}[0-9]{0,1}$|^[1-9]{0,1}[0-9]{0,1}\\.[0-9]{1,3}$",
        "MatchingText": "100|||0|||99.99|||10|||5|||1.28",
        "NonMatchingText": "00|||09.9|||05.9",
        "Description": "Or depending on the decimal convention:\n^100$|^0$|^[1-9]{0,1}[0-9]{0,1}$|^[1-9]{0,1}[0-9]{0,1}\\,[0-9]{1,3}$\n\nCredit to Samir Azza's expression which I used to expand and arrive at the above expression."
    },
    {
        "Pattern": "(\\s+|)((\\(\\d{3}\\) +)|(\\d{3}-)|(\\d{3} +))?\\d{3}(-| +)\\d{4}( +x\\d{1,4})?(\\s+|)",
        "MatchingText": "(222)222-2222||||222-222-2222||||(222) 222 2222||||(222) 222-2222||||222 222 2222 x2222||||(222) 222-2222 x222",
        "NonMatchingText": "222- 222- 2222||||222 222 222||||222-222-2222 x",
        "Description": "This expression only accept numbers, spaces, x, ( ) and -. It accepts the values with 10 digits for phone numbers. These may be seperated with any number of spaces or a single '-'. The expression also allows an optional extension number to be provided atleast a single digit and a maximum of 4 digits."
    },
    {
        "Pattern": "\\.([A-Za-z0-9]{2,5}($|\\b\\?))",
        "MatchingText": "http://regexlib.com/Add.aspx|||/path/to/filename.txt|||TheSpanishInquisition.mpeg|||42.ai|||Dont Panic.xhtml|||http://localhost/webPage/index.php?variable=value",
        "NonMatchingText": "Non-extentionFileName|||FilenameWithOneCharacterExtension.q|||FIlenameWithSixOrMoreCharactersExtension.invalid",
        "Description": "Pattern matches all file extensions from two(2) to five(5) characters in length (e.g. Adobe Illustrator [*.ai] or Extensible Hypertext Markup Language [*.xhtml]). Input can be an absolute path, relative path, URI, directory path, etc. If there are get variables in a URI input, they are ignored."
    },
    {
        "Pattern": "Server=([\\w\\.]+?);\\s*?(?:Port=(\\d+?);\\s*?)?Database=(\\w+?);\\s*?(?:(?:User)|(?:Uid))=(\\w+?);\\s*?(?:(?:Password)|(?:Pwd))=(\\w*?);.*",
        "MatchingText": "Server=127.0.0.1;Port=3306;Database=test;User=echilon;Password=P@55word;charset=utf8 ||| Server=pegasus;Port=3306;Database=test;Uid=johnnytightlips;Pwd=whosaskin;",
        "NonMatchingText": "Server=127.0.0.1;User=echilon;Password=none;charset=utf8",
        "Description": "Matches a MySQL connection string if the arguments are in the specified order.\n\nFails if arguments are missing."
    },
    {
        "Pattern": "(\\d+(?:\\s+d(?:ay)?s?))?\\s?(\\d+(?:\\s+h(?:ou)?r?s?))?\\s?(\\d+(?:\\s+m(?:in)?(?:ute)?s?))?\\s?(\\d+(?:\\s+s(?:ec)?(?:ond)?)?s?)?$",
        "MatchingText": "6 days 18 hrs 2 mins|||4 days 19 hrs 5 mins|||4 days 19 hrs 12 mins|||2 h 20 mins|||1 hr 20 mins|||1 hour|||12 m|||12 minutes 15 seconds|||12 mins 15 secs|||1 min|||1 mins 10 seconds|||1 min 35 secs|||1 m|||1 m 10 s|||1 m 35 secs|||24 seconds|||25 secs|||1 sec|||1 s|||1 secs",
        "NonMatchingText": "7 apples 2 pears|||1 banana 2 banana|||3 banana 4||| 5 banana 6 banana 7 banana more",
        "Description": "Used for matching fuzzy timespans given in days, hours minutes, seconds and any combination thereof."
    },
    {
        "Pattern": "url\\(['\"]?([\\w\\d_\\-\\. ]+)['\"]?\\)",
        "MatchingText": "background: url(\"pattern.jpg\"); |||background: url(\"yellowcard-bg.png\") no-repeat scroll right top #FFFF9E;|||color: #607890;",
        "NonMatchingText": "margin-left: 2em; |||list-style-type: decimal;",
        "Description": "Matches a CSS Background tag. I needed this to replace image links in CSS with data-URI encoded strings."
    },
    {
        "Pattern": "^(\\d{0,4}(?:\\.\\d{0,2})?\n  | \n  [-]\\d{0,2}(?:\\.\\d{0,2})?\n )[%]{0,1}$",
        "MatchingText": "1234.56%|||23.32|||-42.23%",
        "NonMatchingText": "12345%|||-200%|||5.1234%",
        "Description": "validates Percents, where Positive numbers are allowed over 100% (in this case up to 9999), but where Negative percents must not go to or below -100%\n\nThis also allows for the &quot;%&quot; to be present or missing.\n\nThis was used to validate sales Growth Percents (allows for large positive growth, but you could not go negative for more than 100%)."
    },
    {
        "Pattern": "^\\s*((?:(?:\\d+(?:\\x20+\\w+\\.?)+(?:(?:\\x20+STREET|ST|DRIVE|DR|AVENUE|AVE|ROAD|RD|LOOP|COURT|CT|CIRCLE|LANE|LN|BOULEVARD|BLVD)\\.?)?)|(?:(?:P\\.\\x20?O\\.|P\\x20?O)\\x20*Box\\x20+\\d+)|(?:General\\x20+Delivery)|(?:C[\\\\\\/]O\\x20+(?:\\w+\\x20*)+))\\,?\\x20*(?:(?:(?:APT|BLDG|DEPT|FL|HNGR|LOT|PIER|RM|S(?:LIP|PC|T(?:E|OP))|TRLR|UNIT|\\x23)\\.?\\x20*(?:[a-zA-Z0-9\\-]+))|(?:BSMT|FRNT|LBBY|LOWR|OFC|PH|REAR|SIDE|UPPR))?)\\,?\\s+((?:(?:\\d+(?:\\x20+\\w+\\.?)+(?:(?:\\x20+STREET|ST|DRIVE|DR|AVENUE|AVE|ROAD|RD|LOOP|COURT|CT|CIRCLE|LANE|LN|BOULEVARD|BLVD)\\.?)?)|(?:(?:P\\.\\x20?O\\.|P\\x20?O)\\x20*Box\\x20+\\d+)|(?:General\\x20+Delivery)|(?:C[\\\\\\/]O\\x20+(?:\\w+\\x20*)+))\\,?\\x20*(?:(?:(?:APT|BLDG|DEPT|FL|HNGR|LOT|PIER|RM|S(?:LIP|PC|T(?:E|OP))|TRLR|UNIT|\\x23)\\.?\\x20*(?:[a-zA-Z0-9\\-]+))|(?:BSMT|FRNT|LBBY|LOWR|OFC|PH|REAR|SIDE|UPPR))?)?\\,?\\s+((?:[A-Za-z]+\\x20*)+)\\,\\s+(A[BLKSZRAP]|BC|C[AOT]|D[EC]|F[LM]|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ABDEHINOPST]|N[BCDEHJLMSTUVY]|O[HKRN]|P[AERW]|QC|RI|S[CDK]|T[NX]|UT|V[AIT]|W[AIVY]|YT)\\s+((\\d{5}-\\d{4})|(\\d{5})|([AaBbCcEeGgHhJjKkLlMmNnPpRrSsTtVvXxYy]\\d[A-Za-z]\\s?\\d[A-Za-z]\\d))\\s*$",
        "MatchingText": "any us/canadian address",
        "NonMatchingText": "non us/candian address",
        "Description": "This is built on an Address expression by Ross Hammer (who in turn built on an expression from Michael Ash)... and the zipcode expression from Matthew Aznoe.  This one adds validation for Canadian provinces and postal codes (so it does both US and Canada)"
    },
    {
        "Pattern": "\\b[1-9]{1}[0-9]{1,5}-\\d{2}-\\d\\b",
        "MatchingText": "50-00-0",
        "NonMatchingText": "200-001-8",
        "Description": "This is a more robust regex for matching Chemical Abstract Service (CAS) Numbers. This distinguishes between CAS numbers and other identifiers (e.g. EC number)."
    },
    {
        "Pattern": "^(([0-2]\\d|[3][0-1])\\/([0]\\d|[1][0-2])\\/[2][0]\\d{2})$|^(([0-2]\\d|[3][0-1])\\/([0]\\d|[1][0-2])\\/[2][0]\\d{2}\\s00\\:00\\:00)$",
        "MatchingText": "26/07/2010 00:00:00",
        "NonMatchingText": "26/07/2010 10:00:00 | 26/07/2010 10:34:14",
        "Description": "This expression will parse the date with zero time span only (e.g. 26/07/2010 00:00:00)"
    },
    {
        "Pattern": "^[-\\w\\s\"'=/!@#%&,;:`~\\.\\$\\^\\{\\[\\(\\|\\)\\]\\}\\*\\+\\?\\\\]*$",
        "MatchingText": "Test *1 - 2% + $3=#7 ... ?! &lt;",
        "NonMatchingText": "<a href=\"http:/acleditor.com\">CraigsListMultiplier</a>",
        "Description": "Anti-HTML pattern for english sentences. any < or > will make it not match."
    },
    {
        "Pattern": "^(GB)?(\\ )?[0-9]\\d{2}(\\ )?[0-9]\\d{3}(\\ )?(0[0-9]|[1-8][0-9]|9[0-6])(\\ )?([0-9]\\d{2})?|(GB)?(\\ )?GD(\\ )?([0-4][0-9][0-9])|(GB)?(\\ )?HA(\\ )?([5-9][0-9][0-9])$",
        "MatchingText": "GB 123 4567 89|123456789 123|GD 123|HA123",
        "NonMatchingText": "GB 123 4567 97|HA 1234|GB 1234567890",
        "Description": "UK VAT Validation\n\nConforms to format outlined below:\n\nCountry code GB followed by either:\nstandard: \n9 digits (block of 3, block of 4, block of 2 \u2013 e.g. GB999 9999 73)\n\nbranch traders: \n12 digits (as for 9 digits, followed by a block of 3 digits)\n\ngovernment departments: the letters GD then 3 digits from 000 to 499 (e.g. GBGD001)\n\nhealth authorities: \nthe letters HA then 3 digits from 500 to 999 (e.g. GBHA599)\n\nFor the 9-digit scheme, the 2-digit block containing the 8th and 9th digits is always in the range 00 to 96 and is derived from a weighted modulus-97 check number (an identical algorithm is used for the 12-digit scheme, ignoring the extra 3-digit block)"
    },
    {
        "Pattern": "^((0|[1-9]+[0-9]*)-(0|[1-9]+[0-9]*);|(0|[1-9]+[0-9]*);)*?((0|[1-9]+[0-9]*)-(0|[1-9]+[0-9]*)|(0|[1-9]+[0-9]*)){1}$",
        "MatchingText": "0|||0-3|||1;2|||1;2-3|||2-3;10|||1-2;3-40",
        "NonMatchingText": "1;|||2-3;|||a;1|||2-3;a|||001-3|||1-003",
        "Description": "Matches any range of numbers according to the format x;x-xx where \"x\" is a number between 0 and 9, however 0 may not be a the starting digit of a multi-digit number (i.e. 001). The format specifies that a range is denoted by x-x (numbers are seperated by a hyphen) and multiple range specification or single numbers may be seperated by a semi-colon \";\"."
    },
    {
        "Pattern": "^(((\\(800\\))(\\(888\\))(\\(877\\))(\\(866\\))(\\(900\\))\\(\\d{3}\\) ?)|(800)(888)(877)(866)(900)(\\d{3}-))?\\d{3}-\\d{4}",
        "MatchingText": "123-554-1247, (455)521-5482",
        "NonMatchingText": "800-585-1234, (866)958-4221",
        "Description": "This pattern matches US phone numbers but excludes numbers that are 800 or 900 numbers.  It excludes the following area codes 800, 888,877,866, and 900."
    },
    {
        "Pattern": "^\\W{0,5}[Rr]e:\\W[a-zA-Z0-9]{1,10},\\W[a-z]{1,10}\\W[a-z]{1,10}\\W[a-z]{1,10}",
        "MatchingText": "re: ASDFG, hours among lifestyle|||Re: ASD34SSDF, i can't believe|||Re: VZWENKS, the coffin brogade",
        "NonMatchingText": "re: ASDFGASFDASDF, Hours among lifestyle|||Re: ASD34SSDF, I can't believe it's true",
        "Description": "Simple email subject line matching. This regex matches those really annoying emails that begin with 0-5 spaces, followed by a fake reply, contain a random string of letters (usually CAPITALIZED) from 1-10 characters long followed by a comma, and then followed by three lower-case words each from 1-10 characters long. In my experience, the 3 trailing words are always lower-case. the words make begin with, contain, or end in common punctuation marks."
    },
    {
        "Pattern": "^\\d*\\.?((25)|(50)|(5)|(75)|(0)|(00))?$",
        "MatchingText": "0.25|||.75|||123.50",
        "NonMatchingText": ".77|||1.435",
        "Description": "This is a pattern to search and verify that a decimal number ends with a 25, 50, 75, 0 or 00. It does match for a nothing after decimal also but I guess thats ok !!"
    },
    {
        "Pattern": "(0?[1-9]|[12][0-9]|3[01])[.](0?[1-9]|1[012])[.]\\d{4}",
        "MatchingText": "25.12.1234|||1.1.1111|||30.02.9999",
        "NonMatchingText": "32.1.2000|||20.10.234|||20-10-2000",
        "Description": "One or two digits for day and month. Four digits for year.\nDoesn't check for leap years or months day count."
    },
    {
        "Pattern": "^(([^,\\n]+),([^,\\n]+),([^@]+)@([^\\.]+)\\.([^,\\n]+)\\n)+([^,\\n]+),([^,\\n]+),([^@]+)@([^\\.]+)\\.([^,\\n]+)\\n?$",
        "MatchingText": "Mark,Newman,Mark@Newman.com",
        "NonMatchingText": "Mark,,Mark@Newman.com",
        "Description": "This pattern validates a 3 field CSV file. I designed it to capture first name, last name and email address in that order."
    },
    {
        "Pattern": "^[1-9]\\d*\\.?[0]*$",
        "MatchingText": "1|||2|||3",
        "NonMatchingText": "0|||1.2|||01",
        "Description": "natural numbers 1, 2, 3...\n(no zeros)"
    },
    {
        "Pattern": "[A-Za-z_.0-9-]+@{1}[a-z]+([.]{1}[a-z]{2,4})+",
        "MatchingText": "hamza@demo.net|||hamza@demo.co.uk|||s.hamza.hasan@googlemail.com|||a@b.cc",
        "NonMatchingText": "a@b.c|||@co.uk|||hamza@tk.|||demo@.com|||demo.dem@hero.c",
        "Description": "Useful and easy to use RegEx for email validation. Allowed alphabets (capital and small), 0 to 9, \".\", \"_\" and \"-\" before \"@\". Then exactly one \"@\" is allowed in whole email then small letters (1 or more) then multiple set of \".\" and alphabets (2 to 4)"
    },
    {
        "Pattern": "href=[\\\"\\'](http:\\/\\/|\\.\\/|\\/)?\\w+(\\.\\w+)*(\\/\\w+(\\.\\w+)?)*(\\/|\\?\\w*=\\w*(&\\w*=\\w*)*)?[\\\"\\']",
        "MatchingText": "href=\"www.yahoo.com\"|||href=\"http://localhost/blah/\"|||href=\"eek\"",
        "NonMatchingText": "href=\"\"|||href=eek|||href=\"bad example\"",
        "Description": "I wrote up this regular expression to fetch the href attribute found in &lt;a&gt; tags as well as a few other HTML tags."
    },
    {
        "Pattern": "(?P<O>(?P<d>[BEGLMNS]|A[BL]|B[ABDHLNRST]|C[ABFHMORTVW]|D[ADEGHLNTY]|E[HNX]|F[KY]|G[LUY]|H[ADGPRSUX]|I[GMPV]|JE|K[ATWY]|L[ADELNSU]|M[EKL]|N[EGNPRW]|O[LX]|P[AEHLOR]|R[GHM]|S[AEGKL-PRSTWY]|T[ADFNQRSW]|UB|W[ADFNRSV]|YO|ZE)(?P<a>\\d\\d?)|(?P<d>E)(?P<a>\\dW)|(?P<d>EC)(?P<a>\\d[AMNPRVY0])|(?P<d>N)(?P<a>\\dP)|(?P<d>NW)(?P<a>\\dW)|(?P<d>SE)(?P<a>\\dP)|(?P<d>SW)(?P<a>\\d[AEHPVWXY])|(?P<d>W)(?P<a>1[0-4A-DFGHJKSTUW])|(?P<d>W)(?P<a>[2-9])|(?P<d>WC)(?P<a>[12][ABEHNRVX]))\\ (?P<I>(?P<s>\\d)(?P<u>[ABD-HJLNP-UW-Z]{2}))",
        "MatchingText": "CR0 1AA|EC50 1AA|SW1P 1AA|GU1 3AW",
        "NonMatchingText": "DR1 1AA|EC51 1AA|sw1p 1aa|CR01AA|GIR 0AA|SAN TA1|BFPO 2|ASCN 1ZZ",
        "Description": "This is the tightest uk postcode validator I can come up with, I have copy of Royal Mail's PAF (Postal Address File) and I've confirmed that it will correctly validate all 1.75 million distinct postcodes.\n\nI figure this regex will accept 54 million strings as valid, which gives a 30:1 false accept ratio, the best I can do.\n\nI'll endeavour to keep it up to date with new post codes. \n\nI've deliberately excluded special cases, These can be added as simple alternates.\n\n2009-06-05 Improved: Replaced all numbered captured groups with 6 named capture groups (I Incode, O Outcode, d District, s Sector, a Area, u Unit) for separating postcode parts. Also removed begin (^) and end ($) positioning characters ST"
    },
    {
        "Pattern": "^(3[0-1]|2[0-9]|1[0-9]|0[1-9])[\\/](Jan|JAN|Feb|FEB|Mar|MAR|Apr|APR|May|MAY|Jun|JUN|Jul|JUL|Aug|AUG|Sep|SEP|Oct|OCT|Nov|NOV|Dec|DEC)[\\/]\\d{4}$",
        "MatchingText": "11/jun/1980, 11/JUN/1980, 11/Jun/1980",
        "NonMatchingText": "11 jun 1980, 11-jun-1980",
        "Description": "This regular expressions matches dates of the form XX/XXX/YYYY where XX can be 1 or 2 digits long, XXX can be JAN/Jan/jan(Month name in 3 char) and YYYY is always 4 digits long."
    },
    {
        "Pattern": "^([^:])+\\\\.([^:])+$",
        "MatchingText": "setup.exe|||install.dmg|||myapp.app",
        "NonMatchingText": "javascript:file.exe|||java.exe:123|||java:exe.dmg",
        "Description": "Matches Macintosh file names syntax. (does not support paths, just the filename)"
    },
    {
        "Pattern": "^(00[1-9]|0[1-9][0-9]|[1-7][0-9][0-9]|7[0-7][0-2]|77[0-2])(\\d{6})(A|B([1-9]?|[ADGHJKLNPQRTWY])|C([1-9]|[A-Z])|D([1-9]?|[ACDGHJKLMNPQRSTVWXYZ])|E([1-9]?|[ABCDFGHJKM])|F([1-8])|J([1-4])|K([1-9]|[ABCDEFGHJLM])|T([ABCDEFGHJKLMNPQRSTUVWXYZ2]?)|M|W([1-9]?|[BCFGJRT]))$",
        "MatchingText": "123456789F1 123456789W",
        "NonMatchingText": "1234567890 A000000 WCD000000 123-45-6789A",
        "Description": "This is the real regex for a non-railroad board HICN. All combinations are accounted for. This does not account for dashes as they are stripped out before I do the validation.\nThis also only allows 001-772 as the first 3 numbers per spec. It does not take into consideration that 00 is not allowed for 4th and 5th digits and that 0000 is not allowed for last 4 digits."
    },
    {
        "Pattern": "(?P<local1300>^1300[ |\\-]{0,1}\\d{3}[ |\\-]{0,1}\\d{3}$)|(?P<tollcall>^1900|1902[ |\\-]{0,1}\\d{3}[ |\\-]{0,1}\\d{3}$)|(?P<freecall>^1800[ |\\-]{0,1}\\d{3}[ |\\-]{0,1}\\d{3}$)|(?P<standard>^\\({0,1}0[2|3|7|8]{1}\\){0,1}[ \\-]{0,1}\\d{4}[ |\\-]{0,1}\\d{4}$)|(?P<international>^\\+61[ |\\-]{0,1}[2|3|7|8]{1}[ |\\-]{0,1}[0-9]{4}[ |\\-]{0,1}[0-9]{4}$)|(?P<local13>^13\\d{4}$)|(?P<mobile>^04\\d{2,3}\\d{6}$)",
        "MatchingText": "1300 123 123|||1300123123|||+61212341234|||+61 2 1234 1234|||+61-2-1234-1234|||02 1234 1234|||(02) 1234-1234",
        "NonMatchingText": "05 1234 1234||1800xyzabc|||+64-3-1234123",
        "Description": "This will validate most Australian telephone numbers including 13, 1300, 1800, 1900, std and international +61- format numbers. It allows optional spaces, dashes and brackets in most cases."
    },
    {
        "Pattern": "^ *(([\\.\\-\\+\\w]{2,}[a-z0-9])@([\\.\\-\\w]+[a-z0-9])\\.([a-z]{2,3})) *(; *(([\\.\\-\\+\\w]{2,}[a-z0-9])@([\\.\\-\\w]+[a-z0-9])\\.([a-z]{2,3})) *)* *$",
        "MatchingText": "holiday@microsoft.com | have@fun.with.ru ;   jobbs@apple.app; JrrTolkin@loroftherings.fan |   bother@ing.net , kickmeTo@8Heaven.ch   ;  expressions@arecool.google.mail.com  ",
        "NonMatchingText": "sh@fhhj.think | hello@woode.se collin@hotmail.t |  expressions@arecool.google.mail.com ; jobbs@apple.app; JrrT?lkin@loroftherings.fan",
        "Description": "This Expression Validates a string of Email Adresses which are sepereated with one of these[,.] and can have several white spaces between the delimeters. everything can be read out of groups\n^ *(?<FirstEmail>(?<Firstusername>[\\.\\-\\+\\w]{2,}[a-z0-9])@(?<FirstProvider>[\\.\\-\\w]+[a-z0-9])\\.(?<Firstnamespace>[a-z]{2,3})) *(; *(?<EmailList>(?<UsernameList>[\\.\\-\\+\\w]{2,}[a-z0-9])@(?<ProviderList>[\\.\\-\\w]+[a-z0-9])\\.(?<namespaceList>[a-z]{2,3})) *)* *$\nMust cointain at least 3 char before@, 2char after @ and 2-3 char(a-z) as CountryID. If you don't want to validate and 'just' look for Valid E-mail addresses simply remove the first \"^\" and the last \"$\", or remove the optional part after first \"{2,3})) *\"\n"
    },
    {
        "Pattern": "^((((0[1-9]|[1-2][0-9]|3[0-1])[./-](0[13578]|10|12))|((0[1-9]|[1-2][0-9])[./-](02))|(((0[1-9])|([1-2][0-9])|(30))[./-](0[469]|11)))[./-]((19\\d{2})|(2[012]\\d{2})))$",
        "MatchingText": "01/01/1900 |  29/02/2012 | 31/12/2101",
        "NonMatchingText": "30/02/2012 | 31/04/2010 | 31.05.2300",
        "Description": "Date pattern for date format\nDD-MM-YYYY or\nDD/MM/YYYY or\nDD.MM.YYYY.\nYear value limited from 1900-2299\n"
    },
    {
        "Pattern": "^(s-|S-){0,1}[0-9]{3}\\s?[0-9]{2}$",
        "MatchingText": "12345|||932 68|||S-621 46",
        "NonMatchingText": "5367|||425611|||31 545",
        "Description": "Validates swedish zipcodes (postnr) with or without space between groups. With leading s- or not. Can be disconnected by removing ''(s-|S-){0,1}''."
    },
    {
        "Pattern": "^[0-9]{1}$|^[1-6]{1}[0-3]{1}$|^64$|\\-[1-9]{1}$|^\\-[1-6]{1}[0-3]{1}$|^\\-64$",
        "MatchingText": "-1  -10  -64  0  1  10  64",
        "NonMatchingText": "-0  -65  -99  65  99",
        "Description": "This regular expression validate a range between -64 and 64."
    },
    {
        "Pattern": "([0-9]* {0,2}[A-Z]{1}\\w+[,.;:]? {0,4}[xvilcXVILC\\d]+[.,;:]( {0,2}[\\d-,]{1,7})+)([,.;:] {0,4}[xvilcXVILC]*[.,;:]( {0,2}[\\d-,]{1,7})+)*",
        "MatchingText": "\"Deu. xxxiii. 20, 21\" \"1 Ch. v. 18-22\" \"Gen. xxx. 11; xlvi. 16\" \"Genesis 5340:9387\" \"Gen. xxx. 11,12-13 xlvi. 16\"",
        "NonMatchingText": "\"Xtec;a7po1T09, 'the pavement.'\" \"Assyria, about B. c. 740; and\"",
        "Description": "Will find any bible reference even if it uses roman numerals or has multiple chapter/verse and/or multiple verse components. Does not confirm chapter/verse value ranges. It would find/validate Genesis 5340:9387"
    },
    {
        "Pattern": "^((?:\\+27|27)|0)(=72|82|73|83|74|84)(\\d{7})$",
        "MatchingText": "+27832762842|||27832762842|||0832762842",
        "NonMatchingText": "083 276 2842",
        "Description": "Verifies South African mobile numbers with or without the country code."
    },
    {
        "Pattern": "(\\d+(-\\d+)*)+(,\\d+(-\\d+)*)*",
        "MatchingText": "1-2,4,5 | 10, 11-12",
        "NonMatchingText": "1a | 2b",
        "Description": "Format when entering page ranges in Print dialogs."
    },
    {
        "Pattern": "([A-Z&#228;&#246;&#252;0-9\\/][^a-z\\:\\,\\(\\)]*[A-Z&#228;&#246;&#252;0-9])($|[\\.\\:\\,\\;\\)\\-\\ \\+]|s\\b)",
        "MatchingText": "ASN.1|||REGEXP",
        "NonMatchingText": "***",
        "Description": "Used to dynamically find acronyms in a sentence. The first pair of brackets gets the acronym, the second gets the text after the acronym."
    },
    {
        "Pattern": "^(\\d{1,3}'(\\d{3}')*\\d{3}(\\.\\d{1,3})?|\\d{1,3}(\\.\\d{3})?)$",
        "MatchingText": "1'235.140|||1'222'333.120|||456",
        "NonMatchingText": "1234.500|||78'45.123|||123,0012",
        "Description": "This regex match numeric data in the following format: thousands are separated by (') apostrophe, decimal places are separated by dot (.) Maximum three decimal places are not required. It's easy to change to other separators as well."
    },
    {
        "Pattern": "^((0?[1-9]|[12][1-9]|3[01])\\.(0?[13578]|1[02])\\.20[0-9]{2}|(0?[1-9]|[12][1-9]|30)\\.(0?[13456789]|1[012])\\.20[0-9]{2}|(0?[1-9]|1[1-9]|2[0-8])\\.(0?[123456789]|1[012])\\.20[0-9]{2}|(0?[1-9]|[12][1-9])\\.(0?[123456789]|1[012])\\.20(00|04|08|12|16|20|24|28|32|36|40|44|48|52|56|60|64|68|72|76|80|84|88|92|96))$",
        "MatchingText": "31.01.2002|||29.2.2004|||09.02.2005",
        "NonMatchingText": "31.11.2002|||29.2.2002|||33.06.2000",
        "Description": "Fully functional date validator in format dd.MM.yyyy\nWorks only within range of years 2000-2099 !\nIt allows leading zeros but does not require them. The last year pattern (enumeration) is not very clever but I will improve it, if needed."
    },
    {
        "Pattern": "^((\\(([1-9]{2})\\))(\\s)?(\\.)?(\\-)?([0-9]{0,1})?([0-9]{4})(\\s)?(\\.)?(\\-)?([0-9]{4})|(([1-9]{2}))(\\s)?(\\.)?(\\-)?([0-9]{0,1})?([0-9]{4})(\\s)?(\\.)?(\\-)?([0-9]{4}))$",
        "MatchingText": "(13)98145-5566 | (11)8854-3236 | (11) 8854-3236 | (11).8854.3236 | (11)-8854-3236 | 1177854425 | 11.5642-3115",
        "NonMatchingText": "(13654854 | 01 9854-4253 | 11.456758-525",
        "Description": "This expression allows Brazilian phone numbers as they have 4 or 5 prefix digits and with/without regional code. Not perfect but simplifies. Also allows space or dot or hyphen as optional separator in the number as parenthesis in regional code."
    },
    {
        "Pattern": "^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w ]*.*))+\\.(txt|TXT)$",
        "MatchingText": "C:\\Documents and Settings\\roman.lukyanenko\\Desktop\\stuff\\b_card2.txt",
        "NonMatchingText": "C:\\file.doc",
        "Description": "It matches .jpg files. It allows for a dot in the path. A dot may occur in such directories as: C:\\Documents and Settings\\roman.lukyanenko\\Desktop\\stuff\\b_card2.txt or C:\\Windows\\Microsoft.NET etc"
    },
    {
        "Pattern": "^[0-9]{6}",
        "MatchingText": "150016",
        "NonMatchingText": "qqww",
        "Description": "I know its simple, yet there was no Russian postal code regular expression on the RegExLib. Just in case some needs to know the format."
    },
    {
        "Pattern": "\\xA9",
        "MatchingText": "\u00A9",
        "NonMatchingText": "anything",
        "Description": "Matches the copyright symbol (&amp;copy;). Pretty simple, yet I dont think existed on RegExLib before. "
    },
    {
        "Pattern": "^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w ]*.*))+\\.(jpg|JPG)$",
        "MatchingText": "C:\\Documents and Settings\\roman.lukyanenko\\Desktop\\stuff\\b_card2.jpg|||C:\\b_card.jpg|||\\\\network\\fol",
        "NonMatchingText": "C:\\file.xls",
        "Description": "It matches .jpg files. It allows for a dot in the path. A dot may occur in such directories as: C:\\Documents and Settings\\roman.lukyanenko\\Desktop\\stuff\\b_card2.jpg\n\nor C:\\Windows\\Microsoft.NET etc"
    },
    {
        "Pattern": "(((19|20)([2468][048]|[13579][26]|0[48])|2000)/02/29|((19|20)[0-9]{2}/(0[469]|11)/(0[1-9]|[12][0-9]|30)|(19|20)[0-9]{2}/(0[13578]|1[02])/(0[1-9]|[12][0-9]|3[01])|(19|20)[0-9]{2}/02/(0[1-9]|1[0-9]|2[0-8]))) ",
        "MatchingText": "2016-02-29 ||| 2012-04-30 ||| 2019/09/31",
        "NonMatchingText": "2016-02-30 ||| 2012-04-31 ||| 2019/09/35",
        "Description": "Very secure RegEx pattern control for your date entries in english/us format YYYY/MM/DD or YYYY-MM-DD (very easy to only authorize / or -).\n28,29,30,31 days month are controled according to the month & leap year.\nCheck it ! Tested and functionnal !"
    },
    {
        "Pattern": "((((19|20)([2468][048]|[13579][26]|0[48])|2000)-02-29|((19|20)[0-9]{2}-(0[469]|11)-(0[1-9]|[12][0-9]|30)|(19|20)[0-9]{2}-(0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01])|(19|20)[0-9]{2}-02-(0[1-9]|1[0-9]|2[0-8])))\\s([01][0-9]|2[0-3]):([012345][0-9]):([012345][0-9])) ",
        "MatchingText": "2013-04-05 17:59:59 ||| 2013-07-30 01:22:42 ||| 2099-12-30 23:59:59 |||  2016-02-28 00:00:00",
        "NonMatchingText": "2016-02-29 -01:01:02 ||| 3000-04-24 17:42:21 ||| 2012-03-03 24:24:02 ||| 2012-03-03 21:60:45  ",
        "Description": "Very secure MySQL datetime RegEx pattern control.\nStrictly allow the following format only :\n\"YYYY-MM-DD HH:MM:SS\"  \n\nVerify if date is correct (28,29,30,31 days accoring to the month. Leap years with 29/02 also controled."
    },
    {
        "Pattern": "(((\\d{2}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229))(( |-)(\\d{4})( |-)([01]8((( |-)\\d{1})|\\d{1}))|(\\d{4}[01]8\\d{1}))",
        "MatchingText": "9202204720082 | 920220 4720 082 |920220 4720 08 2 | 920220-4720-082 | 920220-4720-08-2  9202204720183 | 920220 4720 183 | 920220 4720 18 3 | 920220-4720-183 | 920220-4720-18-3",
        "NonMatchingText": "9202204720282 | 920220 4720 052 | 920220 4720 05 2 | 920220-4720-252",
        "Description": "Matches valid South African ID numbers based on all criteria (except of course the checksum digit at the end).\n\nMatches the format defined as:\nYYMMDDSSSSCAZ.\nYY - Year,\nMM - Month,\nDD - Day,\nSSSS - Gender,\nC - Denotes citizenship (0 or a 1),\nA - Always an 8,\nZ - Checksum digit (doesn't validate if the checksum itself is valid).\n\nAlso supports the following ways of entering it:\nYYMMDDSSSSCAZ | \nYYMMDD SSSS CAZ | \nYYMMDD SSSS CA Z .\n\nSee this for a reference:\nhttps://www.westerncape.gov.za/general-publication/decoding-your-south-african-id-number-0"
    },
    {
        "Pattern": "^\\(?(?:(?:0(?:0|11)\\)?[\\s-]?\\(?|\\+)44\\)?[\\s-]?\\(?(?:0\\)?[\\s-]?\\(?)?|0)(?:\\d{2}\\)?[\\s-]?\\d{4}[\\s-]?\\d{4}|\\d{3}\\)?[\\s-]?\\d{3}[\\s-]?\\d{3,4}|\\d{4}\\)?[\\s-]?(?:\\d{5}|\\d{3}[\\s-]?\\d{3})|\\d{5}\\)?[\\s-]?\\d{4,5}|8(?:00[\\s-]?11[\\s-]?11|45[\\s-]?46[\\s-]?4\\d))(?:(?:[\\s-]?(?:x|ext\\.?\\s?|\\#)\\d+)?)$ \n",
        "MatchingText": "020 3000 5555, (020) 3000 5555, +44 20 3000 5555, 00 44 20 3000 5555, 011 44 20 3000 5555, 0203 000 5555, 02030 005 555, (+44) 20 3000 5555, (+44 20) 3000 5555,  and many others, any with NSN of 10 or 9.",
        "NonMatchingText": "01750 5555, 0203 5555 7777, +33 1 2345 6789",
        "Description": "Step 1: Test that the input is a UK phone number. Later patterns extract the prefix, NSN and extension, and further tests check the NSN for length and validity.\n\nThe above pattern matches optional opening parentheses, followed by 00 or 011 and optional closing parentheses, followed by an optional space or hyphen, followed by optional opening parentheses. Alternatively, the opening parentheses are followed by a literal + without a following space or hyphen. Any of the previous options are then followed by 44 with optional closing parentheses, followed by optional space or hyphen, followed by optional 0 in optional parentheses, followed by optional space or hyphen, followed by optional opening parentheses (international format). Alternatively, the pattern matches optional opening parentheses followed by the 0 trunk code (national format).\n\nThis is followed by the area code and phone number in 2+8, 3+7, 3+6, 4+6, 4+5, 5+5 or 5+4 format with or without spaces and/or hyphens. This also includes provision for optional closing parentheses and/or optional space or hyphen after where the user thinks the area code ends and the local number begins. The pattern allows any format to be used with any UK number. The display format must be corrected by later logic if the wrong format for this number has been used by the user on input.\n\nThe pattern finally ends with optional space or hyphen followed by x, ext and optional period, or #, followed by a three or four digit extension number. \n\nOnce the input has been confirmed as being a telephone number using the above pattern, another RegEx pattern should extract prefix, NSN and extension and then the NSN should be further tested for length and validity.\n\n(Order fixed for even greater efficiency: shorter area codes match first.)"
    },
    {
        "Pattern": "^\\(?(?:(?:0(?:0|11)\\)?[\\s-]?\\(?|\\+)(44)\\)?[\\s-]?\\(?(?:0\\)?[\\s-]?\\(?)?|0)([1-9]\\d{1,4}\\)?[\\s\\d-]+)(?:((?:x|ext\\.?\\s?|\\#)\\d+)?)$ ",
        "MatchingText": "020 3000 5555, (020) 3000 5555, +44 20 3000 5555, 00 44 20 3000 5555, 011 44 20 3000 5555, 0203 000 5555, 02030 005 555, (+44) 20 3000 5555, (+44 20) 3000 5555, and many others, any with NSN of 10 or 9.",
        "NonMatchingText": "01750 5555, 0203 5555 7777, +33 1 2345 6789",
        "Description": "Step 2: After step 1 has verified the input is likely to be a UK telephone number, this pattern extracts the NSN part of the number so that it can be passed to another routine that will check it for length and validity. $1 is 44 (international format) or null (use 0 for trunk code - national format). $2 is the NSN. $3 is the extension number."
    },
    {
        "Pattern": "^((1[1-9]|2[03489]|3[0347]|5[56]|7[04-9]|8[047]|9[018])\\d{8}|(1[2-9]\\d|[58]00)\\d{6}|8(001111|45464\\d))$ ",
        "MatchingText": "20 3000 5555, 121 555 7777, 1750 618888, 1750 62555, 19467 55555, 16977 3555, 303 555 7788, 500 777999, 55 4455 7788, 70 7788 5577, 800 555777, 800 444 7799, 845 333 5577, 871 444 5577, 909 555 7788 after removing spaces",
        "NonMatchingText": "20 444 666, 20 555 7777, 1999 5577, 1999 555 7799, 22 5000 7777, 800 55555, 803 555777, 815 555 7777, 845 8888 9999",
        "Description": "Step 3: Validate the NSN produced from the pattern in step 2 and check it for length and validity. The pattern here is fairly basic. More detailed patterns for each number type are available elsewhere.\n\n\nStep 4 is to format the number correctly. This needs a variety of RegEx patterns each based on the initial digits and number length.\n\n"
    },
    {
        "Pattern": "^[a-zA-Z0-9._-]+$",
        "MatchingText": "The.Cooler.2003.LIMITED.DVDRip.XViD-ALLiANCE|||blaat.bleahz-GROUP|||blaat_bleahz-GROUP",
        "NonMatchingText": "The Cooler 2003 LIMITED DVDRip XViD-ALLiANCE|||blaat~bleahz@GROUP",
        "Description": "This is to check release names...\nit only allowes alphanumeric and numeric chars , and also _ - and ."
    },
    {
        "Pattern": "^(\\+?)(\\d{2,4})(\\s?)(\\-?)((\\(0\\))?)(\\s?)(\\d{2})(\\s?)(\\-?)(\\d{3})(\\s?)(\\-?)(\\d{2})(\\s?)(\\-?)(\\d{2})",
        "MatchingText": "+41 44 123 12 34|||+41 (0) 44 123 12 34|||+41-44-123-1234|||0041 44 123 12 34",
        "NonMatchingText": "+41 0 44 123 1234|||+41.44.123.1234",
        "Description": "This regex will match various ways of entering a Swiss phone number along with the country code."
    },
    {
        "Pattern": "^\\s*\\(?(020[7,8]{1}\\)?[ ]?[1-9]{1}[0-9{2}[ ]?[0-9]{4})|(0[1-8]{1}[0-9]{3}\\)?[ ]?[1-9]{1}[0-9]{2}[ ]?[0-9]{3})\\s*$",
        "MatchingText": "02071111111|||01000100000",
        "NonMatchingText": "00000000000",
        "Description": "Matches UK phone numbers - London and regional. It started off with something fairly short posted by liljim at www.forums.devshed.com but I wanted a little more precision to weed out all the zeros. Now it also weeds out premium phone numbers (as of 19/12/03)."
    },
    {
        "Pattern": "\\$(\\d*)??,??(\\d*)??,??(\\d*)\\.(\\d*)",
        "MatchingText": "$1,234,567.89|||$1,234.80|||$34.45|||$1234.5",
        "NonMatchingText": "$1,234|||$123-45|||$-123.00",
        "Description": "This captures (for filters out non digits) numbers with or without commas (eg currency as above) in the correct order - the other examples I see here don't capture in right order for all combinations. It doesn't check lengths or leading digits or number of digits between commas- that is left as an exercise for the student.\nFirst example gives:[4],[234],[567],[89]\nSecond gives:\n[],[1],[234],[80]\nrather than the incorrect:\n[1],[],[234],[80]"
    },
    {
        "Pattern": "^((([\\(]?[2-9]{1}[0-9]{2}[\\)]?)|([2-9]{1}[0-9]{2}\\.?)){1}[ ]?[2-9]{1}[0-9]{2}[\\-\\.]{1}[0-9]{4})([ ]?[xX]{1}[ ]?[0-9]{3,4})?$",
        "MatchingText": "(555) 687-6076 X 1234 || (555) 687-6076 || 555.687.5511x1234",
        "NonMatchingText": "555.687.6076 ext 1234",
        "Description": "This regex matches US and CAN phone numbers with area code and optional 3 or 4 digit PBX extention.  It does not check for validity of area code or exchange number, other than for starting with a 0 or 1."
    },
    {
        "Pattern": "^(~/|/|(((ht|f)tp(s?))\\://))[^/](\\S*)[^/]+$",
        "MatchingText": "http://www.google.com ||| ftp://crazy.com ||| https://securecon |||~/rootrelative ||| /absolute/path",
        "NonMatchingText": "www.google.com ||| http:cozystuff ||| go/here ||| /not/valid/",
        "Description": "Allows selection of a root relative path or absolute path; or it allows off-site http://, https://, or ftp:// specific url. "
    },
    {
        "Pattern": "^(?:(?:[\\+]?(?P<CountryCode>[\\d]{1,3}(?:[ ]+|[\\-.])))?[(]?(?P<AreaCode>[\\d]{3})[\\-/)]?(?:[ ]+)?)?(?P<Number>[a-zA-Z2-9][a-zA-Z0-9 \\-.]{6,})(?:(?:[ ]+|[xX]|(i:ext[\\.]?)){1,2}(?P<Ext>[\\d]{1,5}))?$",
        "MatchingText": "1-800-DISCOVER|||(610) 310-5555 x5555|||533-1123",
        "NonMatchingText": "1 533-1123|||553334|||66/12343",
        "Description": "This allows the formatting of most phone numbers."
    },
    {
        "Pattern": "^(([\\w][\\w\\-\\.]*)\\.)?([\\w][\\w\\-]+)(\\.([\\w][\\w\\.]*))?$",
        "MatchingText": "zigamorph.com|||www.zigamorph.com|||localhost",
        "NonMatchingText": "http://www.zigamorph.com|||ftp://zigamorph.com|||localhost/default.aspx",
        "Description": "Is used to evaluating domain names, none of the extras such as paths or protocols."
    },
    {
        "Pattern": "([\\d]{4}[ |-]?){2}([\\d]{11}[ |-]?)([\\d]{2})",
        "MatchingText": "0033-0000-01092010081-07 ||| 0033 0000 01092010081 07 ||| 003300000109201008107 ||| 0033000001092010081 07",
        "NonMatchingText": "0033-0000-01092010081-ds  |||  0033_0000_01092010081_07 ||| 0033000001092010081",
        "Description": "Matches all portuguese bank account numbers."
    },
    {
        "Pattern": "^[ABCEGHJKLMNPRSTVXYabceghjklmnprstvxy]{1}\\d{1}[A-Za-z]{1}\\d{1}[A-Za-z]{1}\\d{1}$",
        "MatchingText": "M4S1G9|||m6p1l1|||m4s1G9",
        "NonMatchingText": "M4S 1G9|||m6p 1l1|||m4s 1G9",
        "Description": "Matches the Canadian postal code with no space between."
    },
    {
        "Pattern": "^([0][1-9]|[1][0-2]):[0-5][0-9] {1}(AM|PM|am|pm)$",
        "MatchingText": "03:45 am|||10:24 PM|||01:03 pm",
        "NonMatchingText": "8:15 am||| 16:10 ||| 10:60 pm ||| 10:13",
        "Description": "Matches if the string is in hh:mm am/pm format. Also the hour and minute values should have left padding 0's if they are single digit."
    },
    {
        "Pattern": "^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$",
        "MatchingText": "01:23:45:67:89:ab|||01:23:45:67:89:AB|||fE:dC:bA:98:76:54",
        "NonMatchingText": "01:23:45:67:89:ab:cd|||01:23:45:67:89:Az|||01:23:45:56:",
        "Description": "This will grep for a valid MAC address , with colons seperating octets. It will ignore strings too short or long, or with invalid characters.  It will accept mixed case hexadecimal. Use extended grep."
    },
    {
        "Pattern": "^[13][a-zA-Z0-9]{26,33}$",
        "MatchingText": "1EEVBLgg4h4TTLv76QiQ1Thcvvk3Be7VPV",
        "NonMatchingText": "31uEbMgunupShBVTewXjtqbBv5MndwfXhbzz, L12332liteoinaddress",
        "Description": "Matches bitcoin payment (public-key) address.\n\nAddress must begin with a 1 or 3 and have 27-34 total alphanumeric characters.\nWill exclude Litecoin addresses.\n\nDoes NOT do a checksum."
    },
    {
        "Pattern": "^L[a-zA-Z0-9]{26,33}$",
        "MatchingText": "Lg6GPVfPsmPAbTWYuKBQXtdGnBuCWcxHcr",
        "NonMatchingText": "19RsSjVgob3JgU9cP9PPEiySftNpbU49Xm, qwerty, __**",
        "Description": "Matches litecoin payment (public-key) address. Address must begin with a L and have 27-34 total alphanumeric characters. Will exclude bitcoin address since they begin with 1 or 3. Does NOT do a checksum."
    },
    {
        "Pattern": "^([1-9]{1}[0-9]{0,7})+((,[1-9]{1}[0-9]{0,7}){0,1})+$",
        "MatchingText": "1,2,3455,12345678|||23045,34678,2892|||1,2,99999999",
        "NonMatchingText": "01,234,567|||123,0445,3434,|||121,,1212,,12,",
        "Description": "Validate a comma delimited string of integer between 1 and 99999999 (change {0,7} to whatever you need). No zero leading."
    },
    {
        "Pattern": "(^\\d{1,9})+(,\\d{1,9})*$",
        "MatchingText": "123,158,19 | 123456789,9568523,1 | 1,2,3",
        "NonMatchingText": "0,0, | ,3444,0999 | 1234567890,25689,1425",
        "Description": "Positive Whole number matched from 0 to 9999999. Only 9 digits length is allowed in every comma separated value.Can be easily changed to modify the length of the comma separated values."
    },
    {
        "Pattern": "^(((((0[1-9])|(1\\d)|(2[0-8]))[/.-]((0[1-9])|(1[0-2])))|((31[/.-]((0[13578])|(1[02])))|((29|30)[/.-]((0[1,3-9])|(1[0-2])))))[/.-]((000[^0])&amp;([0-9][0-9][0-9][0-9]))|(29[/.-]02[/.-](([0-9][0-9](([02468][48])|([2468][048])|([13579][26])))|((([02468][48])|([2468][048])|([13579][26]))00))))$",
        "MatchingText": "29-02/0004|||29/02/0004|||29.02.9996",
        "NonMatchingText": "29-2-0004|||29/02/0005|||29.02.0000",
        "Description": " Checks  0001-9999\n Along with leap years\n intermediate symbols can be / or . or - \n this can be modified easily "
    },
    {
        "Pattern": "^(((((0[1-9])|(1\\d)|(2[0-8]))/((0[1-9])|(1[0-2])))|((31/((0\n[13578])|(1[02])))|((29|30)/((0[1,3-9])|(1[0-2])))))/((000\n[1-9])|(00[1-9][0-9])|(0[1-9][0-9][0-9])|([1-9][0-9][0-9]\n[0-9]))|(29/02/(([0-9][0-9](([02468][48])|([2468][048])|\n([13579][26])))|((([02468][48])|([2468][048])|([13579]\n[26]))00))))$",
        "MatchingText": "29/02/0400|||01/01/0001|||31/12/9999",
        "NonMatchingText": "29/2/0400|||1/01/0001|||29/02/5555",
        "Description": "Checks for years 0001-9999.\nChecks leap year corectly (0004,0400,0040)\nCan use  / as separators or can replace it. \nEasy to understand and can be modified easily for mm/dd/yyyy or yyyy/dd/mm or mm-dd-yy or to any date format."
    },
    {
        "Pattern": "^(\\d{4}((-)?(0[1-9]|1[0-2])((-)?(0[1-9]|[1-2][0-9]|3[0-1])(T(24:00(:00(\\.[0]+)?)?|(([0-1][0-9]|2[0-3])(:)[0-5][0-9])((:)[0-5][0-9](\\.[\\d]+)?)?)((\\+|-)(14:00|(0[0-9]|1[0-3])(:)[0-5][0-9])|Z))?)?)?)$",
        "MatchingText": "2008, 2004-04-14, 1997-01-27T18:57Z, 2010-11-21T08:12:17.243+07:00 ",
        "NonMatchingText": "3:00, 2/28/2003, 2010-14-21T08:12:17.243+07:00 ",
        "Description": "Matches all valid date/datetime strings according to the W3's implementation of ISO 8601, outlined here:\nhttp://www.w3.org/TR/NOTE-datetime"
    },
    {
        "Pattern": "&([a-z]+;|#\\d+;)",
        "MatchingText": "&",
        "NonMatchingText": "&amp;amp;|&amp;quot;|&amp;#353;|&blah;|&amp;copy;",
        "Description": "Single & character is not valid in HTML or XHTML code. In this case you can replace this character with its entity (if & character is not member of other entity [&amp;#353;]). example: preg_replace('/&(?!amp;)/', '&amp;amp;', $str).\n(thanks to mr. Mrva)"
    },
    {
        "Pattern": "<img[^>]*src=\\\"?([^\\\"]*)\\\"?([^>]*alt=\\\"?([^\\\"]*)\\\"?)?[^>]*>",
        "MatchingText": "&lt;img src=\"xxx\"&gt; | &lt;img src=xxx&gt; | &lt;img src=\"xxx\" alt=\"xxx\" /&gt; | &lt;img src=\"xxx\" alt=\"xxx\" width=\"N\" height=\"N\" /&gt; | etc.",
        "NonMatchingText": "&lt;img&gt; | &lt;img /&gt; | &lt;img alt=\"XXX\" src=\"XXX\"&gt;",
        "Description": "Use this RegExp to grab SRC($1) and ALT($3) values from IMG tags in valid or invalid HTML (XHTML). SRC param must by before IMG. (thanks to mr. Mrva)"
    },
    {
        "Pattern": "^(((((\\+)?(\\s)?(\\d{2,4}))(\\s)?((\\(0\\))?)(\\s)?|0)(\\s|\\-)?)(\\s|\\d{2})(\\s|\\-)?)?(\\d{3})(\\s|\\-)?(\\d{2})(\\s|\\-)?(\\d{2})",
        "MatchingText": "0521112233, 052 111 22 33, +41 (0)52 111 22 33, +41 52 111 22 33, 0041 52 111 22 33",
        "NonMatchingText": "0041 052 111 22 33, +41 11 22 33 44",
        "Description": "This regex matchs nearly all forms off swiss phone numbers, not only the official form."
    },
    {
        "Pattern": "^((((([0-1]?\\d)|(2[0-8]))\\/((0?\\d)|(1[0-2])))|(29\\/((0?[1,3-9])|(1[0-2])))|(30\\/((0?[1,3-9])|(1[0-2])))|(31\\/((0?[13578])|(1[0-2]))))\\/((19\\d{2})|([2-9]\\d{3}))|(29\\/0?2\\/(((([2468][048])|([3579][26]))00)|(((19)|([2-9]\\d))(([2468]0)|([02468][48])|([13579][26]))))))\\s(([01]?\\d)|(2[0-3]))(:[0-5]?\\d){2}$",
        "MatchingText": "29/2/2004 15:16:57|||29/01/1900 18:17:15",
        "NonMatchingText": "29/2/1900 14:13:11",
        "Description": "My definitive Date and Time pattern (dd/mm/yyyy hh:mm:ss). It recognizes all correct dates (&gt;1900) and time (even february). What can I say, I'm proud of it"
    },
    {
        "Pattern": "\\b(((\\S+)?)(@|mailto\\:|(news|(ht|f)tp(s?))\\://)\\S+)\\b",
        "MatchingText": "href='http://www.deepart.org'|||demogorgon@deepart.org|||ftp://123.123.123.123",
        "NonMatchingText": "www.deepart.org|||deepart.org|||123.123.123.123",
        "Description": "Whilst writing a plain-text to HTML function, I ran into the problem of links that users had written with &amp;lt;a&amp;gt; tags (as opposed to just writing the URL) were linking improperly.  This regular expression returns many types of URL, and preceding characters, if any.  This allows you to handle each type of match appropriately"
    },
    {
        "Pattern": "^(http|https|ftp)\\://[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}(:[a-zA-Z0-9]*)?/?([a-zA-Z0-9\\-\\._\\?\\,\\'/\\\\\\+&amp;%\\$#\\=~])*$",
        "MatchingText": "http://www.blah.com/~joe|||ftp://ftp.blah.co.uk:2828/blah%20blah.gif|||https://blah.gov/blah-blah.as",
        "NonMatchingText": "www.blah.com|||http://www.blah&quot;blah.com/I have spaces!|||ftp://blah_underscore/[nope]",
        "Description": "Modified URL RegExp that requires (http, https, ftp)://, A nice domain, and a decent file/folder string. Allows : after domain name, and these characters in the file/folder sring (letter, numbers, - . _ ? , ' / \\ + &amp; % $ # = ~). Blocks all other special characters-good for protecting against user input!"
    },
    {
        "Pattern": "<[iI][mM][gG][a-zA-Z0-9\\s=\".]*((src)=\\s*(?:\"([^\"]*)\"|'[^']*'))[a-zA-Z0-9\\s=\".]*/*>(?:</[iI][mM][gG]>)*",
        "MatchingText": "<img src=\"gif.gif\" ></img>|<img id=\"blah\" src=\"gif\"></img>|<img src=\"gif.gif\" id=\"freaky\">|</img>|<img src=\"gif.gif\" />|<img src=\"gif.gif\"/>|<img class=\"FloatLeft Margin\" id=\"calendarButton81\" src=\"calendar.gif\" alt=\"Calendar Button\" />",
        "NonMatchingText": "<input id=\"\" value=\"\"/>",
        "Description": "Great for extracting out all the image src attributes."
    },
    {
        "Pattern": "^[+]?100(\\.0{1,2})?%?$|^[+]?\\d{1,2}(\\.\\d{1,2})?%?$",
        "MatchingText": "0    00    02    025    2.5    2.50    25.01    100    100.00    +60.63    +70.71%    0.01%",
        "NonMatchingText": "-1    101    100.01    100    000    +000    25.001    1,50    25%%    ++50    70+    80%+",
        "Description": "Matches positive percentage strings with '+' as an optional prefix and '%' as an optional postfix."
    },
    {
        "Pattern": "(?:(?:^(?P<sign>[+-]?)(?P<predec>[0-9]{1,3}(?:\\,?[0-9]{2,3})*)(?P<dec>\\.)(?P<postdec>[0-9]*)?$)|(?:^(?P<sign>[+-]?)(?P<predec>[0-9]{1,3}(?:\\.?[0-9]{2,3})*)(?P<dec>\\,)(?P<postdec>[0-9]*)?$)|(?:^(?P<sign>[+-]?)(?P<predec>[0-9]{1,3}(?:\\'?[0-9]{2,3})*)(?P<dec>\\.)(?P<postdec>[0-9]*)?$)|(?:^(?P<sign>[+-]?)(?P<predec>[0-9]{1,3}(?:\\,[0-9]{2,3})*)(?P<dec>\\.)(?P<postdec>[0-9]*)?$)|(?:^(?P<sign>[+-]?)(?P<predec>[0-9]{1,3}(?:\\ [0-9]{2,3})*)(?P<dec>\\,)(?P<postdec>[0-9]*)?$)|(?:^(?P<sign>[+-]?)(?P<predec>[0-9]{1,3}(?:\\'?[0-9]{2,3})*)(?P<dec>\\,)(?P<postdec>[0-9]*)?$))",
        "MatchingText": "234'234.231|||-234 234,231|||1,234,234.2314|||1.234.234,2314",
        "NonMatchingText": "abc|||hundred|||$12,234.23",
        "Description": "Checks a number to see if it matches any international number formats. With or without decimal characters"
    },
    {
        "Pattern": "(^(0{5})(\\d{5})(-?0{4})(|-\\d{4})?$)",
        "MatchingText": "12345 | 12345-1234",
        "NonMatchingText": "00000 | 123451234 | 12345-0000 | 00000-0000 | 00000-1234 | 000001234",
        "Description": "This expression matches two different formats of zip codes: 5 digit US ZIP code and 5 digit US ZIP code + 4.The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen, and then 4 numeric digits."
    },
    {
        "Pattern": "^[0-9]*[02468]$",
        "MatchingText": "12, 2, 012,4,44",
        "NonMatchingText": "-12,3,13",
        "Description": "All even numbers end with either 0, 2, 4, 6 or 8. They can begin with anything."
    },
    {
        "Pattern": "^(\\S+\\.{1})(\\S+\\.{1})*([^\\s\\.]+\\s*)$",
        "MatchingText": "dbo.Users.Order, dbo.Users.Order.Details",
        "NonMatchingText": "dbo.Users.Order., dbo.Users.Order.Details.",
        "Description": "Matches database schema-like strings (xxx.xxx.xxx). To control the allowed characters in xxx, just change \\S (non white-space characters) for the desired group. Demands one initial \"xxx.\", any number of intermediate \"xxx.\" groups and a final \"xxx\" group."
    },
    {
        "Pattern": "^([1-9][0][0]|[1-9][0-9][0][0]|[1-9][0-9][0-9][0][0]|[1-9][0-9][0-9][0-9][0][0]|[1-9][0-9][0-9][0-9][0-9][0][0])$",
        "MatchingText": "100 | 200 | 9999900",
        "NonMatchingText": "101 | 201 | 9999901",
        "Description": "Permite digitar valores m\u00FAltiplos de 100 entre 0 e 9999999."
    },
    {
        "Pattern": "^jdbc:db2://((?:(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))|(?:(?:(?:(?:[A-Z|a-z])(?:[\\w|-]){0,61}(?:[\\w]?[.]))*)(?:(?:[A-Z|a-z])(?:[\\w|-]){0,61}(?:[\\w]?)))):([0-9]{1,5})/([0-9|A-Z|a-z|_|#|$]{1,16})$",
        "MatchingText": "jdbc:db2://MyServer:50008/MyDb    or   jdbc:db2://10.1.63.57:50008/MyDb",
        "NonMatchingText": "jdbc:db2://MyServer/MyDb",
        "Description": "Pattern for testing a jdbc db2 url (Type 4). Format jdbc:db2://<ServerName><Port>/<DatabaseName>"
    },
    {
        "Pattern": "^(\\d[1]{2}|[5]{3})([2-9]\\d{2})([. -]*)\\d{4}$",
        "MatchingText": "222-2222|||295-5000",
        "NonMatchingText": "555-1234|||411-5555|||099-9999",
        "Description": "Validates *usable* US telephone numbers (possibly Canadian and Caribbean Islands as well?) Numbers cannot beginning with zero, one, (any number)11, or 555. It will allow either a hyphen, space or period as a separator. \n\nTechnically (and contrary to popular belief) most 555- numbers ARE valid numbers [see http://www.nanpa.com/nas/public/form555MasterReport.do?method=display555MasterReport ] but they are unlikely to be used by normal folks. Therefore, excluding them with this regex is useful to prevent bogus/fraudulent telephone numbers in forms. \n\nFYI, the fictitious 555- numbers used in the movies and TV are only in the range of 555-0100 through 555-0199. Not very many, huh?"
    },
    {
        "Pattern": "^([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}$",
        "MatchingText": "FEDC:BA98:7654:3210:FEDC:BA98:7654:3210|||1080:0:0:0:8:800:200C:417A|||0:0:0:0:0:0:0:1",
        "NonMatchingText": "128.0.0.1|||FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:AA31|||::1",
        "Description": "IPv6 text representation of addresses without compression from RFC 1884. This regular expression doesn't allow IPv6 compression (&quot;::&quot;) or mixed IPv4 addresses."
    },
    {
        "Pattern": "((079)|(078)|(077)){1}[0-9]{7}",
        "MatchingText": "0795144145,0786654433,0771471471",
        "NonMatchingText": "0886547826,A078655555,951951753",
        "Description": "Jordan mobile numbers, Zain,Umniah and Orange provider ."
    },
    {
        "Pattern": "<!--[\\\\.|\\\\W|\\\\w]*?-->",
        "MatchingText": "<!- <td> amit kumar sinha </td> -->",
        "NonMatchingText": "<td> amit kumar sinha </td> ",
        "Description": "the comments on html page can be extracted or removed."
    },
    {
        "Pattern": "(http):\\\\/\\\\/[\\\\w\\\\-_]+(\\\\.[\\\\w\\\\-_]+)+(\\\\.[\\\\w\\\\-_]+)(\\\\/)([\\\\w\\\\-\\\\.,@?^=%&amp;:/~\\\\+#]*[\\\\w\\\\-\\\\@?^=%&amp;/~\\\\+#]+)(\\\\/)((\\\\d{8}-)|(\\\\d{9}-)|(\\\\d{10}-)|(\\\\d{11}-))+([\\\\w\\\\-\\\\.,@?^=%&amp;:/~\\\\+#]*[\\\\w\\\\-\\\\@?+html^])?",
        "MatchingText": "http://kamitsinha.com/regex/191929393-latestnews.htm",
        "NonMatchingText": "http://kamitsinha.com/regex/latestnews.htm;http://kamitsinha.com/regex;http://kamitsinha.com/regex/19-latestnews.htm",
        "Description": "match http urls in format\nhttp://kamitsinha.com/regex/191929393-latestnews.htm"
    },
    {
        "Pattern": "http://(www\\.)?([^\\.]+)\\.com ",
        "MatchingText": "http://www.yahoo.com ; http://yahoo.com ",
        "NonMatchingText": "yahoo.com",
        "Description": "This regex matches 'http://' optionally followed by 'www.' then starts a group and matches one or more of any character that is not a full stop/period (.) closes the group then matches '.com'."
    },
    {
        "Pattern": "\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\"",
        "MatchingText": "abc@gmail.com",
        "NonMatchingText": "a bc@gmail.com",
        "Description": "This regular expression will only validate addresses that have had any comments stripped and replaced with whitespace (this is done by the module)."
    },
    {
        "Pattern": "^(\\+97[\\s]{0,1}[\\-]{0,1}[\\s]{0,1}1|0)50[\\s]{0,1}[\\-]{0,1}[\\s]{0,1}[1-9]{1}[0-9]{6}$",
        "MatchingText": "+97150 3827741|||0503827741|||050-3827741",
        "NonMatchingText": "040 3827741|||05 3827741|||050_______spaces_______3827741",
        "Description": "regex which matches UAE mobile phone numbers.\nIts capable to take inputs +97150 3827741, +97-150-3827741, +97150 - 3827741,050 3827741, 050 - 3827741\n\nEnjoy REGEXXXXXXX!!!!!!!"
    },
    {
        "Pattern": "^0[234679]{1}[\\s]{0,1}[\\-]{0,1}[\\s]{0,1}[1-9]{1}[0-9]{6}$",
        "MatchingText": "04 3452488|||04 -3452488|||04 - 3452499",
        "NonMatchingText": "01 -3452488|||04 34524888|||08 3452488",
        "Description": "The regex matches the UAE land phone numbers. Checks the area codes[04,02,06...etc] strictly. Force user to input phone numbers in strict manner(it take input 04 3452488, but not 04______spaces_______3452488)"
    },
    {
        "Pattern": "^0{0,1}[1-9]{1}[0-9]{2}[\\s]{0,1}[\\-]{0,1}[\\s]{0,1}[1-9]{1}[0-9]{6}$",
        "MatchingText": "0493 - 3227341|||0493  3227341|||493  3227341",
        "NonMatchingText": "93  0227341|||493  322734111|||493 -- 3227341",
        "Description": "The regex that matches the telephone numbers in India.\n\n\n####Enjoy Regex####"
    },
    {
        "Pattern": "^((\\+){0,1}91(\\s){0,1}(\\-){0,1}(\\s){0,1}){0,1}98(\\s){0,1}(\\-){0,1}(\\s){0,1}[1-9]{1}[0-9]{7}$",
        "MatchingText": "+919847444225|||+91-98-44111112|||98 44111116",
        "NonMatchingText": "+919800444225|||+947444225|||44111116",
        "Description": "The Regex validate the mobile numbers in India.\nGives flexibility to user to enter numbers in different format like\n+919847444225, +91-98-45017381, 9844111116, 98 44111112, 98-44111116\n\n###Enjoy REGEX###"
    },
    {
        "Pattern": "-[0-9]*[x][0-9]*",
        "MatchingText": "image-50x50.jpg",
        "NonMatchingText": "image.jpg",
        "Description": "I wanted to get the original size of an image placed into a Wordpress post. This should find the resized image dimensions, from here you should be able to manipulate the size of the image of remove the dimesions to get the image untouched"
    },
    {
        "Pattern": "^[-]?\\d{1,10}\\.?([0-9][0-9])?$",
        "MatchingText": "2345678901.09 | -2345678901.09",
        "NonMatchingText": "2345678901.0 | -2345678901.9 | -23456789012 | 23456789012",
        "Description": "Limits the max number of digits before the decimal point to 10; if decimal point is entered, requires entry of 2 decimal places. Allows for an optional negative sign. This pattern was derived to meet the maximum number of digits that can be stored in a decimal data type in SQL Server 2005, and allows for the way SQL Server appends the decimal places.  The column in the table is defined as decimal(12,2)."
    },
    {
        "Pattern": "^(([_\\w-+!#$%&amp;'*/=?^`{}|~]+(\\.[_\\w-+!#$%&amp;'*/=?^`{}|~]+)*)|(&quot;([ _\\w-+!#$%&amp;'*/=?^`{}|~]+(\\.[ _\\w-+!#$%&amp;'*/=?^`{}|~]+)*)&quot;))@[\\w-]{1,63}(\\\\.[\\w-]{1,63})*(\\.[_\\w-]{2,6})$",
        "MatchingText": "fred&amp;barney@stonehenge.com|||&quot;fred smith&quot;@domain.com|||sam@domain.com",
        "NonMatchingText": "rudy@asdfasdf-asdfasdf-asdfasdf-asdfasdf-asdfasdf-asdfasdf-asdfasdf-asdfasdf-asdfasdf-.com|||bad\\ema",
        "Description": "Attempt to validate email addresses. Does not support name &lt;host@domain.com&gt; format or ip addresses"
    },
    {
        "Pattern": "\\d{4}\\s\\d{4}\\s\\d{4}\\s\\d{4}$",
        "MatchingText": "1234 5678 9101 1121|||0000 0000 0000 0000|||8924 3578 3248 3212",
        "NonMatchingText": "1234-5678-9101-1121|||ABCD EFGH IJKL MNOP|||ABCD-1234 IJKL-4321",
        "Description": "Validate the Wii Code format. If you like to have slashes and spaces you can change the \"\\s\" for \"[\\s-]\""
    },
    {
        "Pattern": "((\\(\\d{3}\\)?)|(\\d{3}))([\\s-./]?)(\\d{3})([\\s-./]?)(\\d{4})",
        "MatchingText": "1.2123644567|||0-234.567/8912|||1-(212)-123 4567",
        "NonMatchingText": "0-212364345|||1212-364,4321|||0212\\345/6789",
        "Description": "US Phone number that accept a dot, a space, a dash, a forward slash, between the numbers. Will Accept a 1 or 0 in front.  Area Code not necessary"
    },
    {
        "Pattern": "^[a-zA-Z0-9\\s.\\-]+$",
        "MatchingText": "2222 Mock St.|||1 A St.|||555-1212",
        "NonMatchingText": "[A Street]|||(3 A St.)|||{34 C Ave.}",
        "Description": "ANY alphanumeric string with spaces, commas, dashes."
    },
    {
        "Pattern": "&lt;a[a-zA-Z0-9 =&quot;'.:;?]*(name=){1}[a-zA-Z0-9 =&quot;'.:;?]*\\s*((/&gt;)|(&gt;[a-zA-Z0-9 =&quot;'&lt;&gt;.:;?]*&lt;/a&gt;))",
        "MatchingText": "&lt;a name=&quot;anchorName&quot;&gt;Anchor&lt;/a&gt;|||&lt;a name=anchorName /&gt;",
        "NonMatchingText": "&lt;a href=&quot;somewhere&quot;&gt;|||&lt;a href&gt;|||&lt;a name /&gt;",
        "Description": "This expression matches only valid html anchors. Those are anchors with an attribute name=. Such anchor can be closed either with &lt;/a&gt; or with /&gt;.\n\nIf someone can help - one thing still missing is not matching html tags with parameter href, becazse such should be considered as non valid anchors."
    },
    {
        "Pattern": "&lt;a[a-zA-Z0-9 =&quot;'.?_/]*(href\\s*=\\s*){1}[a-zA-Z0-9 =&quot;'.?_/]*\\s*((/&gt;)|(&gt;[a-zA-Z0-9 =&quot;'&lt;&gt;.?_/]*&lt;/a&gt;))",
        "MatchingText": "&lt;a href=&quot;www.google.com&quot;&gt;Google&lt;/a&gt;|||&lt;a href=www.google.com /&gt;|||&lt;a ",
        "NonMatchingText": "&lt;a name=&quot;anchor&quot;&gt;Anchor&lt;/a&gt;|||&lt;img src=&quot;image.gif&quot;&gt;",
        "Description": "An expression that matches all XHTML valid hrefs (links). It even alows spaces like href = &quot;href...&quot;, dough this is not quite XHTML valid. It finds only hrefs but not for instance anchors. If you need to find only anchors, replace &quot;href&quot; within expression with &quot;name&quot; and thats it."
    },
    {
        "Pattern": "^(1?)(-| ?)(\\()?([0-9]{3})(\\)|-| |\\)-|\\) )?([0-9]{3})(-| )?([0-9]{4}|[0-9]{4})$",
        "MatchingText": "14165551212, 4165551212, (416)5551212, 416 555 1212, 416-555-1212, (416)-555-1212, (416) 555 1212, 1-900-888-1212",
        "NonMatchingText": "456-444-45464, 416-SEX-POOP, 4!6-777-#232",
        "Description": "This is a fairly forgiving phone number match. It's original purpose was to extract phone numbers from the details field in our database and into their own phone number table. It worked brilliantly. Enjoy!"
    },
    {
        "Pattern": "(\\/\\*[\\s\\S.]+?\\*\\/|[/]{2,}.*|\\/((\\\\\\/)|.??)*\\/[gim]{0,3}|'((\\\\\\')|.??)*'|\"((\\\\\\\")|.??)*\"|-?\\d+\\.\\d+e?-?e?\\d*|-?\\.\\d+e-?\\d+|\\w+|[\\[\\]\\(\\)\\{\\}:=;\"'\\-&!|+,.\\/*])",
        "MatchingText": "var a = 12.5 * 5 + 3e9;var b = \"str'\\\"ing\";var c = 'str\"\\'ing';var d = /regex/gi;var e = Func();",
        "NonMatchingText": "spaces/newline/tab",
        "Description": "Tokenize a Javascript document for parsing\n\neach token is a language-token : string, int, float, comment, multiline comment, operator, expression etc. etc."
    },
    {
        "Pattern": "(?i)((sun(day)?|mon(day)?|tue(sday)?|wed(nesday)?|thu(rsday)?|fri(day)?|sat(urday)?),?\\s)?((jan(uary)?|feb(ruary)?|mar(ch)?|apr(il)?|may|jun(e)?|jul(y)?|aug(ust)?|sep(tember)?|oct(ober)?|nov(ember)?|dec(ember)?)\\s)+((0?[1-9]|[1-2][0-9]|3[0-1]),?\\s)+([1-2][0-9][0-9][0-9])",
        "MatchingText": "Sun, Mar 7, 2012 ||| Sunday, March 7, 2012 ||| March 07, 2012 ||| SUN MARCH 7 2012",
        "NonMatchingText": "07MAR2012 ||| 03/07/2012 ||| Mar-07-2012",
        "Description": "Matches full textual date formats. Case insensitive, optional commas, short and long weekdays and months, optional weekdays, optional leading zeros in date."
    },
    {
        "Pattern": "(^(\\d+)$)|(^(\\d{1,3}[ ,\\.](\\d{3}[ ,\\.])*\\d{3}|\\d{1,3})$)",
        "MatchingText": "1 234 567|||1.234.567.890|||1,234",
        "NonMatchingText": "-12,990|||100.03|||0,05",
        "Description": "Searches for number greater than 0 with thousand delimiter as space, comma or period."
    },
    {
        "Pattern": "^[\\w0-9&#228;&#196;&#246;&#214;&#252;&#220;&#223;\\-_]+\\.[a-zA-Z0-9]{2,6}$",
        "MatchingText": "gut.txt",
        "NonMatchingText": "&amp;quatsch|||qua%tsch.txt|||auch_quatsch.test.txt",
        "Description": "This RegEx can be used to varify (esp. when receiving data from forms) filenames. No Path is allowed. German Special Characters are allowed."
    },
    {
        "Pattern": "/(A|B|AB|O)[+-]/",
        "MatchingText": "A+|B-|AB+",
        "NonMatchingText": "AA|BC|AZ-",
        "Description": "Matches all currently known positive and negative blood groups, i.e. A+, A-, B+, B-, O+, O-, AB+, AB-"
    },
    {
        "Pattern": "(?:\\s+)|((?:\"(?:.+?)\")|(?:'(?:.+?)')) ",
        "MatchingText": "REGEX ROCKS",
        "NonMatchingText": "\"SOME QUOTED STRING\", \"REGEX'S ROCKS\", 'REGEX ROCKS'",
        "Description": "When removing any whitespace from something like an excel formula, you need to strip the whitespace from around cell references or other non-quoted strings, while leaving quoted (both single and double quotes) in tact.  It even works when another different quote, or double quote is embedded in the string.  You can execute this with a replacement group $1 to replace the spaces with another character (or empty string to remove the spaces).  Does not match if the quoted string spans multiple lines (if \\r\\n is inside the quoted string)"
    },
    {
        "Pattern": "[^ _0-9a-zA-Z\\$\\%\\'\\-\\@\\{\\}\\~\\!\\#\\(\\)\\&\\^]",
        "MatchingText": "one$two folder_name file@name",
        "NonMatchingText": "one:two folder*name file:name",
        "Description": "Use this regular expression to find any invalid characters within a DOS 8.3 Directory or Folder name.\n\nReference: http://support.microsoft.com/?id=120138"
    },
    {
        "Pattern": "<\\/*?([^>]*?\\b(?:a|img)\\b)[^>]*?>",
        "MatchingText": "<script> </html> <anytag>",
        "NonMatchingText": "<a> <img /> </a>",
        "Description": "This regex will match all HTML tags except 'a' tags or 'img' tags. You can edit the list of exclusions as you see fit. I use this regex to strip all HTML tags from source data except anchor tags and image tags."
    },
    {
        "Pattern": "\\\"[^\"]+\\\"|\\([^)]+\\)|[^\\\"\\s\\()]+",
        "MatchingText": "one, two, three, \"four five\", (six seven)",
        "NonMatchingText": "\"four, five\", (six, seven)",
        "Description": "RegEx parses out all whole words, phrases within quotes or parentheses."
    },
    {
        "Pattern": "^[{][A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}[}]$|^[A-Za-z0-9]{8}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{4}-[A-Za-z0-9]{12}$",
        "MatchingText": "778ed84f-2f9c-42b5-b314-4d0e0cde8422, {778ed84f-2f9c-42b5-b314-4d0e0cde8422}",
        "NonMatchingText": "778ed84f-2f9c-42b5-b314-4d0e0cde8422}, {778ed84f-2f9c-42b5-b314-4d0e0cde8422",
        "Description": "This RegEx validates a GUID number with or without curly brackets. But requires both brackets if any is provided. This version is compatible with VBScript's RegEx engine"
    },
    {
        "Pattern": "(\\d\\d\\d\\d)-?(\\d\\d)-?(\\d\\d)T?(\\d\\d):?(\\d\\d)(?::?(\\d\\d)(\\.\\d+)*?)?(Z|[+-])(?:(\\d\\d):?(\\d\\d))?",
        "MatchingText": "2009-06-18T18:50:57-06:00, 2009-06-18T18:30:01.123478-06:00, 2009-06-18T18:30:45Z, 2009-06-18T18:39Z",
        "NonMatchingText": "January 5, 1995, or other non ISO8601 dates.",
        "Description": "This regular expression will parse an ISO8601 date into it's individual parts."
    },
    {
        "Pattern": "^(\\d{4})(?:-([0]\\d|[1][0-2]))(?:-([0-2]\\d|[3][01]))(?:T([01]\\d|2[0-3]))(?::([0-5]\\d))(?::([0-5]\\d)(?:\\.(\\d{1,7}?)|)|)(Z|([+-])([01]\\d|2[0-3])(?::([0-5]\\d)))$",
        "MatchingText": "2013-12-01T04:33Z, 2013-12-01T04:33:12.234Z, 2013-12-01T23:12-07:00",
        "NonMatchingText": "2013, 2013-12, 2013-12-01, 2013-99-99T99:99Z",
        "Description": "Good for JavaScript. Parses an ISO8601 Date into separate Date() object parts, so you can set a Date object by passing in an ISO8601 string. NOTE: Will not match illegal dates such as the 32nd day of a month or the 61st minute of an hour, etc.\n\nUse like this:\n\tif (regexFull.test(dString)) {\n\t\tmatches = dString.toString().match(regexFull);\n\t\toffset = 0;\n\t\tdate.setUTCDate(1);\n\t\tdate.setUTCFullYear(parseInt(matches[1],10));\n\t\tdate.setUTCMonth(parseInt(matches[2],10) - 1);\n\t\tdate.setUTCDate(parseInt(matches[3],10));\n\t\tdate.setUTCHours(parseInt(matches[4],10));\n\t\tdate.setUTCMinutes(parseInt(matches[5],10));\n\t\tif (matches[6]) {\n\t\t\tdate.setUTCSeconds(parseInt(matches[6],10));\n\t\t}\n\t\tif (matches[7]) {\n\t\t\tdate.setUTCMilliseconds(parseInt(matches[7]));\n\t\t}\n\t\tif (matches[8] != 'Z') {\n\t\t\toffset = (matches[10] * 60) + parseInt(matches[11],10);\n\t\t\toffset *= ((matches[9] == '-') ? -1 : 1);\n\t\t\tdate.setTime(date.getTime() - offset * 60 * 1000);\n\t\t}\n\t}"
    },
    {
        "Pattern": "^[ .a-zA-Z0-9:-]{1,150}$",
        "MatchingText": "This is a test.|||This. is - a test:.|||This is 123 test.",
        "NonMatchingText": "This / is a test?|||This is a test*",
        "Description": "Belgian Carenet message Alphanumerical field - as described in the 'programmer's guide for carenet - Belgacom'. \nOnly the following characters, ASCII, are authorised:\nSpace . - : \nAlphanumerical characters (a-z and A-Z)\nNumerical characters (0-9)\n\nLength is restricted to 150 chars"
    },
    {
        "Pattern": "^(http(?:s)?\\:\\/\\/[a-zA-Z0-9]+(?:(?:\\.|\\-)[a-zA-Z0-9]+)+(?:\\:\\d+)?(?:\\/[\\w\\-]+)*(?:\\/?|\\/\\w+\\.[a-zA-Z]{2,7}(?:\\?[\\w]+\\=[\\w\\-]+)?)?(?:\\&[\\w]+\\=[\\w\\-]+)*)$",
        "MatchingText": "http://website.com | http://subdomain.web-site.com/cgi-bin/perl.cgi?key1=value1&key2=value2",
        "NonMatchingText": "http://website.com/perl.cgi?key= | http://web-site.com/cgi-bin/perl.cgi?key1=value1&key2",
        "Description": "A simple but powerful URL validating regex. Accepts multiple sub-domains and sub-directories. Even accepts query strings ande ports! Accepts HTTP or HTTPS. Also accepts optional \"/\" on end of address. This may be the mother of all URL regexes. It's much more stricter than most others that do far less."
    },
    {
        "Pattern": "^([a-zA-Z0-9]+(?:[.-]?[a-zA-Z0-9]+)*@[a-zA-Z0-9]+(?:[.-]?[a-zA-Z0-9]+)*\\.[a-zA-Z]{2,7})$",
        "MatchingText": "name@email.com",
        "NonMatchingText": "_name@.email.com",
        "Description": "Yet another regex to help validate email addresses. This will work for 99% of all email addresses entered into the average website form. Stricter than RFC2822."
    },
    {
        "Pattern": "^(http\\:\\/\\/[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,7}(?:\\/[\\w\\-]+)*\\.(?:jpg|jpeg|gif|png))$",
        "MatchingText": "http://website.com/directory/image.gif",
        "NonMatchingText": "www.website.com/image.php",
        "Description": "An overly simple regex to verify a URL pointing towards an image. It's usually all you need for this purpose."
    },
    {
        "Pattern": "^((?:\\?[a-zA-Z0-9_]+\\=[a-zA-Z0-9_]+)?(?:\\&[a-zA-Z0-9_]+\\=[a-zA-Z0-9_]+)*)$",
        "MatchingText": "?key=value | ?key1=value1&key2=value2",
        "NonMatchingText": "key=value | ?key=value&",
        "Description": "This is a very simple regex that check the query part of a string. That is to say anything after the \"?\" at the end of an URL."
    },
    {
        "Pattern": "^((?:\\/[a-zA-Z0-9]+(?:_[a-zA-Z0-9]+)*(?:\\-[a-zA-Z0-9]+)*)+)$",
        "MatchingText": "/users/web/mysite/web/cgi-bin",
        "NonMatchingText": "/users/web/my site/web/cgi-bin | users/web/mysite/web/cgi-bin/",
        "Description": "An overly simple UNIX based path regex. The path must begin with a forward slash. The path segments may not lead or end with an underscore or dash which is a good thing. They also can not be doubled (__ or --). Another good thing. I've omitted all the punctuation that RFC allows until further notice."
    },
    {
        "Pattern": "^\\d+$",
        "MatchingText": "2|||50|||0",
        "NonMatchingText": "-15|||1.2",
        "Description": "This is derived from Steven Smith's Integer expression (http://www.regexlib.com/REDetails.aspx?regexp_id=51). The only difference is that this does not accept blanks. Written by Jason N. Gaylord."
    },
    {
        "Pattern": "^(\\d{3}-\\d{3}-\\d{4})*$",
        "MatchingText": "555-555-1212|||123-456-7890",
        "NonMatchingText": "555.555.1212|||(555) 555-1212|||5555551212",
        "Description": "This expression is a very simplex expression that allows null values or 3 digits, dash, 3 digits, dash, 4 digits. It validates a basic US phone number. Written by Jason N. Gaylord."
    },
    {
        "Pattern": "^(\\d{2}-\\d{2})*$",
        "MatchingText": "00-00|||54-68",
        "NonMatchingText": "1235|||0|||5-789",
        "Description": "This expression is a simplex expression that checks to see if a value is a valid phone system terminal number. It allows a null value or 2 digits, dash, 2 digits. Written by Jason N. Gaylord."
    },
    {
        "Pattern": "\\{[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}\\}",
        "MatchingText": "{A2B95C88-F211-4A2B-9729-2CFAB45C8984}|||{A2B95C88-F211-4A2B-9729-2CFAB45C8123}|||{A2B95C88-F211-4A2",
        "NonMatchingText": "A2B95C88-F211-4A2B-9729-2CFAB45C8984|||A2B95C88F2114A2B9729-2CFAB45C8984|||123456a",
        "Description": "This matches the specific value for a unique identifier (GUID) from SQL server. Written by Jason N. Gaylord."
    },
    {
        "Pattern": "^((AL)|(AK)|(AS)|(AZ)|(AR)|(CA)|(CO)|(CT)|(DE)|(DC)|(FM)|(FL)|(GA)|(GU)|(HI)|(ID)|(IL)|(IN)|(IA)|(KS)|(KY)|(LA)|(ME)|(MH)|(MD)|(MA)|(MI)|(MN)|(MS)|(MO)|(MT)|(NE)|(NV)|(NH)|(NJ)|(NM)|(NY)|(NC)|(ND)|(MP)|(OH)|(OK)|(OR)|(PW)|(PA)|(PR)|(RI)|(SC)|(SD)|(TN)|(TX)|(UT)|(VT)|(VI)|(VA)|(WA)|(WV)|(WI)|(WY))$",
        "MatchingText": "NY|||PA|||NJ",
        "NonMatchingText": "Pennsylvania|||Pa|||pa",
        "Description": "This validates the states and territories of the United States in a 2 character uppercase format. Very poor excuse for a regular expression!  ;)\n\nWritten by Jason Gaylord."
    },
    {
        "Pattern": "^([\\(]{1}[0-9]{3}[\\)]{1}[ ]{1}[0-9]{3}[\\-]{1}[0-9]{4})$",
        "MatchingText": "(555) 555-1212",
        "NonMatchingText": "555-1212|||1-800-555-1212|||555-555-1212",
        "Description": "It is the exact phone number regular expression for '(###) ###-####'.\n\nWritten by Jason Gaylord."
    },
    {
        "Pattern": "^\\(?082|083|084|072\\)?[\\s-]?[\\d]{3}[\\s-]?[\\d]{4}$",
        "MatchingText": "082-131-5555|||083-145-654|||072 555 1212",
        "NonMatchingText": "131-253-4564|||5551212|||800 555 1212",
        "Description": "I modified the existing phone number regex for another user looking to only allow 082, 083, 084, or 072 exchanges. Written by Jason Gaylord"
    },
    {
        "Pattern": "^(([0]?[0-5][0-9]|[0-9]):([0-5][0-9]))$",
        "MatchingText": "30:05|||5:05|||02:59",
        "NonMatchingText": "25:7|||5m:16|||60:60",
        "Description": "This regex is to validate the time of a ~60 minute CD where the most time on the CD is 59:59 (minutes:seconds). It is derived from Ken Madden's time regex for a project for Erik Porter (Windows/Web guru). Written by Jason Gaylord."
    },
    {
        "Pattern": "^100(\\.0{0,2})? *%?$|^\\d{1,2}(\\.\\d{1,2})? *%?$",
        "MatchingText": "100% 100.00 % 95.4% 1.2 % 12",
        "NonMatchingText": "100.01% 120% -1.2% 95.445% 12%%",
        "Description": "Match any percentage entered between 0.00 and 100.00%, includes up to 2 decimal places. Percent sign is optional"
    },
    {
        "Pattern": "^[+-]? *100(\\.0{0,2})? *%?$|^[+-]? *\\d{1,2}(\\.\\d{1,2})? *%?$",
        "MatchingText": "-96.4% -100% 100% 9% 9.10%",
        "NonMatchingText": "-101% 101% 100.01% 9.288%",
        "Description": "Match any percent from -100.00% to +100.00% up to 2 decimla places. Percent sign is optional"
    },
    {
        "Pattern": "^[+-]? *(\\$)? *((\\d+)|(\\d{1,3})(\\,\\d{3})*)(\\.\\d{0,2})?$",
        "MatchingText": "$ 10.00 -$12 $12 $12,122.90",
        "NonMatchingText": "--$10 $123,1234.00",
        "Description": "Full currency testing, allows up to 2 decimal places.  Checks for corect formatting with commas etc, and allows negative amounts"
    },
    {
        "Pattern": "^([0-9]{5})([\\-]{1}[0-9]{4})?$",
        "MatchingText": "18017|||18017-1401",
        "NonMatchingText": "1801A|||18017-|||18017-152A",
        "Description": "Validates against a U.S. postal code in either a 5 digit format or a 5 dash 4 format."
    },
    {
        "Pattern": "^([4]{1})([0-9]{12,15})$",
        "MatchingText": "4125632152365|||418563256985214|||4125632569856321",
        "NonMatchingText": "3125652365214|||41256321256|||42563985632156322",
        "Description": "Validate against a visa card number. All visa cards start with a 4 and are followed by 12 to 15 more numbers."
    },
    {
        "Pattern": "^([51|52|53|54|55]{2})([0-9]{14})$",
        "MatchingText": "5125632154125412|||5225632154125412|||5525632154125412",
        "NonMatchingText": "5625632154125412|||4825632154125412|||6011632154125412",
        "Description": "Validate against any mastercard number. All MC's start with a number between 51 and 55 and are followed by 14 other numbers."
    },
    {
        "Pattern": "^([34|37]{2})([0-9]{13})$",
        "MatchingText": "341256321524212|||371524254523125",
        "NonMatchingText": "425152365212542|||34256321523621|||3712563212523651",
        "Description": "Validate against any american express number. All american express numbers start with either a 34 or 37, followed by 13 other numbers."
    },
    {
        "Pattern": "^([6011]{4})([0-9]{12})$",
        "MatchingText": "6011212541254121|||6011523654125685",
        "NonMatchingText": "5021152365212541|||601126523652321|||60112563212563215",
        "Description": "Validate against any discover card number. All DC's start with 6011 and are followed by 12 other numbers."
    },
    {
        "Pattern": "^([30|36|38]{2})([0-9]{12})$",
        "MatchingText": "30125212365212|||36125212365212|||38125212365212",
        "NonMatchingText": "301252123652121|||40256631125452|||361251254125212",
        "Description": "Validate against any diner's club card. All diner club cards start with 30,36, or 38, followed by 12 other numbers."
    },
    {
        "Pattern": "(?P<Date>(?P<Year>\\d{4})-(?P<Month>\\d{2})-(?P<Day>\\d{2}))(?:T(?P<Time>(?P<SimpleTime>(?P<Hour>\\d{2}):(?P<Minute>\\d{2})(?::(?P<Second>\\d{2}))?)?(?:\\.(?P<FractionalSecond>\\d{1,7}))?(?P<Offset>-\\d{2}\\:\\d{2})?))?",
        "MatchingText": "2006-04-06T12:31:39.6230000-05:00",
        "NonMatchingText": "4/6/2006",
        "Description": "Parses out the elements of a date in ISO 8601 format."
    },
    {
        "Pattern": "^([3]{1}[0-1]{1}|[1-1]?[0-9]{1})-([0-1]?[0-2]{1}|[0-9]{1})-[0-9]{4}([\\s]+([2]{1}[0-3]{1}|[0-1]?[0-9]{1})[:]{1}([0-5]?[0-9]{1})([:]{1}([0-5]?[0-9]{1}))?)?$",
        "MatchingText": "31-12-2009 23:59:59|||1-1-2010 10:00|||01-01-2010",
        "NonMatchingText": "32-12-2009|||01-13-2010|||01-01-2010 01",
        "Description": "Validates dutch (european) date and time combination (dd-mm-yyyy). Dates are accepted, date and time is accepted. The time notation (hh:mm:ss) may or may not contain a value for seconds"
    },
    {
        "Pattern": "\"(\"\"|[^\"])*\"",
        "MatchingText": "\"\" \"Hello\" \"\"\"Wow\"\", he said\" \"\"\"\"\"\"",
        "NonMatchingText": "\"Unclosed",
        "Description": "This will match the VB-style quoted string. That means to use \" in the quoted string you must use \"\" instead."
    },
    {
        "Pattern": "\"(\\\\.|[^\"])*\"",
        "MatchingText": "\"\" \"!\" \"Hello\" \"Es\\\"Cape\" \"Backslash \\\\\"",
        "NonMatchingText": "\"Backslash\\\", \"Unclosed",
        "Description": "This time is for C-Style Quoted String matching. So to use \" in the quoted string you need to use \\\" and if you wanted to use \\ in your string, use \\\\."
    },
    {
        "Pattern": "([a-zA-Z1-9]*)\\.(((a|A)(s|S)(p|P)(x|X))|((h|H)(T|t)(m|M)(l|L))|((h|H)(t|T)(M|m))|((a|A)(s|S)(p|P))|((t|T)(x|X)(T|x))|((m|M)(S|s)(P|p)(x|X))|((g|G)(i|I)(F|f))|((d|D)(o|O)(c|C)))",
        "MatchingText": "filename.doc,pagename.aspx etc ",
        "NonMatchingText": "page.jpg",
        "Description": "Validate Filename,PageName,ImageName etc\nsuch as\nfilename.doc\nfilename.xls\npagename.aspx\npagename.asp\npagename.htm\npagename.html\nExtensions \netc ..."
    },
    {
        "Pattern": "(?P<Year>(19|20)[0-9][0-9])-(?P<Month>0[1-9]|1[0-2])-(?P<Day>0[1-9]|[12][0-9]|3[01])",
        "MatchingText": "1900-01-01|||2099-12-31|||2004-10-11",
        "NonMatchingText": "2004-01-00|||2004-00-01|||0000-01-01",
        "Description": "This pattern will match all dates from the year 1900 to 2099, invalid dates like 0000-00-00 will not be accepted.\nReplacement string can be used as the Year Month  and day is named.\nThe &quot;-&quot; character can be replaced with &quot;/&quot; character for the required format, and also the &lt;Year&gt;, &lt;Month&gt; and &lt;Day&gt; can also be interchanged according the local culture format (eg dd/mm/yy)"
    },
    {
        "Pattern": "^([0-9]*|\\d*\\.\\d{1}?\\d*)$",
        "MatchingText": ".568|||8578|||1234567.1234567",
        "NonMatchingText": "568.|||56.89.36|||5.3.6.9.6",
        "Description": "Accept only (0-9) integer and one decimal point(decimal point is also optional).After decimal point it accepts at least one numeric .This will be usefull in money related\nfields or decimal fields. "
    },
    {
        "Pattern": "^(((((0[1-9])|(1\\d)|(2[0-8]))/((0[1-9])|(1[0-2])))|((31/((0[13578])|(1[02])))|((29|30)/((0[1,3-9])|(1[0-2])))))/((20[0-9][0-9]))|((((0[1-9])|(1\\d)|(2[0-8]))/((0[1-9])|(1[0-2])))|((31/((0[13578])|(1[02])))|((29|30)/((0[1,3-9])|(1[0-2])))))/((19[0-9][0-9]))|(29/02/20(([02468][048])|([13579][26])))|(29/02/19(([02468][048])|([13579][26]))))$",
        "MatchingText": "29/02/1992|||29/02/2000|||29/02/2004",
        "NonMatchingText": "29/02/1892|||29/02/2100|||29/02/3004",
        "Description": "This expression is an improved version of J&#246;rg Maag. It checks a date field in the Australian DD/MM/YYYY format. Besides, it also validates leap year between 1900 and 2099."
    },
    {
        "Pattern": "^([A-Z]{3,20}\\s?[A-Z]{2}[0-9]{1,3}-([A-Z]{3}|[A-Z]{1}[0-9]{2}))|([A-Z]{1,20}\\s[A-Z]{1,2}[0-9]{1,4}-[A-Z]{1,3})|([\\d,\\w,\\s]{1,20}\\s[A-Z]{3}-[0-9]{1,3})|([A-Z]{1,20}\\s?[\\d,\\w,\\s]{1,20})$",
        "MatchingText": "OSUN BL897 LES | POLICE SS1234-SPY |  OHA 679 | DIPLOMATIC EDY-123",
        "NonMatchingText": "OSUN BL859 LE | LHA-456 | ",
        "Description": "Regular expression for vehicle registration number according to these formats:\nSTATE PRECODENUMBER-LGA for public (commercial and private) (STATEXXX XX999- XXX), for customized: STATE ANYFORMAT (alphanumeric), and government/diplomatic (House of Assembly, Ministries, Commissions,etc) like LAGOS LA123-A03, OHA 67,..... Enjoy!"
    },
    {
        "Pattern": "(\\d{5}-\\d{4}|\\d{5})",
        "MatchingText": "Ohio 43050-2495 USA, Houston 77053 USA Texax",
        "NonMatchingText": "USA 4512, Texas 1234-1234 US",
        "Description": "Matches:\nfive digits hypen four digits\nor just five digits\nanywhere within string.\nC#\nstring reg_usa_postcode = @\"(\\d{5}-\\d{4}|\\d{5})\";"
    },
    {
        "Pattern": "(.*)-----(BEGIN|END)([^-]*)-----(.*)",
        "MatchingText": "-----BEGIN PGP ENCRYPTED MESSAGE-----,-----END CERTIFICATE SIGNING REQUEST-----,-----END RSA PRIVATE KEY-----",
        "NonMatchingText": "-----This is a header-----,-----Account info-----",
        "Description": "This is very useful if you dont want your employees to send encrypted mail, or downloading public keys from HTTP. It also catches certficates, CSR and other useless stuff that is only used to hide data from antivirus programs and such things."
    },
    {
        "Pattern": "^\\$?([0-9]{1,3},([0-9]{3},)*[0-9]{3}|[0-9]+)(\\.[0-9][0-9])?$",
        "MatchingText": "$3,023,123.34|||9,876,453|||123456.78",
        "NonMatchingText": "4,33,234.34|||$1.234|||abc",
        "Description": "Matches US currency input with or without commas.  This provides a fix for the currency regular expression posted at http://regxlib.com/REDetails.aspx?regexp_id=70 by escaping the . (period) to ensure that no other characters may be used in it's place."
    },
    {
        "Pattern": "(^[Bb][Ff][Pp][Oo]\\s*[0-9]{1,4})|(^[Gg][Ii][Rr]\\s*0[Aa][Aa]$)|([Aa][Ss][Cc][Nn]|[Bb][Bb][Nn][Dd]|[Bb][Ii][Qq][Qq]|[Ff][Ii][Qq][Qq]|[Pp][Cc][Rr][Nn]|[Ss][Ii][Qq][Qq]|[Ss][Tt][Hh][Ll]|[Tt][Dd][Cc][Uu]\\s*1[Zz][Zz])|(^([Aa][BLbl]|[Bb][ABDHLNRSTabdhlnrst]?|[Cc][ABFHMORTVWabfhmortvw]|[Dd][ADEGHLNTYadeghlnty]|[Ee][CHNXchnx]?|[Ff][KYky]|[Gg][LUYluy]?|[Hh][ADGPRSUXadgprsux]|[Ii][GMPVgmpv]|[JE]|[je]|[Kk][ATWYatwy]|[Ll][ADELNSUadelnsu]?|[Mm][EKLekl]?|[Nn][EGNPRWegnprw]?|[Oo][LXlx]|[Pp][AEHLORaehlor]|[Rr][GHMghm]|[Ss][AEGK-PRSTWYaegk-prstwy]?|[Tt][ADFNQRSWadfnqrsw]|[UB]|[ub]|[Ww][A-DFGHJKMNR-Wa-dfghjkmnr-w]?|[YO]|[yo]|[ZE]|[ze])[1-9][0-9]?[ABEHMNPRVWXYabehmnprvwxy]?\\s*[0-9][ABD-HJLNP-UW-Zabd-hjlnp-uw-z]{2}$)",
        "MatchingText": "BHPO 111 ||| GIR 0AA ||| SW1 1ZZ ||| BT1 3RT",
        "NonMatchingText": "SW1 1ZZ1 ||| BT01 3RT",
        "Description": "This is my combination of other UK postcode examples to date in this library. This is similar to Howard Richards\u2019s solution in that it only permits valid combinations of letters, e.g. BN works, BM does not. The space(s) are optional, and the string to match does not have to be in an upper or lower case. On top of that this allows BFPO (http://www.bfpo.mod.uk/bfponumbers_ships.htm) and Overseas Territories Postcodes (http://en.wikipedia.org/wiki/UK_postcodes) Please let me know if you have any suggetion to improve this!"
    },
    {
        "Pattern": "(^BFPO\\s*[0-9]{1,4})|(^GIR\\s*0AA$)|(ASCN|BBND|BIQQ|FIQQ|PCRN|SIQQ|STHL|TDCU\\s*1ZZ)|(^(A[BL]|B[ABDHLNRST]?|C[ABFHMORTVW]|D[ADEGHLNTY]|E[CHNX]?|F[KY]|G[LUY]?|H[ADGPRSUX]|I[GMPV]|JE|K[ATWY]|L[ADELNSU]?|M[EKL]?|N[EGNPRW]?|O[LX]|P[AEHLOR]|R[GHM|S[AEGK-PRSTWY]?|Y[ADFNQRSW|UB|W[A-DFGHJKMNR-W]?|[YO]|[ZE])[1-9][0-9]?[ABEHMNPRVWXY]?\\s*[0-9][ABD-HJLNP-UW-Z]{2}$)",
        "MatchingText": "BHPO 111 ||| GIR 0AA ||| SW1 1ZZ ||| BT1 3RT",
        "NonMatchingText": "SW1 1ZZ1 ||| BT01 3RT",
        "Description": "This is my combination of other UK postcode examples to date in this library. This is similar to Howard Richards\u2019s solution in that it only permits valid combinations of letters, e.g. BN works, BM does not. The space(s) are optional, the string to match should be in upper case. On top of that, this solution allows BFPO (http://www.bfpo.mod.uk/bfponumbers_ships.htm) and Overseas Territories Postcodes (http://en.wikipedia.org/wiki/UK_postcodes) Please let me know if you have any suggetion to improve this!"
    },
    {
        "Pattern": "^[H][R][\\-][0-9]{5}$",
        "MatchingText": "HR-00000|||HR-99999",
        "NonMatchingText": "HR 00000|||00000",
        "Description": "Simple expression for internationally formatted croatian postcodes."
    },
    {
        "Pattern": "^(((19|2\\d)\\d{2}\\/(((0?[13578]|1[02])\\/31)|((0?[1,3-9]|1[0-2])\\/(29|30))))|((((19|2\\d)(0[48]|[2468][048]|[13579][26])|(2[048]00)))\\/0?2\\/29)|((19|2\\d)\\d{2})\\/((0?[1-9])|(1[0-2]))\\/(0?[1-9]|1\\d|2[0-8]))$",
        "MatchingText": "2008/2/29|||2010/12/31|||2400/02/29",
        "NonMatchingText": "2009/2/29|||2010/11/31|||2100/02/29",
        "Description": "this expression validates a date-time field in yyyy/m/d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1900-2999, and all 2 digits years except 00"
    },
    {
        "Pattern": "^(((1[6-9]|[2-9]\\d)\\d{2}\\/(((0?[13578]|1[02])\\/31)|((0?[1,3-9]|1[0-2])\\/(29|30))))|((((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))\\/0?2\\/29)|((1[6-9]|[2-9]\\d)\\d{2})\\/((0?[1-9])|(1[0-2]))\\/(0?[1-9]|1\\d|2[0-8]))$",
        "MatchingText": "2008/2/29|||2010/12/31|||2400/02/29",
        "NonMatchingText": "2009/2/29|||2010/11/31|||2100/02/29",
        "Description": "this expression validates a date-time field in yyyy/m/d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00"
    },
    {
        "Pattern": "^(((1[6-9]|[2-9]\\d)\\d{2}([-|\\/])(((0?[13578]|1[02])([-|\\/])31)|((0?[1,3-9]|1[0-2])([-|\\/])(29|30))))|((((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))([-|\\/])0?2([-|\\/])29)|((1[6-9]|[2-9]\\d)\\d{2})([-|\\/])((0?[1-9])|(1[0-2]))([-|\\/])(0?[1-9]|1\\d|2[0-8]))$",
        "MatchingText": "2008/2/29|||2010/12/31|||2400-02-29",
        "NonMatchingText": "2009/2/29|||2010/11/31|||2100-02-29",
        "Description": "this expression validates a date-time field in yyyy/m/d or yyyy-m-d format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00"
    },
    {
        "Pattern": "^(((1[6-9]|[2-9]\\d)\\d{2}([-|\\/])(((0?[13578]|1[02])([-|\\/])31)|((0?[1,3-9]|1[0-2])([-|\\/])(29|30))))|((((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)))([-|\\/])0?2([-|\\/])29)|((1[6-9]|[2-9]\\d)\\d{2})([-|\\/])((0?[1-9])|(1[0-2]))([-|\\/])(0?[1-9]|1\\d|2[0-8]))(\\s)((([0]?[1-9]|1[0-2])(:|\\.)[0-5][0-9]((:|\\.)[0-5][0-9])?(\\s)?([aApP][mM]))|(([0]?[0-9]|1[0-9]|2[0-3])(:|\\.)[0-5][0-9]((:|\\.)[0-5][0-9])?))$",
        "MatchingText": "2008/2/29 8:25:59|||2010/12/31 11:25AM|||2400-02-29 09:30",
        "NonMatchingText": "2009/2/29 8:25:59|||2010/11/31 11:25AM|||2100-02-29 09:30",
        "Description": "this expression validates a date-time field in yyyy/m/d h:m:s or yyyy-m-d h:m:s format. The days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00.\nMatches times seperated by either : or . will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required."
    },
    {
        "Pattern": "^([0]\\d|[1][0-2]\\/([0-2]\\d|[3][0-1])\\/([2][0]\\d{2})\\s([0-1]\\d|[2][0-3])\\:[0-5]\\d\\:[0-5]\\d)?\\s(AM|am|aM|Am|PM|pm|pM|Pm)",
        "MatchingText": "10/13/2008 12:00:00 AM, 10/13/2008 12:00:00 PM",
        "NonMatchingText": "10/13/2008 12:00:00",
        "Description": "Date Time with am/pm."
    },
    {
        "Pattern": "/((https?|ftp)\\:\\/\\/)?([a-z0-9+!*(),;?&=\\$_.-]+(\\:[a-z0-9+!*(),;?&=\\$_.-]+)?@)?(([a-z0-9-.]*)\\.([a-z]{2,6}))|(([0-9]{1,3}\\.){3}[0-9]{1,3})(\\:[0-9]{2,5})?(\\/([a-z0-9+\\$_-]\\.?)+)*\\/?(\\?[a-z+&\\$_.-][a-z0-9;:@&%=+\\/\\$_.-]*)?(#[a-z_.-][a-z0-9+\\$_.-]*)?/i",
        "MatchingText": "google.com",
        "NonMatchingText": "file://hello.txt",
        "Description": "This could be most complete and readable URL-finder regex. I built it from several good examples. Works with PHP preg_match_all(). Finds whatever string that resembles a URL with scheme://, user:password, subdomains.domain (with up to 6 chars top-domain) or IP address xxx.xxx.xxx.xxx, :port, /file/path/, ?request, and #anchor"
    },
    {
        "Pattern": "^(3[0-5]|[012][0-9]|[1-9])\\d{9}$",
        "MatchingText": "starting with 01 to 35",
        "NonMatchingText": "starting with 0 and above 36",
        "Description": "It consists of 11 digit numerals and will be unique throughout the country. First two characters will represent the State Code as used by the Union Ministry of Home Affairs."
    },
    {
        "Pattern": "/[a-z]{3}[cphfatblj][a-z]\\d{4}[a-z]/i",
        "MatchingText": "AAAAA9999A ||| aaaaa9999a",
        "NonMatchingText": "AAAAA99999 ||| 11111aaaaa ",
        "Description": "First 5 letters, next 4 numerals, last character letter.This also validates the fourth character as one of C,P,H,F,A,T,B,L,J,G and it uses the case insensitive flag"
    },
    {
        "Pattern": "^(((\\\\\\\\([^\\\\/:\\*\\?\"\\|<>\\. ]+))|([a-zA-Z]:\\\\))(([^\\\\/:\\*\\?\"\\|<>\\. ]*)([\\\\]*))*)$",
        "MatchingText": "C:\\abc\\xyz, c:\\, \\\\server10\\mnop",
        "NonMatchingText": "c:, \\\\server?abc , c:\\abc|mno\\abc\\xyz",
        "Description": "I'm very new to reg exp\nI've given a try ...\n\nfor C#\n@\"^(((\\\\\\\\([^\\\\/:\\*\\?\"\"\\|<>\\. ]+))|([a-zA-Z]:\\\\))(([^\\\\/:\\*\\?\"\"\\|<>\\. ]*)([\\\\]*))*)$\"\n\nIt worked for me ...\nMake neccessary changes as required"
    },
    {
        "Pattern": "&lt;[^&gt;\\s]*\\bauthor\\b[^&gt;]*&gt;",
        "MatchingText": "&lt;author name=&quot;Daniel&quot;&gt;|||&lt;/sch:author&gt;|||&lt;pp:author name=&quot;Daniel&quot;",
        "NonMatchingText": "&lt;other&gt;|||&lt;/authors&gt;|||&lt;work&gt;author&lt;/work&gt;",
        "Description": "This expression will match the corresponding XML/HTML elements opening and closing tags. Useful to handle documents fragments, without loading an XML DOM.\n"
    },
    {
        "Pattern": "^(?P<assembly>[\\w\\.]+)(,\\s?Version=(?P<version>\\d+\\.\\d+\\.\\d+\\.\\d+))?(,\\s?Culture=(?P<culture>\\w+))?(,\\s?PublicKeyToken=(?P<token>\\w+))?$",
        "MatchingText": "mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089|||My.Assembly",
        "NonMatchingText": "My Assembly|||My.Assembly, Blah|||My.Assembly, 1.0",
        "Description": "Matches .NET assembly names, and captures named groups for easy parsing and constructing of an AssemblyName object. \nCaptured groups are: assembly, version, culture and token."
    },
    {
        "Pattern": "\\w+\\S?\\w+\\s?(@|\\W(at)\\W)\\s?\\w+\\s?(\\.|\\W(dot)\\W)\\s?\\w+\\.?\\w+",
        "MatchingText": "example@demo.net|example @ demo.net|example at demo.net|example at demo dot net|example [at] demo.net|example [at] demo [dot] net|example.example@test.co.uk|example-example@test.co.uk|example_example@test.co.uk",
        "NonMatchingText": "Not Sure Yet",
        "Description": "This should be able to match all emails including ones which try to avoid scrapers."
    },
    {
        "Pattern": "[+]?[\\x20]*(?P<int>\\d+)?[-\\x20]*[\\(]?(?P<area>[2-9]\\d{2})[\\)\\-\\x20]*(?P<pbx>[0-9]{3})[-\\x20]*(?P<num>[0-9]{4})",
        "MatchingText": "1 (800) 123-4567|||001-760-555-0123|||+1 7605551234",
        "NonMatchingText": "(098)737-3942|||123-456-7890",
        "Description": "Based on the pattern from Ricardo Gonzalez.  This one allows for arbitrary space between  parts of the phone number and separates the parts out into different capture groups."
    },
    {
        "Pattern": "(?:Provider=\"??(?P<Provider>[^;\\n]+)\"??[;\\n\"]??|Data\\sSource=(?P<DataSource>[^;\\n]+)[;\\n\"]??|Initial\\sCatalog=(?P<InitialCatalog>[^;\\n]+)[;\\n\"]??|User\\sID=(?P<UserID>[^;\\n]+)[;\\n\"]??|Password=\"??(?P<Password>[^;\\n]+)\"??[;\\n\"]??|Integrated\\sSecurity=(?P<IntegratedSecurity>[^;\\n]+)[;\\n]??|Connection\\sTimeOut=(?P<ConnectionTimeOut>[^;\\n]+)[;\\n\"]??)+$",
        "MatchingText": "Provider=\"SQLOLEDB.1\";Data Source=(local);Initial Catalog=master;User ID=sa;Password=&quot",
        "NonMatchingText": "Any non SQL Connection String",
        "Description": "This RegExp is degigned to mach SQL OLEDB Connection String to the Named Groups Properties useful for .Net              MATCH EXAMPLE(the submition field is too short):Provider=&quot;SQLOLEDB.1&quot;;Data Source=(local);Initial Catalog=master;User ID=sa;Password=&quot;SA_PASS&quot;;Connection TimeOut=90"
    },
    {
        "Pattern": "(?P<TAG>\\s*<(?P<TAG_NAME>\\w*)\\s+(?P<PARAMETERS>(?P<PARAMETER>(?P<PARAMETER_NAME>\\w*)(=[\"']?)(?P<VALUE>[\\w\\W\\d]*?)[\"']?)+)\\s*/?>)",
        "MatchingText": "<td valign=\"top\" align=\"left\" colspan=\"2\">",
        "NonMatchingText": "<!--dynamic_content GlobalID=49113-->",
        "Description": "Parse html tags to extract tag names and parameters with parameter name/value pairs."
    },
    {
        "Pattern": "^(100([\\.\\,]0{1,2})?)|(\\d{1,2}[\\.\\,]\\d{1,2})|(\\d{0,2})$",
        "MatchingText": "100.00 | 99,99 | 99",
        "NonMatchingText": "101 | -99 | 99.999",
        "Description": "Porcentagem positiva de 0 a 100 com at\u00E9 2 casas decimais, usando . (ponto) ou , (virgula)."
    },
    {
        "Pattern": "^[-]?P($)(?:\\d+Y)?(?:\\d+M)?(?:\\d+D)?(?:T($)(?:\\d+H)?(?:\\d+M)?(?:\\d+(?:\\.\\d+)?S)?)?$",
        "MatchingText": "P12Y03M12D|||-P4343D|||-PT343H23M2323.232S",
        "NonMatchingText": "34Y3434M23D|||P2323DT",
        "Description": "Matches the XSD schema duration built in type as defined by http://www.w3.org/TR/xmlschema-2/#duration"
    },
    {
        "Pattern": "(\\/\\*(\\s*|.*?)*\\*\\/)|(\\/\\/.*)",
        "MatchingText": "/* This is a multi-line comment */|||// this is a single-line",
        "NonMatchingText": "/sometext|||/*/",
        "Description": "This regexp is used to match c++,java,etc style multi-line and single line comments."
    },
    {
        "Pattern": "(\\+?1[- .]?)?[.\\(]?[\\d^01]\\d{2}\\)?[- .]?\\d{3}[- .]?\\d{4}",
        "MatchingText": "2345678900||| 234 567 8900||| 234-567-8900||| (234)567-8900|||(234) 567-8900||| 1-2345678900||| 1-234 567 8900||| 1-234-567-8900||| 1-(234)567-8900||| 1-(234) 567-8900||| +1-2345678900||| +1-234 567 8900||| +1-234-567-8900||| +1-(234)567-8900||| +1-(234) 567-8900||| 1 234 567 8900||| +12345678900|||234.567.8900|||1.234.567.8900",
        "NonMatchingText": "012-345-6789||| 9-2345678900||| 234-ABCDFGH",
        "Description": "Matches most format of valid U.S. phone number. Only numbers whose first digit of area code is between 2 and 9 and whose country code is 1 would be matched. Does not match phones contain characters. See examples for more information."
    },
    {
        "Pattern": "^(20|23|27|30|33)-[0-9]{8}-[0-9]$",
        "MatchingText": "20-12345678-9 33-55224478-6 27-23458961-4",
        "NonMatchingText": "19-12345678-9 99-55224478-6 1-23458961-4",
        "Description": "Valida nros de CUIT y CUIL de la AFIP - Argentina. No valida el digito verificador"
    },
    {
        "Pattern": "\\d{1,3}[.]\\d{1,3}[.]\\d{1,3}[.]\\d{1,3}\\s.\\s.\\s\\[\\d{2}\\/\\D{3}\\/\\d{4}:\\d{1,2}:\\d{1,2}:\\d{1,2}\\s.\\d{4}\\]\\s\\&quot;\\S*\\s\\S*\\s\\S*\\&quot;\\s\\d{1,3}\\s\\S*\\s\\&quot;.*\\&quot;\\s\\&quot;.*\\&quot;",
        "MatchingText": "65.93.238.74 - - [12/May/2005:12:37:11 -0400] &quot;GET /dpstyle.css HTTP/1.1&quot; 304 - &quot;http",
        "NonMatchingText": "Have found any yet...",
        "Description": "This RegExp makes sure a line in a log file matches the Apache Common log format:\n\nLogFormat &quot;%h %l %u %t \\&quot;%r\\&quot; %&gt;s %b&quot; common.\n\nIt is not very strict on what appears in the 'page', 'referer' or 'agent' fields, as this text can vary massively, plus it keeps the RegExp as fast as possible...\n\nIt was useful for me to check that logfiles on the server can be parsed by Log Analysis software I'm writing.\n\nI hope someone finds it useful."
    },
    {
        "Pattern": "^([1-9]|1[0-2]):[0-5]\\d ?(a|A|p|P)(m|M)$",
        "MatchingText": "7:15 am|12:30 PM|11:19pM",
        "NonMatchingText": "11am|1300|14:00|3:60 PM",
        "Description": "I built this expression to validate a time input field."
    },
    {
        "Pattern": "[\\w*|\\W*]*<[[\\w*|\\W*]*|/[\\w*|\\W*]]>[\\w*|\\W*]*",
        "MatchingText": "This containt &lt;HTML&gt; tags. &lt;B&gt; Bold! &lt;/B&gt;",
        "NonMatchingText": "This text does not contain HTML.",
        "Description": "This will match true if the string contians at least one HTML tag."
    },
    {
        "Pattern": "[a-zA-Z]{1}[a-zA-Z0-9\\-._]+@([a-zA-Z0-9-]+\\.)+\\w+",
        "MatchingText": "john@something.com|mike123.@hotmail.com|jimmy.joey.@yahoo.es",
        "NonMatchingText": ".fjdkf@mail.com|badDomain@dom..ain|wrong@nice_domain.com",
        "Description": "An email regexp that does not let multiple points repeated on the domain and must start with a letter."
    },
    {
        "Pattern": "^((0[1-9]|1[0-9]|2[0-4])[0-59]\\\\d{7}(00[1-9]|[0-9][1-9][0-9]|[1-9][0-9][0-9]))|((0[1-9]|1[0-9]|2[0-4])6\\\\d{6}(000[1-9]|[0-9][0-9][1-9][0-9]|[0-9][1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]))$",
        "MatchingText": "1803920238001|1792367548190|0664532345999",
        "NonMatchingText": "5003920238001|23A6734569000|0000000000000",
        "Description": "RUC (Registro \u00DAnico de Contribuyentes - ECUADOR). Valida la estructura definida por el SRI, mas no comprueba el d\u00EDgito verificador. Sirve para entidades privadas, p\u00FAblicas, personas naturales y extranjeros."
    },
    {
        "Pattern": "(((^[BEGLMNS][1-9]\\d?) | (^W[2-9] ) | ( ^( A[BL] | B[ABDHLNRST] | C[ABFHMORTVW] | D[ADEGHLNTY] | E[HNX] | F[KY] | G[LUY] | H[ADGPRSUX] | I[GMPV] | JE | K[ATWY] | L[ADELNSU] | M[EKL] | N[EGNPRW] | O[LX] | P[AEHLOR] | R[GHM] | S[AEGKL-PRSTWY] | T[ADFNQRSW] | UB | W[ADFNRSV] | YO | ZE ) \\d\\d?) | (^W1[A-HJKSTUW0-9]) | ((  (^WC[1-2])  |  (^EC[1-4]) | (^SW1)  ) [ABEHMNPRVWXY] ) ) (\\s*)?  ([0-9][ABD-HJLNP-UW-Z]{2})) | (^GIR\\s?0AA)",
        "MatchingText": "W1A 1AA|||EC2V 1JN|||GIR 0AA",
        "NonMatchingText": "TB12 1AB|||EC2V 1JM|||W2A 1AA",
        "Description": "Here it is, the monster UK Postcode regular expression that should prevent the majority of miskeying. Unlike an most other regexes it only permits valid combinations of letters, e.g. BN works, BM does not. Spaces between the first and second parts are optional. I have tested this against a file of 7,500 valid postcodes, and also against a real-world list of about 12,000 which had some bad data. Manually checking a sample of the rejected ones showed it was working correctly (and how poor the data was!!).\n\nI originally started by trying to adapt the GDSC document at http://www.govtalk.gov.uk/gdsc/html/frames/PostCode.htm and specifically their XSD pattern at http://www.govtalk.gov.uk/gdsc/schemaHtml/bs7666-v2-0-xsd-PostCodeType.htm but this turned out to be rather loose. Instead I wrote this. If you find any valid postcodes being rejected by this regex please let me know."
    },
    {
        "Pattern": "(((^[BEGLMNS][1-9]\\d?)|(^W[2-9])|(^(A[BL]|B[ABDHLNRST]|C[ABFHMORTVW]|D[ADEGHLNTY]|E[HNX]|F[KY]|G[LUY]|H[ADGPRSUX]|I[GMPV]|JE|K[ATWY]|L[ADELNSU]|M[EKL]|N[EGNPRW]|O[LX]|P[AEHLOR]|R[GHM]|S[AEGKL-PRSTWY]|T[ADFNQRSW]|UB|W[ADFNRSV]|YO|ZE)\\d\\d?)|(^W1[A-HJKSTUW0-9])|(((^WC[1-2])|(^EC[1-4])|(^SW1))[ABEHMNPRVWXY]))(\\s*)?([0-9][ABD-HJLNP-UW-Z]{2}))$|(^GIR\\s?0AA$)",
        "MatchingText": "W1A 1AA|||EC1V1JN|||N7 8BQ",
        "NonMatchingText": "W1A 1AM|||BM1 1AB|||EC1 1AA",
        "Description": "For the terminally hard of thinking, a version of my UK postcode validator without WHITESPACE. Unlike most validators on regexlib, this knows valid postcode combinations, e.g. W1A is permitted, W1 is not, but W2 is. It should catch between 95-98% of invalid postcodes."
    },
    {
        "Pattern": "((v|[\\\\/])\\W*[i1]\\W*[a@]\\W*g\\W*r\\W*[a@]|v\\W*[i1]\\W*[c]\\W*[o0]\\W*d\\W*[i1]\\W*n)",
        "MatchingText": "(Viagra|V1@GRA|V.I.A.G.R.A|V  I  A  G  R  A)|||(Vicodin|V1C0DIN|V  1  C  0  D  1  N)",
        "NonMatchingText": "Vigorous",
        "Description": "Matches all those Obfuscations which come in those pesky Emails. You will have to strip out all those HTML Remarks first in order to for this to work with the HTML Part of the Email"
    },
    {
        "Pattern": "^(([A-Z])([a-zA-Z0-9]+)?)(\\:)(\\d+)$",
        "MatchingText": "MyServer:8080",
        "NonMatchingText": "1Server:A1|||Server:AAA",
        "Description": "Validate if server and port is valid."
    },
    {
        "Pattern": "^\\d+\\*\\d+\\*\\d+$",
        "MatchingText": "123*4578*8908650",
        "NonMatchingText": "12a*9999*9096",
        "Description": "one or more numbers, asterisk, one or more numbers, asterisk, one or more numbers, no letters or punctuation other than asterisks."
    },
    {
        "Pattern": "<style.*?>(?P<StyledText>.*)<\\s*?/\\s*?style.*?>",
        "MatchingText": "<style class=\"blah\">Captures Me</style>",
        "NonMatchingText": "Will not capture the style tag itself",
        "Description": "A blogger needed a regex to capture the text between style tags.  "
    },
    {
        "Pattern": "(?:(?P<protocol>http(?:s?)|ftp)(?:\\:\\/\\/))\n(?:(?P<usrpwd>\\w+\\:\\w+)(?:\\@))?\n(?P<domain>[^/\\r\\n\\:]+)?\n(?P<port>\\:\\d+)?\n(?P<path>(?:\\/.*)*\\/)?\n(?P<filename>.*?\\.(?P<ext>\\w{2,4}))?\n(?P<qrystr>\\??(?:\\w+\\=[^\\#]+)(?:\\&?\\w+\\=\\w+)*)*\n(?P<bkmrk>\\#.*)?",
        "MatchingText": "https://192.168.0.2:80/users/~fname.lname/file.ext|||ftp://user1:pwd@www.domain.com|||http://www.dom",
        "NonMatchingText": "www.domain.com|||user1:pwd@domain.com|||192.168.0.2/folder/file.ext",
        "Description": "I needed a regular expression to break urls into labled parts.  This is what I came up with.  Got a few ideas from regexlib.com and from this msdn article. http://msdn.microsoft.com/library/default.asp?url=/library/en-us/script56/html/reconbackreferences.asp\n\nhttp://www.domain.com/folder does return a match but will not grab the folder name unless there is &quot;/&quot; at the end.\n\nhttp://www.domain.com/folder/"
    },
    {
        "Pattern": "^\\({0,1}((0|\\+61)(2|4|3|7|8)){0,1}\\){0,1}(\\ |-){0,1}[0-9]{2}(\\ |-){0,1}[0-9]{2}(\\ |-){0,1}[0-9]{1}(\\ |-){0,1}[0-9]{3}$",
        "MatchingText": "0403111111|||(03) 1111 1111|||+61403111111|||02 9111 1111|||0403 111 111|||91111111",
        "NonMatchingText": "9111 11111|||99 1111 1111",
        "Description": "Australian phone number validator. Accepts all forms of Australian phone numbers in different formats (area code in brackets, no area code, spaces between 2-3 and 6-7th digits, +61 international dialing code). Checks that area codes are valid (when entered)."
    },
    {
        "Pattern": "^[0-9]+(,[0-9]+)*$",
        "MatchingText": "1321 | 1321,0,42412 | 0,1,2,3,4",
        "NonMatchingText": "1321,,42412 | 12c,13d,23 | 445, | 412 ,   421, 4122 | 42 4,41",
        "Description": "Parses comma-separated numbers. Doesn't allow spaces inbetween numbers and/or between numbers and commas. Allows single number to be added. Doesn't allow sequence to end with a comma."
    },
    {
        "Pattern": "^[0-9#\\*abcdABCD]+$",
        "MatchingText": "*AB132# | 12#AB*3 | *c3d42a##",
        "NonMatchingText": "r13 | #bCz31* | *%#",
        "Description": "Tests expression for DTMF combinations (numbers 0-9, asterisk, octothorpe and A,B,C,D or a,b,c,d). Does not limit number of occurrences or their order."
    },
    {
        "Pattern": "([0-9]+)\\s(d)\\s(([0-1][0-9])|([2][0-3])):([0-5][0-9]):([0-5][0-9])",
        "MatchingText": "1 d 22:33:44 | 109 d 11:02:00 | 0 d 00:00:00",
        "NonMatchingText": " d 22:33:44 | 1 d 24:00:00 | 3 d 11:75:00",
        "Description": "Displays duration in\n1 d 22:33:44 format. Can be modified to match some other formats e.g. 1.22:33:44 if needed. Takes a 24-hour day into account."
    },
    {
        "Pattern": "^[a-zA-Z]{3}[uU]{1}[0-9]{7}$",
        "MatchingText": "HJCU1234567|||coou9876543",
        "NonMatchingText": "HJCY1234567|||HJCU123456",
        "Description": "Standard freight container number in upper or lower case."
    },
    {
        "Pattern": "^\\+?\\d{2}|\\0(?:\\-?|\\ ?)(?:\\([2-9]\\d{2}\\)\\ ?|[2-9]\\d{2}(?:\\-?|\\ ?))[2-9]\\d{2}[- ]?\\d{4}$",
        "MatchingText": "+91 999 888 7777, 999 888 7777, 9998887777, +91 (999) 888 7777,  (999) 888-7777 | 999-888-7777",
        "NonMatchingText": "Doesn't allow alphabetic characters  |  0010011212 | 1991991212 | 123) not-good",
        "Description": "This regular expression validates all country phone number formats with country code, plus(+) sign, allowed brackets('(', ')'), dots(.), dashes(-). \nPlus (+) and country code is optional.\nAbove expression allows alphabetical characters. To prevent alphabetical characters first check with this expression /^[^a-z]+$/i    then check the main expression."
    },
    {
        "Pattern": "^[1-4]{1}[0-9]{4}(-)?[0-9]{7}(-)?[0-9]{1}$",
        "MatchingText": "42222-1010101-1, 11111-1111111-1, 1111111111111, 11111-11111111",
        "NonMatchingText": "12345678901, 9191-9393939-31",
        "Description": "This expression is used to validate CNIC numbers. The number must start with either 1,2,3 or 4 which represent the province. The hyphen is optional. But if given must be at the correct index (i.e. first one after 5 numbers and second one before the last number). The total length of numbers is 13."
    },
    {
        "Pattern": "src[^&gt;]*[^/].(?:jpg|bmp|gif)(?:\\&quot;|\\')",
        "MatchingText": "src=&quot;../images/image.jpg&quot;|||src=&quot;http://domain.com/images/image.jpg&quot;|||src='d:\\w",
        "NonMatchingText": "src=&quot;../images/image.tif&quot;|||src=&quot;cid:value&quot;",
        "Description": "This expression will return the src (source) property of an image tag &lt;IMG&gt;. The source returned is limited to the file extensions supplied. It doesn't matter if the image is prefixed with '../' or 'http://..blah' or 'drive\\path' or nothing. This expression could be modifed to return other sources or for the tags (ie &lt;BGSOUND&gt;, &lt;SCRIPT&gt;, etc.) depending on the file extensions given.\n\nI needed this to replace the source of images in a HTML page when I wanted to save the page to a local drive and keep the images intact.\n\nIf anybody could modify this further to include only the &lt;IMG&gt; tag, I would appreciate the effort."
    },
    {
        "Pattern": "\\[bible[=]?([a-z\u00E4\u00EB\u00EF\u00F6\u00FC\u00E6\u00F8]*)\\]((([0-9][[:space:]]?)?[a-z\u00E4\u00EB\u00EF\u00F6\u00FC\u00E6\u00F8]*[[:space:]]{1}([a-z\u00E4\u00EB\u00EF\u00F6\u00FC\u00E6\u00F8]*[[:space:]]?[a-z\u00E4\u00EB\u00EF\u00F6\u00FC\u00E6\u00F8]*[[:space:]]{1})?)([0-9]{1,3})(:{1}([0-9]{1,3})(-{1}([0-9]{1,3}))?)?)\\[\\\\/bible\\]",
        "MatchingText": "[bible]Mark 11:23[/bible], [bible=asv]john 3:16[/bible]",
        "NonMatchingText": "[bible]Cheeze[/bible], John 3:16",
        "Description": "I used this to find bbcode [bible][/bible] tags.  It also allows for multiple versions with a default and other than english languages.\n\nThis is eregi, not preg_match"
    },
    {
        "Pattern": "^(\\d|-)?(\\d|,)*\\.?\\d*$",
        "MatchingText": "5,000|||-5,000|||100.044",
        "NonMatchingText": "abc|||Hundred|||1.3.4",
        "Description": "Input for Numeric values.  Handles negatives, and comma formatted values.  Also handles a single decimal point"
    },
    {
        "Pattern": "^(\\d|,)*\\.?\\d*$",
        "MatchingText": "1,000|||3,000.05|||5,000,000",
        "NonMatchingText": "abc|||$100,000|||Forty",
        "Description": "Matches Numeric with Commas and a single decimal point.  Also matches empty string."
    },
    {
        "Pattern": "^([0-1]?[0-9]{1}/[0-3]?[0-9]{1}/20[0-9]{2})$",
        "MatchingText": "2/14/2001 || 12/29/2099 || 19/39/2000",
        "NonMatchingText": "12/29/1999 || 20/40/2100",
        "Description": "This regular expression will validate most (current & future) date options. The weaknesses with this one is that it will allow the days to go up to 39 and does not account for leap year. Also, the months can go up to 19, instead of our commonly accepted 12 month year. :)  I designed this expression to validate dates from the year 2000 to 2099. I do not plan on this same code being in place in 2099, so I hope this is sufficient enough..."
    },
    {
        "Pattern": "1?(?:[.\\s-]?[2-9]\\d{2}[.\\s-]?|\\s?\\([2-9]\\d{2}\\)\\s?)(?:[1-9]\\d{2}[.\\s-]?\\d{4}\\s?(?:\\s?([xX]|[eE][xX]|[eE][xX]\\.|[eE][xX][tT]|[eE][xX][tT]\\.)\\s?\\d{3,4})?|[a-zA-Z]{7})",
        "MatchingText": "8005554444|1 (800) 555-4444 ext. 6666|1-800-NUMBERS",
        "NonMatchingText": "180033344444|3334444|1110524444",
        "Description": "More complete than other patterns I could find here. Matches U.S. Phone numbers with various formats.  Invalid area codes (that start with a 0 or 1) are excluded, as well as invalid exchanges (that start with 0).  Allows, alphabetical exchange+local parts, and many extension notations. Dash and dot delimiters allowed except adjacent to a parenthetical area code. Letters may be used in place of any numbers except the country code and area code."
    },
    {
        "Pattern": "^\\d(\\.\\d{1,2})?$",
        "MatchingText": "123  |  123.00  |  123.99",
        "NonMatchingText": "123.999",
        "Description": "this parttern only use for decimal number."
    },
    {
        "Pattern": "^(-?)(((\\d{1,3})(,\\d{3})*)|(\\d+))(\\.\\d{1,2})?$",
        "MatchingText": "100,000,000.00|-100,000,000.00|100,000,000|-100,000,000|100000000.00|-100000000.00|100000000|-100000000",
        "NonMatchingText": "100,000,00.00|1000.000|1000.",
        "Description": "This RegEx checks whether the input is a number or not. Number may contain commas a seperators, can contain one or two decimal places and can be positive or negative."
    },
    {
        "Pattern": "^((((19[0-9][0-9])|(2[0-9][0-9][0-9]))([-])(0[13578]|10|12)([-])(0[1-9]|[12][0-9]|3[01]))|(((19[0-9][0-9])|(2[0-9][0-9][0-9]))([-])(0[469]|11)([-])([0][1-9]|[12][0-9]|30))|(((19[0-9][0-9])|(2[0-9][0-9][0-9]))([-])(02)([-])(0[1-9]|1[0-9]|2[0-8]))|(([02468][048]00)([-])(02)([-])(29))|(([13579][26]00)([-])(02)([-])(29))|(([0-9][0-9][0][48])([-])(02)([-])(29))|(([0-9][0-9][2468][048])([-])(02)([-])(29))|(([0-9][0-9][13579][26])([-])(02)([-])(29)))$",
        "MatchingText": "1900-01-01|||2025-03-15|||2999-12-31",
        "NonMatchingText": "1890-01-01|||2008-19-45|||3000-01-01",
        "Description": "This regex checks if a date is in ISO-format (yyyy-mm-dd). Leap year should be checked too. Date has to be between 1900-01-01 and 2999-12-31."
    },
    {
        "Pattern": "^(((0[1-9]|[12][0-9]|3[01])([\\.])(0[13578]|10|12)([\\.])((19[0-9][0-9])|(2[0-9][0-9][0-9])))|(([0][1-9]|[12][0-9]|30)([\\.])(0[469]|11)([\\.])((19[0-9][0-9])|(2[0-9][0-9][0-9])))|((0[1-9]|1[0-9]|2[0-8])([\\.])(02)([\\.])((19[0-9][0-9])|(2[0-9][0-9][0-9])))|((29)([\\.])(02)([\\.])([02468][048]00))|((29)([\\.])(02)([\\.])([13579][26]00))|((29)([\\.])(02)([\\.])([0-9][0-9][0][48]))|((29)([\\.])(02)([\\.])([0-9][0-9][2468][048]))|((29)([\\.])(02)([\\.])([0-9][0-9][13579][26])))$",
        "MatchingText": "01.01.1900|||20.11.2009|||31.12.2999",
        "NonMatchingText": "01.01.1890|||11.20.2009|||01.01.3000",
        "Description": "This regex checks if a date is in german date format (dd.mm.yyyy). Leap year should be checked too. Date has to be between 01.01.1900 and 31.12.2999."
    },
    {
        "Pattern": "([0-9]{11}$)|(^[7-9][0-9]{9}$)",
        "MatchingText": "9890124589 , 0207256984",
        "NonMatchingText": "6523145897",
        "Description": "Moblie Number which starts from 7/8/9 (Indian Mobile No.) & 11 digit Landline number"
    },
    {
        "Pattern": "(\\b(xx|yy)\\b)\\b[\\w]+\\b",
        "MatchingText": "x | xxx | xxyy | yyx",
        "NonMatchingText": "xx | yy",
        "Description": "Matches any word except these from alternation (xx|yy|...). Works in JavaScript"
    },
    {
        "Pattern": "^([a-zA-Z]+(.)?[\\s]*)$",
        "MatchingText": "Mr.|||Sr|||Mr                  ",
        "NonMatchingText": "Mr..|||12M|||.Mr",
        "Description": "This regular expression matches titles. The length of the title has not been restricted. It allows only alphabets in the title and takes zero or one . after the title. Also it allows trailing spaces."
    },
    {
        "Pattern": "^(.*?)([^/\\\\]*?)(\\.[^/\\\\.]*)?$",
        "MatchingText": "test|||test.txt|||C:\\test|||C:\\test.txt|||C:\\test.txt\\testing.txt|||C:\\folder\\test|||C:\\folder\\test.txt.txt|||C:\\folder\\test.txt.txt\\testing.txt|||/usr/test|||/usr/test.txt|||/usr/test.txt/testing.pdf",
        "NonMatchingText": "N/A (some captures may end up being blank in the event of a relative path or no file extension)",
        "Description": "Simple (non-validating) match with numbered group captures that extracts parts of a filename into $1 = folder path, $2 = filename w/o extension, $3 = extension. Should work on Windows, OS X, and Unix/Linux, but not on OS 9 and OSs with folder separators other than slashes (either direction). Tested only on .NET RE engine."
    },
    {
        "Pattern": "((0?[13578]|10|12)(-|\\/)((0[0-9])|([12])([0-9]?)|(3[01]?))(-|\\/)((\\d{4})|(\\d{2}))|(0?[2469]|11)(-|\\/)((0[0-9])|([12])([0-9]?)|(3[0]?))(-|\\/)((\\d{4}|\\d{2})))",
        "MatchingText": "1/31/2002|||04-30-02|||12-01/2002",
        "NonMatchingText": "2/31/2002|||13/0/02|||Jan 1, 2001",
        "Description": "Regex used in .NET to validate a date.  Matches the following formats mm/dd/yy, mm/dd/yyyy, mm-dd-yy, mm-dd-yyyy\nThis covers days with 30 or 31 days but does not handle February, it is allowed 30 days."
    },
    {
        "Pattern": "^100$|^[0-9]{1,2}$|^[0-9]{1,2}\\,[0-9]{1,3}$",
        "MatchingText": "12,654|||1,987",
        "NonMatchingText": "128,2|||12,",
        "Description": "Percentage with 3 number after comma."
    },
    {
        "Pattern": "^((61|\\+61)?\\s?)04[0-9]{2}\\s?([0-9]{3}\\s?[0-9]{3}|[0-9]{2}\\s?[0-9]{2}\\s?[0-9]{2})$",
        "MatchingText": "0418123456|||0411 123 456|||0414 12 34 56|||61 0401 123 456|||+61 0418 12 34 56",
        "NonMatchingText": "0418 1 23 45 6|||04 01 123456|||+62 0418 12 34 56",
        "Description": "Validates an Australian mobile telephone number that can include an international prefix and four plus (two or three-digit) grouping.\nI use it in ASP.NET MVC DataAnnotations [RegularExpression()] attributes where I don't get to easily strip out spaces beforehand."
    },
    {
        "Pattern": "oid starvation and planning hungry because you-can't find something balanced to consume.",
        "MatchingText": "Garcinia cambogia can be an extremely effective.",
        "NonMatchingText": "Garcinia cambogia can be an extremely effective.",
        "Description": "http://fitnesseducations.com/deep-cell-activator/\n\nDeep Cell Activator\n\n\nGarcinia cambogia can be an extremely effective supplement. Some individuals recognize it as brindleberry. Its vast majority is expanded in India. Why is it so strong will be the hydroxycitric acid that it has. This material can be utilized in weight loss' pursuit. The western world became acquainted with cambogia about fifty years back. Easterners, however, have already been familiar with it for more than 100 years. It might improve both aching bones and troublesome stomachs. It can also be used as being a cooking element.\n"
    },
    {
        "Pattern": "(?P<tagname>[^\\s]*)=\"(?P<tagvalue>[^\"]*)\"",
        "MatchingText": "<tag attr1=\"value1\"> | <tag attr1=\"value1\" attr2=\"value2\">",
        "NonMatchingText": "<tag attr1=\"value1> | <tag attr1=value1\"> | <tag attr1=value1>",
        "Description": "Quick and dirty extraction of quoted HTML attributes if you begin with just the tag string.  Not intended for use in a full HTML document.\n"
    },
    {
        "Pattern": "^((\\.\\./|[a-zA-Z0-9_/\\-\\\\])*\\.[a-zA-Z0-9]+)$",
        "MatchingText": "../directory/catbus.gif someFile.txt directory/something\\photo.jpeg .htaccess",
        "NonMatchingText": "my directory/file.txt ..\\something.dat someDir/anotherDir",
        "Description": "A basic regex that matches a file path, windows or linux slash directions both match, apart from ..\\"
    },
    {
        "Pattern": "^(0?[1-9]|[12][0-9]|3[01])[- /.](0?[1-9]|1[012])[- /.](19|20)?[0-9]{2}? ?((([0-1]?\\d)|(2[0-3])):[0-5]\\d)?(:[0-5]\\d)? ?([a,p,A,P][m,M])?$",
        "MatchingText": "31-12-2010 14:15:22|||1.1.2010 00:00:00|||2/1/2010|||31/1/2011 05:22 pm",
        "NonMatchingText": "1.31.2011|||31.1.2011 1455|||31.1.2011 14 pm",
        "Description": "Regex to match date and or time either in 12 or 24 hour format.\nIt will also allow for am/pm with mixed cases."
    },
    {
        "Pattern": "^[\\w ]{0,}$",
        "MatchingText": "abcdefghijklmnopqrstuvwxyz1234567890",
        "NonMatchingText": "!@#$%^&*()_+=-?><,./:\";'[]\\{}|",
        "Description": "The alphanumeric patterns I have seen here are unnecessarily long. This is all you need."
    },
    {
        "Pattern": "^[a-zA-Z]+(([\\'\\,\\.\\- ][a-zA-Z ])?[a-zA-Z]*)*$",
        "MatchingText": "T.F. Johnson|||John O'Neil|||Mary-Kate Johnson",
        "NonMatchingText": "sam_johnson|||Joe--Bob Jones|||dfjsd0rd",
        "Description": "Person's name (first, last, or both) in any letter case.  Although not perfect, this expression will filter out many incorrect name formats (especially numerics and invalid special characters)."
    },
    {
        "Pattern": "(0?[1-9]|[12][0-9]|3[01])[/ -](0?[1-9]|1[12])[/ -](19[0-9]{2}|[2][0-9][0-9]{2})",
        "MatchingText": "25/11/1979|||5-12-2004|||5 2 1901",
        "NonMatchingText": "25/11/1899|||9-12-1700|||25111979",
        "Description": "Essa express&#227;o &#233; uma valida&#231;&#227;o de data simplicada onde n&#227;o aceita datas com ano inferior a 1900. Interessante pra valida&#231;&#227;o de data de idade, data atual, etc"
    },
    {
        "Pattern": "^((((((0[13578])|(1[02]))[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9])|(3[01])))|(((0[469])|(11))[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9])|(30)))|((02)[\\s\\.\\-\\/\\\\]?((0[1-9])|(1[0-9])|(2[0-8]))))[\\s\\.\\-\\/\\\\]?(((([2468][^048])|([13579][^26]))00)|(\\d\\d\\d[13579])|(\\d\\d[02468][^048])|(\\d\\d[13579][^26])))|(((((0[13578])|(1[02]))[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9])|(3[01])))|(((0[469])|(11))[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9])|(30)))|((02)[\\s\\.\\-\\/\\\\]?((0[1-9])|([12][0-9]))))[\\s\\.\\-\\/\\\\]?(((([2468][048])|([13579][26]))00)|(\\d\\d[2468][048])|(\\d\\d[13579][26])|(\\d\\d0[48]))))$",
        "MatchingText": "02292000",
        "NonMatchingText": "02291700",
        "Description": "This was made for use in javascript to detect MMDDYYYY formatted text.  It tests all valid dates, including 31 vs 30 days in a month and the 28 vs 29 leap year rules which exclude centennial years not divisible by 400 and years not divisible by 4."
    },
    {
        "Pattern": "^(?P<CountryCode>[1]?)\\s?\\(?(?P<AreaCode>[2-9]{1}\\d{2})\\)?\\s?(?P<Prefix>[0-9]{3})(?:[-]|\\s)?(?P<Postfix>\\d{4})\\s?(?:ext|x\\s?)(?P<Extension>[1-9]{1}\\d*)?$",
        "MatchingText": "1234567890 |||1(234)4567890|||(234) 456-7890 ext 2",
        "NonMatchingText": "(000) 234 5678|||100 234 5678|||aaa bbb cccc|||1 234 567 8990 ext 01|||234-5678",
        "Description": "Validates any format of North American phone number, while parsing the Country Code, Area (City) Code, Prefix and Postfix numbers and the letters ext or x followed by the extension number which cannot begin with 0. Will not accept invalid Area Codes "
    },
    {
        "Pattern": "^((\\(?\\+45\\)?)?)(\\s?\\d{2}\\s?\\d{2}\\s?\\d{2}\\s?\\d{2})$",
        "MatchingText": "(+45) 35 35 35 35 ||| +45 35 35 35 35 ||| 35 35 35 35 ||| 35353535",
        "NonMatchingText": "(45)35353535 ||| 4535353535",
        "Description": "This should help in finding european style phone numbers (without hyphens), particularly danish numbers with consist of 8 digits, and can be separated by a whitespace."
    },
    {
        "Pattern": "IT\\d{2}[ ][a-zA-Z]\\d{3}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{3}|IT\\d{2}[a-zA-Z]\\d{22}",
        "MatchingText": "IT28 W800 0000 2921 0064 5211 151|||IT28W8000000292100645211151",
        "NonMatchingText": "IT28-W800-0000-2921-0064-5211-151",
        "Description": "International Bank Account Number (IBAN) Italian. Identify Bank account in Italy."
    },
    {
        "Pattern": " ^(0{0,1}[1-9]|[12][0-9]|3[01])[- /.](0{0,1}[1-9]|1[012])[- /.](\\d{2}|\\d{4})$",
        "MatchingText": "1.1.2004|||03.07.04|||1-03-03",
        "NonMatchingText": "0.13.2004|||1.1.200|||32.0.03",
        "Description": "Validates dates formatted like &quot;dd.mm.yyyy&quot; or &quot;dd.mm.yy&quot;. Also the separators &quot;/&quot; and &quot;-&quot; are validated &quot;ok&quot;. This expression does not check leap years!\nI did this expression cause I could hardly find any date regex that supports those &quot;dot-formats&quot;."
    },
    {
        "Pattern": "^~/[0-9a-zA-Z_][0-9a-zA-Z/_-]*\\.[0-9a-zA-Z_-]+$",
        "MatchingText": "~/myPage.htm|||~/123._aBc2|||~/Hello_World-Page.aspx",
        "NonMatchingText": "mybadPage.htm|||~/.Not|||~/Very.|||~/Good",
        "Description": "Matches the app relative path of a file. This will work for relative paths of URLs. Not very complicated but will work to do basic validation."
    },
    {
        "Pattern": "^[A-Z]$",
        "MatchingText": "A|||B|||Z",
        "NonMatchingText": "a|||1|||AA",
        "Description": "Matches one Upper-case US ASCII Letter."
    },
    {
        "Pattern": "^\\d+(\\.\\d{2})?$",
        "MatchingText": "13.37|||24|||0.42",
        "NonMatchingText": ".25|||15.2|||2.507",
        "Description": "A Simple Currency Expression. It will validate the number portion only. "
    },
    {
        "Pattern": "^A-?|[BCD][+-]?|[SN]?F|W$",
        "MatchingText": "A|||C+|||SF",
        "NonMatchingText": "A+|||F-|||Z",
        "Description": "This matches a standard set of plus minus letter grades.\nA A- B+ B B- C+ C C- D+ D D- F SF NF W \n(SF - Stopped Attending F)\n(NF - Never Attended F)\n(W - Withdraw)"
    },
    {
        "Pattern": "^[1-9]\\d?-\\d{7}$",
        "MatchingText": "55-5555555|||1-2345678|||99-9999999",
        "NonMatchingText": "00-1111111|||my-einnumb|||5-55555",
        "Description": "Accepts valid EIN numbers. It could use a bit of tweaking because these are the current valid prefixes allowed. 1, 2, 3, 4, 5, 6, 10, 11, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 65, 66, 67, 68, 71, 72, 73, 74, 75, 76, 77, 80, 81, 82, 83, 84, 85, 87, 88, 90, 91, 92, 93, 94, 95, 98, 99"
    },
    {
        "Pattern": "^([a-zA-Z]+[\\'\\,\\.\\-]?[a-zA-Z ]*)+[ ]([a-zA-Z]+[\\'\\,\\.\\-]?[a-zA-Z ]+)+$",
        "MatchingText": "E.J. O'Malley|||Jack O'Neil|||Mary-Lou Elizabeth Jones",
        "NonMatchingText": "Johnathan Michael S.|||Prince|||Teddy Has-a..Fake-Name",
        "Description": "Requires a person's name including at least 2 parts. (first and last) Allows optional extra names. It allows plenty of initials as well as symbols in names. Restricts symbol usage quite a bit, but allows even names with 2 symbols. Requires last name to have at least 2 characters and cannot be an initial. Works well for filtering names on validation."
    },
    {
        "Pattern": "/^[a-zA-Z0-9]+$/",
        "MatchingText": "loka123|||56Dee8|||1Name78",
        "NonMatchingText": "loka1@3|||56D@e8|||1Nam&78",
        "Description": "With this expression we can validate alpha numeric, ie allow only numbers and alphabets. "
    },
    {
        "Pattern": "^(([1-9]|[0-2]\\d|[3][0-1])\\.([1-9]|[0]\\d|[1][0-2])\\.[2][0]\\d{2})$|^(([1-9]|[0-2]\\d|[3][0-1])\\.([1-9]|[0]\\d|[1][0-2])\\.[2][0]\\d{2}\\s([1-9]|[0-1]\\d|[2][0-3])\\:[0-5]\\d)$",
        "MatchingText": "20.10.2003 08:10|||24.12.2003|||1.1.2004 8:15",
        "NonMatchingText": "25.13.2004|||20.10.2003 08:9",
        "Description": "Correct German DateTime. Does not check leap year rules!\n\nPossible Formats of date part: \nD.M.YYYY or D.MM.YYYY or DD.MM.YYYY or DD.M.YYYY\n\nPossible formats of time part:\nh:mm or hh:mm"
    },
    {
        "Pattern": "(^[0][.]{1}[0-9]{0,}[1-9]+[0-9]{0,}$)|(^[1-9]+[0-9]{0,}[.]?[0-9]{0,}$)",
        "MatchingText": "0.003|||34|||6.000|||7.3",
        "NonMatchingText": "0.0|||-34|||-23.00|||0|||-0.30",
        "Description": "This pattern will match any positive number(Real or Integer).  It will not match ZERO or any variation of zero (ie 0.00)"
    },
    {
        "Pattern": "href(\\s*)=(\\s*)('|\")http:\\/\\/(.*)((\"|'))",
        "MatchingText": "href=\"http://yahoo.com\" href=\"google.com\"",
        "NonMatchingText": "src=\"http://domain.com/img.jpg\" href=\"tel:1234567897\"\"",
        "Description": "The pulls the HTML link URLs."
    },
    {
        "Pattern": "^[^\\\\\\/\\?\\*\\&quot;\\'\\&gt;\\&lt;\\:\\|]*$",
        "MatchingText": "321321321 dasds",
        "NonMatchingText": "/\\3fsdfsd",
        "Description": "Validation of a Folder Name. Excludes all forbidden characters"
    },
    {
        "Pattern": "[0-9]{1,2}[:|\u00B0][0-9]{1,2}[:|'](?:\\b[0-9]+(?:\\.[0-9]*)?|\\.[0-9]+\\b)\"?[N|S|E|W]",
        "MatchingText": "12:12:12.223546\"N|12:12:12.2246N|15:17:6\"S|12\u00B030'23.256547\"S",
        "NonMatchingText": "12.2225|15.25.257S|AA:BB:CC.DDS",
        "Description": "Matches common Degree, Minute, Second coordinate values. The last part can be easily modified to be latitude or longitude specific by changing\n[N|S|E|W] to [N|S] for latitude or [E|W] for longitude."
    },
    {
        "Pattern": "copper ingot 99.999% price",
        "MatchingText": "Customized PP Sanding Sheet",
        "NonMatchingText": "Customized PP Sanding Sheet",
        "Description": "every batch of products for better packages;\n3.after sales,we have professional steam tto serve for you everyday.copper ingot 99.999% price\nwebsite:http://www.6nmetal.com/"
    },
    {
        "Pattern": "((([0][1-9]|[12][\\d])|[3][01])[-/]([0][13578]|[1][02])[-/][1-9]\\d\\d\\d)|((([0][1-9]|[12][\\d])|[3][0])[-/]([0][13456789]|[1][012])[-/][1-9]\\d\\d\\d)|(([0][1-9]|[12][\\d])[-/][0][2][-/][1-9]\\d([02468][048]|[13579][26]))|(([0][1-9]|[12][0-8])[-/][0][2][-/][1-9]\\d\\d\\d)",
        "MatchingText": "12/12/2003|||29-02-2004|||31-03-1980",
        "NonMatchingText": "29/02/2003|||31-04-2002|||10-10-0999",
        "Description": "Date validation in the dd/mm/yyyy format for years 1000+ (i.e 999 or 0999 not matching) and taking february leap years into account."
    },
    {
        "Pattern": "[-]?[1-9]\\d{0,16}\\.?\\d{0,2}|[-]?[0]?\\.[1-9]{1,2}|[-]?[0]?\\.[0-9][1-9]",
        "MatchingText": "-9999999999999999.99|9999999999999999.99|1|1.00|0.52|0.02",
        "NonMatchingText": "0|0.0|0.00",
        "Description": "Needed to be able to validate positive and numeric values that equate to SQL Server data type decimal(18, 2) but the value could not be 0.  This regex does that.  If you need to change the precision or scale have at it."
    },
    {
        "Pattern": "(<(!--|script)(.|\\n[^<])*(--|script)>)|(<|&lt;)(/?[\\w!?]+)\\s?[^<]*(>|&gt;)|(\\&[\\w]+\\;)",
        "MatchingText": "<p><font face=\"Trebuchet MS\" size=\"2\" >summary of </font></p>||<body><font face=\"Trebuchet MS\" size=\"2\" >Example 2</font></body>|||<!-- Comment-->",
        "NonMatchingText": "Regular Text|||Regular Text2|||Regular Text3",
        "Description": "Matches any text inside greater than less than characters. Can be used to remove HTML Markup including attributes and comments."
    },
    {
        "Pattern": "^[A-CEGHJ-PR-TW-Z]{1}[A-CEGHJ-NPR-TW-Z]{1}[0-9]{6}[A-DFM]{0,1}$",
        "MatchingText": "JG103759A|||AP019283D|||ZX047829C",
        "NonMatchingText": "DC135798A|||FQ987654C|||KL192845T",
        "Description": "UK National Insurance Number (NINo) validation. The following modifications have been made: The first letter may not be D, F, I, Q, U or Z; the second letter may not be D, F, I, O, Q, U or Z; the final letter is optional."
    },
    {
        "Pattern": "(25[0-5]|2[0-4][0-9]|[1][0-9]?[0-9]?|[1-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[1][0-9]?[0-9]?|[1-9][0-9]?|[0])\\.(25[0-5]|2[0-4][0-9]|[1][0-9]?[0-9]?|[1-9][0-9]?|[0])\\.(25[0-5]|2[0-4][0-9]|[1][0-9]?[0-9]?|[1-9][0-9]?)",
        "MatchingText": "255.12.3.1 | 192.168.0.1 | 1.0.0.1",
        "NonMatchingText": "0.12.23.2 | 12.33.23.0 |  256.12.23.2",
        "Description": "Accurate IP address verification... Th fist and the fourth numeric part of an IP address must be between 1 and 255. The second and the third numeric part of an IP address must be between 0 and 255. "
    },
    {
        "Pattern": "\\|(http.*)\\|(.*)$/ig",
        "MatchingText": "http://www.crapster.com/crap/me.php/site=1&venue=2",
        "NonMatchingText": "Other part of line",
        "Description": "ac80016-29181-12246003492|1224600413|ac8001629181-12246003492|M4.0-300-398598-1224600381630-721324|none|190.40.27.239|31,46,51,63,77,82,94,100\n,110,150,353,357,521,891,1171,1352,1744,2700,3286,4482,4552,4568,5500,5526,5665,7258,8586,9109,9255,10016,10810,11693,11784,11819|Mozilla/4.0(com\npatible;MSIE7.0;WindowsNT6.0;WOW64;SLCC1;.NETCLR2.0.50727;.NETCLR3.0.04506;.NETCLR1.1.4322;InfoPath.2)|http://www.univision.com/uv/music/1169286/Enrique_Iglesias/fotos|/html.ng/SITE=AUDIT&CHANNEL=PORTAL&SUBCHANNEL=POP&SECTION=IGLESIASENRIQUE&CONTENT=PHOTOGALLERY&PARTNER=UNIVISION&CLIENT=AR\n"
    },
    {
        "Pattern": "^\\$(\\d{1,3}(\\,\\d{3})*|(\\d+))(\\.\\d{2})?$",
        "MatchingText": "$0.342 or $123.00, $1,234,422,345.0",
        "NonMatchingText": "123",
        "Description": "It should be universal regular expression for US currency."
    },
    {
        "Pattern": "[\\d+]{10}\\@[\\w]+\\.?[\\w]+?\\.?[\\w]+?\\.?[\\w+]{2,4}/i",
        "MatchingText": "1234211234@wifi.goodnet.com",
        "NonMatchingText": "xxx@email.com",
        "Description": "Requires 10 digit number. Rest is same as email"
    },
    {
        "Pattern": "^\\$YYYY\\$\\$MM\\$\\$DD\\$$",
        "MatchingText": "$YYYY$$MM$$DD$",
        "NonMatchingText": "$YY$$MM$$DD$",
        "Description": "Date Format notations. Mostly used in DB applications where rigorous pattern matching for DATE is required."
    },
    {
        "Pattern": "^(\\w+)s?\\:\\/\\/(\\w+)?(\\.)?(\\w+)?\\.(\\w+)$",
        "MatchingText": "http://www.url.com || http://url.com || http://first.url.com || https://www.url.com || https://url.com",
        "NonMatchingText": "http://.com",
        "Description": "http://www.url.com || http://url.com || http://first.url.com || https://www.url.com || https://url.com"
    },
    {
        "Pattern": "^(\\w+)s?[:]\\/\\/(\\w+)?[.]?(\\w+)[.](\\w+)$",
        "MatchingText": "http://www.url.com || http://url.com || http://first.url.com || https://www.url.com || https://url.com",
        "NonMatchingText": "http://.com",
        "Description": "http://www.url.com || http://url.com || http://first.url.com || https://www.url.com || https://url.com"
    },
    {
        "Pattern": "/Dr[.]?|Phd[.]?|MBA/i",
        "MatchingText": "Dr. Kumar Deepak Ranjan || Kumar Deepak Ranjan PHD. ||Kumar Deepak Ranjan MBA ",
        "NonMatchingText": "None",
        "Description": "Good way to quickly search for highly educated people in a list or file"
    },
    {
        "Pattern": "[\\w]+\\@[\\w]+\\.?[\\w]+?\\.?[\\w]+?\\.?[\\w+]{2,4}",
        "MatchingText": "any_name@mail.domain.com or any_name@mail.conf.domain.com, any_name@mail.com",
        "NonMatchingText": "any name@mail.com",
        "Description": "any email form like any_name@mail.confidential.yahoo.com, any_name@mail.yahoo.com, any_name@yahoo.com, any.name@yahoo.com, anyname@domain.com. You can replace .com with .net | .edu | .uk | .in or anything. I will work."
    },
    {
        "Pattern": "(\\d+)?-?(\\d+)-(\\d+)",
        "MatchingText": "xxx.xxx.xxxx or xxx-xxx-xxxx or xxx.xxxx",
        "NonMatchingText": "xxxx",
        "Description": "Normaly US 10 digit numbers are writen as xxx.xxx.xxxx or xxx-xxx-xxxx or simply 7 digit numbers for local websites where area code is filled by default xxx.xxxx or xxx-xxxx"
    },
    {
        "Pattern": "^\\d{3}\\s?\\d{3}\\s?\\d{3}$",
        "MatchingText": "123 456 789|||123456789|||123 456789",
        "NonMatchingText": "1234 5678 9|||123 456 7890|||123",
        "Description": "Social Insurance Number validator.  \nCanadians only need apply.\n\nIf somebody could help me (I'm bad at regex), I would like to modify this so that if there is one space after the 3rd digit (or 6th) then there must be one after the 6th (or third).  "
    },
    {
        "Pattern": "^(((0?[1-9]|[12]\\d|3[01])\\.(0[13578]|[13578]|1[02])\\.((1[6-9]|[2-9]\\d)\\d{2}))|((0?[1-9]|[12]\\d|30)\\.(0[13456789]|[13456789]|1[012])\\.((1[6-9]|[2-9]\\d)\\d{2}))|((0?[1-9]|1\\d|2[0-8])\\.0?2\\.((1[6-9]|[2-9]\\d)\\d{2}))|(29\\.0?2\\.((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "MatchingText": "1.1.2004|||01.01.2004|||29.2.2004",
        "NonMatchingText": "1/1/2004|||1-1-2004",
        "Description": "I did not found a Regex for german date, so I created my own. This RE validate dates in the dd.MM.yyyy format with leap years 100% integrated valid years from 1600 to 9999. As usual, many tests have been made. I think this one should be fine."
    },
    {
        "Pattern": "^((\\d{5}-?\\d{4})|(\\d{5})|([A-Za-z]\\d[A-Za-z]\\s?\\d[A-Za-z]\\d))$",
        "MatchingText": "90210, 90210-1234, 902101234, H0H0H0, h0h0h0, H0H 0H0, h0h 0h0",
        "NonMatchingText": "9021090210, California, ABC123, ABC 123, H0H H0H",
        "Description": "This expression more loosely matches three different formats of postal codes: 5 digit US ZIP code, 5 digit US ZIP code + 4, and 6 digit alphanumeric Canadian Postal Code. The first one must be 5 numeric digits. The ZIP+4 must be 5 numeric digits, a hyphen (optional), and then 4 numeric digits. The Canadian postal code must be of the form ANANAN where A is any alphabetic character (case insensitive) and N is a numeric digit from 0 to 9.  A space between the 2nd \"A\" and 2nd \"N\" is optional but not required, so the form could also be interpreted as \"ANA NAN\""
    },
    {
        "Pattern": "\\{CHBLOCK\\:(.*?\\})",
        "MatchingText": "{CHBLOCK:sdgs}|||{CHBLOCK:sdgs}sdg{CHBLOCK:sdgs}",
        "NonMatchingText": "{CHBLOCK}|||{CHBLOCK:sdgs",
        "Description": "Litle regexp for my portal engie. Only cut the {CHBLOCK:'modulename'} item"
    },
    {
        "Pattern": "^[0-9]{2}-[0-9]{8}-[0-9]$",
        "MatchingText": "20-28564123-9|||21-89656598-7|||20-89653265-8",
        "NonMatchingText": "202-56899-1|||1-23265865-9|||12548965232",
        "Description": "This regexp tests Argentinian CUIT / CUIT numbers.\n\nEsta expresi&#243;n regular sirve para validar n&#250;meros de CUIT / CUIL de Argentina."
    },
    {
        "Pattern": "^[A-Z]{1,3}\\d{6}$",
        "MatchingText": "A123456 XYZ123456",
        "NonMatchingText": "123456A 123456789A 123456789T1",
        "Description": "This will match Medicare Rail Road Board numbers."
    },
    {
        "Pattern": "^ *([AaBbCcEeGgHhJjKkLlMmNnPpRrSsTtVvXxYy]\\d[a-zA-Z]) *-* *(\\d[a-zA-Z]\\d) *$|^ *(\\d{5}) *$|^ *(\\d{5}) *-* *(\\d{4}) *$",
        "MatchingText": "\"H4H 3p4\" \"90210\" \"10110-4422\" \"v4p-5J3\"",
        "NonMatchingText": "\"D2T1R3\" \"92221-133\" \"xv3r p1T\"",
        "Description": "Matches all valid US standard, US +4, and Canadian postal codes. Returns results for only either one of them, in groups, regardless of case or whitespace (even dashes)."
    },
    {
        "Pattern": "^\\d{5}-\\d{3}$|^\\d{8}$",
        "MatchingText": "12345-678|||12345678",
        "NonMatchingText": "12345*678|||12345-67|||1234567",
        "Description": "Valida\u00E7\u00E3o de CEP Brasileiro. Aceita n\u00FAmero com tra\u00E7o ou sem tra\u00E7o."
    },
    {
        "Pattern": "^([A-HJ-PR-Y]{2,2}[056][0-9]\\s?[A-HJ-PR-Y]{3,3})$|^([A-HJ-NP-Y]{1,3}[0-9]{2,3}?\\s[A-Z]{3,3})$|^([A-Z]{1,3}\\s?[0-9]{1,4}([A-Z]{1,1})?)$|^([0-9]{4,4}[A-Z]{1,3})$|^([A-Z]{1,2}\\s?[0-9]{1,4})$|^([A-Z]{2,3}\\s?[0-9]{1,4})$|^([0-9]{1,4}\\s?[A-Z]{2,3})$",
        "MatchingText": "GL55 ABB ||| A23 GMP ||| UFG 158",
        "NonMatchingText": "GLB1 VVV ||| GL99 AAA ||| SSS 99999",
        "Description": "The regular expression above will validate a UK Vehicle Reg number according to the following criteria:\n\nPre 1932\nXX 9999 - 1 or 2 letters followed by 1 to 4 numbers\n\n1932 - 1963\nXXX 999 - 1 to 3 letters followed by 1 to 3 numbers\n9999 XXX - 4 numbers followed by 1 to 3 letters\n\n1962 - 1982\nXXX 999X - 1 to 3 letters followed by 1 to 3 numbers followed by 1 letter\n\n1983 - 2001\nXXX999 XXX - 1 to 3 letters (excluding I, Q and Z) followed by 2 to 3 numbers followed by 3 letter\n\n2001 to present\nXX99 XXX - 2 letters(excluding I, Q and Z) followed by 2 numbers (the first being 0, 5 or 6) followed by 3 letters\n\nNorthern Ireland\nXXX 9999 - 2 or 3 letters followed by 1 to 4 numbers\n9999 XXX - 1 to 4 numbers followed by 2 or 3 letters"
    },
    {
        "Pattern": "^(\\(?\\+?[0-9]*\\)?)?[0-9_\\- \\(\\)]*$",
        "MatchingText": "(+44)(0)20-12341234|||02012341234|||+44 (0) 1234-1234",
        "NonMatchingText": "(44+)020-12341234|||12341234(+020)",
        "Description": "A regular expression to match phone numbers, allowing for an international dialing code at the start and hyphenation and spaces that are sometimes entered."
    },
    {
        "Pattern": "((A|CA|H|JA|MA|MH|PA|PD|PH|WCA|WCD|WCH|WD|WH)[0-8][0-9]{2}(00)[0-9]{2}(0000)[0-9]{4})|([0-8][0-9]{2}(00)[0-9]{2}(0000)[0-9]{4}(A|B|Bl|B2|B3|B4|B5|B6|B7|B8|B9|BA|BD|BG|BH|BJ|BK|BL|BN|BP|BQ|BR|BT|BW|BY|Cl|C2|C3|C4|C5|C6|C7|C8|C9|CA|CB|CC|CD|CE|CF|CG|CH|CI|CJ|CK|CL|CM|CN|CO|CP|CQ|CR|CS|CT|CU|CV|CW|CX|CY|CZ|D|Dl|D2|D3|D4|D5|D6|D7|D8|D9|DA|DC|DD|DG|DH|DJ|DK|DL|DM|DN|DP|DQ|DR|DS|DT|DV|DW|DX|DY|DZ|E|El|E2|E3|E4|E5|E6|E7|E8|E9|EA|EB|EC|ED|EF|EG|EH|EJ|EK|EM|Fl|F2|F3|F4|F5|F6|F7|F8|Jl|J2|J3|J4|Kl|K2|K3|K4|K5|K6|K7|K8|K9|KA|KB|KC|KD|KE|KF|KG|KH|KJ|KL|KM|T|TA|TB|TC|TD|TE|TF|TG|TH|TJ|TK|TL|TM|TN|TP|TQ|TR|TS|TT|TU|TV|TW|TX|TY|TZ|T2|W|Wl|W2|W3|W4|W5|W6|W7|W8|W9|WB|WC|WF|WG|WJ|WR|WT))",
        "MatchingText": "H265897854",
        "NonMatchingText": "265897548KL",
        "Description": "The above regular expression is current as of 5/15/2014 as per any/all documentation easily found online.  CMS guidlines provides the following guidance as of 9/11/2002:  http://www.cms.gov/Regulations-and-Guidance/Guidance/Manuals/downloads/ge101c02.pdf\n\nSince that date all rules have remained steadfast except the range of SSN has been expanded from  a prefix of 772 to include all numbers through the prefix 899.\n\nNote: This regex assumes any/all dashes have been removed."
    },
    {
        "Pattern": "^[0-9][0-9,]*[0-9]$",
        "MatchingText": "123,345,4444444,56,6",
        "NonMatchingText": "12,@@34,fsff,333,",
        "Description": "It is for Comma separated integer values only.it won't allow comma before and end string.\nValid Expression :\n123,345,4444444,56,6\nInvalid Expressions :\n12,@@34,fsff,333,\n,12,234,456\n34,567,3456,\n111,11fff,&*,fff,567\n\nthe above all invalid."
    },
    {
        "Pattern": "^([-_.0-9])(.*[-_.][-_.])(.*[-_.]$)[A-Za-z0-9-_.]+$",
        "MatchingText": "my.username|||u-s-e-r.n_a_m_e|||xyz724|||c1",
        "NonMatchingText": "9abc|||x..z|||a._-c|||-a|||c54_",
        "Description": "Provide username constraint that allow character and numeric and also perion hyphen and underscore, but it only allows alphabet at the begin, and alphanumeric at the end. also user may not user more than one sign side by side"
    },
    {
        "Pattern": "(http://([\\w-]+\\.)|([\\w-]+\\.))+[\\w-]*(/[\\w- ./?%=]*)?",
        "MatchingText": "http://www.mk.com,www.mk.com,www.mk.com/default.aspx,http://www.mk.com/default.aspx",
        "NonMatchingText": ".com,wwww,1234",
        "Description": "Regular Expression matches any internet URLs. Used with the replace method it comes in very handy."
    },
    {
        "Pattern": "(\\/\\*(\\s*|.*?)*\\*\\/)|(--.*)",
        "MatchingText": "/* My Comment */|||-- A single line comment",
        "NonMatchingText": "*/ Won't work /*|||// Not likely|||- uh uh",
        "Description": "This pattern will match any multi-line or single line comments in TSQL (Stored Procedures or SPROC's) in MS SQL Server."
    },
    {
        "Pattern": "^((\\d?)|(([-+]?\\d+\\.?\\d*)|([-+]?\\d*\\.?\\d+))|(([-+]?\\d+\\.?\\d*\\,\\ ?)*([-+]?\\d+\\.?\\d*))|(([-+]?\\d*\\.?\\d+\\,\\ ?)*([-+]?\\d*\\.?\\d+))|(([-+]?\\d+\\.?\\d*\\,\\ ?)*([-+]?\\d*\\.?\\d+))|(([-+]?\\d*\\.?\\d+\\,\\ ?)*([-+]?\\d+\\.?\\d*)))$",
        "MatchingText": "8.0|||8.0,-.38,+8.9|||8.0, +8.8, 0.09",
        "NonMatchingText": "+|||.|||a,b, c",
        "Description": "This allows a sequence of real numbers to be added, separated by a comma (required) and a space (optional).  Based pretty heavily on an expression by Steven Smith on this site."
    },
    {
        "Pattern": "(?P<user>(?:(?:[^ \\t\\(\\)\\<\\>@,;\\:\\\\\\\"\\.\\[\\]\\r\\n]+)|(?:\\\"(?:(?:[^\\\"\\\\\\r\\n])|(?:\\\\.))*\\\"))(?:\\.(?:(?:[^ \\t\\(\\)\\<\\>@,;\\:\\\\\\\"\\.\\[\\]\\r\\n]+)|(?:\\\"(?:(?:[^\\\"\\\\\\r\\n])|(?:\\\\.))*\\\")))*)@(?P<domain>(?:(?:[^ \\t\\(\\)\\<\\>@,;\\:\\\\\\\"\\.\\[\\]\\r\\n]+)|(?:\\[(?:(?:[^\\[\\]\\\\\\r\\n])|(?:\\\\.))*\\]))(?:\\.(?:(?:[^ \\t\\(\\)\\<\\>@,;\\:\\\\\\\"\\.\\[\\]\\r\\n]+)|(?:\\[(?:(?:[^\\[\\]\\\\\\r\\n])|(?:\\\\.))*\\])))*)",
        "MatchingText": "Trais.Gray@domain.biz|||\"Funny email\".notfunny@glxs.biz|||ok@[funny domain].co.za",
        "NonMatchingText": "\"TravisGray\"extra@ domain.biz",
        "Description": "Validates email addresses according to the RFC 822 specification. The only exception is the exclusion of control characters, which should be sufficient for human input from a keyboard."
    },
    {
        "Pattern": "^((.){1,}(\\d){1,}(.){0,})$",
        "MatchingText": "Teststreet 32 | T\u00F8rststr\u00E6de 4 | T\u00F8rststr\u00E6de 24 1. tv",
        "NonMatchingText": "T\u00F8rststr\u00E6de | 2 T\u00F8rststr\u00E6de",
        "Description": "Does a very basic validation on Danish street addresses.\n\nIt ensures that the format \"Address No\" is honored, but also allows any char to be put after the address.\nThis is to ensure additions like floor, and which door it is. Ex. \"Addrees No Floor LeftDoor.\"\nEnjoy!"
    },
    {
        "Pattern": "^/{1}(((/{1}\\.{1})?[a-zA-Z0-9 ]+/?)+(\\.{1}[a-zA-Z0-9]{2,4})?)$",
        "MatchingText": "/mnt/share/|||/home/.BASH|||/mnt/share/pic.jpeg|||/mnt/share/install.sh",
        "NonMatchingText": "mnt/share|||//mnt///share//|||/mnt/share/install.installer|||/home\\user",
        "Description": "This expressions was written for C#. Matches all valid Linux absolute paths (files or folders). Will not work for relative paths that do not begin with a /, Also  will only match files that have extensions consisting of 2, 3, or 4 characters. Currently fails with _ . or - in the path, this will be updated at some point."
    },
    {
        "Pattern": "https?://[\\w./]+\\/[\\w./]+\\.(bmp|png|jpg|gif)",
        "MatchingText": "http://image2.sina.com.cn/home/07index/sinahome_ws_035.gif",
        "NonMatchingText": "img src=\"images/1.jpg\"",
        "Description": "match web pictrue's address,must be full path,include http head."
    },
    {
        "Pattern": "[0-3]{1}[0-9]{1}(jan|JAN|feb|FEB|mar|MAR|apr|APR|may|MAY|jun|JUN|jul|JUL|aug|AUG|sep|SEP|oct|OCT|nov|NOV|dec|DEC){1}",
        "MatchingText": "12jan|||23dec",
        "NonMatchingText": "4jul|||40sep",
        "Description": "Express\u00E3o para datas no formato ddMMM obrigando dois d\u00EDgitos para o dia e tr\u00EAs letras para o m\u00EAs (em ingl\u00EAs). Regex for dates at ddMMM format mandatory two digits for days and three letters for the months."
    },
    {
        "Pattern": "&lt;[iI][mM][gG]([^&gt;]*[^/&gt;]*[/&gt;]*[&gt;])",
        "MatchingText": "&lt;img src=&quot;/images/foo.gif&quot; /&gt;|||&lt;img src=&quot;/images/foo.gif&quot;&gt;",
        "NonMatchingText": "unknown",
        "Description": "This is a derivation of a few other image tag regex patterns I found on the site that didn't seem to work. This is my first regex, so if I did this wrong - apologies in advance! It works for me..."
    },
    {
        "Pattern": "&lt;[iI][fF][rR][aA][mM][eE]([^&gt;]*[^/&gt;]*[/&gt;]*[&gt;])",
        "MatchingText": "&lt;IFRAME ...&gt;&lt;/IFRAME&gt;",
        "NonMatchingText": "unknown",
        "Description": "My second ever regex - a derivation of an image tag pattern, use in conjunction with &lt;[iI][mM][gG]([^&gt;]*[^/&gt;]*[/&gt;]*[&gt;]) to remove advertisements from RSS feeds. Whee!"
    },
    {
        "Pattern": "^[AHJ-NPR-UW-Z]{2}\\s?[0-9]{3}\\s?[AHJ-NPR-UW-Z]{2}$",
        "MatchingText": "AA999AA       |     AA 123 AB      |     WA756AC",
        "NonMatchingText": "AI999AA        |    AQ 123 AB",
        "Description": "Almost identical to French except no hyphens (optional space) and digits 000 are allowed. s in French no letters I,O,Q or V\n\n AA999AA"
    },
    {
        "Pattern": "^[1-9][0-9]{1,6}\\-[0-9]{2}\\-[0-9]",
        "MatchingText": "506-64-9     |       1234567-21-1",
        "NonMatchingText": "506-64-19   |       12345678-21-1",
        "Description": "Other examples of this show there being upto 6 digits at the start however according to the official website, it should be 7\nhttps://www.cas.org/content/chemical-substances/faqs"
    },
    {
        "Pattern": "^([1-9]+)?[02468]$",
        "MatchingText": "2       |       64          |      4343253298",
        "NonMatchingText": "3       |      65           |      5345643531",
        "Description": "Any number possible as long as its even."
    },
    {
        "Pattern": "\\-?(90|[0-8]?[0-9]\\.[0-9]{0,6})\\,\\-?(180|(1[0-7][0-9]|[0-9]{0,2})\\.[0-9]{0,6})",
        "MatchingText": "-89.999999,180|0.01234,-12.32|90,180|",
        "NonMatchingText": "-90.01,0.121|15.00001,181|90.1,-181",
        "Description": "Parses Standard Latitude, Longitude notation for identifying earth co-ordinates (as per google maps etc). Allows values in format dd.dddddd,ddd.dddddd (lat, lng) where lat can be in range -90 to 90 and lng in range -180 - 180"
    },
    {
        "Pattern": "(([A-HJ-PRSTW]|A[BDHR]|BCK|B[ADEFHK-ORSUW]|BRD|C[AEFHKLNOSTY]|D[AEHKORS]|F[DEHRY]|G[HKNRUWY]|H[HL]|I[EH]|INS|KY|L[AHIKLNORTY]|M[EHLNRT]|N[ENT]|OB|P[DEHLNTWZ]|R[NORXY]|S[ACDEHMNORSTUY]|SSS|T[HNOT]|UL|W[ADHIKNOTY]|YH)[1-9][0-9]{0,2})|([1-9][0-9]{0,2}([A-HJ-PRSTW]|A[BDHR]|BCK|B[ADEFHK-ORSUW]|BRD|C[AEFHKLNOSTY]|D[AEHKORS]|F[DEHRY]|G[HKNRUWY]|H[HL]|I[EH]|INS|KY|L[AHIKLNORTY]|M[EHLNRT]|N[ENT]|OB|P[DEHLNTWZ]|R[NORXY]|S[ACDEHMNORSTUY]|SSS|T[HNOT]|UL|W[ADHIKNOTY]|YH))",
        "MatchingText": "BH156    |     AA12      |      CA52      |       172FD",
        "NonMatchingText": "B156H    |     AC12      |      CB52      |       1172FD",
        "Description": "Maritime vessels are required to be registered in the port nearest to them. Each boat is registered with a 2 Alpha and between 1 and 3 digits reference denoting the port and number. Large boats have the alpha first while small vessels start with the digits"
    },
    {
        "Pattern": "([AEHKLTY][ABEHKLMPRSTWXYZ]|B[ABEHKLMT]|C[ABEHKLR]|GY|[JS][ABCEGHJKLMNPRSTWXYZ]|M[AWX]|N[ABEHLMPRSWXYZ]|O[ABEHKLMPRSX]|P[ABCEGHJKLMNPRSTWXY]|R[ABEHKMPRSTWXYZ]|W[ABEKLMP]|Z[ABEHKLMPRSTWXY])[0-9]{6}[A-D]?",
        "MatchingText": "AB123456A    |    GY654321D",
        "NonMatchingText": "AC123456A    |    GY654321E",
        "Description": "None of the 3 previous examples were fully correct, there are only certain combinations of letters at the start of the NINO rather than simply excluding a handful of allowable chars. The suffix on the end can only be A,B,C or D (M&F were deprecated Temp NINO values)"
    },
    {
        "Pattern": "^(GB)?([0-9]{9})$",
        "MatchingText": "GB123456789     |        123456789",
        "NonMatchingText": "GB12345678       |        AA123456789      |      1234567",
        "Description": "If you dont need to validate anything other than UK Numbers then this is for you, with optional GB at the start. If you need other countries then the EU Pattern is better suited"
    },
    {
        "Pattern": "^[0-9]{8}R[A-HJ-NP-TV-Z]$",
        "MatchingText": "12345678RA       |        43213245RT",
        "NonMatchingText": "1234567RA        |         432132456RR",
        "Description": "Pension Schemes have their own references, 8 digits followed by R and then another letter."
    },
    {
        "Pattern": "[A-Za-z]{2}[0-9]{1,6}|[0-9]{1,8}",
        "MatchingText": "AA213432      |     12345678",
        "NonMatchingText": "12AA3456      |      123456AV",
        "Description": "CIS Reference for Self Employed Construction Industry Workers."
    },
    {
        "Pattern": "((\\bm_[a-zA-Z\\d]*\\b)|(\\bin_[a-zA-Z\\d]*\\b)|(\\bin _[a-zA-Z\\d]*\\b))",
        "MatchingText": "in_name|||m_name",
        "NonMatchingText": "this.name",
        "Description": "This regex limits the use of any special prefix characters to indicate that the variable is scoped to the class. "
    },
    {
        "Pattern": "\\binterface\\b.*(\\bI[_]\\w*\\b)",
        "MatchingText": "interface I_Point",
        "NonMatchingText": "interface IPoint",
        "Description": "This regex forbids the use of underscore in the interface decleration."
    },
    {
        "Pattern": "^(?:Ala(?:(?:bam|sk)a)|American Samoa|Arizona|Arkansas|(?:^(Baja )California)|Colorado|Connecticut|Delaware|District of Columbia|Florida|Georgia|Guam|Hawaii|Idaho|Illinois|Indiana|Iowa|Kansas|Kentucky|Louisiana|Maine|Maryland|Massachusetts|Michigan|Minnesota|Miss(?:(?:issipp|our)i)|Montana|Nebraska|Nevada|New (?:Hampshire|Jersey|Mexico|York)|North (?:(?:Carolin|Dakot)a)|Ohio|Oklahoma|Oregon|Pennsylvania|Puerto Rico|Rhode Island|South (?:(?:Carolin|Dakot)a)|Tennessee|Texas|Utah|Vermont|Virgin(?:ia| Island(s?))|Washington|West Virginia|Wisconsin|Wyoming|A[KLRSZ]|C[AOT]|D[CE]|FL|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$",
        "MatchingText": "California, NY, VI",
        "NonMatchingText": "Baja California, MP, York",
        "Description": "Includes all 50 states, some territories, plus two-letter abbreviations. Specifically excludes \"Baja California\" due to the data set that originally drove me to this expression."
    },
    {
        "Pattern": "^\\w+(([-+']|[-+.]|\\w+))*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$",
        "MatchingText": "Any letter, number or underscore,dot,quotes",
        "NonMatchingText": "Any char except letter, number,dot,quotes",
        "Description": "Allow quotes in email address. Its Allow to enter quotes after first char and before @."
    },
    {
        "Pattern": "How to Avert Spotting on Oral Contraceptive?",
        "MatchingText": "How to Avert Spotting on Oral Contraceptive?",
        "NonMatchingText": "How to Avert Spotting on Oral Contraceptive?",
        "Description": "The spotting normally engages only a small amount of blood and regularly does not need the use of a feminine hygiene product, like tampons or sanitary pads. If the problem persists, need to grab the right information from authorized source - goo.gl/gj4ftt"
    },
    {
        "Pattern": "^\\s*[a-zA-Z\\s]+\\,[0-9\\s]+\\s*$",
        "MatchingText": "navjot, 24  | Sweet, 23",
        "NonMatchingText": "456, abcd | abcd 123",
        "Description": "its validating the string as shown in example(matches)."
    },
    {
        "Pattern": "(\\d{3}.?\\d{3}.?\\d{3}-?\\d{2})",
        "MatchingText": "000.000.000-00|||00000000000",
        "NonMatchingText": "0000.00.000-00|||0000000",
        "Description": "Brazilian CPF - Personal document in Brazil."
    },
    {
        "Pattern": "^\\d{5}(\\d{3})?$",
        "MatchingText": "12345|||12345678",
        "NonMatchingText": "123.45|||12345-678",
        "Description": "Brazilian CEP. A variable of others validations, but only numbers are allowed.  \n  \n"
    },
    {
        "Pattern": "\\w+([-+.]\\w+)*@((hotmail|gmail|yahoo|msn|excite|lycos|aol|live)\\.com$)\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*",
        "MatchingText": "joe@somewhere.com | jo-elaine@myfunplace.com",
        "NonMatchingText": "joe@gmail.com | joe@a",
        "Description": "Should you need to validate that an email address is correctly formmatted and need to block hotmail and gmail, this expression will do it for you.  Thanks to Sergei Z from regexadvice.com"
    },
    {
        "Pattern": "(Word1|Word2).*?(10|[1-9])",
        "MatchingText": "Word1: I need to extract this substring starting with testing. 8",
        "NonMatchingText": "This is a test, again I am test",
        "Description": "If you have one or more words that you are searching for, random text and then a number at the end from 0 to 10, this regex should work."
    },
    {
        "Pattern": "^\\d{1,7}$",
        "MatchingText": "1234567|||9999999|||1",
        "NonMatchingText": "12345678|||9999.99|||-1234",
        "Description": "Positive Whole number matched from 0 to 9999999. Only 7 digits length is allowed."
    },
    {
        "Pattern": "^((\\d{2}(([02468][048])|([13579][26]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])))))|(\\d{2}(([02468][1235679])|([13579][01345789]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))(\\s(((0?[1-9])|(1[0-9])|(2[0-3]))\\:([0-5][0-9])((\\s)|(\\:([0-5][0-9])))?))?$",
        "MatchingText": "2006-1-20|||2006/01/20|||2006-01-20 15:30|||2006-01-20 15:30:21",
        "NonMatchingText": "2003-2-29|||2003-13-02|||2003-2-2 10:72:30",
        "Description": "Date YYYY-MM-DD (optional time HH:MM(optional seconds :SS)).  Was borrowed from this [http://regexlib.com/REDetails.aspx?regexp_id=390] but changed to use 24 hour time and optional seconds.  You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099."
    },
    {
        "Pattern": "^(?:(\\\\d{1,6})-)?(\\\\d{2,10})/(\\\\d{4})$",
        "MatchingText": "1234567890/1234|12-1234567890/1234|1-12/1234",
        "NonMatchingText": "1/1|1/1234/12345678901/1234",
        "Description": "Czech domestic bank acount number.\n\n"
    },
    {
        "Pattern": "Dynamical Solar Power Pack This portable product is designed to power digital devices like laptops, digital cameras, phones, blue tooth earphones, GPS, Pads, PSP, MP3 players and MP4 players and is equipped with alternative lighting modes. In the meanwhile, it can jump start a car. Key words: multifunctional solar charger panel; outdoor solar charger for iphone; portable foldable outdoor solar charger; hiking solar charger for iphone; multi charger mobile devices a.Quick details Place of Origin: China (Mainland) Brand Name: Sunharmonics Model Number: SY-DSPP Accessories: Emergency Power Supply and Charger Bag Flexibility: Portable Size: 258*160*25mm Output: 30W Solar panel: Flexible CIGS Weight: 1.5kg b.Packaging & Delivery Delivery Detail: Shipped in 15 days after payment c.Product Description ? Power 5V,12V~19V electronics ? Jump start automobile ? 30W portable solar charger ? LED displays battery charging state ? Safe, high efficiency lithium battery ? Built-in LED illumination light ? Selectable output voltage ? Dedicated USB outlet d.Applications e.Accessories The dynamical solar power pack is equipped with 20W or 30W solar charger and multifunction jump starter kit. SY-SPF20SY-SPF30 Maximum power20W30W Maximum tolerance\u00B17%\u00B17% Voc28.8V22.8V Isc1.5A2.1A Peak voltage19.2V18.8V Peak current1.4A1.6A Size folded290*196*25mm258*160*25mm Weight300g560g Output interfaceSAE/DC+USBSAE/DC+USB Working temperature-40~70?-40~70? Warranty1 year1 year Multifunction jump starter kit Outputs5V/2.1A\u2014USB devices 12V?16V?19V/3.5A\u201412Vdevices 12V/200A\u2014car emergency start output Size170*79*41mm Charging methodCC/CV 15V 1A Peak current400A(3S) Cyclic life3000 times Working temperature-10?\u201485?  cheap Multifunctional Emergency Solar Charger website:http://www.sygdcigscell.com/outdoor-modules/multifunctional-emergency-solar-charger/",
        "MatchingText": "zzx",
        "NonMatchingText": "xxc",
        "Description": "Dynamical Solar Power Pack\nThis portable product is designed to power digital devices like laptops, digital cameras, phones, blue tooth earphones, GPS, Pads, PSP, MP3 players and MP4 players and is equipped with alternative lighting modes. In the meanwhile, it can jump start a car.\nKey words: multifunctional solar charger panel; outdoor solar charger for iphone; portable foldable outdoor solar charger; hiking solar charger for iphone; multi charger mobile devices\na.Quick details\nPlace of Origin: China (Mainland)\nBrand Name: Sunharmonics\nModel Number: SY-DSPP\nAccessories: Emergency Power Supply and Charger Bag\nFlexibility: Portable\nSize: 258*160*25mm\nOutput: 30W\nSolar panel: Flexible CIGS\nWeight: 1.5kg\nb.Packaging & Delivery\nDelivery Detail: Shipped in 15 days after payment\nc.Product Description\n? Power 5V,12V~19V electronics\n? Jump start automobile\n? 30W portable solar charger\n? LED displays battery charging state\n? Safe, high efficiency lithium battery\n? Built-in LED illumination light\n? Selectable output voltage\n? Dedicated USB outlet\nd.Applications\ne.Accessories\nThe dynamical solar power pack is equipped with 20W or 30W solar charger and multifunction jump starter kit.\nSY-SPF20SY-SPF30\nMaximum power20W30W\nMaximum tolerance\u00B17%\u00B17%\nVoc28.8V22.8V\nIsc1.5A2.1A\nPeak voltage19.2V18.8V\nPeak current1.4A1.6A\nSize folded290*196*25mm258*160*25mm\nWeight300g560g\nOutput interfaceSAE/DC+USBSAE/DC+USB\nWorking temperature-40~70?-40~70?\nWarranty1 year1 year\nMultifunction jump starter kit\nOutputs5V/2.1A\u2014USB devices\n12V?16V?19V/3.5A\u201412Vdevices\n12V/200A\u2014car emergency start output\nSize170*79*41mm\nCharging methodCC/CV 15V 1A\nPeak current400A(3S)\nCyclic life3000 times\nWorking temperature-10?\u201485?\n cheap Multifunctional Emergency Solar Charger\nwebsite:http://www.sygdcigscell.com/outdoor-modules/multifunctional-emergency-solar-charger/"
    },
    {
        "Pattern": "Shenyang Hualun Lubricant Additive Co.,Ltd . is a professional lubricant additive designer, manufacturer and supplier. We were founded in 1999, located in the heavy industry city-Shenyang. Within the development, we have an innovative research group, advanced manufacturing facilities and severe testing procedure. Hualun has passed the ISO9001:2000 Certificate in 2003. The annual production capacity is 5000 tons. We specialize in lubricant components and lubricant additive packages. The main lubricant components are detergents & dispersants, antioxidants, corrosion inhibitors, EP anti-wear agents, friction modifiers, emulsifiers, viscosity index improvers. The main additive packages are additive packages of engine oil, gear oil, hydraulic oil, industrial lubricant etc. Due to the quality of the products is good, stable and reliable, and is deeply trusted by customers, the company production growth, products enter the international market smoothly. At present, products are exported to the country more than 30 provinces, cities and autonomous regions and exported to Taiwan, Spain, southeast Asia, South Africa and other countries.P120, T406E, YM Metal passivator are our proprietary intellectual property products which have uniquely excellent properties. They are at the advanced level of the similar products worldwide. With high product quality, competetive product price and excellent after-sales service, Hualun have very high reputation in lubricant industry of China. Our products are traded to many countries and regions around the world. Performance products, precise product data, attentive service and technique support are provided to you. Welcome to visit our company in Shenyang, Liaoning Province.  Lube oil additive website:http://www.syhltjj-lube-additive.com/",
        "MatchingText": "zzx",
        "NonMatchingText": "xxc",
        "Description": "Shenyang Hualun Lubricant Additive Co.,Ltd . is a professional lubricant additive designer, manufacturer and supplier. We were founded in 1999, located in the heavy industry city-Shenyang. Within the development, we have an innovative research group, advanced manufacturing facilities and severe testing procedure. Hualun has passed the ISO9001:2000 Certificate in 2003. The annual production capacity is 5000 tons.\nWe specialize in lubricant components and lubricant additive packages. The main lubricant components are detergents & dispersants, antioxidants, corrosion inhibitors, EP anti-wear agents, friction modifiers, emulsifiers, viscosity index improvers. The main additive packages are additive packages of engine oil, gear oil, hydraulic oil, industrial lubricant etc. Due to the quality of the products is good, stable and reliable, and is deeply trusted by customers, the company production growth, products enter the international market smoothly. At present, products are exported to the country more than 30 provinces, cities and autonomous regions and exported to Taiwan, Spain, southeast Asia, South Africa and other countries.P120, T406E, YM Metal passivator are our proprietary intellectual property products which have uniquely excellent properties. They are at the advanced level of the similar products worldwide.\nWith high product quality, competetive product price and excellent after-sales service, Hualun have very high reputation in lubricant industry of China. Our products are traded to many countries and regions around the world.\nPerformance products, precise product data, attentive service and technique support are provided to you.\nWelcome to visit our company in Shenyang, Liaoning Province.\n Lube oil additive\nwebsite:http://www.syhltjj-lube-additive.com/"
    },
    {
        "Pattern": "Shenzhen chuangan Electronic Co., Ltd. was established in 2008, Shenzhen is a professional engaged in anti-theft alarm equipment R & D, production and sales of high-tech private enterprises. Mainly engaged in magnetometer detector, emergency button, infrared detector, smoke detector, gas detector, the acousto-optic alarm, horn, etc. security products. The company after years of development and accumulated rich anti-theft alarm products technology development and production experience.  Have a high-quality development and production team and advanced production and testing equipment company, a large production base, with a strong production capacity matching. Products are sold and exported in Europe and America, the Middle East, Southeast Asia, and other countries and Hong Kong and Taiwan. And a number of distribution, engineering contractors maintained long-term cooperation.  Company according to the standard of ISO9001: 200, the establishment of a strict quality management system, products through the CE.ROHS environmental protection certification. Covers incoming inspection, process inspection and outgoing inspection of each link, guarantee delivery of finished products pass rate of 100%; chuang\u2018an company to a \"customer first, reputation first\" as its purpose, perseverance to customers provide the best quality products and efficient high-efficient service to meet customer needs and exceed customer expectations.  Enterprise spirit : \"customer first, integrity gratitude\"  Quality policy :  the quality assurance of products and service quality. Starting from the most subtle, continuous pursuit of perfection, with the use of sophisticated equipment to produce high quality products Integrity, Thanksgiving is our principles, dedication, innovation is our work attitude.  Thanks to your support and cooperation, to provide you with high cost of security products and good service will be the direction of our continuous effortsIR beam motion detector brands website:http://www.szca-alarm.com/",
        "MatchingText": "zzx",
        "NonMatchingText": "xxc",
        "Description": "Shenzhen chuangan Electronic Co., Ltd. was established in 2008, Shenzhen is a professional engaged in anti-theft alarm equipment R & D, production and sales of high-tech private enterprises. Mainly engaged in magnetometer detector, emergency button, infrared detector, smoke detector, gas detector, the acousto-optic alarm, horn, etc. security products. The company after years of development and accumulated rich anti-theft alarm products technology development and production experience. \nHave a high-quality development and production team and advanced production and testing equipment company, a large production base, with a strong production capacity matching. Products are sold and exported in Europe and America, the Middle East, Southeast Asia, and other countries and Hong Kong and Taiwan. And a number of distribution, engineering contractors maintained long-term cooperation. \nCompany according to the standard of ISO9001: 200, the establishment of a strict quality management system, products through the CE.ROHS environmental protection certification. Covers incoming inspection, process inspection and outgoing inspection of each link, guarantee delivery of finished products pass rate of 100%; chuang\u2018an company to a \"customer first, reputation first\" as its purpose, perseverance to customers provide the best quality products and efficient high-efficient service to meet customer needs and exceed customer expectations. \nEnterprise spirit : \"customer first, integrity gratitude\" \nQuality policy :  the quality assurance of products and service quality. Starting from the most subtle, continuous pursuit of perfection, with the use of sophisticated equipment to produce high quality products Integrity, Thanksgiving is our principles, dedication, innovation is our work attitude. \nThanks to your support and cooperation, to provide you with high cost of security products and good service will be the direction of our continuous effortsIR beam motion detector brands\nwebsite:http://www.szca-alarm.com/"
    },
    {
        "Pattern": "  Shenzhen CLAN brings you high quality and discount sc apc/upc fiber optic adaptor made in China from its professional factory. We are one of the leading China manufacturers and suppliers in the optical fiber field. Welcome to wholesale the customized and low price optical fiber products in stock with us and get the free sample from us. Basic Info Structure: SC Ferrule Endface: Upc/APC Fabrication Process: Moulded Connector Type: Sc, FC, St, LC, Mu, MTRJ Sleeve: Ceramic, Bronze Return Loss: More Than 45dB Warranty: 5 Years Transport Package: Customized Origin:China Transmission Medium: Singlemode or Multimode Number of Cores: Single or Multi Core Shape: Square Application: Fiber Distribution Frame Brand: OEM Insertion Loss: Less Than 0.2dB Delivery Time: Within 2 to 3 Days Specification: 1 pcs Product Description Sc APC/UPC Fiber Optic Adaptor Fiber Optic Adapter / Adaptor is a fiber optic connector on the activities of linking components. The complete series of products, including FC, SC, ST, LC, MTRJ, widely used in optical distribution frames (ODF), and optical fiber communications equipment, instrumentation, performance is stable and reliable. Features: 1. Precise size 2. Excellent repeatability 3. Ceramic caps can provide low-loss and the stability of specifications 4. Caps diameter (mm): 0.125 ~ 0.127 (0.140mm is available) 5. Caps diameter (mm): 2.499\u00B10.0005 for SM (\u00B10.001 for MM) 6. Sheath diameter (mm): 0.9, 2.0, 2.4, 3.0 7. Insertion loss: <0.3 dB for SM, <0.5 dB for MM, <0.4 dB for SM / APC 8. Reflection attenuation: >45 dB for PC, and >50 dB for UPC, >65 dB for APC 9. Environmental requirements: Ambient temperature: -40 ? to 85 ? Storage temperature: -45 ? ~ +95 ? Application: 1. Optical fiber communication network 2. Fiber Broadband Access Network 3. CATV fiber 4. FTTP 5. LAN & WAN typeFC/PCFC/APCSC/PCSC/APCST/PC Insertion loss<0.20 (dB) Repeatability<0.10 (dB) Interchangeability<0.20 (dB) Telescopic materialsCeramic Temperature-40 _ +80 (?) Storage temperature-40 _ +85 (?) Certicicate: Factory Show: SHENZHEN CLAN OPTICAL COMMUNICATION CO.,LTD Add:Longquan Information Science And Technology Industrial Park,No.19,Huaxing Rd,Dalang,Longhua Distance,Shenzhen City,China Contact US: Daisy Liu                                                     Justin Chen Whatsapp      +86-13927477074                Whatsapp       +86-13927477861 Skype            daisy@cxclan.com                Skype             chen.justin4 Facebook      daisy@cxclan.com                Facebook       justin@cxclan.com E-mail            daisy@cxclan.com                E-mail            justin@cxclan.comSC Adapter website:http://www.szclanoptic.com/fiber-optic-adapter/sc-adapter/",
        "MatchingText": "zzx",
        "NonMatchingText": "xxc",
        "Description": "  Shenzhen CLAN brings you high quality and discount sc apc/upc fiber optic adaptor made in China from its professional factory. We are one of the leading China manufacturers and suppliers in the optical fiber field. Welcome to wholesale the customized and low price optical fiber products in stock with us and get the free sample from us.\nBasic Info\nStructure: SC\nFerrule Endface: Upc/APC\nFabrication Process: Moulded\nConnector Type: Sc, FC, St, LC, Mu, MTRJ\nSleeve: Ceramic, Bronze\nReturn Loss: More Than 45dB\nWarranty: 5 Years\nTransport Package: Customized\nOrigin:China\nTransmission Medium: Singlemode or Multimode\nNumber of Cores: Single or Multi Core\nShape: Square\nApplication: Fiber Distribution Frame\nBrand: OEM\nInsertion Loss: Less Than 0.2dB\nDelivery Time: Within 2 to 3 Days\nSpecification: 1 pcs\nProduct Description\nSc APC/UPC Fiber Optic Adaptor\nFiber Optic Adapter / Adaptor is a fiber optic connector on the activities of linking components. The complete series of products, including FC, SC, ST, LC, MTRJ, widely used in optical distribution frames (ODF), and optical fiber communications equipment, instrumentation, performance is stable and reliable.\nFeatures:\n1. Precise size\n2. Excellent repeatability\n3. Ceramic caps can provide low-loss and the stability of specifications\n4. Caps diameter (mm): 0.125 ~ 0.127 (0.140mm is available)\n5. Caps diameter (mm): 2.499\u00B10.0005 for SM (\u00B10.001 for MM)\n6. Sheath diameter (mm): 0.9, 2.0, 2.4, 3.0\n7. Insertion loss: <0.3 dB for SM, <0.5 dB for MM, <0.4 dB for SM / APC\n8. Reflection attenuation: >45 dB for PC, and >50 dB for UPC, >65 dB for APC\n9. Environmental requirements: Ambient temperature: -40 ? to 85 ? Storage temperature: -45 ? ~ +95 ?\nApplication:\n1. Optical fiber communication network\n2. Fiber Broadband Access Network\n3. CATV fiber\n4. FTTP\n5. LAN & WAN\ntypeFC/PCFC/APCSC/PCSC/APCST/PC\nInsertion loss<0.20\n(dB)\nRepeatability<0.10\n(dB)\nInterchangeability<0.20\n(dB)\nTelescopic materialsCeramic\nTemperature-40 _ +80\n(?)\nStorage temperature-40 _ +85\n(?)\nCerticicate:\nFactory Show:\nSHENZHEN CLAN OPTICAL COMMUNICATION CO.,LTD\nAdd:Longquan Information Science And Technology Industrial Park,No.19,Huaxing Rd,Dalang,Longhua Distance,Shenzhen City,China\nContact US:\nDaisy Liu                                                     Justin Chen\nWhatsapp      +86-13927477074                Whatsapp       +86-13927477861\nSkype            daisy@cxclan.com                Skype             chen.justin4\nFacebook      daisy@cxclan.com                Facebook       justin@cxclan.com\nE-mail            daisy@cxclan.com                E-mail            justin@cxclan.comSC Adapter\nwebsite:http://www.szclanoptic.com/fiber-optic-adapter/sc-adapter/"
    },
    {
        "Pattern": "Shenzhen Guanke Aquarium Products Co,. Ltd. is a professional aquarium equipment manufacturer which sets product design, production and sales as one. Since 2010, our company began to produce LED aquarium dedicated lights, and now the products expands to small fish tank, air pump, heater, filter, germicidal lamp and so on. And most of our products has passed a variety of certification include CE, FCC etc. Our company has a strong R&D team consists of many engineers with 10 years experience. Based on the unique talent advantages and innovative spirit in Shenzhen, we focus on research and development to enhance and improve our products in the market and to keep pace with the times. Our company deeply understands the true value of E-commerce is being fast and best.We insist on the belief of \"Faster delivery and higher quality\".Since the establishment,we have been serving in the field of domestic E-commerce and cross-border E-commerce for many years,and have made some significant achievements:our brand of GAKO became the brand merchant in Tmall and several authorized store sales ahead of the same industry.In addition,our company has become the stable cooperation partner of many famous cross-border e-commerce companies. We insist on \"customers first\" and try the shortest delivery time to provide top quality products and good service. We place great significance in our employees and care for their career development. People with a passion to grow are now invited to join us for a bright future.Small Fish Tanks price website:http://www.szgako.com/ website2:http://www.szgako.net/",
        "MatchingText": "zzx",
        "NonMatchingText": "xxc",
        "Description": "Shenzhen Guanke Aquarium Products Co,. Ltd. is a professional aquarium equipment manufacturer which sets product design, production and sales as one. Since 2010, our company began to produce LED aquarium dedicated lights, and now the products expands to small fish tank, air pump, heater, filter, germicidal lamp and so on. And most of our products has passed a variety of certification include CE, FCC etc.\nOur company has a strong R&D team consists of many engineers with 10 years experience. Based on the unique talent advantages and innovative spirit in Shenzhen, we focus on research and development to enhance and improve our products in the market and to keep pace with the times.\nOur company deeply understands the true value of E-commerce is being fast and best.We insist on the belief of \"Faster delivery and higher quality\".Since the establishment,we have been serving in the field of domestic E-commerce and cross-border E-commerce for many years,and have made some significant achievements:our brand of GAKO became the brand merchant in Tmall and several authorized store sales ahead of the same industry.In addition,our company has become the stable cooperation partner of many famous cross-border e-commerce companies.\nWe insist on \"customers first\" and try the shortest delivery time to provide top quality products and good service.\nWe place great significance in our employees and care for their career development. People with a passion to grow are now invited to join us for a bright future.Small Fish Tanks price\nwebsite:http://www.szgako.com/\nwebsite2:http://www.szgako.net/"
    },
    {
        "Pattern": "Customized decorative metal label for handbags metal logo alloy plate with rack plating finish for sale  Basic Info:  New fashion metal decorative label for shoe accessories with gold color, HEARTBRIDGE is committed to providing high quality products and excellent customer service for the global customers.  Model NO.: B0603 Material: Alloy  Logo: None Color: Gold by Rack  Size: 39MM MOQ: 10,000 PCS Technics: Rack Plating  Feature: Decorative    Product Specification:  Type Metal Trims  Button Type Metal ornament for shoe's accessories  Quality Level High  Usage Men's clothing, Women's Clothing, Jeans, Jackets  Color Barrel Plating: Electroplated by rolling barrel tools: Nickel, Anti-nickel, Matte nickel, Brass, Anti-brass, Copper, Anti-copper, Copper Tin, Brass Tin, Contrasted Tin, Oxided Tin, Gunmetal, Gold, etc.  Rack Plating: Electroplated by hanging tools: Nickel, Gold, Rose Gold, Light Gold, Gunmetal, Copper, Brass, etc.  Enamel / Painting: Enameled as per Pantone Color Card, YKK Color Card, Color Swatches.   Customized metal badge website:http://www.sz-heartbridge.com/metal-producs/metal-tags/",
        "MatchingText": "zzx",
        "NonMatchingText": "xxc",
        "Description": "Customized decorative metal label for handbags metal logo alloy plate with rack plating finish for sale \nBasic Info: \nNew fashion metal decorative label for shoe accessories with gold color, HEARTBRIDGE is committed to providing high quality products and excellent customer service for the global customers. \nModel NO.: B0603\nMaterial: Alloy \nLogo: None\nColor: Gold by Rack \nSize: 39MM\nMOQ: 10,000 PCS\nTechnics: Rack Plating \nFeature: Decorative   \nProduct Specification: \nType Metal Trims \nButton Type Metal ornament for shoe's accessories \nQuality Level High \nUsage Men's clothing, Women's Clothing, Jeans, Jackets \nColor Barrel Plating: Electroplated by rolling barrel tools: Nickel, Anti-nickel, Matte nickel, Brass, Anti-brass, Copper, Anti-copper, Copper Tin, Brass Tin, Contrasted Tin, Oxided Tin, Gunmetal, Gold, etc. \nRack Plating: Electroplated by hanging tools: Nickel, Gold, Rose Gold, Light Gold, Gunmetal, Copper, Brass, etc. \nEnamel / Painting: Enameled as per Pantone Color Card, YKK Color Card, Color Swatches. \n Customized metal badge\nwebsite:http://www.sz-heartbridge.com/metal-producs/metal-tags/"
    },
    {
        "Pattern": "Company Profile Shenzhen Mascot Jewelry Co., Ltd. located in Guangdong province,  covering an area of 4 00 square meters, is a professional manufacturer and supplier of fashion jewelry including 925 Sterling Silver, Brass, Copper and other materials. We supply over 10, 000 products with high quality, at moderate wholesale prices to customers from all over the world. With total 100 staff and years' experience in the jewelry field, we can meet customer's own designs. Shenzhen Mascot Jewelry Co., Ltd. adhere to the \"new style, exquisite workmanship, reasonable price, supremacy of credibility\" for the marketing core, OEM and ODM both are welcome! Work Process Packing & Delivery FAQ 1. Why choose us? > High quality with guarantee > Sample order & small quantity is accepted > Factory-Direct price > On time delivery 2. Can I mix colors? Sure, colors can be mixed when quantity is OK. 3. Can I get discounts? Yes, we will give reasonable discounts for big order and Frequent Customers. 4. Could you supply OEM/ODM service? Sure. Please let me know the designs, and if you can sent us a sample, so much the better. 5. Can I get one sample? Yes, one or two sample can be sent for quality checking, And we will refund the sample fee after you place a bulk order. 6. How long a sample order takes? How about bulk order? Sample order: <7 days, bulk order: <15 days. If any other questions, please feel free to contact us. Thank you!silver jewelry pendant manufacturers website:http://www.szjewelryfactory6.com/ website2:http://www.jewelry-made.com/",
        "MatchingText": "zzx",
        "NonMatchingText": "xxc",
        "Description": "Company Profile\nShenzhen Mascot Jewelry Co., Ltd. located in Guangdong province,  covering an area of 4 00 square meters, is a professional manufacturer and supplier of fashion jewelry including 925 Sterling Silver, Brass, Copper and other materials. We supply over 10, 000 products with high quality, at moderate wholesale prices to customers from all over the world. With total 100 staff and years' experience in the jewelry field, we can meet customer's own designs.\nShenzhen Mascot Jewelry Co., Ltd. adhere to the \"new style, exquisite workmanship, reasonable price, supremacy of credibility\" for the marketing core, OEM and ODM both are welcome!\nWork Process\nPacking & Delivery\nFAQ\n1. Why choose us?\n> High quality with guarantee\n> Sample order & small quantity is accepted\n> Factory-Direct price\n> On time delivery\n2. Can I mix colors?\nSure, colors can be mixed when quantity is OK.\n3. Can I get discounts?\nYes, we will give reasonable discounts for big order and Frequent Customers.\n4. Could you supply OEM/ODM service?\nSure. Please let me know the designs, and if you can sent us a sample, so much the better.\n5. Can I get one sample?\nYes, one or two sample can be sent for quality checking, And we will refund the sample fee after you place a bulk order.\n6. How long a sample order takes? How about bulk order?\nSample order: <7 days, bulk order: <15 days.\nIf any other questions, please feel free to contact us. Thank you!silver jewelry pendant manufacturers\nwebsite:http://www.szjewelryfactory6.com/\nwebsite2:http://www.jewelry-made.com/"
    },
    {
        "Pattern": "(^(\\+?\\-? *[0-9]+)([,0-9 ]*)([0-9 ])*$)|(^ *$)",
        "MatchingText": "+0335456 545 545 |||-5465 545 |||5456465 5454,545",
        "NonMatchingText": "fsd54df 54",
        "Description": "This is my basic phone number verification. it allows a + - , signs digits, spaces and blank entry"
    },
    {
        "Pattern": "^([A-Z]|[a-z]|[0-9])(([A-Z])*(([a-z])*([0-9])*(%)*(&)*(')*(\\+)*(-)*(@)*(_)*(\\.)*)|(\\ )[^  ])+$",
        "MatchingText": "AccountName_123|||Account@email.com|||James & Dana Inc.",
        "NonMatchingText": "!MYACCOUNT!|||{Superman}|||$  Money     Man  $",
        "Description": "will match as long as the only chars exist in the string : A-Z,a-z,0-9,'Space' chr(32),%&amp;'+-@_.\nIt's useful for check vs Account Names where you might want to forbid entering other chars then what is in the pattern. also will not allow repeated space in the string"
    },
    {
        "Pattern": "^(?:[\\w]+[\\&amp;\\-_\\.]*)+@(?:(?:[\\w]+[\\-_\\.]*)\\.(?:[a-zA-Z]{2,}?))$",
        "MatchingText": "user@email.com",
        "NonMatchingText": "user@-email.com|||-user@email.com",
        "Description": "This validates an email address and only an email address. None of the &lt;email&gt; stuff, just user@email.whatever. Comments are more then welcome."
    },
    {
        "Pattern": "[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}",
        "MatchingText": "192.168.1.1|||10.2.234.1|||66.129.71.122",
        "NonMatchingText": "192.168.1|||10.2.1234.1|||66 129 71 122",
        "Description": "Very Simple Match for dotted Decimal IP address.  Doesn\u2019t Validate addresses"
    },
    {
        "Pattern": "^[AaWaKkNn][a-zA-Z]?[0-9][a-zA-Z]{1,3}$",
        "MatchingText": "kd6dun|||W9OXZ|||kb8ae",
        "NonMatchingText": "kdd90bz|||de7bgw|||WV7BXQ5",
        "Description": "Simple match for U.S. Amateur Radio Call signs\nMust start with an A,K,N or W.\n1 or two prefix letters (not case sensitive),\nExactly one zone digit,\nOne to three suffix digits( not case sensitive).\n\n73\n"
    },
    {
        "Pattern": "^\\.{0,2}[\\/\\\\]",
        "MatchingText": "./some/file.html \\this\\is\\a.file ../blah/blah",
        "NonMatchingText": "path\\in\\current.folder",
        "Description": "Will match any web path that's supposed to start in the root (e.g. with \"/\" in front of it."
    },
    {
        "Pattern": "^((http|https|ftp)\\://|www\\.)[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,4}(/[a-zA-Z0-9\\-\\._\\?=\\,\\'\\+%\\$#~]*[^\\.\\,\\)\\(\\s])*$",
        "MatchingText": "www.something.com || http://something.com/something?action=delete || http://www.something.com/~etc",
        "NonMatchingText": "http://www.something.com/, || wwww.something.com || ",
        "Description": "Matches any valid URLs which can activate links in a text."
    },
    {
        "Pattern": "^(?P<1>.*[\\\\/])(?P<2>.+)\\.(?P<3>.+)?$|^(?P<1>.*[\\\\/])(?P<2>.+)$|^(?P<2>.+)\\.(?P<3>.+)?$|^(?P<2>.+)$",
        "MatchingText": "d:\\Program Files\\Hello.txt ||| /home/Hello.txt ||| Hello.txt ||| .\\Hello",
        "NonMatchingText": "\\\\Hello\\ ||| Hello\\\\",
        "Description": "Parses any file path and extracts directory, file name and extension separately."
    },
    {
        "Pattern": "^(~?/|[a-zA-Z]:[\\\\/]).+",
        "MatchingText": "/usr/local/lib|||~/temp|||C:\\windows\\path",
        "NonMatchingText": "file.ext|||./path/file|||~file",
        "Description": "Written to tell absolute and relative paths apart (by matching only absolute paths) on *nix or Windows systems, for a cross-platform PHP project. Admittedly there are a few weird edges cases that will outwit the pattern, like the %FOO% anchor things that can be used in windows paths."
    },
    {
        "Pattern": "(^\\d*\\.?\\d*[1-9]+\\d*$)|(^[1-9]+\\d*\\.\\d*$)",
        "MatchingText": "0.050|||5.0000|||5000",
        "NonMatchingText": "0|||0.0|||.0",
        "Description": "Accepts only positive decimal values. Zero and negatvie numbers are non-matching. Allows zeros after last non-zero numeric value after decimal place for significant digits."
    },
    {
        "Pattern": "(^-\\d*\\.?\\d*[1-9]+\\d*$)|(^-[1-9]+\\d*\\.\\d*$)",
        "MatchingText": "-0.050|||-5.000|||-5",
        "NonMatchingText": "0|||0.0|||.0",
        "Description": "Accepts only negative decimal values. Zero and positive numbers are non-matching. Allows zeros after last non-zero numeric value after decimal place for significant digits. "
    },
    {
        "Pattern": "\\d+(,\\d{1,2})?",
        "MatchingText": "0.05",
        "NonMatchingText": "0.00.05",
        "Description": "Checks value for US money."
    },
    {
        "Pattern": "^((A[ABEHKLMPRSTWXYZ])|(B[ABEHKLMT])|(C[ABEHKLR])|(E[ABEHKLMPRSTWXYZ])|(GY)|(H[ABEHKLMPRSTWXYZ])|(J[ABCEGHJKLMNPRSTWXYZ])|(K[ABEHKLMPRSTWXYZ])|(L[ABEHKLMPRSTWXYZ])|(M[AWX])|(N[ABEHLMPRSWXYZ])|(O[ABEHKLMPRSX])|(P[ABCEGHJLMNPRSTWXY])|(R[ABEHKMPRSTWXYZ])|(S[ABCGHJKLMNPRSTWXYZ])|(T[ABEHKLMPRSTWXYZ])|(W[ABEKLMP])|(Y[ABEHKLMPRSTWXYZ])|(Z[ABEHKLMPRSTWXY]))\\d{6}([A-D]|\\s)$",
        "MatchingText": "NS123456A|||AA555555A|||ZY654321 ",
        "NonMatchingText": "QB123456A|||DD123456D|||MB654321X",
        "Description": "UK National Insurance (NI) Number, updated 14 Dec 2005 and current for 2006."
    },
    {
        "Pattern": "^[A-Z1-9]{5}-[A-Z1-9]{5}-[A-Z1-9]{5}-[A-Z1-9]{5}-[A-Z1-9]{5}$",
        "MatchingText": "12345-12345-12345-12345-12345|||ABCDE-ABCDE-ABCDE-ABCDE-ABCDE|||AB5DE-AB5DE-AB5DE-AB5DE-AB5DE",
        "NonMatchingText": "12345-123-123456-12345|||ABC-ABCDEF-ABCDE-ABCDE|||12AB5-ABC-12AB567-12AB5",
        "Description": "Simple Microsoft product key check."
    },
    {
        "Pattern": "^((A(((H[MX])|(M(P|SN))|(X((D[ACH])|(M[DS]))?)))?)|(K7(A)?)|(D(H[DLM])?))(\\d{3,4})[ABD-G][CHJK-NPQT-Y][Q-TV][1-4][B-E]$",
        "MatchingText": "AXDA3200DKV4E|||A1000AMT3B|||D800AUT1B",
        "NonMatchingText": "N/A",
        "Description": "Matches valid reference codes for AMD Athlon and Duron processors (not Athlon 64)."
    },
    {
        "Pattern": "^([A-Z]{3}\\s?(\\d{3}|\\d{2}|d{1})\\s?[A-Z])|([A-Z]\\s?(\\d{3}|\\d{2}|\\d{1})\\s?[A-Z]{3})|(([A-HK-PRSVWY][A-HJ-PR-Y])\\s?([0][2-9]|[1-9][0-9])\\s?[A-HJ-PR-Z]{3})$",
        "MatchingText": "ABC 123 A|||A 123 ABC|||AB 12 ABC",
        "NonMatchingText": "AB 123 C|||A 123 AB|||AB 12 AB",
        "Description": "UK vehicle registration system. This is the obvious combination of two previous expressions posted here, to merge the older system with the current system."
    },
    {
        "Pattern": "^([A-HK-PRSVWY][A-HJ-PR-Y])\\s?([0][2-9]|[1-9][0-9])\\s?[A-HJ-PR-Z]{3}$",
        "MatchingText": "AB51DVL|||AB 51 DVL",
        "NonMatchingText": "AZ01DLQ|||AZ 01 DLQ",
        "Description": "UK vehicle registration system currently in use (as defined by the DVLA and put into effect from September 2001, and therefore does not allow registrations prior to this date)."
    },
    {
        "Pattern": "^([A-Z]{3}\\s?(\\d{3}|\\d{2}|d{1})\\s?[A-Z])|([A-Z]\\s?(\\d{3}|\\d{2}|\\d{1})\\s?[A-Z]{3})$",
        "MatchingText": "ABC123A|||A 123 ABC",
        "NonMatchingText": "AB123A|||A 123 AB",
        "Description": "UK vehicle registration system prior to September 2001. Allows both older suffix and the later prefix formats in simple form, with optional spaces."
    },
    {
        "Pattern": "^(\\+44\\s?7\\d{3}|\\(?07\\d{3}\\)?)\\s?\\d{3}\\s?\\d{3}$",
        "MatchingText": "07222 555555|||(07222) 555555|||+44 7222 555 555",
        "NonMatchingText": "7222 555555|||+44 07222 555555|||(+447222) 555555",
        "Description": "UK mobile phone number, with optional +44 national code. Allows optional brackets and spaces at appropriate positions."
    },
    {
        "Pattern": "^(((\\+44\\s?\\d{4}|\\(?0\\d{4}\\)?)\\s?\\d{3}\\s?\\d{3})|((\\+44\\s?\\d{3}|\\(?0\\d{3}\\)?)\\s?\\d{3}\\s?\\d{4})|((\\+44\\s?\\d{2}|\\(?0\\d{2}\\)?)\\s?\\d{4}\\s?\\d{4}))(\\s?\\#(\\d{4}|\\d{3}))?$",
        "MatchingText": "+447222555555|||+44 7222 555 555|||(0722) 5555555 #2222",
        "NonMatchingText": "(+447222)555555|||+44(7222)555555|||(0722) 5555555 #22",
        "Description": "Modified version of UK phone number regular expression. Now allows +44 national code in addition to extension numbers of 3 or 4 digits. Previous expression was: ^((\\(?0\\d{4}\\)?\\s?\\d{3}\\s?\\d{3})|(\\(?0\\d{3}\\)?\\s?\\d{3}\\s?\\d{4})|(\\(?0\\d{2}\\)?\\s?\\d{4}\\s?\\d{4}))(\\s?#(\\d{4}|\\d{3}))?$"
    },
    {
        "Pattern": "^((\\(?0\\d{4}\\)?\\s?\\d{3}\\s?\\d{3})|(\\(?0\\d{3}\\)?\\s?\\d{3}\\s?\\d{4})|(\\(?0\\d{2}\\)?\\s?\\d{4}\\s?\\d{4}))(\\s?\\#(\\d{4}|\\d{3}))?$",
        "MatchingText": "01222 555 555|||(010) 55555555 #2222|||0122 555 5555#222",
        "NonMatchingText": "01222 555 5555|||(010) 55555555 #22|||0122 5555 5555#222",
        "Description": "UK phone number. Allows 3, 4 or 5 digit regional prefix, with 8, 7 or 6 digit phone number respectively, plus optional 3 or 4 digit extension number prefixed with a # symbol. Also allows optional brackets surrounding the regional prefix and optional spaces between appropriate groups of numbers."
    },
    {
        "Pattern": "^(([a-z][0-9])|([0-9][a-z])|([a-z0-9][a-z0-9\\-]{1,2}[a-z0-9])|([a-z0-9][a-z0-9\\-](([a-z0-9\\-][a-z0-9])|([a-z0-9][a-z0-9\\-]))[a-z0-9\\-]*[a-z0-9]))\\.(co|me|org|ltd|plc|net|sch|ac|mod|nhs|police|gov)\\.uk$",
        "MatchingText": "zeropanic.co.uk|||z2.co.uk|||1-1.org.uk",
        "NonMatchingText": "zeropanic.com|||z.co.uk|||zz.co.uk",
        "Description": "UK domain names. Includes the following restrictions from Nominet as at time of posting: \n1.Only a-z, 0-9 and hyphen may be used. \n2.First or last character may not be a hyphen. \n3.Third and fourth characters may not both be hyphens. \n4.Third level domain may not be a single character. \n5.Third level domain may not be two letters or two numbers. \n6.Third level domain may be one letter and one number. \n \nThis does not yet include the following restrictions: \n1.Whole domain may not be longer than 64 characters in length. \n2.Third level domain may not duplicate any top/second level domain."
    },
    {
        "Pattern": "^[A-Z]{3}\\d{8}$",
        "MatchingText": "AAA12345678",
        "NonMatchingText": "AA12345",
        "Description": "Basic UK child benefit reference number."
    },
    {
        "Pattern": "[1-9][0-9]{3}(SS|SA|SD)[A-Z]{2}",
        "MatchingText": "1234AA ||| 9474RK ||| 6446ka",
        "NonMatchingText": "1234SS ||| 9758 KS ||| 0146KF ||| 846KS ||| 9465A",
        "Description": "Regex for Dutch zip/postal codes. A Dutch zip code exists of 4 numbers and 2 letters. The first number must be a 0 or higher. Letter combinations of \"SS\", \"SD\" and \"SA\" are excluded for historical reasons."
    },
    {
        "Pattern": "^(0[1-9]|1[012])[/](0[1-9]|[12][0-9]|3[01])[/][0-9]{4}(\\s((0[1-9]|1[012])\\:([0-5][0-9])((\\s)|(\\:([0-5][0-9])\\s))([AM|PM|]{2,2})))?$",
        "MatchingText": "12/24/2004 12:42:25 AM,  12/24/2004(without time)",
        "NonMatchingText": "12-24-2004 12:42:24 AM,  12/24/2004 12:42:24 am",
        "Description": "I got a regex for date time from here, which had some bugs. so i referred a few regex from this site and created a regex which i tested and didnt find any errors. I will check again and update if required."
    },
    {
        "Pattern": "^(0?\\d|1[012])\\/([012]?\\d|3[01])\\/(\\d{2}|\\d{4})$",
        "MatchingText": "1/1/10 , 12/12/2010, 01/01/2010",
        "NonMatchingText": "1JAN10",
        "Description": "This is the US date expression. It's very flexible on omitting numbers.\n$1 = month\n$2 = day\n$3 = year"
    },
    {
        "Pattern": "^((0[1-9])|(1[0-2]))\\/(\\d{2})$",
        "MatchingText": "11/03|||01/04",
        "NonMatchingText": "13/03|||10/2003",
        "Description": "Validates MM/YY for rough checking credit card expiration dates."
    },
    {
        "Pattern": "^(20|21|22|23|[01]\\d|\\d)(([:.][0-5]\\d){1,2})$",
        "MatchingText": "09:00:00|||09.00|||9:00",
        "NonMatchingText": "9:00AM",
        "Description": "24 hour clock as prefered by MS-SQL, allows for shorter more human methods of writing time (no preceding zero or seconds required).\nMS-SQL prefers semi-colon although this accepts full stops for users ease of use."
    },
    {
        "Pattern": "^(\\d{2,3}|\\(\\d{2,3}\\))?[ ]?\\d{3,4}[-]?\\d{3,4}$",
        "MatchingText": "(98) 227-2799|||(98) 9981-2799|||227-2799",
        "NonMatchingText": "98-227-2799|||(98)-227-2799|||98 227-2799 R. 279",
        "Description": "Telefone for Brazilian telefone standard. The Area code is optional."
    },
    {
        "Pattern": "^(\\d{2,3}|\\(\\d{2,3}\\))[ ]?\\d{3,4}[-]?\\d{3,4}$",
        "MatchingText": "(98) 227-2799|||(98) 9981-2799|||98 227-2799",
        "NonMatchingText": "98-227-2799|||(98)-227-2799|||227-0001",
        "Description": "Validation for Brazilian telephone with required area code."
    },
    {
        "Pattern": "(antifraud\\.ref\\.num)[0-9]*(@citibank\\.com)",
        "MatchingText": "antifraud.ref.num123@citibank.com|||antifraud.ref.num46356356@citibank.com|||&lt;antifraud.ref.num66",
        "NonMatchingText": "antifraud.ref.numCHAR@citibank.com|||antifraud.ref.num666 @citibank.com|||@citibank.com",
        "Description": "We have be receiving a lot of Spam with this Return-Path address. It uses diferent ref. numbers all the time So I created this pattern."
    },
    {
        "Pattern": "^\\S{1}(?:.){4,}\\S$",
        "MatchingText": "4 good p@ssW0rd? | password ",
        "NonMatchingText": "pass | word | 12345",
        "Description": "Check if a string contains at least 6 characters. Can not end or start with whitespace but can contain any other. PCRE optimized with none-capturing parentheses."
    },
    {
        "Pattern": "\\b(((20)((0[0-9])|(1[0-1])))|(([1][^0-8])?\\d{2}))((0[1-9])|1[0-2])((0[1-9])|(2[0-9])|(3[01]))[-+]?\\d{4}[,.]?\\b",
        "MatchingText": "7712314582 | 810325+0782 | 19771231-4582",
        "NonMatchingText": "137712314582 | 201211224567 | 10880215-0987",
        "Description": "Matches a Swedish social security number in format xxYYMMDD-NNNN, xxYYMMDD+NNNN, YYMMDD-NNNN, YYMMDD-NNNN and YYMMDDNNN. Does not allow birth years before 1900 and after 2011.\n\nTo raise the birth year to higher level of birth just change the 1[0-1] part to i.e. 1[0-4] to allow birth years up to 2014 etc.\n\nThis will find the SSN within a string. Also allow for a comma(,) or period(.) behind the SSN."
    },
    {
        "Pattern": "^(((20)((0[0-9])|(1[0-1])))|(([1][^0-8])?\\d{2}))((0[1-9])|1[0-2])((0[1-9])|(2[0-9])|(3[01]))[-]?\\d{4}$",
        "MatchingText": "7712314582 | 810325-0782 | 19771231-4582 | 197712314582",
        "NonMatchingText": "137712314582 | 201211224567 | 10880215-0987",
        "Description": "Matches a Swedish social security number in format CCYYMMDD-NNNN, CCYYMMDDNNNN, YYMMDD-NNNN and YYMMDDNNNN on a single line. More useful version of my earlier expression. Will only match 1900 - 2011 years."
    },
    {
        "Pattern": "^(((2|8|9)\\d{2})|((02|08|09)\\d{2})|([1-9]\\d{3}))$",
        "MatchingText": "200|||0820|||2753",
        "NonMatchingText": "700|||0700|||abcd",
        "Description": "Matched Australian Postcodes, as defined by AusPost.\n\nMany Australian developers are unaware of the small range of 3 digit, or 0 starting postcodes.\n\n220 and 221 (or 0220 and 0221) are for ANU and LVR.\n\n800s and 900s (or 0800s and 0900s) are for NT, and parts of SA, WA.\n\n1000s are for big companies in Sydney, competition mailings, etc."
    },
    {
        "Pattern": "(^\\*\\.[a-zA-Z][a-zA-Z][a-zA-Z]$)|(^\\*\\.\\*$)",
        "MatchingText": "*.doc|*.DOC|*.*",
        "NonMatchingText": "*.docDOC|*.*d",
        "Description": "Matching any file extension."
    },
    {
        "Pattern": "/^(https?|ftp)(:\\/\\/)(([\\w]{3,}\\.[\\w]+\\.[\\w]{2,6})|([\\d]{3}\\.[\\d]{1,3}\\.[\\d]{3}\\.[\\d]{1,3}))(\\:[0,9]+)*(\\/?$|((\\/[\\w\\W]+)+\\.[\\w]{3,4})?$)/",
        "MatchingText": "http://www.website.com, http://subdomain.website.com, https://www.website.net/subfolder/subfolder/file.htm, http://www.website.org/subfolder/subfolder/file_weird%20Name$@#.pdf, https://209.165.5.487/about.html",
        "NonMatchingText": "http://www.missingperiodcom, http:/misssingforwardslash.com, http://www.missingTLD., www.missingHTTP.com",
        "Description": "This expression will test against most URLs and return whether they are valid URL's or not. It will allow some false positives in that it is only checking for the correct character count, but this could be enhanced by adjusting it to check for specific TLDs or file extensions."
    },
    {
        "Pattern": "^([0-9]{2})?(\\([0-9]{2})\\)([0-9]{3}|[0-9]{4})-[0-9]{4}$",
        "MatchingText": "55(21)123-4567|||(11)1234-5678|||55(71)4562-2234",
        "NonMatchingText": "3434-3432|||4(23)232-3232|||55(2)232-232",
        "Description": "A simple expression to brazilian phone number code, with international code. \nSimple DDI without &quot;+&quot; 99 plus simple DDD (99) plus simple local phone number 3 or 4 digits plus &quot;-&quot; plus 4 digits."
    },
    {
        "Pattern": "^\\d{2}(\\x2e)(\\d{3})(-\\d{3})?$",
        "MatchingText": "12.345-678|||23.345-123|||99.999",
        "NonMatchingText": "41222-222|||3.444-233|||43.324444",
        "Description": "Other expression to standard 5 digit Brazilian Postal Codes (CEP), or the CEP + 3 digits (distribution identifiers - suffix).\nThe diference of the original one, is that the &quot;.&quot; is mandatory."
    },
    {
        "Pattern": "^((nntp|sftp|ftp(s)?|http(s)?|gopher|news|file|telnet):\\/\\/)?(([a-zA-Z0-9\\._-]*([a-zA-Z0-9]\\.[a-zA-Z0-9])[a-zA-Z]{1,6})|(([0-9]{1,3}\\.){3}[0-9]{1,3}))(:\\d+)?(\\/[^:][^\\s]*)?$",
        "MatchingText": "http://www.google.com/#sclient=psy&hl=en&q=this+is+a+google+serach+%5E((Csftp)%3A%2F%2F)%3F((%5Ba-zA-Z0-9%5C._-%5D%2B%5C.%5Ba-zA-Z%5D%7B2%2C7%7D)%7C((%5B0-9%5D%7B1%2C3%7D%5C.)%7B3%7D%5B0-9%5D%7B1%2C3%7D))(%3A%5Cd%2B)%3F(%2F%5Ba-zA-Z0-9%5C%26amp%3B%25_%5C.%2F-~-%23%5D*)%3F%24&aq=f&aqi=&aql=&oq=&gs_rfai=&pbx=1&fp=ca05a7bb65e82229 ||| http://192.168.1.1:5649",
        "NonMatchingText": "htttp://google.com ||| http://google-.com ||| http://google.123 ||| http://google.commmmmm ||| http://123.456.789.1231",
        "Description": "Finally, an expression that can reliably match any valid URL/URN! Future proof against vanity TLDs, doesn't require a schema, can parse IPv4s with or without port, can parse regular URLs with/without port, can accept extra baggage at the end, and, with a slight modification (a la ^$ and changing the final rule around a bit) this can be used to find and activate URLs in bodies of text safely and reliably. Have fun (tell me if it could be improved)!"
    },
    {
        "Pattern": "^\\s*([A-Za-z]{2,4}\\.?\\s*)?(['\\-A-Za-z]+\\s*){1,2}([A-Za-z]+\\.?\\s*)?(['\\-A-Za-z]+\\s*){1,2}(([jJsSrR]{2}\\.)|([XIV]{1,6}))?\\s*$",
        "MatchingText": "Dr. Tre-Tre Morgan V. Copperstone Mc'Giles Jr. || Tre Giles",
        "NonMatchingText": "@#$#",
        "Description": "Match to just about any valid human name you could think of."
    },
    {
        "Pattern": "^((\\+)?[1-9]{1,4})?([-\\s\\.\\/])?((\\(\\d{1,4}\\))|\\d{1,4})(([-\\s\\.\\/])?[0-9]{1,6}){2,6}(\\s?(ext|x)\\s?[0-9]{1,6})?$",
        "MatchingText": "555-955-5555 ||| 5555555555 ||| +1(773).9554-8946 ||| +1-(773)+95548946 ext 8875 ||| 1/(773)/9554/8946x563 ||| (00)7-901-759-92-61ext15",
        "NonMatchingText": "$%^&* (of course not)",
        "Description": "After searching for one, I just said \"screw it\" and wrote my own, and here she is. A regular expression to match against phone numbers, both international and USA! \n\nVery VERY flexible, if I do say so myself (and I do)."
    },
    {
        "Pattern": "/^([a-zA-Z0-9\\.\\_\\-\\&]+)@[a-zA-Z0-9]+\\.[a-zA-Z]{3}|(.[a-zA-Z]{2}(\\.[a-zA-Z]{2}))$/",
        "MatchingText": "anurag_mishra@mail.com",
        "NonMatchingText": "anu^reg@mail.com",
        "Description": "It allows only alphanumeric characters and some special symbols like \"&\",\".\",\"-\"and\"_\"before'@'.After'@' symbolagain only alphanumeric character set are allowed.Then there should be a \".\"and after that it may have either three letter's word or two letter's word with a \".\"and one more two letter word attached with it. for example: noni@yahoo.com OR noni@yahoo.co.in."
    },
    {
        "Pattern": "^[a-zA-Z]+[a-zA-Z0-9_-]*@([a-zA-Z0-9]+){1}(\\.[a-zA-Z0-9]+){1,2}",
        "MatchingText": "correct@email.com|||sample@yahoo.co.in|||sam_ple@yahoo.com",
        "NonMatchingText": "$sample@yahoo.co.in|||#sample@yahoo.com|||a#@.com",
        "Description": "Email Validator. Enmail address has to start with alphabets"
    },
    {
        "Pattern": "\\s?\\b((\\b50\\b|\\b00\\b)\\w*)\\b\\s?",
        "MatchingText": "ask me 50 times|||ask me 00 times|||ask me 50 00 times",
        "NonMatchingText": "..|||..|||..",
        "Description": "This Expression exclude any word/code from a sentence.\nTo find out all the words except any specific codes/words use this. In this example we will exclude 50 and 00 and find all other words in the sentence.\n\nExample Text: &quot;Ask me 50 00 times&quot;\nMatches:Ask,me,times\n\nHere it ignores 50 and 00 and matches the other words. Modify according to your needs. I excluded 50 or 00.\n"
    },
    {
        "Pattern": "4400mAh Ersatzakku f\u00FCr hp compaq business notebook 6715b Laptop, hp compaq business notebook 6715b akku",
        "MatchingText": "hp notebook 6715b Akku",
        "NonMatchingText": "notebook 6715b Akku",
        "Description": "Ladeger\u00E4t f\u00FCr HP Compaq Business Notebook 6715b Akku,HP Compaq Business Notebook 6715b Notebook Netzteil Ladeger\u00E4t,AC Adapter\n\nProdukt : Ladeger\u00E4t f\u00FCr HP Compaq Business Notebook 6715b Akku\nFarbe : Schwarz\nBeschreibung:Ganz neu,30 Tage Geld-Zur\u00FCck-Garantie,1 Jahr Garantie,Direktimport vom Hersteller.\nJetzt kaufen, gibt es vorteile.\nPreis : \u20AC 34.49\n http://www.kaufenakkus.com/hp-compaq-business-notebook-6715b.html "
    },
    {
        "Pattern": "4400mAh Ersatzakku f\u00FCr samsung aa-pb2vc6b Laptop, samsung aa-pb2vc6b akku",
        "MatchingText": "akku Samsung AA-PB2VC6B",
        "NonMatchingText": "Samsung AA-PB2VC6B akku",
        "Description": "Hohe Qualit\u00E4t . Sie erhalten einen Lithium-Ionen samsung aa-pb2vc6b akku Garantiert 100 % passgenau ,Kapazit\u00E4t garantiert identisch mit \u00FCberschreiten dem samsung aa-pb2vc6b Original-Akku\n http://www.kaufenakkus.com/samsung-aa-pb2vc6b.html "
    },
    {
        "Pattern": "^(000)(666)([0-8]\\d{2}) ([ -])? (00)\\d\\d ([ -])? (0000)\\d{4}$",
        "MatchingText": "899-04 1234|||001 99-8000|||667999999",
        "NonMatchingText": "900123456|||000349850|||324001234|||765870000|||900-12-1234",
        "Description": "Current SSN randomization rules, also caled Social Security Number Randomization, effective since June 25, 2011. Validates 9 digit numbers, not separated or separated by - or space, not starting with 000, 666, or 900-999, not containing 00 or 0000 in the middle or at the end of SSN."
    },
    {
        "Pattern": "^(?P<address1>(\\d{1,6}(\\ 1\\/[234])?( (N(orth)?|S(outh)?)? ?(E(ast)?|W(est)?))?(( \\d+ ?(th|rd|st|nd))|( [A-Z]([a-z])+)+) ((?i)THROUGHWAY|TRAFFICWAY|CROSSROADS|EXPRESSWAY|BOULEVARD|CROSSROAD|EXTENSION|JUNCTIONS|MOUNTAINS|STRAVENUE|UNDERPASS|CAUSEWAY|CRESCENT|CROSSING|JUNCTION|MOTORWAY|MOUNTAIN|OVERPASS|PARKWAYS|TURNPIKE|VILLIAGE|VILLAGES|CENTERS|CIRCLES|COMMONS|CORNERS|ESTATES|EXPRESS|FORESTS|FREEWAY|GARDENS|GATEWAY|HARBORS|HIGHWAY|HOLLOWS|ISLANDS|JUNCTON|LANDING|MEADOWS|MOUNTIN|ORCHARD|PARKWAY|PASSAGE|PRAIRIE|RANCHES|SPRINGS|SQUARES|STATION|STRAVEN|STRVNUE|STREETS|TERRACE|TRAILER|TUNNELS|VALLEYS|VIADUCT|VILLAGE|ALLEE|ARCADE|AVENUE|BLUFFS|BOTTOM|BRANCH|BRIDGE|BROOKS|BYPASS|CANYON|CAUSWA|CENTER|CENTRE|CIRCLE|CLIFFS|COMMON|CORNER|COURSE|COURTS|CRSENT|CRSSNG|DIVIDE|DRIVES|ESTATE|EXTNSN|FIELDS|FOREST|FORGES|FREEWY|GARDEN|GATEWY|GATWAY|GREENS|GROVES|HARBOR|HIGHWY|HOLLOW|ISLAND|ISLNDS|JCTION|JUNCTN|KNOLLS|LIGHTS|MANORS|MEADOW|MEDOWS|MNTAIN|ORCHRD|PARKWY|PLAINS|POINTS|RADIAL|RADIEL|RAPIDS|RIDGES|SHOALS|SHOARS|SHORES|SKYWAY|SPRING|SPRNGS|SQUARE|STRAVN|STREAM|STREME|STREET|SUMITT|SUMMIT|TRACES|TRACKS|TRAILS|TUNNEL|TURNPK|UNIONS|VALLEY|VIADCT|VILLAG|ALLEE|ALLEY|ANNEX|AVENU|AVNUE|BAYOO|BAYOU|BEACH|BLUFF|BOTTM|BOULV|BRNCH|BRDGE|BROOK|BURGS|BYPAS|CANYN|CENTR|CNTER|CIRCL|CRCLE|CLIFF|COURT|COVES|CREEK|CRSNT|CREST|CURVE|DRIVE|FALLS|FERRY|FIELD|FLATS|FORDS|FORGE|FORKS|FRWAY|GARDN|GRDEN|GRDNS|GTWAY|GLENS|GREEN|GROVE|HARBR|HRBOR|HAVEN|HIWAY|HILLS|HOLWS|ISLND|ISLES|JCTNS|KNOLL|LAKES|LNDNG|LIGHT|LOCKS|LODGE|LOOPS|MANOR|MILLS|MISSN|MOUNT|MNTNS|PARKS|PKWAY|PKWYS|PATHS|PIKES|PINES|PLAIN|PLAZA|POINT|PORTS|RANCH|RNCHS|RAPID|RIDGE|RIVER|ROADS|ROUTE|SHOAL|SHOAR|SHORE|SPRNG|SPNGS|SPURS|STATN|STRAV|STRVN|SUMIT|TRACE|TRACK|TRAIL|TRLRS|TUNEL|TUNLS|TUNNL|TRNPK|UNION|VALLY|VIEWS|VILLG|VILLE|VISTA|WALKS|WELLS|ALLY|ANEX|ANNX|AVEN|BEND|BLUF|BLVD|BOUL|BURG|BYPA|BYPS|CAMP|CNYN|CAPE|CSWY|CENT|CNTR|CIRC|CRCL|CLFS|CLUB|CORS|CRSE|COVE|CRES|XING|DALE|DRIV|ESTS|EXPR|EXPW|EXPY|EXTN|EXTS|FALL|FRRY|FLDS|FLAT|FLTS|FORD|FRST|FORG|FORK|FRKS|FORT|FRWY|GRDN|GDNS|GTWY|GLEN|GROV|HARB|HIWY|HWAY|HILL|HLLW|HOLW|INLT|ISLE|JCTN|JCTS|KEYS|KNOL|KNLS|LAKE|LAND|LNDG|LANE|LOAF|LOCK|LCKS|LDGE|LODG|LOOP|MALL|MNRS|MDWS|MEWS|MILL|MSSN|MNTN|MTIN|NECK|ORCH|OVAL|PARK|PKWY|PASS|PATH|PIKE|PINE|PNES|PLNS|PLZA|PORT|PRTS|RADL|RAMP|RNCH|RPDS|REST|RDGE|RDGS|RIVR|ROAD|SHLS|SHRS|SPNG|SPGS|SPUR|SQRE|SQRS|STRA|STRM|STRT|TERR|TRCE|TRAK|TRKS|TRLS|TRLR|TUNL|VLLY|VLYS|VDCT|VIEW|VILL|VLGS|VIST|VSTA|WALK|WALL|WAYS|WELL|ALY|ANX|ARC|AVE|AVN|BCH|BND|BLF|BOT|BTM|BRG|BRK|BYP|CMP|CPE|CEN|CTR|CIR|CLF|CLB|COR|CTS|CRK|DAM|DIV|DVD|DRV|EST|EXP|EXT|FLS|FRY|FLD|FLT|FRD|FRG|FRK|FRT|FWY|GLN|GRN|GRV|HBR|HVN|HTS|HWY|HLS|ISS|JCT|KEY|KYS|KNL|LKS|LGT|LCK|LDG|MNR|MDW|MNT|MTN|NCK|OVL|PRK|PKY|PLN|PLZ|PTS|PRT|PRR|RAD|RPD|RST|RDG|RIV|RVR|RDS|ROW|RUE|RUN|SHL|SHR|SPG|SQR|SQU|STA|STN|STR|SMT|TER|TRK|TRL|VLY|VIA|VWS|VLG|VIS|VST|WAY|WLS|AV|BR|CP|CT|CV|DL|DM|DV|DR|FT|HT|HL|IS|KY|LK|LN|LF|MT|PL|PT|PR|RD|SQ|ST|UN|VW|VL|WY))( (N(orth)?|S(outh)?)? ?(E(ast)?|W(est)?)?)?)$",
        "MatchingText": "2255 140th Ave NE|535 Bellevue Sq|14008 NE 8th St|15615 NE 8th St|555 108th Ave NE|12821 SE 38th St|15920 NE 8th St|4065 Factoria Blvd SE|1829 130th Ave Ne|3720 Factoria Blvd SE|150 112th Ave NE|16640 Redmond Way|730 NW Gilman Blvd|15220 SE 37th St|1328 156th Ave NE|5905 Airport Way S|600 E Pine St",
        "NonMatchingText": "|Crossroads Mall|Hungry Bear Market",
        "Description": "Using this to validate street addresses, eg from yelp API\n\nhttps://regex101.com/r/sW5iI3/2"
    },
    {
        "Pattern": "^[^<>`~!/@\\#}$%:;)(_^{&*=|'+]+$",
        "MatchingText": "This is a test",
        "NonMatchingText": "<href =|||<br>|||That's it",
        "Description": "A general string validation to insure that NO malicious code or specified characters are passed through user input.  This will allow you to input any characters except those specified.  The expression above does not allow user input of &lt;&gt;`~!/@\\#}$%:;)(_^{&amp;*=|'+. Input as many invalid characters you wish to deny.  This really works!"
    },
    {
        "Pattern": "//.*|/\\*[\\s\\S]*?\\*/",
        "MatchingText": "// Comment here|||/// Comment here|||/* Cmment Here */|||/**** Comment Here ****/",
        "NonMatchingText": "/ * Comment Here */|||/* Comment here * /",
        "Description": "Matches single line or multi-line comments."
    },
    {
        "Pattern": "/^(1)?(-|.)?(\\()?([0-9]{3})(\\))?(-|.)?([0-9]{3})(-|.)?([0-9]{4})/",
        "MatchingText": "1231231234 | 11231231234 | 1-1231231234 | 1123-1231234 | 1123123-1234 | 1-123-1231234 | 1-123123-1234 | 1123-123-1234 | 1-123-123-1234 | (1231231234 | 123)1231234 | (123)1231234 | (123)-1231234 | (123)123-1234 | (123)-123-1234 | (123-1231234 | (123123-1234 | 123)-1231234 | 123)123-1234 | (123-123-1234 | 123)-123-1234 | 1(123)1231234 | 1(1231231234 | 1123)1231234 | 1-(1231231234 | 1-123)1231234 | 1-(123)1231234 | 1-(123-1231234 | 1-(123123-1234 | 1-123)-1231234 | 1-123)123-1234 | 1-(123)-1231234 | 1-(123)123-1234 | 1-(123)-123-1234 | -1231231234 | -123-1231234 | -123123-1234 | -123-123-1234 | -",
        "NonMatchingText": ")123(1231234 | 123-1233-123 | (123(1231234",
        "Description": "I was looking for a regex that allows pretty much any combo of a US phone number. I found some that covered most of the bases, but not all of them. \n\nThis regex allows for missing characters, periods, hyphens. It should cover most of the bases. If not, let me know! I want to make it better!"
    },
    {
        "Pattern": "http[s]?://[a-zA-Z0-9.-/]+",
        "MatchingText": "http://www.google.com https://www.google.com http://localhost/",
        "NonMatchingText": "www.google.com ",
        "Description": "Checks to make sure that entry starts with http:// or https://  and that contents are limited to alphas . - /"
    },
    {
        "Pattern": "^-?[0-9]\\d{0,8}(\\.\\d{1,4})",
        "MatchingText": "123456789.1234, -123.123, 0.00, -123456789.1234",
        "NonMatchingText": "1234567890,0.12345",
        "Description": "Numeric with decimal values. Accepts negative and zeros. Upto 9 digits and upto 4 decimals allowed"
    },
    {
        "Pattern": "^[a-zA-Z0-9\\-]+\\.cn$",
        "MatchingText": "dotnetblog.cn",
        "NonMatchingText": "dotnetblog.com.cn,dotnetblog.com.cn",
        "Description": "select .cn from domain where nic.deleted"
    },
    {
        "Pattern": "[a-zA-Z]+[0-9]*@[a-zA-Z]+[\\.](edu|org|com)",
        "MatchingText": "aaa@dd.com, aa2332@bb.edu",
        "NonMatchingText": "aa@dd.ee",
        "Description": "matches email syntax with com,edu,org only. You can add more the way you  like it"
    },
    {
        "Pattern": "(\\'([^\\'\\\\]*\\\\.)*[^\\'\\\\]*\\')+",
        "MatchingText": "'this is ''a'' string\\n with \\'embedded\\' quotes'",
        "NonMatchingText": "'a string \\'without\\' terminator",
        "Description": "Matches mysql single-quoted string literals. double quotes and backslashed quotes are recognised."
    },
    {
        "Pattern": "20\\d{2}(-|\\/)((0[1-9])|(1[0-2]))(-|\\/)((0[1-9])|([1-2][0-9])|(3[0-1]))(T|\\s)(([0-1][0-9])|(2[0-3])):([0-5][0-9]):([0-5][0-9])",
        "MatchingText": "2099-12-31T23:59:59|||2002/02/09 16:30:00|||2000-01-01T00:00:00",
        "NonMatchingText": "2000-13-31T00:00:00|||2002/02/33 24:00:00|||2000-01-01 60:00:00",
        "Description": "Sql date format tester. "
    },
    {
        "Pattern": "/(<\\/?)(\\w+)([^>]*>)/e",
        "MatchingText": "all html and xml and script  tags",
        "NonMatchingText": "any",
        "Description": "Returns string with all alphabetic characters converted to uppercase. \nin php programing you can use \npreg_replace(\"/(<\\/?)(\\w+)([^>]*>)/e\", \n             \"'$1'.strtoupper('$2').'$3'\", \n             $html_body) "
    },
    {
        "Pattern": "/(<\\/?)(\\w+)([^>]*>)/e",
        "MatchingText": "all html and xml and script  tags",
        "NonMatchingText": "eny",
        "Description": "Returns string with all alphabetic characters converted to lowercase.\nin php programing you can use \npreg_replace(\"/(<\\/?)(\\w+)([^>]*>)/e\", \n             \"'$1'.strtolower('$2').'$3'\", \n             $html_body) "
    },
    {
        "Pattern": "ng-[^\\s]+?=\".*?\"",
        "MatchingText": "ng-class=\"foo\"|ng-if=\"foo\"|ng-show=\"foo\"",
        "NonMatchingText": "class=\"foo\"|ngClass=\"foo\"|class=\"ng-scope\"",
        "Description": "Find all angular properties in HTML markup. Handy for removing them."
    },
    {
        "Pattern": "&amp;([a-zA-Z]{2,6};|#[0-9]{3};)",
        "MatchingText": "&amp;ThisIsTooLong;|||Lilo &amp; Stich|||&amp;l;",
        "NonMatchingText": "&amp;lt;|||&amp;brvbar;|||&amp;#166;",
        "Description": "The goal of this regular expression is to replace all &amp; (ampersand) characters by &amp;amp; if they are not the start of HTML entities. I used\nhttp://www.w3schools.com/html/html_entitiesref.asp as a reference. You can then use RegExp Replace method to do the work. Was helpful for me, might helpful be for you..."
    },
    {
        "Pattern": "^([1-9]{1}[\\d]{0,2}(\\.[\\d]{3})*(\\,[\\d]{0,2})?|[1-9]{1}[\\d]{0,}(\\,[\\d]{0,2})?|0(\\,[\\d]{0,2})?|(\\,[\\d]{1,2})?)$",
        "MatchingText": "100.000,00|||100000,00|||89|||89,87|||",
        "NonMatchingText": "89.87|||100,000.00|||0.75",
        "Description": "Aceita duas casas decimas ap\u00F3s a v\u00EDrgula. Pode ser usado para Real Brasil.\nUses up to two decimal places. Good to use for brazilian money format (Real)."
    },
    {
        "Pattern": ".\\{\\d\\}",
        "MatchingText": "The quick {0} fox {1} over the lazy dog.",
        "NonMatchingText": "The {b} is wrong",
        "Description": "String formater matching."
    },
    {
        "Pattern": "^\\d{2}([0][1-9]|[1][0-2])([0][1-9]|[1-2][0-9]|[3][0-1])-\\d{4}$",
        "MatchingText": "791231-1234",
        "NonMatchingText": "791332-1234",
        "Description": "Simple regex for the Swedish personal number. It's in the form: YYMMDD-xxxx where xxxx is an arbitrary number from 0000-9999."
    },
    {
        "Pattern": "^0(83|85|86|87|88|89)\\s?\\d{1}\\s?\\d{1}\\s?\\d{1}\\s?\\d{1}\\s?\\d{1}\\s?\\d{1}\\s?\\d{1}$",
        "MatchingText": "0831234567 089 123 1234",
        "NonMatchingText": "0841234567 081 123 1234",
        "Description": "Matches mobile telephone numbers in Republic of Ireland.  Allows for spaces at any point after the initial 08x part.  Will only validate legitimate mobile prefixes, will not validate old pager numbers (082)."
    },
    {
        "Pattern": "^([a-zA-Z0-9\\-]{2,80})$",
        "MatchingText": "01  |  ABC-123  |  Reg-ex01",
        "NonMatchingText": "1  |  ABC.123  |  Reg_ex01",
        "Description": "Can be used for identification numbers."
    },
    {
        "Pattern": "^011-(?P<IntlCountryCode>[1-9][0-9]{1,5})-(?P<IntlAreaCode>[0-9]+)-(?P<IntlPhoneNumber>[0]?\\d[0-9]+)(?:[^\\d\\-]+(?P<IntlExtension>\\d{1,4}))?$",
        "MatchingText": "011-12345-67-8901234|011-12345-67-8901234 5678 ",
        "NonMatchingText": "123-456-7890|123-456-7890 1234",
        "Description": "Requires the International Phone Number to be separated into its component parts by dashes (\"011-CC-AC-PH EXT\" where \"CC\" is the 1 to 5 digit country code, \"AC\" is the area code, \"PH\" is the phone number, and \"EXT\" is the optional 1 to 4 digit extension.) (The separator before extension is one or more characters that are not a dash or a number.) This allows explicit parsing/extraction of the extension.  Also Captures international phone number components, including an optional extension into named groups."
    },
    {
        "Pattern": "^011-(?P<IntlCountryCode>[1-9][0-9]{1,5})-(?P<IntlAreaCode>[0-9]+)-(?P<IntlPhoneNumber>[0]?\\d[0-9]+)(?:[^\\d\\-]+(?P<IntlExtension>\\d{1,4}))?$",
        "MatchingText": "011-44-020-123456 ext. 1234 | 011-44-020-123456 1234 | 011-44-020-123456 x1234",
        "NonMatchingText": "44-020-123456 ext. 1234 | 123-456-7890",
        "Description": "International Phone Number separated into its component parts by dashes (International Country Code, International Area Code, International Phone Number, and optional 1-4 digit Extension). (The separator before extension is one or more characters that are not a dash or a number.) This allows explicit parsing/extraction of the extension."
    },
    {
        "Pattern": "/^[a-z][\\w\\.]+@([\\w\\-]+\\.)+[a-z]{2,7}$/i",
        "MatchingText": "s.ewew@sderer.in.net|test@ttt123.co.in|test@test123.com",
        "NonMatchingText": "test@teesat|test12122|.e@rere.coA",
        "Description": "This pattern is set to case in-sensitive (i.e '/i')."
    },
    {
        "Pattern": "<link href=\"../Common/Styles/iLienStyle.css\" type=\"text/css\" rel=\"stylesheet\" />",
        "MatchingText": "<link href=\"../Common/Styles/iLienStyle.css\" rel=\"stylesheet\" type=\"text/css\" />",
        "NonMatchingText": "<link hrf=\"../Common/Styles/iLienStyle.caaa\" rel=\"stylesheet\" typef=\"textf/css\" />",
        "Description": "hi i want to evaluate the following expression with regular expression.\n\n<link href=\"Lien.css\"  id=\"lbl\" />\n\ncond1: compulsary start with <link\ncond2: <link (one space)\ncond3: next string should be \"href\"; if u give any other it will return error.\ncond4: \"lien.css\" in this .css should be same and before string may vary.\neg:     dotnet.css (right)\n           dotnet.conn (wrong)\n\nnext: same thing for id also.\n\none more important cond: \n\n<link href=\"lien.css\" id=\"lbl\" /> (should be correct)\n<link id=\"lbl\" href=\"lien.css\"  /> (should be correct) (if u change the places of href and id also it will give correct)"
    },
    {
        "Pattern": "(?i)\\s*MOVE\\s+\\w+(\\-\\w+)*\\s+TO\\s+\\w+(\\-\\w+)*",
        "MatchingText": "MOVE WS-IDFD9 TO DF-FD-FF",
        "NonMatchingText": "MOVE WS-IDFD9 TO DF*dfd*",
        "Description": "This is Regular Expression for COBOL's Move Verb.\neg.: MOVE WS-IDFD9 TO DF-FD-FF\nHere in eg. variables have hyphen instead of underscore. "
    },
    {
        "Pattern": "\\d{1,2}(/|-)\\d{1,2}(/|-)\\d{2,4}",
        "MatchingText": "02/06/2010",
        "NonMatchingText": "02 June 2010",
        "Description": "This is regular expression for date.\neg.:02/06/2010\n    2/6/10\n    02-06-2010\n    2-6-10\n\n"
    },
    {
        "Pattern": "^\\d{1,2}\\.\\d{3}\\.\\d{3}[-][0-9kK]{1}$",
        "MatchingText": "12.025.365-6 || 5.698.124-k || 7.999.647-K",
        "NonMatchingText": "125.326.452-1 || 15.336.054-H || 15254587k",
        "Description": "Verifica que un RUT tenga el formato 00.000.000-X, despues de comprobar el formato ser\u00E1 necesario validar su d\u00EDgito verificador."
    },
    {
        "Pattern": "^([0-9]{1}[\\d]{0,2}(\\,[\\d]{3})*(\\,[\\d]{0,2})?|[0-9]{1}[\\d]{0,}(\\,[\\d]{0,2})?|0(\\,[\\d]{0,2})?|(\\,[\\d]{1,2})?)$",
        "MatchingText": "0001 | 12345 |",
        "NonMatchingText": "abcd | 012a",
        "Description": "Match any number , no characters, no empty sets, and accept zero. "
    },
    {
        "Pattern": "/^(\"(\\\\[\"\\\\]|[^\"])*\"|[^\\n])*(\\n|$)/gm",
        "MatchingText": "a \" b \\n \" c \\n Line2... \\n Line3... ||| a \" b \\r\\n \" c \\r\\n Line2... \\r\\n Line3...",
        "NonMatchingText": "matches all",
        "Description": "JavaScript match() method (or equivalent) creates an array of lines from a text file. This pattern handles lines ending with \\r\\n as well as \\n at the expense of including the line-ending chars in the output. The Matching Examples are ready for enclosure in single quotes. Output from Matching Example 1: [0]=a \" b [\\n] \" c [\\n]\n[1]= Line2... [\\n]\n[2]= Line3...\nOutput from Matching Example 2: [0]=a \" b [\\r][\\n]\" c [\\r][\\n]\n[1]= Line2... [\\r][\\n]\n[2]= Line3... "
    },
    {
        "Pattern": "/\"(\\\\[\"\\\\]|[^\"])*(\"|$)|(\\\\[\"\\\\]|[^\\s\"])+/g",
        "MatchingText": "a \" b b \" c\\\\\"c \"\" \"\\\\\"\" \"\\\\\\\\\" ||| a\" b\\\\\"\"c\"d\" \" e \\\\\" f",
        "NonMatchingText": "only strings with <1 non-whitespace char",
        "Description": "Intended for single line. JavaScript match() method (or equivalent) creates an array of values each of which is either an unquoted string of non-whitespace chars, or a quoted string which can contain whitespace, escaped quotes (\\\"), escaped escaped chars (\\\\), or be empty (\"\"). Splits on whitespace AND splits on opening and closing quotes. An unclosed quote matches all until end of input. The Matching Examples are ready for enclosure in single quotes. Output of Matching Example 1: \n[0]=a\n[1]=\" b b \"\n[2]=c\\\"c\n[3]=\"\"\n[4]=\"\\\"\"\n[5]=\"\\\\\"\nOutput of Matching Example 2: \n[0]=a\n[1]=\" b\\\"\"\n[2]=c\n[3]=\"d\"\n[4]=\" e \\\" f \n"
    },
    {
        "Pattern": "/\"(\")(\"\"|[^\"])*(\"|$)|((\"\")+|[^\\s\"])+/g",
        "MatchingText": "a \" b b \" c\"\"c \"\" \"\"\"d\"\"\" ||| a\" b\"\"\"c\"d\" \" e \"\" e",
        "NonMatchingText": "only strings with <1 non-whitespace char",
        "Description": "Intended for single line. JavaScript match() method (or equivalent) creates an array of values each of which is either an unquoted string of non-whitespace chars, or a quoted string which can contain whitespace, escaped quotes (\"\"), escaped escaped chars (\"\"\"), or be empty (\"\"). Splits on whitespace AND splits on opening and closing quotes. An unclosed quote matches all until end of input. The Matching Examples are ready for enclosure in single quotes. Output of Matching Example 1: \n[0]=a\n[1]=\" b b \"\n[2]=c\"\"c\n[3]=\"\"\n[4]=\"\"\"d\"\"\"    \nOutput of Matching Example 2: \n[0]=a\n[1]=\" b\"\"\"\n[2]=c\n[3]=\"d\"\n[4]=\" e \"\" e "
    },
    {
        "Pattern": "/(\"(\\\\[\"\\\\]|[^\"])*(\"|$)|\\S)+/g",
        "MatchingText": "a \" b b \" c\\\\\"c \"\" \"\\\\\"\" \"\\\\\\\\\" ||| a\" a\\\\\"\"a\"a\" \" b \\\\\" b",
        "NonMatchingText": "only strings with <1 non-whitespace char",
        "Description": "Intended for single line. JavaScript match() method (or equivalent) creates an array of values each of which is either an unquoted string of non-whitespace chars, or a quoted string which can contain whitespace, escaped quotes (\\\"), escaped escaped chars (\\\\), or be empty (\"\"). Splits (only) on whitespace. (Does not split on opening or closing quotes.) An unclosed quote matches all until end of input. The Matching Examples are ready for enclosure in single quotes. Output of Matching Example 1:\n[0]=a \n[1]=\" b b \" \n[2]=c\\\"c \n[3]=\"\" \n[4]=\"\\\"\" \n[5]=\"\\\\\"\nOutput of Matching Example 2: \n[0]=a\" a\\\"\"a\"a\"\n[1]=\" b \\\" b "
    },
    {
        "Pattern": "(\"(\")(\"\"|[^\"])*(\"|$)|\\S)+/g",
        "MatchingText": "a \" b b \" c\"\"c \"\" \"\"d\"\" ||| a\" a\"\"\"a\"a\" \" b \"\" b",
        "NonMatchingText": "only strings with <1 non-whitespace char",
        "Description": "Intended for single line. JavaScript match() method (or equivalent) creates an array of values each of which is either an unquoted string of non-whitespace chars, or a quoted string which can contain whitespace, escaped quotes (\"\"), escaped escaped chars (\"\"\"), or be empty (\"\"). Splits (only) on whitespace. (Does not split on opening or closing quotes.) An unclosed quote matches all until end of input. The Matching Examples are ready for enclosure in single quotes. Output of Matching Example 1: \n[0]=a \n[1]=\" b b \" \n[2]=c\"\"c \n[3]=\"\" \n[4]=\"\"d\"\"  \nOutput of Matching Example 2: [0]=a\" a\"\"\"a\"a\"\n[1]=\" b \"\" b "
    },
    {
        "Pattern": "/\"(\\\\[\"\\\\]|[^\"])*(\"|$)|'(\\\\['\\\\]|[^'])*('|$)|(\\\\[\"'\\\\]|[^\\s\"'])+/g",
        "MatchingText": "a \\' b\"\\\\\\'b \\'\\'b2\\' \"c\\\\\"\\'c\" \"d",
        "NonMatchingText": "only strings with <1 non-whitespace char",
        "Description": "Intended for single line. JavaScript match() method (or equivalent) creates an array of values each of which is either an unquoted string of non-whitespace chars, or a quoted string which can contain whitespace, escaped quotes (\\' or \\\"), escaped escaped chars (\\\\), or be empty ('' or \"\"). Splits on whitespace AND splits on opening and closing quotes. An unclosed quote matches all until end of input. The Matching Example is ready for enclosure in single quotes. Output of Matching Example: [0]=a\n[1]=' b\"\\'b '\n[2]='b2'\n[3]=\"c\\\"'c\"\n[4]=\"d\n"
    },
    {
        "Pattern": "/^(\"(\\\\\"|[^\"])*\"|'(\\\\'|[^'])*'|[^\\n])*(\\n|$)/gm",
        "MatchingText": "a \" b \\n \" \\'c\\n\\' \\n \"a \\\\\" \\' \"  b  \\'c \" \\\\\\' \\' \\n Line3...",
        "NonMatchingText": "matches all",
        "Description": "JavaScript match() method (or equivalent) creates an array of lines from a text file. This pattern handles lines ending with \\r\\n as well as \\n at the expense of including the line-ending chars in the output. The Matching Example is ready for enclosure in single quotes. Output from Matching Example: [0]=a \" b [\\n] \" 'c[\\n]' [\\n]\n[1]= \"a \\\" ' \"  b  'c \" \\' ' [\\n]\n[2]= Line3... "
    },
    {
        "Pattern": "/(?:(.):)?(?:(.*)\\\\)?(?:(.*)\\.)?(.*)/",
        "MatchingText": "'d:\\\\p.p\\\\p\\\\f.f.e' ||| '\\\\f' ||| 'f.e'",
        "NonMatchingText": "matches all",
        "Description": "Does not validate. For parsing a file name known to be valid. Handles periods in the file name. Does not include terminating characters in the output, as preferred. Javascript exec() method produces the following array elements: [1]=drive; [2]=path; IF extension exists THEN [3]=filename; [4]=extension; ELSE [3]=undefined; [4]=filename. (To avoid the awkwardness, see \"Parse Windows Filename (complex version).\" \nMatching Example 1 output: [1]=d\n[2]=\\p.p\\p\n[3]=f.f\n[4]=e  \nMatching Example 2 output: [1]=[undefined]\n[2]=[empty string]\n[3]=[undefined]\n[4]=f  \nMatching Example 3 output: [1]=undefined\n[2]=undefined\n[3]=f\n[4]=e "
    },
    {
        "Pattern": "/^(\"(\\\\[\"\\\\]|[^\"])*\"|[^\\n])*$/gm",
        "MatchingText": "a \" b \\n \" c \\n Line2... \\n Line3... ||| a \" b \\r\\n \" c \\r\\n Line2... \\r\\n Line3...",
        "NonMatchingText": "matches all",
        "Description": "JavaScript match() method (or equivalent) creates an array of lines from a text file. This pattern only handles lines ending with \\n, not \\r\\n. The Matching Examples are ready for enclosure in single quotes. Output from Matching Example 1: \n[0]=a \" b [\\n] \" c \n[1]= Line2... \n[2]= Line3... \nOutput from Matching Example 2: \n[0]=a \" b [\\r][\\n]\" c [\\r]\n[1]=\n[2]= Line2... [\\r]\n[3]=\n[4]= Line3... "
    },
    {
        "Pattern": "^\\d{1}(\\.\\d{3})-\\d{3}(\\.\\d{1})$",
        "MatchingText": "1.236-963.8 | 3.569-566.4",
        "NonMatchingText": "123.9-896.4 | 3.6699-36.5",
        "Description": "It Will check for unique Pattern Which we have used in our project"
    },
    {
        "Pattern": "^[-]?\\d*(\\.\\d*)$",
        "MatchingText": "-0.123 | 987.990 |  - 99.987 | 99.99",
        "NonMatchingText": "9999 |   +12399 ",
        "Description": "Field Should accept only - and . in special characters and it should allow only numeric data "
    },
    {
        "Pattern": "(\"(?:(?:(?:\\\\.)|[^\"\\\\\\r\\n])*)\"|'(?:(?:(?:\\\\.)|[^'\\\\\\r\\n])*)'|`(?:(?:(?:\\\\.)|[^`\\\\\\r\\n])*)`)|((?:-- .*)|(?:#.*)|(?:/\\*(?:(?:[^*]|\\*(/))*)\\*/))",
        "MatchingText": "-- insurance, # renaming some primary keys, /**/, \"hello -- this is not a comment\"",
        "NonMatchingText": "ALTER TABLE table_insurance_covered",
        "Description": "Isolates MySQL Query strings and comments. Lines that look like comments inside strings are not falsely recognised as comments. To strip comments from a MySQL Query, simply replace all matches with group 1"
    },
    {
        "Pattern": "\\b(([01]?\\d?\\d|2[0-4]\\d|25[0-5])\\.){3}([01]?\\d?\\d|2[0-4]\\d|25[0-5])\\b",
        "MatchingText": "217.6.9.89|||0.0.0.0|||255.255.255.255",
        "NonMatchingText": "256.0.0.0|||0978.3.3.3|||65.4t.54.3",
        "Description": "Most Concise RegExp for matching Decimal IPs.  If nothing else, it'll make your code easier to read.  (And I know that \\d?\\d is \\d{1,2} but that's 2 extra characters.)\n--Update: darkone noticed 8 characters could be shaved down. I've edited it to reflect this. Thanks, darkone!"
    },
    {
        "Pattern": "^((((0?[1-9]|1[012])/(0?[1-9]|1\\d|2[0-8])|(0?[13456789]|1[012])/(29|30)|(0?[13578]|1[02])/31)/(19|[2-9]\\d)\\d{2}|0?2/29/((19|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00))))[\\s]((([0]?[1-9]|1[0-2])(:|\\.)[0-5][0-9]((:|\\.)[0-5][0-9])?( )?(AM|am|aM|Am|PM|pm|pM|Pm))|(([0]?[0-9]|1[0-9]|2[0-3])(:|\\.)[0-5][0-9]((:|\\.)[0-5][0-9])?))$",
        "MatchingText": "09/10/2004 10:30am, 1/1/1999 1:32pm",
        "NonMatchingText": "09/02/07,02/29/2001,23:00",
        "Description": "The date field takes all values with slashes. Leap year is taken care of Year has to be specified in 4digit. Time is a 12hrclock taking am n pm(case insensitive). AM or Pm has to be specified. Not suited for 24hr clock. In the format of SQL Server datetime field"
    },
    {
        "Pattern": "^\\s*[a-zA-Z0-9,\\s\\-\\'\\.]+\\s*$",
        "MatchingText": "plain's text with- a hyphen, apostrophe and period.",
        "NonMatchingText": "no match with exclamation!",
        "Description": "My first submission. Probably pretty obvious. Just wanted something that would  check text boxes that non-programmers might fill out. Some of this came from http://www.reducedcomplexity.com/"
    },
    {
        "Pattern": "^([1-9]|0[1-9]|[12][0-9]|3[01])(-|/)(([1-9]|0[1-9])|(1[0-2]))(-|/)(([0-9][0-9])|([0-9][0-9][0-9][0-9]))$",
        "MatchingText": "1/1/1111|||1-1-1111|||01/01/1111|||1/01/1111|||31/12/1985|||07/07/1985|||7/7/1985|||31/12/08",
        "NonMatchingText": "01/01/1|||1985/05/05|||32/13/2008",
        "Description": "Brazilian format for date validating in MySql UDF.\n\nFormato brasileiro para valida\u00E7\u00E3o de data em MySql UDF.\n\n*** Formatos aceit\u00E1veis:\ndd/mm/yyyy\ndd-mm-yyyy\ndd-mm-yy\nd-m-yy\n"
    },
    {
        "Pattern": "([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|(\\d{1,3}\\.){3}\\d{1,3}",
        "MatchingText": "0:123:af00:ffff:0C67:0:0:8787|||0:0:0:0:0:0:0:1|||0.0.0.1|||999.999.999.999",
        "NonMatchingText": "::1",
        "Description": "Matches all IPV6 and IPV4 addresses.  Doesn't limit IPV4 to just values of 255. Doesn't allow IPV6 compression."
    },
    {
        "Pattern": "^(H(P|T|U|Y|Z)|N(A|B|C|D|F|G|H|J|K|L|M|N|O|R|S|T|U|W|X|Y|Z)|OV|S(C|D|E|G|H|J|K|M|N|O|P|R|S|T|U|W|X|Y|Z)|T(A|F|G|L|M|Q|R|V)){1}\\d{4}(NE|NW|SE|SW)?$|((H(P|T|U|Y|Z)|N(A|B|C|D|F|G|H|J|K|L|M|N|O|R|S|T|U|W|X|Y|Z)|OV|S(C|D|E|G|H|J|K|M|N|O|P|R|S|T|U|W|X|Y|Z)|T(A|F|G|L|M|Q|R|V)){1}(\\d{4}|\\d{6}|\\d{8}|\\d{10}))$",
        "MatchingText": "NA1234SE",
        "NonMatchingText": "AA1234SE",
        "Description": "This pattern validates a British Ordnance Survey Grid/Tile/Sheet Reference Number. Information on the range of possible values can be found here: http://www.ordnancesurvey.co.uk/oswebsite/gps/information/coordinatesystemsinfo/guidetonationalgrid/page17.html. Grid Ref, Tile Ref, Sheet Ref."
    },
    {
        "Pattern": "^(?P<link>((?P<prot>http:\\/\\/)*(?P<subdomain>(www|[^\\-\\n]*)*)(\\.)*(?P<domain>[^\\-\\n]+)\\.(?P<after>[a-zA-Z]{2,3}[^>\\n]*)))$",
        "MatchingText": "http://www.google.com|||www.123google.com|||www.google.com/help/me",
        "NonMatchingText": "-123google.com|||http://-123.123google.com",
        "Description": "I wrote this after I couldn't find an expression that would search for valid URLs, whether they had HTTP in front or not.  This will find those that don't have hyphens anywhere in them (except for after the domain)."
    },
    {
        "Pattern": "\\A(.*?)\\s+(\\d+[a-zA-Z]{0,1}\\s{0,1}[-]{1}\\s{0,1}\\d*[a-zA-Z]{0,1}|\\d+[a-zA-Z-]{0,1}\\d*[a-zA-Z]{0,1})",
        "MatchingText": "Sophia van Teylingenstraat 19 ||| Abrikozenstraat 116A ||| Laan van Meerdervoort 1218-1220 ||| Laan van Meerdervoort 1218 - 1220",
        "NonMatchingText": "none",
        "Description": "This pattern splits the streetname and housenumber of Dutch Postal Addresses."
    },
    {
        "Pattern": "^[a-zA-Z0-9][a-zA-Z0-9_]{2,29}$",
        "MatchingText": "fname_lastname, fname, f_name, 1_fname, 1_f",
        "NonMatchingText": "_fname, _f, f_ , ff, 11,",
        "Description": "A regexp for general username entry. Which doesn't allow special characters other than underscore. Username must be of length ranging(3-30). starting letter should be a number or a character.   "
    },
    {
        "Pattern": "\\bhttp(s?)\\:\\/\\/[a-zA-Z0-9\\/\\?\\-\\.\\&amp;\\(\\)_=#]*",
        "MatchingText": "https://icd.slr.xxp.corp/xxp(bD1lbiZjPTAwMSZkPW1pbg==)/bc/bsp/xxp/crm_ui_start/default.htm?sxxrole=ZSU_DEF     |     http://de.selfhtml.org/perl/sprache/regexpr.htm#zeichen     |     http://dict.leo.org/#/search=precede&searchLoc=0&resultOrder=basic&multiwordShowSingle=on",
        "NonMatchingText": "www.mgvo.de     |    www.facebook.com    |    google.de",
        "Description": "Detects URLs in texts. http or https must precede the URL."
    },
    {
        "Pattern": "((DK|FI|HU|LU|MT|SI)(-)?\\d{8})|((BE|EE|DE|EL|LT|PT)(-)?\\d{9})|((PL|SK)(-)?\\d{10})|((IT|LV)(-)?\\d{11})|((LT|SE)(-)?\\d{12})|(AT(-)?U\\d{8})|(CY(-)?\\d{8}[A-Z])|(CZ(-)?\\d{8,10})|(FR(-)?[\\dA-HJ-NP-Z]{2}\\d{9})|(IE(-)?\\d[A-Z\\d]\\d{5}[A-Z])|(NL(-)?\\d{9}B\\d{2})|(ES(-)?[A-Z\\d]\\d{7}[A-Z\\d])",
        "MatchingText": "CZ-7907111883|||ESA12345678|||FRAB123456789",
        "NonMatchingText": "CZ55912|||XY123456|||FR-IB123456789",
        "Description": "Matches valid VAT identification number for all current EU's member states, in format CC-xxx or CCxxx (where CC is country code and xxx actual VAT number)."
    },
    {
        "Pattern": "(^([1-3]{1}[0-9]{0,}(\\.[0-9]{1})?|0(\\.[0-9]{1})?|[4]{1}[0-9]{0,}(\\.[0]{1})?|5(\\.[5]{1}))$)",
        "MatchingText": "0.0|||4.0|||5.5",
        "NonMatchingText": "0.|||.9|||4.1",
        "Description": "GPA (Grade Point Average) expression.  Validates the standars 0.0 thru 4.0 and also accepts 5.5 -- which I use as unknown."
    },
    {
        "Pattern": "^(?P<lat>(-?(90|(\\d|[1-8]\\d)(\\.\\d{1,6}){0,1})))\\,{1}\\s?(?P<long>(-?(180|(\\d|\\d\\d|1[0-7]\\d)(\\.\\d{1,6}){0,1})))$",
        "MatchingText": "\"0,0\u201C, \u201E48.05, 11.9666679, \u201E90,0\u201C, \u201E-90,-180\u201C",
        "NonMatchingText": "\u201E05.12345,0\u201C, \u201E90.1234,1\u201C, \u201E1,-180.1\u201C, \u201E0,1.1234567\u201C",
        "Description": "Regular expression for Google's format of Latitude and Longitude (if you were to copy and paste from either the Maps application or the web address).\n\nAllows 7 decimal places, and an optional space after the comma.\n\nA really small extension to Juergen Jungwirth's expression, to allow an optional space between the commas, and an additional decimal place, which is the format that Google often gives."
    },
    {
        "Pattern": "^[a-zA-Z0-9]+[\\s]*[a-zA-Z0-9.\\-\\,\\#]+[\\s]*[a-zA-Z0-9.\\-\\,\\#]+[a-zA-Z0-9\\s.\\-\\,\\#]*$",
        "MatchingText": "123 E DRACHMAN TUCSON AZ 12345, St # 123, North AVE New York. NY 12345",
        "NonMatchingText": "-1 AVE,1, Aa,#1 Street ,. 20 North,,1 AVE",
        "Description": "US Addresses validation having atleast 3 characters ignoring any spaces. Can have hash \"#\" comma \",\" dash \"-\" dot \".\" but cannot start with these."
    },
    {
        "Pattern": "/^[A-Z0-9._-]+@[A-Z0-9.-]+\\.[A-Z0-9.-]+$/i",
        "MatchingText": "testemail@testdomain.co.uk",
        "NonMatchingText": "test%email@testdomain.co.uk, test*#@gmail.com test@test",
        "Description": "Simple, but effective; including .com.mt, .co.uk etc.\n\nTo include more characters for the email name:\n\n^[A-Z0-9._(ADD HERE)-]+@[A-Z0-9.-]+\\.[A-Z0-9.-]+$\n\nremove brackets obviously."
    },
    {
        "Pattern": "^\\-?\\(?([0-9]{0,3}(\\,?[0-9]{3})*(\\.?[0-9]*))\\)?$",
        "MatchingText": "0.123|||(1234.123)|||-01,200",
        "NonMatchingText": "2.3.123|||1,23.45",
        "Description": "Match a positive or negative decimal value with any precision and scale.  Allows for left-padded zeroes, commas as group separator, negative sign (-) or parenthesis to indicate negative number."
    },
    {
        "Pattern": "^((\\+91)?|91)?[789][0-9]{9}",
        "MatchingText": "917000000000,918000000000,919000000000, +917000000000, 9800000000, 8200000000",
        "NonMatchingText": "916000000000, +027000000000, 909000000000",
        "Description": "^ :Means Start from\n\n((\\+91)?|91) :Means +91 or 91\n\n? :Means OR\n\n[789][0-9]{9} :Means Mobile Number starting from 7,8 or 9."
    },
    {
        "Pattern": "^([0-9][0-9])[.]([0-9][0-9])[.]([0-9][0-9])$",
        "MatchingText": "01.02.23",
        "NonMatchingText": "1.2.3",
        "Description": "Versioning in XX.YY.ZZ format"
    },
    {
        "Pattern": "^[A-Z]{3}-[0-9]{4}$",
        "MatchingText": "KAA-2345 ||| OBA-3231 ||| NMN-2222",
        "NonMatchingText": "kaa-2323 ||| OBA-22 ||| JBN1123",
        "Description": "Formato de placas de ve\u00EDculos padr\u00E3o brasileiro."
    },
    {
        "Pattern": "^((CN=['\\w\\d\\s\\-\\&amp;]+,)+(OU=['\\w\\d\\s\\-\\&amp;]+,)*(DC=['\\w\\d\\s\\-\\&amp;]+[,]*){2,})$",
        "MatchingText": "CN=Joey O'Brenn,OU=Test &amp; 1,OU=Test &amp; 2,DC=support,DC=com",
        "NonMatchingText": "CN=Laurie Brenn,CN=Users,DC=support",
        "Description": "Matches the LDAP path of Microsoft Active Directory entry.  Checks to ensure the ADsPath attribute is accurate."
    },
    {
        "Pattern": "((http|https|ftp|telnet|gopher|ms\\-help|file|notes)://)?(([a-z][\\w~%!&amp;',;=\\-\\.$\\(\\)\\*\\+]*)(:.*)?@)?(([a-z0-9][\\w\\-]*[a-z0-9]*\\.)*(((([a-z0-9][\\w\\-]*[a-z0-9]*)(\\.[a-z0-9]+)?)|(((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)))(:[0-9]+)?))?(((/([\\w`~!$=;\\-\\+\\.\\^\\(\\)\\|\\{\\}\\[\\]]|(%\\d\\d))+)*/([\\w`~!$=;\\-\\+\\.\\^\\(\\)\\|\\{\\}\\[\\]]|(%\\d\\d))*)(\\?[^#]+)?(#[a-z0-9]\\w*)?)?",
        "MatchingText": "http://username:password@subdomain1.subdomain2.google.com:5000/test?q=2121ddf&opt=blah#ttg|||http://localhost/path/to/file-test.hml?q=45|||/index.html|||index.html|||http://127.0.0.1/path/to/?q=45",
        "NonMatchingText": "user@172.168.0.1|||httpss://test.com|||about:blank|||urn:oasis:names:specification",
        "Description": "I think this is the ultimate url match expression to every possible url pattern including named or ip address domain PS: you have got to try RegexBuddy it's a very cool tool that helps realy http://www.regexbuddy.com"
    },
    {
        "Pattern": "^(?:(?:http|https|ftp|telnet|gopher|ms\\-help|file|notes)://)?(?:(?:[a-z][\\w~%!&amp;',;=\\-\\.$\\(\\)\\*\\+]*):.*@)?(?:(?:[a-z0-9][\\w\\-]*[a-z0-9]*\\.)*(?:(?:(?:(?:[a-z0-9][\\w\\-]*[a-z0-9]*)(?:\\.[a-z0-9]+)?)|(?:(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)))(?::[0-9]+)?))?(?:(?:(?:/(?:[\\w`~!$=;\\-\\+\\.\\^\\(\\)\\|\\{\\}\\[\\]]|(?:%\\d\\d))+)*/(?:[\\w`~!$=;\\-\\+\\.\\^\\(\\)\\|\\{\\}\\[\\]]|(?:%\\d\\d))*)(?:\\?[^#]+)?(?:#[a-z0-9]\\w*)?)?$",
        "MatchingText": "http://username:password@subdomain1.subdomain2.google.com:5000/test?q=2121ddf&opt=blah#ttg|||http://www.test.com/test.htm#ttg|||domain.com/?q=test|||http://localhost/test|||http://127.0.0.1/test|||127.0.0.1|||me@test.com",
        "NonMatchingText": "[test]|||opt=blah#ttg|||/path?q=test",
        "Description": "I think this is the ultimate url match expression to every possible url pattern including named or ip address domain\n\nPS: you have got to try RegexBuddy it's a very cool tool that helps realy http://www.regexbuddy.com"
    },
    {
        "Pattern": "^(?:mailto:)?(?:[a-z][\\w~%!&amp;',;=\\-\\.$\\(\\)\\*\\+]*)@(?:[a-z0-9][\\w\\-]*[a-z0-9]*\\.)*(?:(?:(?:[a-z0-9][\\w\\-]*[a-z0-9]*)(?:\\.[a-z0-9]+)?)|(?:(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)))$",
        "MatchingText": "mailto:support@regexbuddy.com|||user@172.168.0.1|||user%20name@domain.com|||admin@localhost",
        "NonMatchingText": "@172.168.0.1|||domain.com|||user%20name@domain.com/test",
        "Description": "I think this is a very good e-mail validation match expression\n\nPS: you have got to try RegexBuddy it's a very cool tool that helps realy http://www.regexbuddy.com"
    },
    {
        "Pattern": "^(?P<username>[a-z][\\w.-]*)(?::(?P<pwd>[\\w.-]*))$",
        "MatchingText": "user:anything4654sASD:454!@#$|||user-name:anything4654sASD:454!@#$|||user.name:anything4654sASD:454!@#$",
        "NonMatchingText": "user name:anything4654sASD:454!@#$|||username|||user!name:anything4654sASD454",
        "Description": "accepts:\n1. user name\n   - starting with a letter\n   - [a-z, 0-9, _, - ]*\n2. : delimiter\n3. password with any characters"
    },
    {
        "Pattern": "^(?:(?:\\.\\./)|/)?(?:\\w(?:[\\w`~!$=;\\-\\+\\.\\^\\(\\)\\|\\{\\}\\[\\]]|(?:%\\d\\d))*\\w?)?(?:/\\w(?:[\\w`~!$=;\\-\\+\\.\\^\\(\\)\\|\\{\\}\\[\\]]|(?:%\\d\\d))*\\w?)*(?:\\?[^#]+)?(?:#[a-z0-9]\\w*)?$",
        "MatchingText": "..//test/tesf|||/cgi-bin/version.pl?r=fhjkjh%20ds&djj=fffsd#kit|||index.html|||/?q=test",
        "NonMatchingText": ".path./index.html|||about:blank|||..///test/tesf",
        "Description": "parse/match url path with:\n1. optional relative path\n2. optional query string\n3. optional fragments"
    },
    {
        "Pattern": "^#[\\dA-Fa-f]{3}(?:[\\dA-Fa-f]{3}[\\dA-Fa-f]{0,2})?$",
        "MatchingText": "#fff|||#123456|||#12345678|||#1f35cc",
        "NonMatchingText": "#1234|||#0|||#123456789",
        "Description": "matches # + 3 hex numbers + optional 3 more hex numbers and 2 more hex numbers for alpha\n\nPS: you have got to try RegexBuddy it's a very cool tool that helps realy http://www.regexbuddy.com"
    },
    {
        "Pattern": "^\\({0,1}0(2|3|7|8)\\){0,1}(\\ |-){0,1}[0-9]{4}(\\ |-){0,1}[0-9]{4}$",
        "MatchingText": "(02) 9323 1234|||0293231234|||02-9323-1234",
        "NonMatchingText": "01 9323 1234|||02 932 123|||02/9323/1234",
        "Description": "Expression to parse Australian landline telephone numbers. Will only accept valid STD codes. Allows for brackets around the STD code and either spaces or dashes between number groups."
    },
    {
        "Pattern": "^[6]\\d{7}$",
        "MatchingText": "61234567|||63829324|||67654321",
        "NonMatchingText": "6123-4567|||6-CALL-CPY|||6123abcd",
        "Description": "In Singapore, the first digit must start with a \"6\", and the rest is made up of 7 digits, which means that there are 8 digits in a Singapore's telephone number."
    },
    {
        "Pattern": "^[SFTG]\\d{7}[A-Z]$",
        "MatchingText": "S9912345A|||T1234567V|||F0094839P",
        "NonMatchingText": "K4928940829F|||T1234567|||M1234567C",
        "Description": "The National Registry Identification Number (NRIC) of Singapore is made up of the first character being a S/F/T or G. The next 2 numbers is the year of birth for people born 1967 and later. The last character is a checksum done on the numbers, and the algorithm will not be released."
    },
    {
        "Pattern": "^\\$?([A-Za-z]{0,2})\\$?([0-9]{0,5}):?\\$?([A-Za-z]{0,2})\\$?([0-9]{0,5})$",
        "MatchingText": "$A:$A|$5:$5|$H$19|H19|g21:n36|$G$31:$N$36",
        "NonMatchingText": "$A$A",
        "Description": "Since MS Excel will be giving you the cell range addresses, this simple regex provides nice match captures.  It may not validate the only possibles that Excel takes, but it is \"good enough\" for a majority of circumstances."
    },
    {
        "Pattern": "^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5})$",
        "MatchingText": "somthing@someserver.com|||firstname.lastname@mailserver.domain.com|||username-something@some-server.",
        "NonMatchingText": "username@someserver.domain.c|||somename@server.domain-com|||someone@something.se_eo",
        "Description": "Easy expression that checks for valid email addresses."
    },
    {
        "Pattern": "^(?:\\s*(Sun|Mon|Tue|Wed|Thu|Fri|Sat)\\s*)(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s+?(0?[1-9]|[1-2][0-9]|3[01])\\s+(2[0-3]|[0-1][0-9]):([0-5][0-9]):(60|[0-5][0-9])\\s+((?:E|C|M|P)(?:ST|DT))\\s+(19[0-9]{2}|[2-9][0-9]{3}|[0-9]{2})",
        "MatchingText": "Wed Sep 21 04:33:26 EDT 2011|||Thu Aug 21 23:33:26 PDT 2011|||Thu Aug 21 23:33:26 PDT 2011",
        "NonMatchingText": "Sun Aug 30 23:33:26 GMT 2033|||Sunday Aug 31 23:59:59 EST 2033|||Sun Feb 32 23:59:59 EST 2033",
        "Description": "Validates the toString from a java.util.Date object. It is NOT formatted for java-source."
    },
    {
        "Pattern": "^(\\$|)([1-9]+\\d{0,2}(\\,\\d{3})*|([1-9]+\\d*))(\\.\\d{2})?$",
        "MatchingText": "$1,234,567.00|||$1234567.00|||1234567.00",
        "NonMatchingText": "$1,2345,67.00|||$0|||$0.00",
        "Description": "By combining the contributions from Bri Gipson and Michael Ash in this site.  I have come up with this RE to exclude the zero dollar amounts such as $0.00, 0.00, 0, etc."
    },
    {
        "Pattern": "^(\\$|)([1-9]\\d{0,2}(\\,\\d{3})*|([1-9]\\d*))(\\.\\d{2})?$",
        "MatchingText": "$1,234,567.89|||1234567.89|||$9.99",
        "NonMatchingText": "$1,2345,67.89|||$1234,345,678.0|||0",
        "Description": "Combine Michael Ash's US Dollar amount and Bri Gipson's eliminating zero input to create this RE to accept Optional leading dollar sign, optional well-formed comma separator dollar amount with no zero amount allowed.\n\n*** Correction: Remove the &quot;+&quot; otherwise it will incorrectly matches 4 leading digits like 1234,345,678.00 03-03-2005\n"
    },
    {
        "Pattern": "^(?P<Drive>([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w].*))(?P<Year>\\d{4})-(?P<Month>\\d{1,2})-(?P<Day>\\d{1,2})(?P<ExtraText>.*)(?P<Extension>.csv|.CSV)$",
        "MatchingText": "c:\\upload\\yyyy-mm-dd-DailyUpload.csv",
        "NonMatchingText": "DailyUpload.csv",
        "Description": "Allows a file with the format <drive><directory>yyyy-mm-dd-DailyUpload.csv"
    },
    {
        "Pattern": "^[0-9]{4}((0[1-9])|(1[0-2]))$",
        "MatchingText": "200401|||000001|||200412",
        "NonMatchingText": "aaa|||20040123|||200414",
        "Description": "Match a string in CCYYMM/YYYYMM format."
    },
    {
        "Pattern": "^[A-Za-z0-9](([_\\.\\-]?[a-zA-Z0-9]+)*)@([A-Za-z0-9]+)(([\\.\\-]?[a-zA-Z0-9]+)*)\\.([A-Za-z]{2,})$",
        "MatchingText": "he_llo@worl.d.com|||hel.l-o@wor-ld.museum|||h1ello@123.com",
        "NonMatchingText": "hello@worl_d.com|||he&amp;llo@world.co1|||.hello@wor#.co.uk",
        "Description": "does not allow IP for domain name : hello@154.145.68.12\ndoes not allow litteral addresses &quot;hello, how are you?&quot;@world.com\nallows numeric domain names\nafter the last &quot;.&quot; minimum 2 letters"
    },
    {
        "Pattern": "^(((\\.\\.){1}/)*|(/){1})?(([a-zA-Z0-9]*)/)*([a-zA-Z0-9]*)+([.jpg]|[.gif])+$",
        "MatchingText": "../../pictures/products/image.gif; ../image.jpg; image.gif",
        "NonMatchingText": "http://www.domain.de/image.gif; ../../badscript.php;",
        "Description": "Nice for checking local filesystem relative pathing. I used it for testing in php scripts that work with images."
    },
    {
        "Pattern": "(\\+989|9|09)(0[1-3]|1[0-9]|2[0-2]|3[0-9]|90|9[8-9])\\d{7}",
        "MatchingText": "09221113344",
        "NonMatchingText": "09057614584",
        "Description": "Regex for current available mobile numbers mention at \nhttps://fa.wikipedia.org/wiki/%D8%B4%D9%85%D8%A7%D8%B1%D9%87%E2%80%8C%D9%87%D8%A7%DB%8C_%D8%AA%D9%84%D9%81%D9%86_%D8%AF%D8%B1_%D8%A7%DB%8C%D8%B1%D8%A7%D9%86"
    },
    {
        "Pattern": "^]:\\\\[^:\\*\\?\"<>|\\/\\\\]+(\\.[^:\\*\\?\"<>|\\/\\\\]+|[^:\\*\\?\"<>|\\/]+[^:\\*\\?\"<>|\\/\\\\]+\\.[^:\\*\\?\"<>|\\/\\\\]+)$",
        "MatchingText": "C:\\my-directory\\my-file.ext|||g:\\file.txt",
        "NonMatchingText": ":\\my-directory\\my-file.ext|||c:\\file\\\\.ext",
        "Description": "The match return true if the test value is a valid path on windows."
    },
    {
        "Pattern": "^(NT|SD2|S?(0T|D[01]|BR|K[1-9][0-9]{0,5}|[1-9][0-9]{0,5}[LMNT]))$",
        "MatchingText": "BR | SBR | 1150L | S1150M | K950 | SK950 | D02",
        "NonMatchingText": "SNT | 1150X | K0",
        "Description": "UK tax codes can be one of the following fixed formats: 0T, BR, D0, D1 and NT.  Or, they can be a number following by one of the following letters LMNT, or a K followed by a number.   All of the above can  also be prefixed by a letter S (to indicate Scottish) except for the NT code.  Scottish regime also has a D02 code."
    },
    {
        "Pattern": "^(.*\\n.*)(?:([^:]*)(?::(.*?))?@)?([^:]*)(?::([^:]*?))?$",
        "MatchingText": "user@example.com:80 ||| user:password@example.com:8080 ||| site.com:8080 | site.com | 192.168.1.1:443 | usern@me@site.com | usern@me:pass@site.com",
        "NonMatchingText": "\\n ||| : ||| @",
        "Description": "For the purposes of this regex, the authority/domain of a URL comes after the scheme + \"//\", and includes an optional username, password, and port.\nThis is a perl-compatible regex (PCRE) that captures the various parts of the a domain, including the (optional) username, (optional) password, host, and (optional) port. The capturing groups are as follows: 1 = username, 2 = password, 3 = host, 4 = post. See the source link for the logic behind parsing the domain. NOTE: This is NOT intended to parse entire URLs, you will need a separate regular expression to extract the domain. Technically, only strings with newline characters are non-matches. The rest yield empty capturing groups. ANOTHER NOTE: This does NOT verify that only ascii characters are used in domain names. It is intended to extract pieces from domains that should already be valid. "
    },
    {
        "Pattern": "^((?:.*(\\d))*(?:\\D*)?)(\\d+)$",
        "MatchingText": "123|||aaa123|||aaa123aaa123",
        "NonMatchingText": "aaa|||aaa123aaa",
        "Description": "Matches the number at the end of the string.\n"
    },
    {
        "Pattern": "<[a-zA-Z]+(\\s+[a-zA-Z]+\\s*=\\s*(\"([^\"]*)\"|'([^']*)'))*\\s*/>",
        "MatchingText": "<img src=\"test.gif\"/>",
        "NonMatchingText": "<img src=\"test.gif\">|||<img src=\"test.gif\"a/>",
        "Description": "Matches a valid &quot;empty&quot; tag (has trailing slash).  Note, if you run it against a string such as &lt;img src=&quot;test.gif&quot; alt=&quot;&lt;hr /&gt;&quot;&gt; it will indeed return a match.  But, the match is not at character 1 like you'd suspect, but rather it's matching the internal &lt;hr /&gt;.  If you look at the source of this tag (http://concepts.waetech.com/unclosed_tags/) you'll find a whoe suite of regex's for matching html tags.  Using them you could feasibly step though a document and avoid this mismatch as the outer tag would match *in totality* and you'd completely skip this inner match.\n"
    },
    {
        "Pattern": "(\\+)?([-\\._\\(\\) ]?[\\d]{3,20}[-\\._\\(\\) ]?){2,10}",
        "MatchingText": "(604) 789-0136|||+123-45678-908",
        "NonMatchingText": "01.12.23",
        "Description": "Telephone number filter - use to catch and replace phone numbers where you don't want them to appear."
    },
    {
        "Pattern": "^([\\w-]+\\.)*?[\\w-]+@[\\w-]+\\.([\\w-]+\\.)*?[\\w]+$",
        "MatchingText": "name@domain.com|||name.name2@domain.com|||name.name2@sub.domain.com",
        "NonMatchingText": "name.@domain.com|||name@.domain.com|||.name@domain.com",
        "Description": "The following pattern checks whether the input string is a valid email address in the form &quot;name@domain.com&quot;. Actually, it does not have to be a &quot;.com&quot; address. Any combination of letters following the last period are fine. Also, the email name can have a dash or be separated by one or more periods. The Domain name can also have multiple words separated by periods. Thus, it will validate bob@hotmail.com and bill.michaels@us.office.gov.\n"
    },
    {
        "Pattern": "&lt;!--[\\w\\W]*?--&gt;",
        "MatchingText": "&lt;!-- comment --&gt;|||&lt;!-- &lt;some tag&gt; --&gt;",
        "NonMatchingText": "&lt;!- - comment --&gt;|||&lt;!-- ccccc",
        "Description": "This expression will find sigle or multilined HTML comments."
    },
    {
        "Pattern": "^[ \\w]{3,}([A-Za-z]\\.)?([ \\w]*\\#\\d+)?(\\r\\n| )[ \\w]{3,},\\x20[A-Za-z]{2}\\x20\\d{5}(-\\d{4})?$",
        "MatchingText": "123 Anywhere Dr. apt #99 Somewhere, ST 55789|||123 Anywhere Dr. Somewhere, ST 55789|||123 Anywhere D",
        "NonMatchingText": "123 Anywhere Drive #99 Somewhere, ST 55789 - 1234|||123 Anywhere Dr. apt. #99  Somewhere, ST 55789||",
        "Description": "This is a simple expression to check a US street address entered on either one or two lines.  Being short it does not check that the road qualifer is &quot;valid&quot; (eg. drive, avenue, etc), but it does allow for the extended zip code.  A word of warning, the multiline mode can be picky about ending the first line with extra space."
    },
    {
        "Pattern": "(^\\d{1,2}\\.\\d{1,2}\\.\\d{4})|(^\\d{1,2}\\.\\d{1,2})|(^\\d{1,2})$",
        "MatchingText": "20 | 20.11 | 15.10.2004 | 88.88.0000",
        "NonMatchingText": "hi | 123.25 | 11e",
        "Description": "simple test for C# inputs and CZ locale. No all accepted inputs are corect."
    },
    {
        "Pattern": "^07[789]-\\d{7}$",
        "MatchingText": "079-5675777, 078-6543289, 077-7698435",
        "NonMatchingText": "075-787653",
        "Description": "Regular expression to validate mobile numbers in Jordan provided by Zain, Orange, and Umnia."
    },
    {
        "Pattern": "  True CBD Oil Next, when you clean your ears of ear wax, is the wax hard or soft? In the UK the cannabis plant is illegal, and so is the leaf or any by product. You will find that there is cover ups and it's against the rights of human life on this planet. This handy chart captures a good number of organic spots for locals to frequent.  MSM accumulate in cell walls to make them soft and flexible which allows nutrients to enter the cell and toxins to move out of the cell. This prevents against coronary heart diseases, strokes and hypertension. Marijuana can affect your self control causing a loss in sense of time and as I pointed out earlier it does affect your ability to operate a vehicle. Its natural Cannabidiol brightness can extinguish the need to use chlorine bleach which means to extremely toxic dioxin being dumped into water sources. They have the ability to make things better for you just by their physical presence beside you.  You should try to eat foods rich in omega-3, which is an important polyunsaturated fat. Then other Indian spices would be cumin and I have something called garamasala which has coriander, cumin, chilies, something I can't read, I think it says clove, bay leaf, cassia and ginger. And there's no sign yet that the approach works in laboratory animals, let alone people.Still, the finding does suggest that more than one compound in marijuana might boost cancer treatment, said study author Sean McAllister, an associate scientist at California Pacific Medical Center Research Institute in San Francisco. \"Combination therapies might be more appropriate,\" McAllister said.  Omega 3 is a group of essential fatty acids that is required for good health. For those unfamiliar, THC is substance in marijuana that produces the \"high.\" But companies like Medical Marijuana, Inc. (MJNA.PK) - whose subsidiary companies produce many hemp products that contain the non-psychoactive cannabinoid compound Cannabidiol (CBD) which is legal to consume in all 50 states - are also affected. One of the most viable and varied sources of hemp are the Cannabis seeds. Medication can only treat the symptoms and often carry potential side effects that worsen your symptoms.  https://musclebuildingbuy.com/true-cbd-oil/",
        "MatchingText": "5",
        "NonMatchingText": "3",
        "Description": "True CBD Oil\nNext, when you clean your ears of ear wax, is the wax hard or soft? In the UK the cannabis plant is illegal, and so is the leaf or any by product. You will find that there is cover ups and it's against the rights of human life on this planet. This handy chart captures a good number of organic spots for locals to frequent.\nMSM accumulate in cell walls to make them soft and flexible which allows nutrients to enter the cell and toxins to move out of the cell. This prevents against coronary heart diseases, strokes and hypertension. Marijuana can affect your self control causing a loss in sense of time and as I pointed out earlier it does affect your ability to operate a vehicle. Its natural Cannabidiol brightness can extinguish the need to use chlorine bleach which means to extremely toxic dioxin being dumped into water sources. They have the ability to make things better for you just by their physical presence beside you.\nYou should try to eat foods rich in omega-3, which is an important polyunsaturated fat. Then other Indian spices would be cumin and I have something called garamasala which has coriander, cumin, chilies, something I can't read, I think it says clove, bay leaf, cassia and ginger. And there's no sign yet that the approach works in laboratory animals, let alone people.Still, the finding does suggest that more than one compound in marijuana might boost cancer treatment, said study author Sean McAllister, an associate scientist at California Pacific Medical Center Research Institute in San Francisco. \"Combination therapies might be more appropriate,\" McAllister said.\nOmega 3 is a group of essential fatty acids that is required for good health. For those unfamiliar, THC is substance in marijuana that produces the \"high.\" But companies like Medical Marijuana, Inc. (MJNA.PK) - whose subsidiary companies produce many hemp products that contain the non-psychoactive cannabinoid compound Cannabidiol (CBD) which is legal to consume in all 50 states - are also affected. One of the most viable and varied sources of hemp are the Cannabis seeds. Medication can only treat the symptoms and often carry potential side effects that worsen your symptoms.\nhttps://musclebuildingbuy.com/true-cbd-oil/"
    },
    {
        "Pattern": "^(([a-zA-Z\u00E4\u00F6\u00FC\u00C4\u00D6\u00DC]\\D*)\\s+\\d+?\\s*.*)$",
        "MatchingText": "Am Plan 3c|||Hauptstr. 4 1/2|||A-Weg 8",
        "NonMatchingText": "Am Plan|||Hauptstr.5|||Heideweg Drei",
        "Description": "Erkl\u00E4rt Stra\u00DFe-Hausnummer-Kombinationen nach folgenden Regeln f\u00FCr g\u00FCltig:\nStra\u00DFe muss mit einem dt. Buchstaben beginnen, \nvor der Hausnummer muss (mind.) ein Whitespace stehen,\nder Nummer d\u00FCrfen andere Zeichen folgen (\"1/2\", \"c\" etc.)."
    },
    {
        "Pattern": "^([^ \\x21-\\x26\\x28-\\x2C\\x2E-\\x40\\x5B-\\x60\\x7B-\\xAC\\xAE-\\xBF\\xF7\\xFE]+)$",
        "MatchingText": "Anna-Maria|||Ren\u00E9|||Karl-Theodor|||Janne\u00DF-Ra\u00DFmus",
        "NonMatchingText": "Anna Maria|||Ute08|||Dieter&Thomas|||Ernie_Bert",
        "Description": "Pr\u00FCft auf einen Namen (evtl. zusammengesetzt mit Bindestrich \"-\"). L\u00E4sst auch Akzentzeichen zu.\nVerifies a first name (possibly hyphenated). Accepts also accent marks."
    },
    {
        "Pattern": "^(((((((00|\\+)49[ \\-/]?)|0)[1-9][0-9]{1,4})[ \\-/]?)|((((00|\\+)49\\()|\\(0)[1-9][0-9]{1,4}\\)[ \\-/]?))[0-9]{1,7}([ \\-/]?[0-9]{1,5})?)$",
        "MatchingText": "+49(89)123456|||089-1234-5678|||(089)1234-5678",
        "NonMatchingText": "0049089123456|||0172.55555",
        "Description": "'Deutsche Telefonnummern'\nMatches German phone and fax numbers (including cell phone numbers) in various formats like:\n004989123456, \n+49 89 123456, \n+49(89)123456, \n089-1234-5678, \n089 1234 5678, \n(089)1234-5678\nMax. number of digits is 21.\n\n\n"
    },
    {
        "Pattern": "#QuickenSupportPhoneNumber,QuickenPhoneNumber#QiuckenHelp#QuickenCustomerService",
        "MatchingText": "http://www.quickensupportnumber247.com/",
        "NonMatchingText": "www.quickensupportnumber247.com/",
        "Description": "Our master geeks have various ways to deal with unwind your little or huge particular issue in a noteworthy viable manner. Every last one of us would be especially stressed over this issue. As a trusted Quicken Support Phone Number provider it is our sole commitment to know your issues well and give a legitimate response for the same. Meet our nerds on phone call at+1-800-277-6571. http://www.quickensupportnumber247.com/\n"
    },
    {
        "Pattern": "^\\(\\d{3}\\) ?\\d{3}( |-)?\\d{4}|^\\d{3}( |-)?\\d{3}( |-)?\\d{4}",
        "MatchingText": "(658)154-1122|||6581541122|||658-154-1122",
        "NonMatchingText": "(658 154 1122|||759-1245|||875 (489 1568)",
        "Description": "Expresion Regular para Tel&#233;fonos con clave lada en M&#233;xico\nseparada o no con guiones o espacios. Sirve para tel&#233;fonos estacionarios y/o celulares, con o sin par&#233;ntesis, 10 n&#250;meros a fuerzas, funciona en .net"
    },
    {
        "Pattern": "^(000)([0-6]\\d{2}|7([0-6]\\d|7[012])) ([ -])? (00)\\d\\d([ -|])? (0000)\\d{4}$",
        "MatchingText": "145470191|||145 47 0191|||145-47 0191",
        "NonMatchingText": "000470191|||145-00-0191|||145.47.0191",
        "Description": "U.S. social security numbers (SSN), within the range of numbers that have been currently allocated. Matches the pattern AAA-GG-SSSS, AAA GG SSSS, AAA-GG SSSS, AAA GG-SSSS, AAAGGSSSS, AAA-GGSSSS, AAAGG-SSSS, AAAGG SSSS or AAA GGSSSS. All zero in any one field is not allowed. \n\n** Additionally, spaces and/or dashes and/or nothing are allowed.  In Michael Ash's example 123-45 6789 and 123456789 would fail there was a '\\3' after the second octet of numbers that seemed to confuse the regex. now any combination of spaces, dashes, or nothing will work between the SSN octets. BoxerX.com thanks Michael for the regex!"
    },
    {
        "Pattern": "^(((0[13578]|10|12)([-./])(0[1-9]|[12][0-9]|3[01])([-./])(\\d{4}))|((0[469]|11)([-./])([0][1-9]|[12][0-9]|30)([-./])(\\d{4}))|((02)([-./])(0[1-9]|1[0-9]|2[0-8])([-./])(\\d{4}))|((02)(\\.|-|\\/)(29)([-./])([02468][048]00))|((02)([-./])(29)([-./])([13579][26]00))|((02)([-./])(29)([-./])([0-9][0-9][0][48]))|((02)([-./])(29)([-./])([0-9][0-9][2468][048]))|((02)([-./])(29)([-./])([0-9][0-9][13579][26])))$",
        "MatchingText": "01/01/2001",
        "NonMatchingText": "01/01/00000",
        "Description": "This works for all accept 01/01/0000 mainly 0000. can anybody suggest a solution."
    },
    {
        "Pattern": "^\\$?(\\d{1,3}(\\,\\d{3})*|(\\d+))(\\.\\d{0,2})?$",
        "MatchingText": "$0,234.50|||0234.5|||0,234.",
        "NonMatchingText": "$1,23,50|||$123.123",
        "Description": "From Author: DON'T USE THIS ONE. FIND MY OTHER ONE THAT BLOCKS LEADING ZEROS.  My site also couldn't swallow the \\d, so I switched to numeric ranges and it worked fine.\nKEYWORDS Currency Money Dollar \n"
    },
    {
        "Pattern": "^\\$?([1-9]{1}[0-9]{0,2}(\\,[0-9]{3})*(\\.[0-9]{0,2})?|[1-9]{1}[0-9]{0,}(\\.[0-9]{0,2})?|0(\\.[0-9]{0,2})?|(\\.[0-9]{1,2})?)$",
        "MatchingText": "$1,234.50|||$0.70|||.7",
        "NonMatchingText": "$0,123.50|||$00.5",
        "Description": "Many currency expresssions allow leading zeros, thus $01.40 passes thru them.  This expression kills them, except for 0 in the one's column. Works with or without commas and/or dollar sign. Decimals not mandatory, unless no zero in ones column and decimal point is placed. Allows $0.00 and .0 Keywords: money dollar currency"
    },
    {
        "Pattern": "( xmlns:.*=[&quot;,'].*[&quot;,'])|( xmlns=[&quot;,'].*[&quot;,'])",
        "MatchingText": "&lt;el xmlns=&quot;http://SomeCorp/Namespace1&quot;&gt;|||&lt;el xmlns='http://SomeCorp/Namespace1'&",
        "NonMatchingText": "&lt;el xmlns=http://SomeCorp/Namespace1&gt;",
        "Description": "Matches xml namespace (xmlns) attribtutes. Works with single and double quotes, could be extended to support unquoted attributes."
    },
    {
        "Pattern": "(^\\d{1,5}$|^\\d{1,5}\\.\\d{1,2}$)",
        "MatchingText": "0|||00000|||00.00",
        "NonMatchingText": "asds|||000000|||00000.",
        "Description": "This expression evaluates simple currency values...  alteast 1 digit and max 5 digits and if period then atleast one digit after period and max two digits after period"
    },
    {
        "Pattern": "(?P<raw_message>\\:(?P<source>((?P<nick>[^!]+)![~]{0,1}(?P<user>[^@]+)@)?(?P<host>[^\\s]+)) (?P<command>[^\\s]+)( )?(?P<parameters>[^:]+){0,1}(:)?(?P<text>[^\\r^\\n]+)?)",
        "MatchingText": ":irc.server.com 001 someguy :welcome to the IRC server",
        "NonMatchingText": "*** : Connecting to server",
        "Description": "Simple regular expression for creating an IRC client. This will parse the raw octet stream into message segments and groups that make it easy to build a client."
    },
    {
        "Pattern": "(\\(?\\+44\\)?\\s?(1|2|3|7|8)\\d{3}|\\(?(01|02|03|07|08)\\d{3}\\)?)\\s?\\d{3}\\s?\\d{3}|(\\(?\\+44\\)?\\s?(1|2|3|5|7|8)\\d{2}|\\(?(01|02|03|05|07|08)\\d{2}\\)?)\\s?\\d{3}\\s?\\d{4}|(\\(?\\+44\\)?\\s?(5|9)\\d{2}|\\(?(05|09)\\d{2}\\)?)\\s?\\d{3}\\s?\\d{3}",
        "MatchingText": "01234 123 123 , (+44)1234 123 123 , 0123 456 7890 , 01234567890 , (01234) 567 890",
        "NonMatchingText": "1234 123 123 , +44 01234 567 890",
        "Description": "Matches most common patterns for UK telephone numbers including +44 prefix , and with or without brackets. Covers 10 and 11 digit number ranges. Should be easy to modify for other number ranges."
    },
    {
        "Pattern": "((\\(\\d{3,4}\\)|\\d{3,4}-)\\d{4,9}(-\\d{1,5}|\\d{0}))|(\\d{4,12})",
        "MatchingText": "0833-1234567-8888|||(0833)1234567-8888|||12345678",
        "NonMatchingText": "ceocio|||!@$@#$",
        "Description": "telphone number check."
    },
    {
        "Pattern": "<font[a-zA-Z0-9_\\^\\$\\.\\|\\{\\[\\}\\]\\(\\)\\*\\+\\?\\\\~`!@#%&-=;:'\",/\\n\\s]*>",
        "MatchingText": "<font color=\"#006666\">, <font face=\"arial\" style=\"font-size: 11pt\">",
        "NonMatchingText": "<font, </font>, <font <>",
        "Description": "This expression will capture font tags(or any other HTML tag if you change the word font in the expression) with parameters and stop at the closing font tag bracket.  The only keyboard characters it will not find between the starting and ending bracket are additional brackets.  So for example if you are looking for image tags it will not find <img src=\"...\" alt=\">My Picture<\"> due to the nested brackets.  When I allowed nested brackets like this the expression did not always return only the tag I was looking for.  Sometimes it returned additional tags at the end so I suggest staying away from brackets in alt text and anywhere else you may be allowed to do it."
    },
    {
        "Pattern": "^((?:[A-HJ-PR-Y][A-HJ-PR-Y]\\s?(?:0[2-9]|[1-9][0-9])\\s?[A-HJ-PR-Z]{3})|(?:[A-Z](?:[IZ][A-Z]|[A-Z][IZ])\\s?\\d{1,4})|(?:[A-HJ-NP-TV-Y]\\s?\\d{1,3}\\s?[A-Z]{3})|(?:[A-Z]{3}\\s?\\d{1,3}\\s?[A-HJ-NPR-TV-Y])|(?:\\d{1,3}\\s?[A-HJ-Y]{1,3}|[A-HJ-Y]{1,3}\\s?\\d{1,3})|(?:\\d{1,4}\\s?(?:[IZ][A-Z]|[A-Z][IZ]))|(?:[A-Z]{1,2}\\s?\\d{1,4}))$",
        "MatchingText": "AAA111|||A123BCD|||ACB123D|||AB12CDE",
        "NonMatchingText": "A12345|||I123JKL|||IQ12RST|||ABC123O",
        "Description": "Matches all UK number plates used in England, Scotland, Wales and Northern Ireland, including the dateless formats pre-1932 and 1932-1963 formats, the year prefix and suffix formats, and the current style format brought into use from 2001 onwards."
    },
    {
        "Pattern": "(^[A-Z\u00C0-\u00DC]{1}[a-z\u00E0-\u00FC']+\\s[a-zA-Z\u00E0-\u00FC\u00C0-\u00DC]+((([\\s\\.'])|([a-z\u00E0-\u00FC']+))|[a-z\u00E0-\u00FC']+[a-zA-Z\u00E0-\u00FC\u00C0-\u00DC']+))",
        "MatchingText": "Carlos Rodrigues|||C\u00E1 de Laaa|||Crras R. L. Rodrig\u00FCes",
        "NonMatchingText": "aa\u00E4A",
        "Description": "Checks if has the first and the last name, and check the capital letters.\n\nUse with the RegExp.test method"
    },
    {
        "Pattern": "((?:Microsoft)?.?(?:(?:Windows.NT.(?:[1-4].[0-9]))|(?:Win(?:dows)?.?NT).?[1-4](?:.?[0-9])?|NT[1-4]))",
        "MatchingText": "Windows NT 4.0 ||| Microsoft Windows NT 4.0|||Microsoft Windows NT 3.5|||Win NT4|||NT4|||Windows_NT_4.0|||MicrosoftWindowsNT3.1|||WindowsNT4|||Windows_NT.4",
        "NonMatchingText": "WinNT|||Win NT|||Windows 2000|||Windows NT",
        "Description": "Matches the \"Official\" and several other popular expressions of the \"Windows NT\" line of operating systems. Used to discern one OS version from another. Must include at least one digit of the version number (1 to 4 or  1.0 to 4.9 will match).\nOnly one capture group will return the full, matching string."
    },
    {
        "Pattern": "^[0-9,]+['][-](\\d|1[01])&quot;$",
        "MatchingText": "49'-10\" ||| 100'-0\" ||| 0'-2\"",
        "NonMatchingText": "100'-13\" ||| 15'-3 1/2\" ||| 200'",
        "Description": "Feet and Inches. Only allows 1 to 11\". Feet can be 0 to higher. No fractions."
    },
    {
        "Pattern": "^([A-Z]+\\s*[A-Z]+)$",
        "MatchingText": "JOHN DOE ||| BOB ||| MELTON HILL",
        "NonMatchingText": "John 3 ||| THE CHEROKEE LAKE ||| Bill",
        "Description": "1 or 2 words with 1 or no space. Words are in all capital letters. Nothing in front or end of word(s)."
    },
    {
        "Pattern": "^[1-9]+[0-9]*$",
        "MatchingText": "1 | 12 | 1000",
        "NonMatchingText": "0 | -2 | 1.00",
        "Description": "Matches all Positive Numbers not including zero (0). Does not allow decimals."
    },
    {
        "Pattern": "^0?.[0]{1,2}[1-9]{1}$|^0?.[1-9]{1}?\\d{0,2}$|^(1|1.{1}[0]{1,3})$|^0?.[0]{1}[1-9]{1}\\d{1}$",
        "MatchingText": "1.0||1||.905||0.010||.009",
        "NonMatchingText": "1.00||.0009||.000||1.",
        "Description": "Decimal values from 1 to .001 with precision of three, leading zero optional.  Can be 1 or 1.0 or 1.000 "
    },
    {
        "Pattern": "^(([0]([2|3|4|5|6|8|9|7])))\\d{7,8}$",
        "MatchingText": "055123450 0551234505 0200000000",
        "NonMatchingText": "000000000000 02000000000",
        "Description": "matches all phone numbers including mobile, 9 charachters and 10, starting with 0, no space or -."
    },
    {
        "Pattern": "^\\{[A-Fa-f\\d]{8}-[A-Fa-f\\d]{4}-[A-Fa-f0\\d]{4}-[A-Fa-f\\d]{4}-[A-Fa-f\\d]{12}\\}$",
        "MatchingText": "{CA373C30-293E-4DB8-A5E4-07AEA8D3F16E}|||{01234567-8998-7654-3210-012345678998}|||{ABCDEFFE-DCBA-ABCD-EFFE-DCBAABCDEFFE}",
        "NonMatchingText": "{ABCDEFGH-IJKL-MNOP-QRST-UVWXYZ123456}|||{0123-456789AB-CDEF-FEDC-BA9876543210}\"|||{0123456789ABCDEFFEDCBA9876543210}",
        "Description": "This validates GUID strings. It is not case sensitive and requires the beginning and ending curly brackets - '{' and '}' - to be present."
    },
    {
        "Pattern": "^([A-Z]{0,3}?[0-9]{9}($[0-9]{0}|[A-Z]{1}))",
        "MatchingText": "ABC123456789A12",
        "NonMatchingText": "CA1234567885",
        "Description": "Medicare number validation:XXXYYYYYYYYYZBBXXX- can be up to 3 letters. Not requiredYYY- 9 digits \u2013 requiredZ- must be letter. No number. Not requiredBB- can be letter or numbers. Not required. Can only exist if Z is exists. "
    },
    {
        "Pattern": "(http(s?)://|[a-zA-Z0-9\\-]+\\.)[a-zA-Z0-9/~\\-]+\\.[a-zA-Z0-9/~\\-_,&\\?\\.;]+[^\\.,\\s<]",
        "MatchingText": "sub.test.com",
        "NonMatchingText": "test.com",
        "Description": "This regex avoids matching typical mistakes where a sentence ends but there is no space after the full stop (period). Other regexes will think any two words with a dot in between is a URL! My regex does not require http:// and if there isn't http:// it will need to find AT LEAST two dots to guarantee its likely to be a URL and not a sentence that's missing a space like this.It will match www.test.com, http://test.com, test.com/index.htm but it will NOT match test.com. It will not match a dot or a comma at the very end which some people may type when including a URL in a sentence like this www.test.com, or this www.test.com."
    },
    {
        "Pattern": "((https?|ftp|gopher|telnet|file|notes|ms-help):((//)|(\\\\\\\\))+[\\w\\d:#@%/;$()~_\\+-=\\\\\\.&]*)",
        "MatchingText": "http://regexlib.com/Add.aspx, http://www.regexlib.com/Add.aspx",
        "NonMatchingText": "http://regexlib.com/Search.aspx?k=&c=2&m=-1&ps=20",
        "Description": "Modified URL RegExp that requires (http, https, ftp,gopher,telnet,file|notes,ms-help)://, A nice domain, and a decent file/folder string."
    },
    {
        "Pattern": "(\\bR(\\.|)R(\\.|)|RURAL\\s{0,}(ROUTE|RT(\\.|)))\\s{0,}\\d{1,}(,|)\\s{1,}\\bBOX\\s{0,}\\d",
        "MatchingText": "R.R. 2, Box 2|||Rural Route 2, Box 2|||Rural Route 2 Box 2",
        "NonMatchingText": "Rural Route Box 2|||Rural Route 2Box 2|||Rural Route 2Box 2",
        "Description": "This will validate a rural route address against the United States Postal Service (USPS) rural route standard."
    },
    {
        "Pattern": "(((0[13578]|10|12)([/])(0[1-9]|[12][0-9]|3[01])([/])([1-2][0,9][0-9][0-9]))|((0[469]|11)([/])([0][1-9]|[12][0-9]|30)([/])([1-2][0,9][0-9][0-9]))|((02)([/])(0[1-9]|1[0-9]|2[0-8])([/])([1-2][0,9][0-9][0-9]))|((02)([/])(29)(\\.|-|\\/)([02468][048]00))|((02)([/])(29)([/])([13579][26]00))|((02)([/])(29)([/])([0-9][0-9][0][48]))|((02)([/])(29)([/])([0-9][0-9][2468][048]))|((02)([/])(29)([/])([0-9][0-9][13579][26])))",
        "MatchingText": "05/15/2008,02/29/2008",
        "NonMatchingText": "05-12-2008,02/29/2007",
        "Description": "This is the USA Date Format. MM/DD/YYYY with checking leaf year"
    },
    {
        "Pattern": "(\\d{2}|\\d{4})(?:\\-)?([0]{1}\\d{1}|[1]{1}[0-2]{1})(?:\\-)?([0-2]{1}\\d{1}|[3]{1}[0-1]{1})(?:\\s)?([0-1]{1}\\d{1}|[2]{1}[0-3]{1})(?::)?([0-5]{1}\\d{1})(?::)?([0-5]{1}\\d{1})",
        "MatchingText": "00-00-00 00:00:00|||0000-00-00 00:00:00|||09-05-22 08:16:00|||1970-00-00 00:00:00|||20090522081600",
        "NonMatchingText": "2009-13:01 00:00:00|||2009-12-32 00:00:00|||2002-12-31 24:00:00|||2002-12-31 23:60:00|||02-12-31 23:00:60",
        "Description": "Will match a date accepted by MySQL datetime type.\nYears with 2 or 4 digits from any range.\nMonths with 2 digits from 00 to 12.\ndays with 2 digits from 00 to 31.\nHours with 2 digits from 00-23\nMinutes with 2 digits from 00 to 59.\nSeconds with 2 digits from 00 to 59."
    },
    {
        "Pattern": "^(0|[-]{1}([1-9]{1}[0-9]{0,1}|[1]{1}([0-1]{1}[0-9]{1}|[2]{1}[0-8]{1}))|(\\+)?([1-9]{1}[0-9]{0,1}|[1]{1}([0-1]{1}[0-9]{1}|[2]{1}[0-7]{1})))$",
        "MatchingText": "-128|||127|||0|||1|||-10",
        "NonMatchingText": "-129|||128|||-0|||+0",
        "Description": "Not just a number, a byte type. Will match any number from range -128 to 127."
    },
    {
        "Pattern": "^(0|[-]{1}([1-9]{1}[0-9]{0,3}|[1-2]{1}[0-9]{1,4}|[3]{1}([0-1]{1}[0-9]{3}|[2]{1}([0-6]{1}[0-9]{2}|[7]{1}([0-5]{1}[0-9]{1}|([6]{1}[0-8]{1})))))|(\\+)?([1-9]{1}[0-9]{0,3}|[1-2]{1}[0-9]{1,4}|[3]{1}([0-1]{1}[0-9]{3}|[2]{1}([0-6]{1}[0-9]{2}|[7]{1}([0-5]{1}[0-9]{1}|([6]{1}[0-7]{1}))))))$",
        "MatchingText": "-32768|||-10|||0|||10|||32767",
        "NonMatchingText": "+0|||-0|||-32769|||32768",
        "Description": "Short type, will match a short number from range -32768 to 32767."
    },
    {
        "Pattern": "(0|[1-9]{1}[0-9]{0,8}|[1]{1}[0-9]{1,9}|[-]{1}[2]{1}([0]{1}[0-9]{8}|[1]{1}([0-3]{1}[0-9]{7}|[4]{1}([0-6]{1}[0-9]{6}|[7]{1}([0-3]{1}[0-9]{5}|[4]{1}([0-7]{1}[0-9]{4}|[8]{1}([0-2]{1}[0-9]{3}|[3]{1}([0-5]{1}[0-9]{2}|[6]{1}([0-3]{1}[0-9]{1}|[4]{1}[0-8]{1}))))))))|(\\+)?[2]{1}([0]{1}[0-9]{8}|[1]{1}([0-3]{1}[0-9]{7}|[4]{1}([0-6]{1}[0-9]{6}|[7]{1}([0-3]{1}[0-9]{5}|[4]{1}([0-7]{1}[0-9]{4}|[8]{1}([0-2]{1}[0-9]{3}|[3]{1}([0-5]{1}[0-9]{2}|[6]{1}([0-3]{1}[0-9]{1}|[4]{1}[0-7]{1})))))))))",
        "MatchingText": "-2147483648|||-100|||0|||100|||2147483647",
        "NonMatchingText": "-2147483649|||-0|||+0|||2147483648",
        "Description": "Will match any integer from range -2147483648 to 2147483647."
    },
    {
        "Pattern": "^\\\\\\\\[\\w-]+\\\\(([\\w()-][\\w\\s()-]*[\\w()-]+)|([\\w()-]+))\\$?(\\\\(([\\w()-][\\w\\s()-]*[\\w()-]+)|([\\w()-]+)))*\\\\?$",
        "MatchingText": "\\\\server\\my share\\my subdir|||\\\\server\\my share$\\|||\\\\server\\my share\\subdir1\\subdir2\\",
        "NonMatchingText": "c:\\subdir|||\\\\my server\\share$|||\\\\myserver\\share\\subdir\\file.ext",
        "Description": "Validation of a directory (not file) in UNC format\n\nChecks for \\\\server\\share\\subdir, where subdirs are optional.\nShare may have a $, but only at the end.\nShares and subdir may have embedded spaces.\nString may optionally have a trailing slash."
    },
    {
        "Pattern": "(?P<scheme>[a-zA-Z][a-zA-Z0-9\\+\\-\\.]*):(?://(?:(?P<username>(?:[a-zA-Z0-9_~!&',;=\\.\\-\\$\\(\\)\\*\\+]|(?:%[0-9a-fA-F]{2}))+):?(?:[a-zA-Z0-9_~!&',;=\\.\\-\\$\\(\\)\\*\\+]|(?:%[0-9a-fA-F]{2}))*@)?(?P<host>(?:[a-zA-Z0-9_~!&',;=\\.\\-\\$\\(\\)\\*\\+]|(?:%[0-9a-fA-F]{2}))*)(?::(?P<port>[0-9]*))?(?P<path>(?:/(?:[a-zA-Z0-9_~!&',;=:@\\.\\-\\$\\(\\)\\*\\+]|(?:%[0-9a-fA-F]{2}))*)*)|(?P<path>/(?:(?:[a-zA-Z0-9_~!&',;=:@\\.\\-\\$\\(\\)\\*\\+]|(?:%[0-9a-fA-F]{2}))+(?:/(?:[a-zA-Z0-9_~!&',;=:@\\.\\-\\$\\(\\)\\*\\+]|(?:%[0-9a-fA-F]{2}))*)*)?)|(?P<path>(?:[a-zA-Z0-9_~!&',;=:@\\.\\-\\$\\(\\)\\*\\+]|(?:%[0-9a-fA-F]{2}))+(?:/(?:[a-zA-Z0-9_~!&',;=:@\\.\\-\\$\\(\\)\\*\\+]|(?:%[0-9a-fA-F]{2}))*)*))?(?:\\?(?P<query>(?:[a-zA-Z0-9_~!&',;=:@/?\\.\\-\\$\\(\\)\\*\\+]|(?:%[0-9a-fA-F]{2}))*))?(?:\\#(?P<fragment>(?:[a-zA-Z0-9_~!&',;=:@/?\\.\\-\\$\\(\\)\\*\\+]|(?:%[0-9a-fA-F]{2}))*))?",
        "MatchingText": "http://www.google.com  telnet://172.16.1.1:80  ftp://ftp.rfc-editor.org/in-notes/rfc3986.txt  https://testapp/application?kjj98734087234897  ftp://username@testapp/pub/upload  http://testapp/function.asp#appload",
        "NonMatchingText": "www.google.com http://www.google.com:www/",
        "Description": "Generic RFC3986 compliant hierarchical URI.  Does not support IPv6 literal strings as hosts.  Does not validate a host address against any registry types.  Does not validate a URI structure against scheme constraints.  Provides named groups for scheme(protocol), username, host, port, path, query, and fragment."
    },
    {
        "Pattern": "^[^_][a-zA-Z0-9_]+[^_]@{1}[a-z]+[.]{1}(([a-z]{2,3})|([a-z]{2,3}[.]{1}[a-z]{2,3}))$",
        "MatchingText": "xy_z@asg.com,xy_z@123g.co.in",
        "NonMatchingText": "xy.z@abc.com,x.y.z@abc.com",
        "Description": "this pattern validates email address. it allows (1)numeric characters and underscore(_) in an address.(2)numeric characters in domain name. it doesn't match user names with a dot(.). doesn;t allow username starting or ending with @ underscore. they can be used in between"
    },
    {
        "Pattern": "^[^_.]([a-zA-Z0-9_]*[.]?[a-zA-Z0-9_]+[^_]){2}@{1}[a-z0-9]+[.]{1}(([a-z]{2,3})|([a-z]{2,3}[.]{1}[a-z]{2,3}))$",
        "MatchingText": "vj.joe.hi@gmail.com and previous ones",
        "NonMatchingText": ".abc@xyz.com,_abc@xyz.com,ab.cd.ef.gh@xmail.com",
        "Description": "Email-it is an extension to my previous expression for Validating email address.it has the following additional features: 1-username cant begin with a periods(.) and underscore(_) 2-maximum 2 periods(.) can be used in a username(previous xprsn didn't allowed any)(remember gmail which allows periods)"
    },
    {
        "Pattern": "^([A-Z]+[a-zA-Z]*)(\\s|\\-)?([A-Z]+[a-zA-Z]*)?(\\s|\\-)?([A-Z]+[a-zA-Z]*)?$",
        "MatchingText": "Rana Mohsin Ali",
        "NonMatchingText": "rana Mohsin Ali",
        "Description": "That is just an improved expression for handling capitalized names. Improvement #1 - Allowed using names consisting of 3 parts. Improvement #2 - Introduced restriction that the name must start from capital character."
    },
    {
        "Pattern": "^\\{?[a-fA-F\\d]{8}-([a-fA-F\\d]{4}-){3}[a-fA-F\\d]{12}\\}?$",
        "MatchingText": "{e02ff0e4-00ad-090A-c030-0d00a0008ba0}|||e02ff0e4-00ad-090A-c030-0d00a0008ba0",
        "NonMatchingText": "0xe02ff0e400ad090Ac0300d00a0008ba0",
        "Description": "Validates a GUID with and without brackets. 8,4,4,4,12 hex characters seperated by dashes."
    },
    {
        "Pattern": "<[a-zA-Z][^>]*\\son\\w+=(\\w+|'[^']*'|\"[^\"]*\")[^>]*>",
        "MatchingText": "<IMG onmouseover=\"window.close()\">",
        "NonMatchingText": "<IMG src=\"star.gif\">",
        "Description": "Find HTML tags that have javascript events attached to them."
    },
    {
        "Pattern": "\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*([,;]\\s*\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*)*",
        "MatchingText": "lewis@moten.com|||lewis@moten.com, me@lewismoten.com|||lewis@moten.com;me@lewismoten.com",
        "NonMatchingText": "lewis@@moten.com",
        "Description": "Validates 1 or more email addresses.  Email addresses can be delimited with either comma or semicolon.  White space is allowed after delimiter, but not necessary.  I needed this to allow my users to specify multiple email addresses if they choose to do so."
    },
    {
        "Pattern": "^[-\\w`~!@#$%^&amp;*\\(\\)+={}|\\[\\]\\\\:&quot;;'&lt;&gt;?,.\\/ ]*$",
        "MatchingText": "My@Password!!|||Lewis Moten",
        "NonMatchingText": "&#176;&#177;&#178;\u00A6\u00A6",
        "Description": "Make sure string only contains characters that appear on keyboard.  Extended characters (such as those with ascii values above 127), will not pass the test."
    },
    {
        "Pattern": "^[A-Z].*$",
        "MatchingText": "Lewis|||Edward|||Moten",
        "NonMatchingText": "lewis|||1moten|||@home",
        "Description": "Test string to verify it begins with an upper-case letter."
    },
    {
        "Pattern": "[a-zA-Z]+\\-?[a-zA-Z]+",
        "MatchingText": "smith/smith-wesson",
        "NonMatchingText": "smith123",
        "Description": "This will test a last name field and allow hyphen is someone uses it."
    },
    {
        "Pattern": "style=\"[^\"]*\"|'[^']*'",
        "MatchingText": "style=\"width: 10px;border:0\" , style='width: 10px;border:0'",
        "NonMatchingText": "style = \"width:10px\"",
        "Description": "Get the style attribute inner text contained inside \" or ' caracters with the \"style=\" prefix."
    },
    {
        "Pattern": "^(([01][0-9]|[012][0-3]):([0-5][0-9]))*$",
        "MatchingText": "01:00 , 23:59",
        "NonMatchingText": "2:00, 2:2, 02-30",
        "Description": "The Regular Expression to  validate time format in [24:00] hrs.  \n>> Pemitted values from 00:00 to 23:59\n>> Prefix zero for single digit hours 01:00 to 09:59\n\n>> Tested & Certified by Mr. Shripad Pramod Bhende :-)"
    },
    {
        "Pattern": "(([1-9]|[0][1-9])|1[012])[- /.](([1-9]|[0][1-9])|[12][0-9]|3[01])[- /.](19|20)\\d\\d",
        "MatchingText": "1/1/2008, 01/01/2008, 01/1/2008, 1/01/2008, 1-01-2008",
        "NonMatchingText": "31/12/2009",
        "Description": "Regular Expression to validate date in MM/DD/YYYY format.\n>> Permitted formats \"1/1/2008\u201D or \u201C01/01/2008\u201D or \u201C01/1/2008\u201D or 1/01/2008\u201D"
    },
    {
        "Pattern": "^.*lager(?:(~n\").)*$",
        "MatchingText": "lager:info(\"bla bla ~p\",[BlaBla]),|||lager:debug(\"error - eof reached\"),|||lager:error(\"We ignore the ~n in the middle of the string\"),",
        "NonMatchingText": "lager:info(\"bla bla ~p~n\",[BlaBla]),|||lager:debug(\"\")~n\",|||lager:error(\"~n\"),",
        "Description": "This is a regex I made to ifnd all the lines of erlang code that use lager to log information, and that might be missing the line return at the end."
    },
    {
        "Pattern": "\\[(?P<name>[^\\]]*)\\](?P<value>[^\\[]*)",
        "MatchingText": "[a]b[c]d",
        "NonMatchingText": "N/A",
        "Description": "Matches name/value pairs. In the example below, the 'name' of 'a' will have the 'value' of 'b'.  'c' will have the value 'd'."
    },
    {
        "Pattern": "^((((19|20)(([02468][048])|([13579][26])).02.29))|((20[0-9][0-9])|(19[0-9][0-9])).((((0[1-9])|(1[0-2])).((0[1-9])|(1[0-9])|(2[0-8])))|((((0[13578])|(1[02])).31)|(((0[1,3-9])|(1[0-2])).(29|30)))))$",
        "MatchingText": "2000.02.29 | 1976.11.10 | 1988-02-29",
        "NonMatchingText": "2001.02.29 | 1980.04.31 | 1977-05-32",
        "Description": "Validates yyyy.MM.dd and yyyy-MM-dd format date,and also verifying leap years. "
    },
    {
        "Pattern": "jar:file:/(([A-Z]:)?/([A-Z 0-9 * ( ) + \\- & $ # @ _ . ! ~ /])+)(/[A-Z 0-9 _ ( ) \\[ \\] - = + _ ~]+\\.jar!)",
        "MatchingText": "jar:file:/C:/installation/path/jarfile.jar!/com/regexlib/example",
        "NonMatchingText": "Any text not using internal jar file url",
        "Description": "In java using this.getClass().getResource(\"\"); will result in a jar:file:/ etc url ending with yourjarfile.jar!/internal/package/path/ this regular expression matches the directory before the internal jar path declaration returning the physical directory the file resides in. should work in both posix and windows machines (untested for posix*)"
    },
    {
        "Pattern": "(jar:)?file:/(([A-Z]:)?/([A-Z0-9\\*\\()\\+\\-\\&$#@_.!~\\[\\]/])+)((/[A-Z0-9_()\\[\\]\\-=\\+_~]+\\.jar!)|([^!])(/com/regexlib/example/))",
        "MatchingText": "jar:file:/C:/installation/dir/program.jar!/com/regexlib/example/ || file:/install/dir/development/workspace/com/regexlib/example/",
        "NonMatchingText": "Does not match non-java url || http:/www.regexlib.com/applet.jar!/com/regexlib/example/",
        "Description": "More advanced regular expression to get the full path to the directory from which your program is running. You may use this to detect the program installation dir whether you are just debugging or having a deployed program. Using the second group combined with the 7th group you'll have a full path to your program. Very useful if you use resources outside of the java package."
    },
    {
        "Pattern": "^[A-PR-UWYZ]([0-9]([A-HJKSTUW]|[0-9])?|[A-HK-Y][0-9]([ABEHMNPRVWXY]|[0-9])) [0-9][ABD-HJLNP-UW-Z]{2}|GIR 0AA$",
        "MatchingText": "A4 7BD|||C45 9NZ|||AB90 5FG|||GIR 0AA",
        "NonMatchingText": "A47BD|||34 6GJ|||AN5P 3XY",
        "Description": "Validates all UK Postcodes based on format given at cabinetoffice.uk.gov. Must be in uppercase before validation."
    },
    {
        "Pattern": "((a|p|A|P)(m|M)\\s{0,1}(0[0-9]|1[0-2]|[0-9]):[0-5][0-9]:[0-5][0-9])|((a|p|A|P)(m|M)\\s{0,1}(0[0-9]|1[0-2]|[0-9]):[0-5][0-9])|((0[0-9]|1[0-2]|[0-9]):[0-5][0-9]\\s{0,1}(a|p|A|P)(m|M))|((0[0-9]|1[0-2]|[0-9]):[0-5][0-9]:[0-5][0-9]\\s{0,1}(a|p|A|P)(m|M))|((0[0-9]|1[0-9]|2[0-3]|[0-9]):[0-5][0-9]:[0-5][0-9])|((0[0-9]|1[0-9]|2[0-3]|[0-9]):[0-5][0-9])",
        "MatchingText": " 0:26:12 aM|||00:26:12 Pm |||0:26:12aM||| 00:26:12Pm|||Am 0:26:12|||pM 00:26:12||| Am0:26:12|||pM00:26:12||| 0:26 PM||| 01:26 am||| 0:26PM||| 01:26am|||Am 0:26|||pM 00:26|||Am0:26|||pM00:26||| 23:26:12||| 00:26:12||| 0:26:12||| 23:26||| 0:26",
        "NonMatchingText": "n/a",
        "Description": "Matches all types of time declaration with ':' separator."
    },
    {
        "Pattern": "^([1-9]+\\d{0,2},(\\d{3},)*\\d{3}(\\.\\d{1,2})?|[1-9]+\\d*(\\.\\d{1,2})?)$",
        "MatchingText": "1200||1,200||1,200.0||12,324,532.23",
        "NonMatchingText": "-43||0||01,423,534.23||24.4223||32,42,123",
        "Description": "Accepts non-negative numbers with max two decimals. Commas can be added after every thousand."
    },
    {
        "Pattern": "/(2|3)[0-9][0-9][0-1][0-9][0-3][0-9](01|02|03|04|11|12|13|14|15|16|17|18|19|21|22|23|24|25|26|27|28|29|31|32|33|34|35|88)\\d\\d\\d\\d\\d/",
        "MatchingText": "29508030102487",
        "NonMatchingText": "69508030102487",
        "Description": "https://ar.wikipedia.org/wiki/%D8%A8%D8%B7%D8%A7%D9%82%D8%A9_%D8%A7%D9%84%D8%B1%D9%82%D9%85_%D8%A7%D9%84%D9%82%D9%88%D9%85%D9%8A_%D8%A7%D9%84%D9%85%D8%B5%D8%B1%D9%8A%D8%A9\n"
    },
    {
        "Pattern": "(((0[13578]|10|12)([-./])(0[1-9]|[12][0-9]|3[01])([-./])(\\d{4}))|((0[469]|11)([-./])([0][1-9]|[12][0-9]|30)([-./])(\\d{4}))|((2)([-./])(0[1-9]|1[0-9]|2[0-8])([-./])(\\d{4}))|((2)(\\.|-|\\/)(29)([-./])([02468][048]00))|((2)([-./])(29)([-./])([13579][26]00))|((2)([-./])(29)([-./])([0-9][0-9][0][48]))|((2)([-./])(29)([-./])([0-9][0-9][2468][048]))|((2)([-./])(29)([-./])([0-9][0-9][13579][26])))",
        "MatchingText": "02/29/2084|||01/31/2000|||11/30/2000",
        "NonMatchingText": "02/29/2083|||11/31/2000|||01/32/2000",
        "Description": "My meager attempt at a date validator with leap years using a strict mm/dd/yyyy format."
    },
    {
        "Pattern": "^(((\\d{1,3})(,\\d{3})*)|(\\d+))(.\\d+)?$",
        "MatchingText": "9999999|||99999.99999|||99,999,999.9999",
        "NonMatchingText": "9999.|||9,99,99999.999|||999.9999.9999",
        "Description": "validates numbers, with or without decimal places, and comma 1000 separators."
    },
    {
        "Pattern": "[^\\d^\\-^\\,^\\x20]+",
        "MatchingText": "abcABC ! *$%&/()",
        "NonMatchingText": "123456789 ,-",
        "Description": "Just a beginner....here's something I'm using to emulate the Microsoft \"Print\" functionality, where you can enter page numbers to print seperated by commas or specify a range using the \"-\" symbol. The expression checks across a whole string looking for anything that is NOT equal to a number, a minus symbol, a comma and a space character. You can use this expression to do a quick true-false check to see if the user has entered a valid string / page numbers. Later you could then write a routine to sort and / or process the input. Nothing fancy but might help someone. Comments welcome."
    },
    {
        "Pattern": "^(V-|I-)?[0-9]{5}$",
        "MatchingText": "23887, 23001, 20066",
        "NonMatchingText": "1234, 1996, ",
        "Description": "Regular Expression for validate italian CAP (poste code)."
    },
    {
        "Pattern": "^((\\\\){2})(([A-Za-z ',.;]+)(\\\\?)([A-Za-z ',.;]\\\\?)*)$",
        "MatchingText": "\\\\test\\sub1\\ ||| \\\\test\\sub1\\sub2 ||| \\\\test\\sub\\sub1\\sub2",
        "NonMatchingText": "\\test|||\\\\ ||| \\\\test\\\\sub|||  \\\\test\\sub\\\\",
        "Description": "Validates a network path on a shared location."
    },
    {
        "Pattern": "([a-zA-Z]{2}[0-9]{1,2}\\s{0,1}[0-9]{1,2}[a-zA-Z]{2})",
        "MatchingText": "GL50 4ED | GL504ED | gl504ed | gl50 4ed | GL5 4ED | GL5 43ED ",
        "NonMatchingText": "1323 | 3ws23 ",
        "Description": "This is a simple post code regex for UK. It does a wonderfull job."
    },
    {
        "Pattern": "^[A-Fa-f0-9]{32}$|({|\\()?[A-Fa-f0-9]{8}-([A-Fa-f0-9]{4}-){3}[A-Fa-f0-9]{12}(}|\\))?$|^({)?[0xA-Fa-f0-9]{3,10}(, {0,1}[0xA-Fa-f0-9]{3,6}){2}, {0,1}({)([0xA-Fa-f0-9]{3,4}, {0,1}){7}[0xA-Fa-f0-9]{3,4}(}})$",
        "MatchingText": "ca761232ed4211cebacd00aa0057b223|||CA761232-ED42-11CE-BACD-00AA0057B223|||{CA761232-ED42-11CE-BACD-0",
        "NonMatchingText": "{CA761232ED4211CEBACD00AA0057B223}",
        "Description": "Matches GUIDs defined in MSDN library (http://msdn2.microsoft.com/en-us/library/96ff78dc.aspx)"
    },
    {
        "Pattern": "(?:Error|Warning|Exception)",
        "MatchingText": "2009-11-07 08:04:49.401 UTC    Warning    w3wp.24    SoapUtilities.CreateException    ThrowException: actor = http://servername.subdomain.domain.com:8530/SimpleAuthWebService/SimpleAuth.asmx, ID=9ea54fc1-1351-4fb3-a6a3-ba52d5bd4671, ErrorCode=InternalServerError, Message=, Client=?",
        "NonMatchingText": "Any log/text file that does not contain the words in the expression",
        "Description": "Find any and all occurences of any of the three terms \"Error\" \"Warning\" \"Exception\" in a log or txt file.\nUse this as a filter with TextAnalysisTool.NET for quick parsing of log files when looking for errors"
    },
    {
        "Pattern": "^(([+]31|0031)\\s\\(0\\)([0-9]{9})|([+]31|0031)\\s0([0-9]{9})|0([0-9]{9}))$",
        "MatchingText": "+31 0205315386|||0031 (0)205315386|||0205315386",
        "NonMatchingText": "020531538|||1205315386|||020531538677",
        "Description": "Expression to check Dutch phone numbers. Number must start with zero and number of digits should be 10. Different area and country codes are allowed."
    },
    {
        "Pattern": "^(([1-4][0-9])|(0[1-9])|(5[0-2]))\\/[1-2]\\d{3}$",
        "MatchingText": "47/2006",
        "NonMatchingText": "00/3005",
        "Description": "This pattern can be used to validate a numeric week (between 01 and 52) and four digit year (valid years between 1000 and 2999) separated by a slash in the form of WW/YYYY."
    },
    {
        "Pattern": "^(([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5}){1,25})+([;.](([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5}){1,25})+)*$",
        "MatchingText": "te_s-t@ts.co.in;te_s-t@ts.co.in;te_s-t@ts.co.in",
        "NonMatchingText": "nospace@between.mailids.in ; only@semi.colons.com ",
        "Description": "this will accept multiple email ids separated only by semi-colons (anyway u can change it)."
    },
    {
        "Pattern": "^[a-zA-Z]{1}[0-9]{1}[a-zA-Z]{1}(\\-| |){1}[0-9]{1}[a-zA-Z]{1}[0-9]{1}$",
        "MatchingText": "h2j-3c4|||H2J 3C4|||H2J-3c4",
        "NonMatchingText": "H2J_3C4|||H213C4|||123456",
        "Description": "This expression will help match Quebec's postal codes."
    },
    {
        "Pattern": "/^(?:(?:0?[13578]|1[02])|(?:0?[469]|11)(\\/31)|(?:0?2)(?:(\\/3[01]|\\/29\\/(?:(?:0[^48]|[13579][^26]|[2468][^048])00|(?:\\d{2}(?:0[^48]|[13579][^26]|[2468][^048]))))))\\/(?:0?[1-9]|[12][0-9]|3[01])\\/(?:0?19|20)\\d{2}$/",
        "MatchingText": "\t 02/29/2004 | 07/16/2092 | 12/31/1999",
        "NonMatchingText": "\t 14/29/2004 | 07/32/1992 | 12/31/1899",
        "Description": "will match all dates in mm/dd/yyyy format. takes into account leap-years and months without 31 days.,It will only take years starting with 19 and 20"
    },
    {
        "Pattern": "^[a-z0-9!$'*+\\-_]+(\\.[a-z0-9!$'*+\\-_]+)*@([a-z0-9]+(-+[a-z0-9]+)*\\.)+([a-z]{2}|aero|arpa|biz|cat|com|coop|edu|gov|info|int|jobs|mil|mobi|museum|name|net|org|pro|travel)$",
        "MatchingText": "bob@smith.com | bob.j@j.smith.museum | !$'*+-_@a--1.ca",
        "NonMatchingText": ".bob@smith.com | bob..j@smith.com | bob@-smith.com",
        "Description": "Checks email format against RFC 3696 (http://tools.ietf.org/html/rfc3696). Allows all characters described in Sections 2 and 3 of the RFC EXCEPT those described in Section 4.3 as unsafe for mailto URLs without encoding. Allows any 2-letter TLD plus any of the current gTLDs as listed at http://www.icann.org/registries/top-level-domains.htm. Does not accept quoted strings in the local part or IP addresses in lieu of the domain name. Does not enforce length limits. Intended to be used as case-insensitive. Comments are appreciated!"
    },
    {
        "Pattern": "^[a-zA-Z]{4}((\\d{2}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229)(H|M)(AS|BC|BS|CC|CL|CM|CS|CH|DF|DG|GT|GR|HG|JC|MC|MN|MS|NT|NL|OC|PL|QT|QR|SP|SL|SR|TC|TS|TL|VZ|YN|ZS|SM|NE)([a-zA-Z]{3})([a-zA-Z0-9\\s]{1})\\d{1}$+",
        "MatchingText": "LAZM890202MYNNGR09",
        "NonMatchingText": "SM890202MYNNGR09",
        "Description": "I use this one to validate CURP structure. CURP is a mexican unique identifier for certain intitutions like INFONAVIT and it's very useful"
    },
    {
        "Pattern": "([\\r\\n ]*//[^\\r\\n]*)+",
        "MatchingText": "// code comments",
        "NonMatchingText": "Code",
        "Description": "Matches groups of single-line code comments.  Comment sections will be returned as a single match."
    },
    {
        "Pattern": "(@\\s*\".*?\")|(\"([^\"\\\\]|\\\\.)*?\")",
        "MatchingText": "\"text\" \"te\\\"xt\" @\"text\"",
        "NonMatchingText": "text",
        "Description": "Matches C# string literals; verbatin and or normal."
    },
    {
        "Pattern": "\\b(?P<KEYWORD>abstract|event|new|struct|as|explicit|null|switch|base|extern|object|this|bool|false|operator|throw|break|finally|out|true|byte|fixed|override|try|case|float|params|typeof|catch|for|private|uint|char|foreach|protected|ulong|checked|goto|public|unchecked|class|if|readonly|unsafe|const|implicit|ref|ushort|continue|in|return|using|decimal|int|sbyte|virtual|default|interface|sealed|volatile|delegate|internal|short|void|do|is|sizeof|while|double|lock|stackalloc|else|long|static|enum|namespace|string)\\b",
        "MatchingText": "for int using public",
        "NonMatchingText": "forty intty usingty",
        "Description": "matches a C# keyword."
    },
    {
        "Pattern": "\\w*",
        "MatchingText": "gjh23_sdfsd45",
        "NonMatchingText": "fg@#$234TRET",
        "Description": "Small w is used in expression. if you'll use capital W then it is for \"Not Alphanumeric\""
    },
    {
        "Pattern": "([1-9]{1,2})?(d|D)([1-9]{1,3})((\\+|-)([1-9]{1,3}))?",
        "MatchingText": "d12|||2d4|||3D8-2|||99D999+999",
        "NonMatchingText": "0d6|||100d4|||2a4|||3D8*3",
        "Description": "For the geeks out there, you can use this to break down die rolls of multisided dice for things like role playing games.  Includes support for a die multiplier and an end modifier value. Supports a multiplier up to 99, and sides and a modifier of up to 999."
    },
    {
        "Pattern": "^([A-Z][a-z]+)\\s([A-Z][a-zA-Z-]+)$",
        "MatchingText": "John Smith|||Jane Smith-Doe|||John McSmith|||Abc Xyz",
        "NonMatchingText": "john smith|||J Smith|||Mrs. Doe",
        "Description": "The pattern matches what would at least appear to be a first and last name, with an optional hyphenated last name.  There is an obvious flaw that it can't distinguish between actual names and any two words that start with capital letters as noted in the matching text.  Also, two part first names like \"Mary Jo\" can cause problems."
    },
    {
        "Pattern": "https?://(\\S*?domainname\\.tld/)\\S*?/",
        "MatchingText": "http://www.domainname2.tld2/|||http://sub.domainname3.tld3/|||https://secure.domainname4.tld4/|||http://domainname5.tld5/",
        "NonMatchingText": "http://www.domainname.tld/|||http://sub.domainname.tld/|||https://secure.domainname.tld/|||http://domainname.tld/",
        "Description": "This type of filter can be used if you're trying to get rid of results from a report or something not originating from a given domain of the format domainname.tld.  Anything matching the pattern can then be excluded, deleted, etc. (Like with a Google Mini, GSA, or site auditing software)"
    },
    {
        "Pattern": "^\\#?[A-Fa-f0-9]{3}([A-Fa-f0-9]{3})?$",
        "MatchingText": "fff | #990000 | #cc3366 | #AAAAAA",
        "NonMatchingText": "#5555 | #ZJK000 | CDCDCDCD",
        "Description": "Matches valid 3 or 6 character hex codes used for HTML or CSS. "
    },
    {
        "Pattern": "^(97(8|9))?\\d{9}(\\d|X)$",
        "MatchingText": "0672317249|||9780672317248",
        "NonMatchingText": "0-672-31724-9|||5555555555555",
        "Description": "Validates both ISBN 10 and ISBN 13 numbers, and confirms ISBN 13 numbers start with only 978 or 979."
    },
    {
        "Pattern": "([A-Za-z]{0,}[\\.\\,\\s]{0,}[A-Za-z]{1,}[\\.\\s]{1,}[0-9]{1,2}[\\,\\s]{0,}[0-9]{4})| ([0-9]{0,4}[-,\\s]{0,}[A-Za-z]{3,9}[-,\\s]{0,}[0-9]{1,2}[-,\\s]{0,}[A-Za-z]{0,8})| ([0-9]{1,4}[\\/\\.\\-][0-9]{1,4}[\\/\\.\\-][0-9]{1,4})",
        "MatchingText": "11/16/2003|||11-16-2003|||11.16.2003|||11.16.03|||2003-11-16|||Sunday, November 16, 2003|||November 16, 2003|||Nov. 16, 2003|||2003 November 16|||2003Nov16|||2003-Nov-16|||2003-Nov-16, Sunday",
        "NonMatchingText": "Anything",
        "Description": "Will match a variety of different date formats; however, it is not a good example of \"simple\" regex and can really contribute to processing time.  This was made for a very specific purpose and should only be used when no other faster methods are available."
    },
    {
        "Pattern": "([0-9]{1,2}[:][0-9]{1,2}[:]{0,2}[0-9]{0,2}[\\s]{0,}[AMPamp]{0,2})",
        "MatchingText": "12:00 PM|||14:00 AM|||12:13:14|||14:00        AM",
        "NonMatchingText": "Anything",
        "Description": "Made for a very specific purpose.  It's likely pretty slow.  Use at your own risk and don't complain."
    },
    {
        "Pattern": "^([A-Za-z0-9]\\s?)+([,]\\s?([A-Za-z0-9]\\s?)+)*$",
        "MatchingText": "123, 4567, 8901|||abc, defghi, jklmn|||abc123",
        "NonMatchingText": " abc123|||abc123,|||,abc123",
        "Description": "This regular expression can be used to parse a comma delimited string. Leading whitespaces (at the beginning of the entire string) and ending commas are not acceptable. Any combination of letters and numbers with zero or one white space between them are acceptable. Note: To change the delimiter, simply replace the comma in the square brackets to the delimiter of choice."
    },
    {
        "Pattern": "[?&]([^&#=]+)(?:=([^&#]*))?",
        "MatchingText": "http://example.com/?param=value&emptyParam=&undefinedParam#anchor|||https://www.google.com/imghp?hl=en&tab=wi|||http://www.youtube.com/results?search_type=videos&search_query=Regular+Expressions&uni=3",
        "NonMatchingText": "http://example.com/#anchor|||http://www.google.com/|||URL's with no GET parameters",
        "Description": "Matches parameters in an URL's query part. The parameters' name and value will be available as subsrting $1 and $2. $2 will be empty if the value is empty (e.g. \"\u2026&param=&\u2026\") or undefined if there's no equals to sign (e.g. \"\u2026&param&\u2026\")."
    },
    {
        "Pattern": "&amp;(([a-zA-Z0-9#]{1,6};))",
        "MatchingText": "[&amp;]|||[ &amp; ]|||[dasdasd&amp;fsdfsd]",
        "NonMatchingText": "[&amp;quot;]|||[gdfgd&amp;#123;vvf]",
        "Description": "I'am using it in PHP preg_match() to replace in string parts with non-entity ampersand. Made for my RSS."
    },
    {
        "Pattern": "^\\((([2-7][0-9]{2})|(8(0[^0]|[^0]0|1\\d|2[^2]|[^2]2|3[^3]|[^3]3|4[^4]|[^4]4|5[^5]|[^5]5|6[^6]|[^6]6|7[^7]|[^7]7|8[^8]|[^8]8|9\\d){1})|(9(0[^0]|[^0]0|[1-9][1-9])))\\)\\s?[0-9]{3}(-|\\s)?[0-9]{4}$|^(([2-7][0-9]{2})|(8(0[^0]|[^0]0|1\\d|2[^2]|[^2]2|3[^3]|[^3]3|4[^4]|[^4]4|5[^5]|[^5]5|6[^6]|[^6]6|7[^7]|[^7]7|8[^8]|[^8]8|9\\d){1})|(9(0[^0]|[^0]0|[1-9][1-9])))-?[0-9]{3}-?[0-9]{4}$",
        "MatchingText": "814-###-#### - (814) ###-####",
        "NonMatchingText": "800-###-#### - (866)-###-####",
        "Description": "Based on PJ Bijoy's regex for a US phone number, I've added validation that the area code is a valid US Area code (first digit is greater than 2) and that the area code is not a reserved Toll Free Code (800, 822, 833, 844, 855, 866, 877, 888) and not a premium number (900).  It will accept phone patterns of ###-###-#### (3 digits dash 3 digits dash 4 digits), ########## (10 digits), (###)###-#### (3 digits in parens 3 digits dash 4 digits), (###)### #### (3 digits in parens 3 digits space 4 digits), (###) ###-#### (3 digits in parens space 3 digits dash 4 digits), (###) ### #### (3 digits in parens space 3 digits space 4 digits)"
    },
    {
        "Pattern": "preg_match_all(\"/([\\(\\+])?([0-9]{1,3}([\\s])?)?([\\+|\\(|\\-|\\)|\\s])?([0-9]{2,4})([\\-|\\)|\\.|\\s]([\\s])?)?([0-9]{2,4})?([\\.|\\-|\\s])?([0-9]{4,8})/\",$string, $phones); ",
        "MatchingText": "all phone numbers",
        "NonMatchingText": "i couldnt find any",
        "Description": "This expression matches all following Telephone number patterns [US Telephone, Indian Telephone, Canadian Telephone & Fax Numbers]. I tested it and its working fine. and hope this will be helpful to u people. suggestion are welcome ! +91-80-1234567 | +91 80 1234567 | +91 80-1234567 | +91-80 1234567 | +91.80.1234567 | +91.80-1234567 | +91-80.1234567 | (91)80-1234567 | (91)80 1234567 | (91)80.1234567 | +91-80-12345678 | +91 80 12345678 | +91 80-12345678 | +91-80 12345678 | +91.80.12345678 | +91.80-12345678 | +91-80.12345678 | (91)80-12345678 | (91)80 12345678 | (91)80.12345678 | +91-484-1234567 | +91 484 1234567 |  +91 484-1234567 | +91-484 1234567 | +91.484.1234567 | +91.484-1234567 |  +91-484.1234567 | (91)484-1234567 | (91)484 1234567 | (91)484.1234567 | +91-484-12345678 | +91 484 12345678 | +91 484-12345678 | +91-484 12345678 | +91.484.12345678 | +91.484-12345678 | +91-484.12345678 | (91)484-12345678 | (91)484 12345678 | (91)484.12345678 | +123-123-1234 | +123 123 1234 | +123 123-1234 | +123-123 1234 | +123.123.1234 | +123.123-1234 | +123-123.1234 | (123)123-1234 | (123)123 1234 | (123)123.1234 | +123-123-1234 | +123 123 1234 | +123 123-1234 | +123-123 1234 | +123.123.1234 | +123.123-1234 | +123-123.1234 | (123)123-1234 | (123)123 1234 | (123)123.1234 | 123-123-1234 | 123 123 1234 | 123 123-1234 | 123-123 1234 | 123.123.1234 | 123.123-1234 | 123-123.1234 | 123-123-1234 | (001)456-789-1234 | 001-456-789-1234 | 4841801234 | +91.1234567890 | +91-1234567890 | +91 1234567890 | 1-561-555-1212 | 1234567890 | 1234-1234567 | 123-12345678 (05)12341234 | 09886657989  - Phone , Telephone\n\n\"+91 80 2559 4800\" and \"91 (80) 234 65453\""
    },
    {
        "Pattern": "(https:[/][/]|http:[/][/]|www.)[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}(:[a-zA-Z0-9]*)?/?([a-zA-Z0-9\\-\\._\\?\\,\\'/\\\\\\+&amp;%\\$#\\=~])*$",
        "MatchingText": "https://yahoo.com http://www.yahoo.com/ http://www.google.com/search?q=good+url+regex https://ajay.com?query https://google.com http://kdsir.co.in http://qa.re.com/no_session.jsp www.yahoo.co.in",
        "NonMatchingText": "https://yahoo yahoo.com/ kushagra.co.in ht://google.com htp://google.co",
        "Description": "Regular Expression matches any internet URLs. Used with the replace method it comes in very handy."
    },
    {
        "Pattern": "(?P<Nbr>[\\+-]?((\\d*\\,\\d+)|(\\d*\\.\\d+)|\\d+))\\s*(?P<Unit>mm|cm|dm|min|km|s|m|h)",
        "MatchingText": "345,3m, 345.m, 345m, 345,5 m",
        "NonMatchingText": "abc, ABC, 0-9",
        "Description": "Matches decimal numbers (english or german writing) followed by metric or time units (mm, cm, dm, m, km, s, min and h) in labels surrounded by any digit."
    },
    {
        "Pattern": "^(\\(?\\d\\d\\d\\)?)?( |-|\\.)?\\d\\d\\d( |-|\\.)?\\d{4,4}(( |-|\\.)?[ext\\.]+ ?\\d+)?$",
        "MatchingText": "(888) 555-1212|||888.555.1212|||(888) 555.1212 ext. 1212",
        "NonMatchingText": "(800) got-fish|||011+ 78907 2344323",
        "Description": "Basic US phone number matching pattern.  I found this place and used a regex, so figured I'd share."
    },
    {
        "Pattern": "/^([0-9a-zA-Z]+|[a-zA-Z]:(\\\\(\\w[\\w ]*.*))+|\\\\(\\\\(\\w[\\w ]*.*))+)\\.[0-9a-zA-Z]{1,3}$/",
        "MatchingText": "c:\\dir\\dir\\file.ext; c:\\dir\\file.ex; c:\\dir\\file.e; \\\\dir\\file.ext",
        "NonMatchingText": "URL",
        "Description": "Match a path location. This regular expression check the file location and validate a file from one to three character extension description."
    },
    {
        "Pattern": "^([0-9]{3,4})$",
        "MatchingText": "123|||1234",
        "NonMatchingText": "12|||12345",
        "Description": "Allows you to check the length of a number (in this case either 3 or 4 digits).\nI found it useful when validating Credit Card Identification Codes (CVV2/CVC2/CID) which are either 3 or 4 numerical digits."
    },
    {
        "Pattern": "(<meta\\s+)*((name\\s*=\\s*(\"|')(?P<name>[^'(\"|')]*)(\"|')){1}|content\\s*=\\s*(\"|')(?P<content>[^'(\"|')]*)(\"|')|scheme\\s*=\\s*(\"|')(?P<scheme>[^'(\"|')]*)(\"|'))",
        "MatchingText": "<meta name=\"DC.subject\" content=\"metadata\"/>",
        "NonMatchingText": "the other html constructs",
        "Description": "Capture the attributes &quot;content&quot;, &quot;name&quot; and &quot;scheme&quot; used to parse META tags from any XHTML or HTML input. Useful for developers looking for expresions to parse &amp; get Dublin Core single elements from HTML pages."
    },
    {
        "Pattern": "^([EV])?\\d{3,3}(\\.\\d{1,2})?(, *([EV])?\\d{3,3}(\\.\\d{1,2})?)*$",
        "MatchingText": "E123 | E123.45, V456.6 | V456,E987.2,  123.45",
        "NonMatchingText": "E123V456 | E123, x | 12;467.789",
        "Description": "See my sigle ICD9 validator for ICD9 rules.  This does the same, and validates for comma delitter (with optiona space after comma)"
    },
    {
        "Pattern": "^\\d{4,4}[A-Z0-9]$",
        "MatchingText": "0001F | 21082",
        "NonMatchingText": "F0123 | 0001f | 100F",
        "Description": "a CPT code is a 4 digits + a captial letter or number (forming 5 character code).  The CPT code describes a medical procedure"
    },
    {
        "Pattern": "^\\d{4,4}[A-Z0-9](, *\\d{4,4})[A-Z0-9]*$",
        "MatchingText": "99396, 1234T | 12345 | 12345,98765, 99396",
        "NonMatchingText": "1234T, x | 99396, 1234t",
        "Description": "see my regex for explaining basic CPT.  This validates a comma delimited (with possible spaces after comma) string of CPT codes"
    },
    {
        "Pattern": "(\\A|(.*,))VALUE(\\z|([,]?.))",
        "MatchingText": "VALUE,1   1,VALUE,2  VALUE  VALUE,1",
        "NonMatchingText": "1  1,2  ",
        "Description": "use this to see if your VALUE is in a given string that is comma delimited.  Replace VALUE with your own"
    },
    {
        "Pattern": "^[\\w0-9]+( [\\w0-9]+)*$",
        "MatchingText": "Test 000",
        "NonMatchingText": "Punctuation! Or doubled  up, leading or trailing spaces",
        "Description": "Allows \"words\" with alphanumeric characters, including the underscore _ character.  Disallows leading or trailing spaces, also doubled-up spaces within the text.  If you want to disallow the underscore character, you can replace the two occurrences of \\w with a-zA-Z"
    },
    {
        "Pattern": "((?P<strElement>(^[A-Z0-9-;=]*:))(?P<strValue>(.*)))",
        "MatchingText": "BEGIN:|||TEL;WORK;VOICE:|||TEL:",
        "NonMatchingText": "begin:|||TEL;PREF;",
        "Description": "Usesful for importing vcards. Matches vcard elements and values."
    },
    {
        "Pattern": "^([1-zA-Z0-1@.\\s]{1,255})$",
        "MatchingText": "email@email.com|||My Name|||asdf12df",
        "NonMatchingText": "\u2018,\\*&amp;$&lt;&gt;|||1001' string",
        "Description": "A general string validation to insure no malicious code is being passed through user input.  General enough too allow email address, names, address, passwords, so on.  Disallows \u2018,\\*&amp;$&lt;&gt; or other characters that could cause issues.   "
    },
    {
        "Pattern": "(\\(\")([0-9]*)(\\\")",
        "MatchingText": "(\"847\"  (\"123456789\"",
        "NonMatchingText": "\"847\")",
        "Description": "Very basic, but couldn't find it, so from one Regex noob to another... \nNeeded to replace quotes around giant SQL INSERT unique numeric field; that was in quotes... In DW, FYI, I replaced with: ($2  $2 being the second sub exp."
    },
    {
        "Pattern": "(\")([0-9]*)(\",\")([0-9]*)(\"\\))",
        "MatchingText": "\"0\",\"0\")  \"999\",\"999999\")",
        "NonMatchingText": "0,0)",
        "Description": "This was made to change non-decimal prices at the end of a huge SQL Insert... To use to replace in DW (without quotes) use sub expression like: $2,$4)"
    },
    {
        "Pattern": "^\\d{1,2}\\/\\d{2,4}$",
        "MatchingText": "9/02|||09/2002|||09/02",
        "NonMatchingText": "Fall 2002|||Sept 2002",
        "Description": "Accepts 1-2 digits followed by a slash followed by 2-4 digits.  Useful for numeric month/year entry."
    },
    {
        "Pattern": "(^(\\d|,)*\\.?\\d*[1-9]+\\d*$)|(^[1-9]+(\\d|,)*\\.\\d*$)|(^[1-9]+(\\d|,)*\\d*$)",
        "MatchingText": "2,000.00, 2,000, .0020, 100, 100.00",
        "NonMatchingText": "0, 0.00, -100.00, -0, -2000.00",
        "Description": "This expression will match all positive numbers that contain decimals and commas."
    },
    {
        "Pattern": "^((4\\d{3})|(5[1-5]\\d{2}))(-?|\\040?)(\\d{4}(-?|\\040?)){3}|^(3[4,7]\\d{2})(-?|\\040?)\\d{6}(-?|\\040?)\\d{5}",
        "MatchingText": "3711-078176-01234|||4123 5123 6123 7123|||5123412361237123",
        "NonMatchingText": "3711-4123-5123-6112",
        "Description": "Credit card validator for AMEX, VISA, MasterCard only. Allows spaces, dashes, or no separator between digit groups according to the layout (4-6-5 for AMEX, 4-4-4-4 for Visa and Mastercard)"
    },
    {
        "Pattern": "(((?P<numb1>[\\d\\.-]+)([\\s]*?)(?P<oper1>(\\>=|\\<=|=\\>|=\\<|\\<|\\>|=){1})([\\s]*?)){0,1})(?P<varname>(salary|mph|kph|ph){1})((([\\s]*?)(?P<oper2>(\\>=|\\<=|=\\>|=\\<|\\<|\\>|=){1})([\\s]*?)(?P<numb2>[\\d\\.-]+)){0,1})",
        "MatchingText": "30<mph<60 | 3<PH | pH < 3 | 40000<salary<=60000",
        "NonMatchingText": "30<speed<60| ph 3 to 5 | salary over 120000| income>60000",
        "Description": "Extract a variable name and range from text containing expressions like: \"car travelling 30 < mph < 80\"\nor  \"acid solution pH < 3\"\nor \"net income 40000<salary<=60000\"\nor \"executive salary > 120000\".\n\nRecognises comparisons before and or after the variable name.\nTolerates white space between elements.  \nRecognises =, <, <=, =<, >, >=, =< comparison symbols.\n\nLIMITATIONS: * Intended to extract information for a limited number of variable names from text that has not been diligently formatted.  * Numeric value portions of the pattern could be refined.  * Add/change variable names (mph, ph etc) to match your requirements. * When editing varname list put longer names first to avoid confusion between ph and mph (for example mph will be returned as ph if ph is listed first in the pattern)."
    },
    {
        "Pattern": "(<input )(.*?)(>)",
        "MatchingText": "&lt;input attrib1=\"value1\" attrib2=\"value2\" &gt; ",
        "NonMatchingText": "any other tag",
        "Description": "Finds all &lt;input attrib1=\"value1\" attrib2=\"value2\" ... &gt; tags. You can make it end with \"/&gt;\" for xhtml compatibility replacing with the expression \"&lt;input $2 /&gt;\". You can repeat it with other tags like &lt;img /&gt; or &lt;br / &gt;"
    },
    {
        "Pattern": "^(BE)[0-1]{1}[0-9]{9}$|^((BE)|(BE ))[0-1]{1}(\\d{3})([.]{1})(\\d{3})([.]{1})(\\d{3})",
        "MatchingText": "BE 0471.339.727  |  BE0471.339.727  |  BE0471339727 ",
        "NonMatchingText": "BE 0471.3397.27  |  BE 047133972  |  0471339727",
        "Description": "VAT Number BE. Assumes BE followed by 0 or 1 or ' ' the digits will grouped by xxxxxxxxxx or xxxx.xxx.xxx. If you only want VAT numbers starting with 0 then replace [0-1]{1} with [0]"
    },
    {
        "Pattern": "^\\s*(([\\w-]+\\.)+[\\w-]+|([a-zA-Z]{1}|[\\w-]{2,}))@(\\w+\\.)+[A-Za-z]{2,5}$",
        "MatchingText": "afae@erew.com, rfew@fwe.co.in, dqweqw@fwertfwe.museum",
        "NonMatchingText": "werew@rtre.c, efgtre@wtg., .wer@rtre.cn, were..wrfw@wewer.com, eewq.weqw.@ewrew.com, spaces not at the beginning",
        "Description": "Created by me.It works in almost all the normal cases."
    },
    {
        "Pattern": "\"^\\s*((([\\w-]+\\.)+[\\w-]+|([a-zA-Z]{1}|[\\w-]{2,}))@(\\w+\\.)+[A-Za-z]{2,5}[?= ]?[?=,;]?[?= ]?)+?$\"",
        "MatchingText": "Ignore the brackets - (rfew@fwe.cn,afae@erew.com) (rfew@fwe.cn;afae@erew.com) (rfew@fwe.cn afae@erew.com) (rfew@fwe.cn , afae@erew.com) (rfew@fwe.cn ;afae@erew.com)",
        "NonMatchingText": "(.wer@rtre.cn) (gffg d@sdgsdg.com)",
        "Description": "Created by me.Allows for checking 1 mail id or more.If more than 1 it should be separated by a , or ; and or space."
    },
    {
        "Pattern": "^[1-9]+[0-9]*$",
        "MatchingText": "1|||12|||124",
        "NonMatchingText": "-1|||a|||1.0",
        "Description": "Allows only positive integers that are greater then 0. Easily modified for +/- intergers and allowing zero."
    },
    {
        "Pattern": "((((0[1-9]|[12][0-9]|3[01])(0[13578]|10|12)(\\d{2}))|(([0][1-9]|[12][0-9]|30)(0[469]|11)(\\d{2}))|((0[1-9]|1[0-9]|2[0-8])(02)(\\d{2}))|((29)(02)(0(0|4|8)))|((29)(02)([2468][048]))|((29)(02)([13579][26])))[- ]?\\d{4})",
        "MatchingText": "020955-2012 .020955-2012 241283-1234|  290204-1234  010111-1111",
        "NonMatchingText": "459434-1234 123456-1234",
        "Description": "Matches the format from www.cpr.dk and fixed to match 29th February for leap years"
    },
    {
        "Pattern": "^\\$?([0-9]{1,3},([0-9]{3},)*[0-9]{3}|[0-9]+)(.[0-9][0-9])?$",
        "MatchingText": "$3,023,123.34|||9,876,453|||123456.78",
        "NonMatchingText": "4,33,234.34|||$1.234|||abc",
        "Description": "Matches currency input with or without commas."
    },
    {
        "Pattern": "(^[\u00D1A-Z][a-z\u00E1\u00E9\u00ED\u00F3\u00FA\u00F1'\u00D1A-Z]*$)|(^[\u00D1A-Z][a-z\u00E1\u00E9\u00ED\u00F3\u00FA\u00F1'\u00D1A-Z]*[- ]^[\u00D1A-Z][a-z\u00E1\u00E9\u00ED\u00F3\u00FA\u00F1'\u00D1A-Z]*$)",
        "MatchingText": "Mart\u00EDnez-Fort\u00FAn|||O'Connell|||MacDonald|||Pe\u00F1o",
        "NonMatchingText": "garcia|||John F Kennedy|||Bob44",
        "Description": "Validates up to two names. Names must start with uppercase followed by letters (including accented and egne). Separator is assumed to be one hyphen or one space."
    },
    {
        "Pattern": "^(\\$?)((\\d{1,20})|(\\d{1,2}((,?\\d{3}){0,6}))|(\\d{3}((,?\\d{3}){0,5})))$",
        "MatchingText": "$99,999,999,999,999,999,999|||$56,987|||56,123456,456",
        "NonMatchingText": "$77,8,888|||asadf|||67.98",
        "Description": "This expression will allow whole dollar amounts (along with $ and ,) which are 20 digit wide. So the maximum amount will be $99,999,999,999,999,999,999. Note: This regular expression allows skipped commas, but will not allow multiple or commas at the wrong location. This can be used for all languages that have comma before the 3rd, 6th, 9th... digit."
    },
    {
        "Pattern": "^((((((0?[1-9])|([1-2][0-9])|(3[0-1]))-(([jJ][aA][nN])|([mM][aA][rR])|([mM][aA][yY])|([jJ][uU][lL])|([aA][uU][gG])|([oO][cC][tT])|([dD][eE][cC])))|(((0?[1-9])|([1-2][0-9])|(30))-(([aA][pP][rR])|([jJ][uU][nN])|([sS][eE][pP])|([nN][oO][vV])))|(((0?[1-9])|(1[0-9])|(2[0-8]))-([fF][eE][bB])))-(20(([13579][01345789])|([2468][1235679]))))|(((((0?[1-9])|([1-2][0-9])|(3[0-1]))-(([jJ][aA][nN])|([mM][aA][rR])|([mM][aA][yY])|([jJ][uU][lL])|([aA][uU][gG])|([oO][cC][tT])|([dD][eE][cC])))|(((0?[1-9])|([1-2][0-9])|(30))-(([aA][pP][rR])|([jJ][uU][nN])|([sS][eE][pP])|([nN][oO][vV])))|(((0?[1-9])|(1[0-9])|(2[0-9]))-([fF][eE][bB])))-(20(([13579][26])|([2468][048])))))$",
        "MatchingText": "29-fEb-2012, 1-JaN-2013, 31-Dec-2099",
        "NonMatchingText": "29-feb-2013, 35-nov-2078, 25-dec-2100",
        "Description": "This expression can validate dates in the range of years 2010-2099 with accounting for leap year. Format of date dd-mmm-yyyy. \n\nWith a bit of tweaking, the year range can be expanded. Didn't do it myself as requirement was to validate future dates."
    },
    {
        "Pattern": "^\\d{5}(-\\d{4})?$",
        "MatchingText": "48222|||48222-1746",
        "NonMatchingText": "4632|||Blake|||37333-32",
        "Description": "Matches standard 5 digit US Zip Codes, or the US ZIP + 4 Standard."
    },
    {
        "Pattern": "^\\d+?(\\.\\d+)?$",
        "MatchingText": "0  0.1  1 1.0  1000.1 1.111 ",
        "NonMatchingText": ".1 1. -1 ... ",
        "Description": "This expression matches the integer or double. A double is separated by the dot."
    },
    {
        "Pattern": "(?P<pgnGame>\\s*(?:\\[\\s*(?P<tagName>\\w+)\\s*\"(?P<tagValue>[^\"]*)\"\\s*\\]\\s*)+(?:(?P<moveNumber>\\d+)(?P<moveMarker>\\.|\\.{3})\\s*(?P<moveValue>(?:[PNBRQK]?[a-h]?[1-8]?x?[a-h][1-8](?:\\=[PNBRQK])?|O(-?O){1,2})[\\+#]?(\\s*[\\!\\?]+)?)(?:\\s*(?P<moveValue2>(?:[PNBRQK]?[a-h]?[1-8]?x?[a-h][1-8](?:\\=[PNBRQK])?|O(-?O){1,2})[\\+#]?(\\s*[\\!\\?]+)?))?\\s*(?:\\(\\s*(?P<variation>(?:(?P<varMoveNumber>\\d+)(?P<varMoveMarker>\\.|\\.{3})\\s*(?P<varMoveValue>(?:[PNBRQK]?[a-h]?[1-8]?x?[a-h][1-8](?:\\=[PNBRQK])?|O(-?O){1,2})[\\+#]?(\\s*[\\!\\?]+)?)(?:\\s*(?P<varMoveValue2>(?:[PNBRQK]?[a-h]?[1-8]?x?[a-h][1-8](?:\\=[PNBRQK])?|O(-?O){1,2})[\\+#]?(\\s*[\\!\\?]+)?))?\\s*(?:\\((?P<varVariation>.*)\\)\\s*)?(?:\\{(?P<varComment>[^\\}]*?)\\}\\s*)?)*)\\s*\\)\\s*)*(?:\\{(?P<comment>[^\\}]*?)\\}\\s*)?)*(?P<endMarker>1\\-?0|0\\-?1|1/2\\-?1/2|\\*)?\\s*)",
        "MatchingText": "[Event \"30/8/2011 9:10:18 am\"] 1.e4! (1. d4 (1. a3) { in variation comment}  ) {comment}  1...e5 ?! ",
        "NonMatchingText": "xxx",
        "Description": "Parses chess games in PGN notation. It supports variation and curly brace commentaries (just make sure you have commentaries after variations if there are both). It does not support semicolon commentaries, NAGs, % comments or international notation of board pieces. As Regex is not recursive,  parsing must be done on found variations, until there are none left."
    },
    {
        "Pattern": "^0[1-6]{1}(([0-9]{2}){4})|((\\s[0-9]{2}){4})|((-[0-9]{2}){4})$",
        "MatchingText": "01 46 70 89 12|||01-46-70-89-12|||0146708912",
        "NonMatchingText": "01-46708912|||01 46708912|||+33235256677",
        "Description": "Regular Expression that validate phone in France."
    },
    {
        "Pattern": "^(\\d)?(\\d|,)*\\.?\\d{1,2}$",
        "MatchingText": "1,000|||1,200.45|||4,567,567.45|||2450.45",
        "NonMatchingText": "$1,000|||1,200.45343|||2.5.000",
        "Description": "Validates Numeric values with commas and limited decimal places. Can change the value d{1,2} to limit decimal places from 1 to n"
    },
    {
        "Pattern": "^(\\+[0-9]{2,}[0-9]{4,}[0-9]*)(x?[0-9]{1,})?$",
        "MatchingText": "+17034567890|||+17034567890x1234|||+912024553455|||+912024553455x12|||+441237761457",
        "NonMatchingText": "x1234|||+1|||+123|||+x1234|||+12x12|||+1(703)4563245x1234",
        "Description": "This comes from our requirement to have tight clean telephone database column. This expression supports only strict format and none others.It accepts any international country code with optional extension number."
    },
    {
        "Pattern": "^([A-HJ-TP-Z]{1}\\d{4}[A-Z]{3}|[a-z]{1}\\d{4}[a-hj-tp-z]{3})$",
        "MatchingText": "C1406HHA|||A4126AAB|||c1406hha",
        "NonMatchingText": "c1406HHA|||4126|||C1406hha",
        "Description": "Codigos Postales Argentinos (CPA)\nThis expression defines the new zip code format for Argentina."
    },
    {
        "Pattern": "^((750|7[0-4]\\d|[1-6]\\d\\d|[1-9]\\d|[3-9])|((7[0-4]\\d|[1-6]\\d\\d|[1-9]\\d|[3-9])\\.{1}[0,5]{1}){1}|750.0)$",
        "MatchingText": "3.0 | 10.5 | 750.0 | 750",
        "NonMatchingText": "2.0 | 750.5 | 2.5 | 23,5",
        "Description": "Validate a number between 3 and 750 with one decimal that only is 0 or 5. Decimal separator is '.'"
    },
    {
        "Pattern": "^\\\\{2}[-\\w]+\\\\(([^\"*/:?|<>\\\\,;[\\]+=.\\x00-\\x20]|\\.[.\\x20]*[^\"*/:?|<>\\\\,;[\\]+=.\\x00-\\x20])([^\"*/:?|<>\\\\,;[\\]+=\\x00-\\x1F]*[^\"*/:?|<>\\\\,;[\\]+=\\x00-\\x20])?)\\\\([^\"*/:?|<>\\\\.\\x00-\\x20]([^\"*/:?|<>\\\\\\x00-\\x1F]*[^\"*/:?|<>\\\\.\\x00-\\x20])?\\\\)*$",
        "MatchingText": "\\\\Dpk\\T c\\, \\\\be\\projects$\\Wield\\Rff\\",
        "NonMatchingText": "j:ohn\\, \\\\Dpk\\, G:\\GD, \\\\cae\\.. ..\\, d:\\, E:\\reference\\h101\\",
        "Description": "Validates the format of a Windows folder path ending with a backslash using the Universal Naming Convention (UNC)--without using lookaround.<br><br>Windows UNC folder components: <br>(I) The server name can only contain letters, numbers, and hyphens. However, Windows does allow underscores--which aren\u2019t standard characters in the Request for Comments (RFC) 1035 standard--for networks using the Microsoft DNS Server. (Reference: http://support.microsoft.com/default.aspx?scid=kb;en-us;222823) <br>(II) The share name (also called the service name) (1) Can contain any character except ones with an ASCII code in the range of 0 (x00) through 31 (x1F) and the following: \" * / : ? | < > \\ , ; [ ] + = (Reference: http://support.microsoft.com/default.aspx?scid=kb;en-us;236388) (2) Can begin or end with a period, but cannot contain all periods (3) Cannot begin or end with a space (4) There must be at least one character that is not a space or period if the rest of the share name contains periods and spaces or just periods. <br>(III) The folder and subfolder names (without the share and server names) (1) Can contain any character except ones with an ASCII code in the range of 0 (x00) through 31 (x1F) and the following: \" * / : ? | < > \\ (Reference: http://msdn2.microsoft.com/en-us/library/aa365247.aspx) (2) Cannot begin or end with a space or period."
    },
    {
        "Pattern": "^[A-Za-z]:\\\\([^\"*/:?|<>\\\\.\\x00-\\x20]([^\"*/:?|<>\\\\\\x00-\\x1F]*[^\"*/:?|<>\\\\.\\x00-\\x20])?\\\\)*$",
        "MatchingText": "d:\\, E:\\reference\\h101\\",
        "NonMatchingText": "j:ohn\\, \\\\Dpk\\, G:\\GD, \\\\cae\\.. ..\\, \\\\be\\projects$\\Wield\\Rff\\, \\\\Dpk\\T c\\",
        "Description": "Validates the format of a Windows folder path ending with a backslash using the drive path--without using lookaround.<br><br>Windows folder drive path components: <br>(I) The drive can only be one letter. <br>(II) The folder and subfolder names (without the drive) (1) Can contain any character except ones with an ASCII code in the range of 0 (x00) through 31 (x1F) and the following: \" * / : ? | < > \\ (Reference: http://msdn2.microsoft.com/en-us/library/aa365247.aspx) (2) Cannot begin or end with a space or period."
    },
    {
        "Pattern": "^([A-Za-z]:|\\\\{2}([-\\w]+|((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))\\\\(([^\"*/:?|<>\\\\,;[\\]+=.\\x00-\\x20]|\\.[.\\x20]*[^\"*/:?|<>\\\\,;[\\]+=.\\x00-\\x20])([^\"*/:?|<>\\\\,;[\\]+=\\x00-\\x1F]*[^\"*/:?|<>\\\\,;[\\]+=\\x00-\\x20])?))\\\\([^\"*/:?|<>\\\\.\\x00-\\x20]([^\"*/:?|<>\\\\\\x00-\\x1F]*[^\"*/:?|<>\\\\.\\x00-\\x20])?\\\\)*$",
        "MatchingText": "d:\\, \\\\Dpk\\T c\\, E:\\reference\\h101\\, \\\\be\\projects$\\Wield\\Rff\\, \\\\70.60.44.88\\T d\\SPC2\\",
        "NonMatchingText": "j:ohn\\, \\\\Dpk\\, G:\\GD, \\\\cae\\.. ..\\, \\\\70.60.44\\T d\\SPC2\\",
        "Description": "Validates the format of a Windows folder path ending with a backslash using the drive path or Universal Naming Convention (UNC)--without using lookaround.<br><br>Windows folder components: <br>(I) The drive can only be one letter. <br>(II) The server name (1) can only contain letters, numbers, and hyphens. However, Windows does allow underscores--which aren\u2019t standard characters in the Request for Comments (RFC) 1035 standard--for networks using the Microsoft DNS Server. (Reference: http://support.microsoft.com/default.aspx?scid=kb;en-us;222823) or (2) can be an IP address <br>(III) The share name (also called the service name) (1) Can contain any character except ones with an ASCII code in the range of 0 (x00) through 31 (x1F) and the following: \" * / : ? | < > \\ , ; [ ] + = (Reference: http://support.microsoft.com/default.aspx?scid=kb;en-us;236388) (2) Can begin or end with a period, but cannot contain all periods (3) Cannot begin or end with a space (4) There must be at least one character that is not a space or period if the rest of the share name contains periods and spaces or just periods. <br>(IV) The folder and subfolder names (without the drive, share, or server name) (1) Can contain any character except ones with an ASCII code in the range of 0 (x00) through 31 (x1F) and the following: \" * / : ? | < > \\ (Reference: http://msdn2.microsoft.com/en-us/library/aa365247.aspx) (2) Cannot begin or end with a space or period."
    },
    {
        "Pattern": "(^([\\w]+[^\\W])([^\\W]\\.?)([\\w]+[^\\W]$))",
        "MatchingText": "Alex.FirstRegex alex alex.firstregex alex_firstRegex",
        "NonMatchingText": "@alex alex.firstRegex. alex#FirstRegex",
        "Description": "My first REGEX pattern. Matches all alphanumerics + underscore (_) + dot (.)\n"
    },
    {
        "Pattern": "^[/]*([^/\\\\ \\:\\*\\?\"\\<\\>\\|\\.][^/\\\\\\:\\*\\?\\\"\\<\\>\\|]{0,63}/)*[^/\\\\ \\:\\*\\?\"\\<\\>\\|\\.][^/\\\\\\:\\*\\?\\\"\\<\\>\\|]{0,63}$",
        "MatchingText": "path/to/filename.txt||/prefixed.slash/value||/a/single/l/e/t/t/e/r",
        "NonMatchingText": " lead/space||.hidden/folder||wildcards.???",
        "Description": "a simplistic path/filename for windows (more restrictive than for Mac OS or *nix). Updated escaping, end of string."
    },
    {
        "Pattern": "^([a-zA-Z0-9_\\-\\.]+)@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.)|(([a-zA-Z0-9\\-]+\\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\\]?)$",
        "MatchingText": "asmith@mactec.com|||foo12@foo.edu|||bob.smith@foo.tv",
        "NonMatchingText": "joe|||@foo.com|||a@a",
        "Description": "Email validator that adheres directly to the specification for email address naming. It allows for everything from ipaddress and country-code domains, to very rare characters in the username."
    },
    {
        "Pattern": "\\b(?:a(?:[nst]|re|nd)?|b[ey]|f(?:or|rom)|i[nst]?|o[fnr]|t(?:o|hat|he|his)|w(?:as|h(?:at|en|ere|ich|o)|i(?:th|ll)))\\b",
        "MatchingText": "by|||when|||or",
        "NonMatchingText": "bye|||craptastic|||nor",
        "Description": "Removes &quot;stop&quot; or &quot;delete&quot; words that google removes from search strings.  Ordinarily have no search significance. I used this to remove the words in my own web search application.  Take out the ?: for grouping.\n\nI've tested this a bit, yet this is my 1st regex that I've ever written.  It's working fine for me."
    },
    {
        "Pattern": "(?P<commentblock>((?m:^[\\t ]*\\/{2}[^\\n\\r\\v\\f]+[\\n\\r\\v\\f]*){2,})|(\\/\\*[\\w\\W]*?\\*\\/))",
        "MatchingText": "/* Some text (may be any number of lines) */",
        "NonMatchingText": "// Some text (only a single line)|||Some code // comment here (even if next line has comment)|||/* S",
        "Description": "This expression will match comment blocks in javascript, c, c++, etc\n\nI wrote this as a named group called &quot;commentblock&quot;, as I like to use it with other expressions.\n\nIt avoids single line comments or inline commented code (which are not considered comment &quot;blocks&quot;) unless the comments are in a /* text */ comment style\n\ncould not create a multiline example in the matching examples, here is what I tried to enter\n\n  // Some text    \n  //(must be two or more lines long and each line may only be preceded by whitespace)\n\n"
    },
    {
        "Pattern": "^[^\\*]{0,}[\\*]{0,1}[^\\*]{0,}$",
        "MatchingText": "search*|||*search|||se*rch|||search|||*",
        "NonMatchingText": "search**|||**search|||**|||s**rch|||s*a*ch",
        "Description": "An expression to validate a search string which accepts a wildcard(asterik) at most once anywhere in the string."
    },
    {
        "Pattern": "^(([0-9])|([0-1][0-9])|([2][0-3])):(([0-9])|([0-5][0-9]))$",
        "MatchingText": "1:59|||01:59|||23:59",
        "NonMatchingText": "12:63|||25:60|||13.10",
        "Description": "reg. expr. 4 checking 24 time"
    },
    {
        "Pattern": "^(\\$)?(([1-9]\\d{0,2}(\\,\\d{3})*)|([1-9]\\d*)|(0))(\\.\\d{2})?$",
        "MatchingText": "$1,234,567.89|||1234567.89|||$0.00",
        "NonMatchingText": "$1,2345,67.89|||$1234,345,678.0",
        "Description": "Modified Joe Lynwood's to allow zero amounts.  Handles US Dollars including zero dollars.  "
    },
    {
        "Pattern": "^([0-9a-fA-F]{1,2})(\\s[0-9a-fA-F]{1,2})*$",
        "MatchingText": "1b 2e|||1B 70 00 90 F0",
        "NonMatchingText": "gh 4b|||1G 70 00 UU ",
        "Description": "Expression validating a series of hex codes (byte values) separated by spaces."
    },
    {
        "Pattern": "^((\\([2-9]\\d{2}\\)[ ]?)|([2-9]\\d{2})[- ]?)\\d{3}[- ]?\\d{4}$",
        "MatchingText": "(555) 555-5555 | 555-555-5555 | 555 555-5555",
        "NonMatchingText": "(555 555-5555, (555)-555-5555 | 555) 555-5555",
        "Description": "Requires area code, optional parentheses but requires both.  Allows '-' or ' '."
    },
    {
        "Pattern": "^(?P<lat>(-?(90|(\\d|[1-8]\\d)(\\.\\d{1,6}){0,1})))\\,{1}(?P<long>(-?(180|(\\d|\\d\\d|1[0-7]\\d)(\\.\\d{1,6}){0,1})))$",
        "MatchingText": "\"0,0\u201C, \u201E48.05,11.966667, \u201E90,0\u201C, \u201E-90,-180\u201C",
        "NonMatchingText": "\u201E05.12345,0\u201C, \u201E90.1234,1\u201C, \u201E1,-180.1\u201C, \u201E0,1.1234567\u201C",
        "Description": "Allows extraction of values vio name. tested with dotnet 2003."
    },
    {
        "Pattern": "^[a-zA-Z0-9]+([a-zA-Z0-9\\-\\.]+)?\\.(com|org|net|mil|edu|COM|ORG|NET|MIL|EDU)$",
        "MatchingText": "my.domain.com|||regexlib.com|||big-reg.com",
        "NonMatchingText": ".mydomain.com|||regexlib.comm|||-bigreg.com",
        "Description": "Checks domain names.  This is an attempt to deal with some of the issues of the other reg ex in not handling leading periods(.) and hypens(-)."
    },
    {
        "Pattern": "^(\\d)(\\.)(\\d)+\\s(x)\\s(10)(e|E|\\^)(-)?(\\d)+$",
        "MatchingText": "2.99 x 10^33; 3.14159 x 10E5 ",
        "NonMatchingText": "33.2 x  10^7; 0.180 X 10^6.3",
        "Description": "Scientific notation from school as best as we can put it on textboxes/textareas."
    },
    {
        "Pattern": "^([A-Z]{2}|[A-Z]\\d|\\d[A-Z])[1-9](\\d{1,3})?$",
        "MatchingText": "NW1451 9M116 RG8",
        "NonMatchingText": "N1265 BZ003",
        "Description": "Flight numbers have two parts: The first 2 characters denote the airline's two-letter code. This airline code MUST be either letter-letter, number-letter, or letter-number, NEVER number-number. The 3rd digit has to be a numeric digit from 1 to 9 inclusive. After this 3rd digit, we may append any integer from 0 to 999."
    },
    {
        "Pattern": "^[A-Z][a-z]+(tz)?(man|berg)$",
        "MatchingText": "Feldman, Portman, Krentzman, Silberman, Goldberg ",
        "NonMatchingText": "Schumann, Damon, Pittsburgh, Landenberger",
        "Description": "Legend has it that if a last name ends in -man or -berg, the person who has that last name is Jewish. Of course there are Jewish people whose names don't follow the pattern, and there could be those whose last names end in -man or -berg who are not Jewish (or are they and they don't just know it?)."
    },
    {
        "Pattern": "^(Op(.|us))(\\s)[1-9](\\d)*((,)?(\\s)N(o.|um(.|ber))\\s[1-9](\\d)*)?$",
        "MatchingText": "Op. 3 No. 2; Op. 10, No. 6",
        "NonMatchingText": "Opus 4 Num. 5; Opu. 9 Numb. 99",
        "Description": "This is how a composer catalogued his or her musical works in classical music, except for Bach (who used BWV) and Mozart (who used K.). There may have been others. However, most other composers used the format Opus x, Number y. Sometimes, it's just Opus x if it's a big work like a concerto or a symphony."
    },
    {
        "Pattern": "^((\\d){3})(-)?(\\d){2}(-)?(\\d){4}(A|B[1-7]?|M|T|C[1-4]|D)$",
        "MatchingText": "315-77-8771A 002-51-3788B2",
        "NonMatchingText": "215-77-8866 002-18-3399E",
        "Description": "An individual's (soon to be) Medicare number in the USA is a social security number (whether it be the individual's, spouse's, or parent) plus a series of 1 or 2 digit characters at the end."
    },
    {
        "Pattern": "^[A-Z][a-z]+((i)?e(a)?(u)?[r(re)?|x]?)$",
        "MatchingText": "Trudeau, Lemieux, Pelletier, Coderre, Bordeaux, LaFleur, Adieu, Dedonder",
        "NonMatchingText": "Craveiro, Sbardelli, Baciu",
        "Description": "You can tell whether a last name is French or not. How do you teach your programs to recognize French last names? Here's an attempt. We haven't really covered other French names like LaMarre or Fran\u00E7ois yet. Those will be in future French-regonition regular expressions."
    },
    {
        "Pattern": "^[A-Z]{3}(\\d|[A-Z]){8,12}$",
        "MatchingText": "XOF800108019 MRT10829939W WHWXZA130299",
        "NonMatchingText": "XQM100X 129-22-5898 R12345678",
        "Description": "For all of you who have Blue Cross Blue Shield insurance coverage (not Federal, though)- check out your insurance cards! It ALWAYS begins with 3 letters (called the alpha prefix) and a series of alpha-numeric characters ranging from 8 to 12 digits."
    },
    {
        "Pattern": "^R(\\d){8}",
        "MatchingText": "R12345678 R85731119",
        "NonMatchingText": "R0000111 ABC123",
        "Description": "For those who work in the government somewhere who have BCBS coverage, this is your regular expression."
    },
    {
        "Pattern": "^[A-Z][a-z]+(o(i|u)(n|(v)?r(t)?|s|t|x)(e(s)?)?)$",
        "MatchingText": "Fran\u00E7ois, Benoit, LaCroix, Des Moines, Chaudoir, Boire, Betencourt ",
        "NonMatchingText": "Gagnon, Lefebvre, Legendre, Flores",
        "Description": "Part II of French last names. Like part 1, it doesn't cover all French names."
    },
    {
        "Pattern": "^[A-G](b|#)?((m(aj)?|M|aug|dim|sus)([2-7]|9|13)?)?(\\/[A-G](b|#)?)?$",
        "MatchingText": "F#maj7 B Abaug7 C#m6/A#",
        "NonMatchingText": "Amajb B#sus10 Gbm/D#6",
        "Description": "Play guitar or read sheet music for piano/keyboard? You've got to be familiar with chord notations. They've got to have some format that regular expressions can test."
    },
    {
        "Pattern": "~[A-Z][a-z]+(b|ch|d|g|j|k|l|m|n|p|r|s|t|v|z)(ian)$",
        "MatchingText": "Topalian, Minasian, Hagopian, Khachaturian, Marderosian",
        "NonMatchingText": "Mendeleav, Centurion, Miriam",
        "Description": "From experience and what I've been told, last names ending in -ian are most likely of Armenian origin. There could be some other foreign names that pass this pattern. Also, not every Armenian has a last name that ends in -ian. -ian is just common enough to stereotype."
    },
    {
        "Pattern": "^[A-Z][a-z]+((e(m|ng)|str)a)$",
        "MatchingText": "Wiersema, Huizenga, Dykstra, Drolema, Hamstra",
        "NonMatchingText": "Bistro, Hamstring, Anselmi, Manga",
        "Description": "How do you tell whether a last name is of Dutch origin? This pattern captures the -enga's, -stra's, and -ema's. There are also other Dutch names that don't end with these three \"suffixes\" but you know it's Dutch if it ends with either of those three."
    },
    {
        "Pattern": "^[A-Z]{4}[1-8](\\d){2}$",
        "MatchingText": "CPTR451 ENGL101 MATH173",
        "NonMatchingText": "GRMN099 ENGR48 ENG1100",
        "Description": "College course numbers are usually in the format LLLLNNN where L is a letter and N is a numeric digit, where the first digit ranges from 1-8 inclusive. 1-4 is undergrad, and 5-8 is masters and above."
    },
    {
        "Pattern": "^[A-Z][a-z]+((eir|(n|l)h)(a|o))$",
        "MatchingText": "Coelho Cunha Pereira Texeira Carreiro",
        "NonMatchingText": "Ferrero Bandera Singh Bacalao",
        "Description": "I noticed that a last name is Portuguese if it ends in -eira, -eiro, -nha, or -nho. I know there are other Portuguese names that don't end with these, but I haven't yet come across any other foreign last names (besides Portuguese/Brazilian) that end in those 4."
    },
    {
        "Pattern": "^[2-5](2|4|6|8|0)(A(A)?|B|C|D(D(D)?)?|E|F|G|H)$",
        "MatchingText": "32A 36C 46DD",
        "NonMatchingText": "33B 20Q 12AAA",
        "Description": "Yes, bra sizes can also be tested by regular expressions. The numeric digits represent the rib cage circumference, measured under the breast excluding the breast. It MUST be an even number. The letters determine the cup size - AA is the smallest, H (and beyond, which this regular expression does not represent) is the largest. In summary, the cup sizes are determined by the \"full chest circumference\" (which includes the breast) MINUS the rib cage circumference. Smaller differences are closer to A and larger differences are closest to DDD or F"
    },
    {
        "Pattern": "\\b[P|p]?(OST|ost)?\\.?\\s*[O|o|0]?(ffice|FFICE)?\\.?\\s*[B|b][O|o|0]?[X|x]?\\.?\\s+[#]?(\\d+)\\b",
        "MatchingText": "po box 123, p.o.b. #123, box 123",
        "NonMatchingText": "123 box canyon rd",
        "Description": "Modified version of Chris Myers' regexp for po boxes.  This one won't match the word \"box\" in the address. Only matches if there is a number following the po box. Also accepts a # in front of the number and other spelling variations."
    },
    {
        "Pattern": "^[0-9]{6}-(?:[0-9]+){1,3}[0-9A-Za-z]$",
        "MatchingText": "010236-987B, 241200-6667",
        "NonMatchingText": "010236987B, 2412000-6667,241200-A666",
        "Description": "This one is for Finnish social security numbers. I tested it with my own Java Application by checking several real world SSNs"
    },
    {
        "Pattern": "^((0[123456789]|1[0-2])(0[1-3]|1[0-9]|2[0-9]))|((0[13456789]|1[0-2])(30))|((0[13578]|1[02])(31))$",
        "MatchingText": "0229|||0331|||0630|||0902",
        "NonMatchingText": "0230|||0431|||1245|||1299|||0011",
        "Description": "Evaluates a date in the format of MMDD. Will evaluate month day ranges accurately with Feb going up to 29."
    },
    {
        "Pattern": "^(0?2/3)(0?2/29/.{3}[13579])(0?2/29/.{2}[02468][26])(0?2/29/.{2}[13579][048])((0?[469]|11)/31)(0?2/29/[13579][01345789]0{2})(0?2/29/[02468][1235679]0{2})(0?[1-9]|1[012])/(0?[1-9]|[12][0-9]|3[01])/([0-9]{4})$",
        "MatchingText": "1/30/2012|||2/29/2012|||02/29/2400",
        "NonMatchingText": "04/31/2000|||02/29/2100|||2/30/2012",
        "Description": "Validates dates in the format MM/DD/YYYY, M/D/YYYY, or any permutation in between. Takes into account leap year as well as the rule that century marks are leap years only if they are divisible by 400."
    },
    {
        "Pattern": "^213\\.61\\.220\\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])$",
        "MatchingText": "213.61.220.0 213.61.220.196",
        "NonMatchingText": "213.61.220.300 213.61.221.196 45",
        "Description": "finds all addresses in the network starting with \"213.61.220.\" "
    },
    {
        "Pattern": "((0[1-9])|(1[02]))/\\d{2}",
        "MatchingText": "01/00|||12/99",
        "NonMatchingText": "13/00|||12/AS",
        "Description": "Fromat check for MM/YY, checks month is 1-12 and any 2 digit year."
    },
    {
        "Pattern": "((http\\://|https\\://|ftp\\://)|(www.))+(([a-zA-Z0-9\\.-]+\\.[a-zA-Z]{2,4})|([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}))(/[a-zA-Z0-9%:/-_\\?\\.'~]*)?",
        "MatchingText": "www.diskusneforum.sk|||http://diskusneforum.sk|||ftp://23.45.267.189/",
        "NonMatchingText": "diskusneforum.sk|||localhost",
        "Description": "This RE matches the web links which begin http://, ftp://, https:// or www. \nYou can edit this disadvantage easy..."
    },
    {
        "Pattern": "(((file|gopher|news|nntp|telnet|http|ftp|https|ftps|sftp)://)|(www\\.))+(([a-zA-Z0-9\\._-]+\\.[a-zA-Z]{2,6})|([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}))(/[a-zA-Z0-9\\&amp;%_\\./-~-]*)?",
        "MatchingText": "http://diskusneforum.sk|||www.diskusneforum.sk|||ftp://123.123.123.123/",
        "NonMatchingText": "diskusneforum.sk",
        "Description": "You can use this regular expression in your PHP scripts to convert entered URL in text to URL link. Example:\n$text=ereg_replace(&quot;(((file|gopher|news|nntp|telnet|http|ftp|https|ftps|sftp)://)|(www\\.))+(([a-zA-Z0-9\\._-]+\\.[a-zA-Z]{2,6})|([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}))(/[a-zA-Z0-9\\&amp;%_\\./-~-]*)?&quot;,&quot;&lt;a href=\\&quot;./redir.php?url=\\\\0\\&quot; target=\\&quot;_blank\\&quot;&gt;\\\\0&lt;/a&gt;&quot;,$text);"
    },
    {
        "Pattern": "^(([0][1-9]|[1|2][0-9]|[3][0|1])[./-]([0][1-9]|[1][0-2])[./-]([0-9]{4})|(([0][1-9]|[1|2][0-9]|[3][0|1])[./-]([0][1-9]|[1][0-2])[./-]([0-9]{4}))[ ]([0|1][0-2])[:](([0-5][0-9]))([:](([0-5][0-9])))?)$",
        "MatchingText": "01-01-2014 10:50   |||  01/01/2014 10:50:59  |||  11-10-2012",
        "NonMatchingText": "01-01-2014 10:60  ||| 32-01-2014 10:50  |||  01-13-2014 10:50",
        "Description": "this regular expression accepts date and optinal time with format \n(dd)[.-/](MM)[.-/](yyyy)[ ]\n(hh)[:](mm)[:](ss)"
    },
    {
        "Pattern": "(http://|https://)([a-zA-Z0-9]+\\.[a-zA-Z0-9\\-]+|[a-zA-Z0-9\\-]+)\\.[a-zA-Z\\.]{2,6}(/[a-zA-Z0-9\\.\\?=/#%&\\+-]+|/|)",
        "MatchingText": "http://www.url.com, http://www.url.com.au, http://www.url.co.nz, http://www.url123.com, http://www.url-123.com, http://www.url.com/, http://www.url.com/page.html, http://www.url.com/page.asp?id=you123&num=%60&pass=big-long+password#anchor",
        "NonMatchingText": "http://www.url.1com, http://www.url.com.1au",
        "Description": "As always, I couldn't find a regex that worked for me. It only covers full urls with http:// and https://, obviously if you want to add ftp:// then change the first part to: (http://|https://|ftp://) etc..., you get my drift. If you want to cover everything, like short urls, try this site: http://internet.ls-la.net/folklore/url-regexpr.html"
    },
    {
        "Pattern": "^0[23489]{1}(\\-)?[^0\\D]{1}\\d{6}$",
        "MatchingText": "03-6106666|||036106666|||02-5523344",
        "NonMatchingText": "00-6106666|||03-0106666|||02-55812346",
        "Description": "Regular Expression that validate a phone number inside israel.\n"
    },
    {
        "Pattern": "^0(5[012345678]|6[47]){1}(\\-)?[^0\\D]{1}\\d{5}$",
        "MatchingText": "050-346634|||058633633|||064-228226",
        "NonMatchingText": "059-336622|||064-022663|||0545454545",
        "Description": "Regular Expression that validate Cellular phone in israel."
    },
    {
        "Pattern": ".+\\.([^.]+)$",
        "MatchingText": "foo.bar|||more.foo.bar",
        "NonMatchingText": ".|||bar",
        "Description": "Get any file extension..."
    },
    {
        "Pattern": "^(smtp)\\.([\\w\\-]+)\\.[\\w\\-]{2,3}$",
        "MatchingText": "smtp.yahoo.com|||smtp.charter.net",
        "NonMatchingText": "pop.yahoo.com",
        "Description": "Matches basic SMTP server names."
    },
    {
        "Pattern": "^(?:(?:[\\w\\.\\-_]+@[\\w\\d]+(?:\\.[\\w]{2,6})+)[,;]?\\s?)+$",
        "MatchingText": "elvis@mywebsite.com|||elvis@mywebsite.com;me@mywebsite.com|||elvis@mywebsite.com,me@mywebsite.com, elvis.furtado@mywebsite.net|||newyork@sydneyUniv.gov.us,elvis@mywebsite.com;me@mywebsite.com",
        "NonMatchingText": "elvis@@mywebsite.com|||elvis@@mywebsite.c|||elvis @mywebsite.com.in.org",
        "Description": "I am using a repeating section to provide multi email check wherein the separator can  be either a comma or a semi-colon. whitespaces are allowed after a delimiter."
    },
    {
        "Pattern": "^((A[LKSZR])|(C[AOT])|(D[EC])|(F[ML])|(G[AU])|(HI)|(I[DLNA])|(K[SY])|(LA)|(M[EHDAINSOT])|(N[EVHJMYCD])|(MP)|(O[HKR])|(P[WAR])|(RI)|(S[CD])|(T[NX])|(UT)|(V[TIA])|(W[AVIY]))$",
        "MatchingText": "AZ NY ",
        "NonMatchingText": "Ax Arizona",
        "Description": "matches US states and territories in 2 character UPPER case. Reduced from Jason Gaylord's http://regexlib.com/REDetails.aspx?regexp_id=396"
    },
    {
        "Pattern": "^((A[LKZR])|(C[AOT])|(D[EC])|(FL)|(GA)|(HI)|(I[DLNA])|(K[SY])|(LA)|(M[EDAINSOT])|(N[EVHJMYCD])|(O[HKR])|(PA)|(RI)|(S[CD])|(T[NX])|(UT)|(V[TA])|(W[AVIY]))$",
        "MatchingText": "AZ NY ",
        "NonMatchingText": "az Az Arizona",
        "Description": "The 50 US states and DC (Disctrict of Columbia)."
    },
    {
        "Pattern": "^((http://)|(https://))((([a-zA-Z0-9_-]*).?([a-zA-Z0-9_-]*))|(([a-zA-Z0-9_-]*).?([a-zA-Z0-9_-]*).?([a-zA-Z0-9_-]*)))/?([a-zA-Z0-9_/?%=&+#.-~]*)$",
        "MatchingText": "http://sportsalert.net, https://www.sportsalert.net, http://sportsalert.net.uk, http://sportsalert.net/index.html, http://sportsalert.net/subdirectory, http://sportsalert.net?var1=param1&var2=param2",
        "NonMatchingText": "www.sportsalert.net, http://.sportsalert.net, http://sportsalert..net",
        "Description": "A regex I came up with for validating urls, didn't test thoroughly but seems to do the trick."
    },
    {
        "Pattern": "^([a-zA-Z0-9_\\-\\._]+)@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.)|(([a-zA-Z0-9\\-_]+\\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\\]?)$",
        "MatchingText": "MC-O_RAY@iD_SOCORROe-O-VENTO.com.br",
        "NonMatchingText": "MC-O_RAY@iD_SOCORROe-O-VEN TO.",
        "Description": "This RegEx is based on existing one of Andy Smith ( http://regexlib.com/REDetails.aspx?regexp_id=26 ) here but add UNDERLINE and it validates this email \nMC-O_RAY@iD_SOCORROe-O-VENTO.com.br"
    },
    {
        "Pattern": "<([!/]?[ABIU][>\\s])[^>]*>",
        "MatchingText": "<u><b>hello</b></u>",
        "NonMatchingText": "hello",
        "Description": "Used to return all the html tags and closing tags in a section of html. Can be used to replace all the tags with nothing or itterate through them."
    },
    {
        "Pattern": "^(http(s?):\\/\\/)?(www\\.)?youtu(be)?\\.([a-z])+\\/(watch(.*?)(\\?|\\&)v=)?(.*?)(&(.)*)?$",
        "MatchingText": "http://www.youtube.com/watch?v=lK-zaWCp-co&feature=g-all-u&context=G27a8a4aFAAAAAAAAAAA|||http://youtu.be/AXaoi6dz59A|||youtube.com/watch?gl=NL&hl=nl&feature=g-vrec&context=G2584313RVAAAAAAAABA&v=35LqQPKylEA|||https://youtube.com/watch?gl=NL&hl=nl&feature=g-vrec&context=G2584313RVAAAAAAAABA&v=35LqQPKylEA",
        "NonMatchingText": "http://www.mytube.com/watch?v=35LqQPKylEA|||http://www.youtube.com/watch?b=35LqQPKylEA|||www.youtube.com",
        "Description": "also matches youtu.be/video_id,\n\nthe video id is at $9"
    },
    {
        "Pattern": "[\\w\\-_\\+\\(\\)]{0,}[\\.png|\\.PNG]{4}",
        "MatchingText": "my_image.png | my-image.png | DSC00481.PNG",
        "NonMatchingText": "some.image.png | some_image.jpg | some-image.gif",
        "Description": "This expression matches exclusively .png files. Filenames may contain hyphens, underscores, plusses or brackets, and may be both lower and uppercase."
    },
    {
        "Pattern": "(http://)?(www\\.)?(youtube|yimg|youtu)\\.([A-Za-z]{2,4}|[A-Za-z]{2}\\.[A-Za-z]{2})/(watch\\?v=)?[A-Za-z0-9\\-_]{6,12}(&[A-Za-z0-9\\-_]{1,}=[A-Za-z0-9\\-_]{1,})*",
        "MatchingText": "www.youtube.co.uk/watch?v=KUlv7qraZaM | http://www.yimg.com/watch?v=KUlv7qraZaM | http://www.youtube.com/watch?v=apxKFXJ8jSg&feature=relmfu | youtu.be/apxKFXJ8jSg",
        "NonMatchingText": "youtube.com/watch/v=apxKFXJ8jSg",
        "Description": "Matches only valid YouTube links. This includes directly linked videos (yimg) and using YouTube's shortening service (youtu.be). Also supports local domains, like youtube.nl, youtube.de, youtube.co.uk, etc."
    },
    {
        "Pattern": "^[a-zA-Z]{1}[-][0-9]{7}[-][a-zA-Z]{1}$",
        "MatchingText": "A-1234567-Z|||a-1234567-z",
        "NonMatchingText": "2-abcdefg-3",
        "Description": "Spanish NIE Number. Currently ignores case, but seems to work quite nicely."
    },
    {
        "Pattern": "^[0-9+]{5}-[0-9+]{7}-[0-9]{1}$",
        "MatchingText": "12345-1234567-1",
        "NonMatchingText": "1234512345671",
        "Description": "This validation is for Pakistan New CNIC."
    },
    {
        "Pattern": "^(([a-z])+.)+[A-Z]([a-z])+$",
        "MatchingText": "com.test.Test|||com.Test",
        "NonMatchingText": "com.test.test|||com.test.TEst|||Com.test.Test",
        "Description": "This matches Java class names such as &quot;com.test.Test&quot;. It's being used within an XML Schema to validate classname as specified in XML documents."
    },
    {
        "Pattern": "^(http|https|ftp)\\://(((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])|([a-zA-Z0-9_\\-\\.])+\\.(com|net|org|edu|int|mil|gov|arpa|biz|aero|name|coop|info|pro|museum|uk|me))((:[a-zA-Z0-9]*)?/?([a-zA-Z0-9\\-\\._\\?\\,\\'/\\\\\\+&amp;%\\$#\\=~])*)$",
        "MatchingText": "http://www.allkins.com|||http://255.255.255.255|||http://allkins.com/page.asp?action=1",
        "NonMatchingText": "http://test.testing",
        "Description": "First attempt at reg ex - work in progress - can't quite get it to work absolutely correctly so any comments would be great.\n\nMatches everything as it should apart from the last part of the IP, i.e. allows http://255.255.255.999 (which obviously it shouldn't but ran out of inspiration) so any corrections humbly and gratefully accepted.\n\nTLD check is not complete - just added most of the major ones but easy to dd to if you want to.\n\nBTW - you'll need to replace the &amp; with just the ampersand in the reg ex"
    },
    {
        "Pattern": "^.*(yourdomain.com).*$",
        "MatchingText": "yourdomain.com ||| http://www.yourdomain.com ||| http://subdomain.yourdomain.com/pages/manage/?act=4015876&ag=709254588456a",
        "NonMatchingText": "your-domain.com ||| ourdomain.com ||| yourdomain.co",
        "Description": "Matches the TLD of a given domain (replace yourdomain.com with whatever domain you're trying to enforce).\n\nI was writing an web application in which I wanted to to display a special message to visitors if and only if they were referred to my site by one specific site.  However, because the specific site in question was highly dynamic, referring URLs were all over the place in terms of consistency and the only thing I knew I could count on 100% was the TLD (subdomains and file paths acceptable, so long as the TLD matches exactly)."
    },
    {
        "Pattern": "^([a-zA-Z]){4}(AF|AX|AL|DZ|AS|AD|AO|AI|AQ|AG|AR|AM|AW|AU|AZ|BS|BH|BD|BB|BY|BE|BZ|BJ|BM|BT|BO|BA|BW|BV|BR|IO|BN|BG|BF|BI|KH|CM|CA|CV|KY|CF|TD|CL|CN|CX|CC|CO|KM|CG|CD|CK|CR|CI|HR|CU|CY|CZ|DK|DJ|DM|DO|EC|EG|SV|GQ|ER|EE|ET|FK|FO|FJ|FI|FR|GF|PF|TF|GA|GM|GE|DE|GH|GI|GR|GL|GD|GP|GU|GT|GG|GN|GW|GY|HT|HM|VA|HN|HK|HU|IS|IN|ID|IR|IQ|IE|IM|IL|IT|JM|JP|JE|JO|KZ|KE|KI|KP|KR|KW|KG|LA|LV|LB|LS|LR|LY|LI|LT|LU|MO|MK|MG|MW|MY|MV|ML|MT|MH|MQ|MR|MU|YT|MX|FM|MD|MC|MC|MN|ME|MS|MA|MZ|MM|MA|NR|NP|NL|AN|NC|NZ|NI|NE|NG|NU|NF|MP|NO|OM|PK|PW|PS|PA|PG|PY|PE|PH|PN|PL|PT|PR|QA|RE|RO|RU|RW|SH|KN|LC|PM|VC|WS|SM|ST|SA|SN|RS|SC|SL|SG|SK|SI|SB|SO|ZA|GS|ES|LK|SD|SR|SJ|SZ|SE|CH|SY|TW|TJ|TZ|TH|TL|TG|TK|TO|TT|TN|TR|TM|TC|TV|UG|UA|AE|GB|US|UM|UY|UZ|VU|VE|VN|VG|VI|WF|EH|YE|ZM|ZW)([0-9a-zA-Z]){2}([0-9a-zA-Z]{3})$",
        "MatchingText": "DEUTDEFF500, AIBKIE2D, RBOSGB2L, RBOSGB2LXXX",
        "NonMatchingText": "83-00-01, SA03 8000 0000 6080 1016 7519",
        "Description": "Validates 8 or 10 character Bank Idenifier Code (BIC) / SWIFT. Also validates 2-letter country ISO code (5th and 6th characters)."
    },
    {
        "Pattern": "^(Jan(uary)?|Feb(ruary)?|Mar(ch)?|Apr(il)?|May|Jun(e)?|Jul(y)?|Aug(ust)?|Sep(tember)?|Sept|Oct(ober)?|Nov(ember)?|Dec(ember)?)$",
        "MatchingText": "January, April, December",
        "NonMatchingText": "january, janvier, dece, ramadan",
        "Description": "Validates name of months January, Febuary, ..., December. Also accepts short hand forms jan, feb,..., dec. "
    },
    {
        "Pattern": "^((\\+)?(\\d{2}[-]))?(\\d{10}){1}?$",
        "MatchingText": "+91-9822345654,9822345654,+91-80-25746669",
        "NonMatchingText": "+923-9855777897,6463466",
        "Description": "Indian mobile no. with country code as optional\n\nexample:--\nfunction validate() \n{\n\tvar filter1=/^((\\+)?(\\d{2}[-]))?(\\d{10}){1}?$/,filter2=/^((\\+)?(\\d{2}[-])(\\d{2}[-]))?(\\d{8}){1}?$/;\n\tvar mobileNo=$(\"#mobileNo\").val(),temp=0;\n\tif (filter1.test(mobileNo)) {\n\t\t//temp++;\n\t} \n\tif (filter2.test(mobileNo)) {\n\t\ttemp++;\n\t}\n\tif (temp>0) {\n\t\talert(\"Matched with given format!\");\n\t} else {\n\t\talert(\"Not Matched with given format!\");\n\t} \nhere mobileNo is an input filed in my html page.. you can use it as per your need.."
    },
    {
        "Pattern": "^(([1][0-2])|([0]?[1-9]{1}))\\/(([0-2]?\\d{1})|([3][0,1]{1}))\\/(([1]{1}[9]{1}[9]{1}\\d{1})|([2-9]{1}\\d{3}))$",
        "MatchingText": "12/31/2012|||12/0/2012|||2/31/2012",
        "NonMatchingText": "19/28/2012|||0/12/1999|||5/25/1980",
        "Description": "MM/DD/YYYY\nYear from 1990-9999\nThx to: http://regexlib.com/%28X%281%29%29/REDetails.aspx?regexp_id=60"
    },
    {
        "Pattern": "^\\s+|\\s+$",
        "MatchingText": "   kesav    |||   kkk|||kk   ",
        "NonMatchingText": "kesav|||kesav kumar",
        "Description": "This expression is a trim using regular expression.  This expression removes white spaces before and after the given input string"
    },
    {
        "Pattern": "[0][x][0-9a-fA-F]+",
        "MatchingText": "0x0ffe",
        "NonMatchingText": "x0ffe",
        "Description": "Matches hexadecimal values like in c-sourcecode exists."
    },
    {
        "Pattern": "\\d{4}-\\d{4}-\\d{2}|\\d{5}-\\d{3}-\\d{2}|\\d{5}-\\d{4}-\\d{1}|\\d{5}-\\*\\d{3}-\\d{2}",
        "MatchingText": "1234-5678-90 | 12345-678-90 | 12345-6789-0 | 49981-*007-01",
        "NonMatchingText": "1234-56-8-90 | 123-45678-90 | 1-345-6789-0",
        "Description": "http://en.wikipedia.org/wiki/National_Drug_Code"
    },
    {
        "Pattern": "^((([0]?[1-9]|1[0-2])(:|\\.)(00|15|30|45)?( )?(AM|am|aM|Am|PM|pm|pM|Pm))|(([0]?[0-9]|1[0-9]|2[0-3])(:|\\.)(00|15|30|45)?))$",
        "MatchingText": "1:00 PM|||6:45 am|||17:30",
        "NonMatchingText": "4:32 am|||5:30:00 am|||17:01",
        "Description": "This expression will allow a time value with 15 minute increments.  It will not accept seconds.  You can use either US time or Military time format."
    },
    {
        "Pattern": "^[0]|[0-3]\\.(\\d?\\d?)|[4].[0]$",
        "MatchingText": "0, 1.25, 3.5, 4.0",
        "NonMatchingText": "4.2, 3.555, 5.1",
        "Description": "Validates student Grade Point Average (GPA) value (based on U.S. Standard 0 thru 4.0 values)"
    },
    {
        "Pattern": "^(0[1-9]|[12]\\d|3[01])(0[1-9]|1[0-2])([5-9]\\d\\+|\\d\\d-|[01]\\dA)\\d{3}[\\dABCDEFHJKLMNPRSTUVWXY]$",
        "MatchingText": "010593-123A|||010503A123A|||210566-022Y",
        "NonMatchingText": "010593123A|||011403A123A|||011203-123O",
        "Description": "Description\t\nThis is for the Finnish social security numbers (henkil\u00F6tunnus / hetu).  It consists of eleven characters of the form DDMMYYCZZZQ, where DDMMYY is the date of birth, C the century sign (-,+, or A), ZZZ the individual number (even for men and odd for female), and Q the control character or the checksum. It is calculated DDMMYYZZZ mod 31, where the remainder 0,1,2,..,31 is converted from the list 0,1,...A,B,C..Y . The G,I, O and Q are not in the list, they are too similar to numbers 1, 8 and 0 (zero). Note: This regex does not calculate the checksum (mod 31). "
    },
    {
        "Pattern": "^(000000[1-9])$|^(00000[1-9][0-9])$|^(0000[1-9][0-9][0-9])$|^(000[1-9][0-9][0-9][0-9])$|^(00[1-9][0-9][0-9][0-9][0-9])$|^(0[1-9][0-9][0-9][0-9][0-9][0-9])$|^([1-9][0-9][0-9][0-9][0-9][0-9][0-9])$",
        "MatchingText": "0000001 | 1234567  |  0003344",
        "NonMatchingText": "000012  | 12345678  |  123456A",
        "Description": "This will check to see if the string entered is all digits and is seven digits long. It will allow for leading zeros and also not allow for all zeros to be entered."
    },
    {
        "Pattern": "^((0[1-9])|(1[0-2]))\\/((0[1-9])|(1[0-9])|(2[0-9])|(3[0-1]))\\/(\\d{4})$",
        "MatchingText": "12/25/2007|||11/07/1517|||02/25/2727",
        "NonMatchingText": "1/27/1977|||00/01/000|||15/07/2002",
        "Description": "This regular expressions matches dates in the format MM/DD/YYYY where MM can be 01 to 12, DD can be 01 to 31 and YYYY is always 4 digits long. "
    },
    {
        "Pattern": "^(((\\d{4}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|((\\d{2}[02468][048]|\\d{2}[13579][26]))0229)){0,8}$",
        "MatchingText": "20041231|||20040229",
        "NonMatchingText": "20043112|||2003/04/02",
        "Description": "Validates a date expression (or empty value) in CCYYMMDD format, checking a leap year from 00000101 A.D. to 99991231"
    },
    {
        "Pattern": "([a-z\\s.\\-_'])*<\\w+([-+.']\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*\\>",
        "MatchingText": "Alex D'souza<Alex2@yahoo.com>",
        "NonMatchingText": "alex2 D'souza<alex@yahoo.com>",
        "Description": "This will work with name in UPPER case and  LOWER case with or without spaces may include single quotes and email ID within fish marks.Email Id may include numbers too"
    },
    {
        "Pattern": "([a-z\\s.\\-_'])*<\\w+([-+.']\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*\\>|^\\w+([-+.']\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*",
        "MatchingText": "Alex D'soza <Alex@yahoo.com>",
        "NonMatchingText": "A12lex<alex@yahoo.com>",
        "Description": "this pattern has the option of entering email ID with or without name .The name will allow '  and spaces as Alex D'souza"
    },
    {
        "Pattern": "^\\d*$|^\\d+$*[a-zA-Z]*$;^\\d+$|^\\d+$*[a-zA-Z]+$",
        "MatchingText": "234||23444drrrtr",
        "NonMatchingText": "esd",
        "Description": "this will accept any number and any alphabet.\nAlphabets are optional but numbers are compulsory "
    },
    {
        "Pattern": "<script type=\"text/javascript\">\nfunction fin_city() {   city_c=document.frm_naccnt.City.value;   var toreplace=/(st )|(st.)|(St )|(St.)|(ST )|(saint)|(sant)|(siant)|(SANT)|(SIANT)/mg;   city_d=city_c.replace(toreplace,\"Saint \");   document.frm_naccnt.City.value=city_d;   fin_cityb(); } </script>",
        "MatchingText": "\"Saint \" (has 1 space char after word)",
        "NonMatchingText": "st ,st.,St,St.,ST,saint,sant,siant,SANT,SIANT",
        "Description": "Replaces abreviated spellings of the name St, siant, etc, with the proper full name (Saint) expected by many servers. Must NOT insert an 'i' at the end of expression or code may loop and expand spacing."
    },
    {
        "Pattern": "[a-zA-Z0-9]*",
        "MatchingText": "[a-zA-Z0-9]* || [a-zA-Z0-9]* || [a-zA-Z0-9]*",
        "NonMatchingText": "[a-zA-Z0-9]* || [a-zA-Z0-9]* || [a-zA-Z0-9]*",
        "Description": "This will allow user to enter only AlphaNumeric values. you can use as a Regular expression in Asp.net from version 1.1,2.0,3.5\n\neg: Your Textbox can not contain special characters like @ # $ % ^ & * ( )\n"
    },
    {
        "Pattern": "^(([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,6}/(DC=['\\w\\d\\s\\-\\&amp;]+[,]*){2,})|((\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])/(DC=['\\w\\d\\s\\-\\&amp;]+[,]*){2,})|((DC=['\\w\\d\\s\\-\\&amp;]+[,]*){2,})$",
        "MatchingText": "aa.com/dc=ll,dc=ll|||181.168.5.5/dc=cc,dc=ll|||dc=ll,dc=aa",
        "NonMatchingText": "a/dc=aa|||aa.com|||181.168.5.5",
        "Description": "This expression gets a server bound or serverless ldap path without &quot;LDAP://&quot; in front of it."
    },
    {
        "Pattern": "^\\d+(\\.\\d+)?$",
        "MatchingText": "123|||3.14159",
        "NonMatchingText": "abc|||-3.14159|||3.4.2|||.234|||.",
        "Description": "Matches any unsigned floating point number/numeric string."
    },
    {
        "Pattern": "^-?\\d+(\\.\\d+)?$",
        "MatchingText": "123|||3.14159|||-1.2",
        "NonMatchingText": "abc|||3.4.2|||.234|||",
        "Description": "Matches any unsigned or signed floating point number/numeric string."
    },
    {
        "Pattern": "^[\\(]? ([^0-1]){1}([0-9]){2}([-,\\),/,\\.])*([ ])?([^0-1]){1}([0-9]){2}[ ]?[-]?[/]?[\\.]? ([0-9]){4}$",
        "MatchingText": "(713) 555-1212|||713/555/1212|||713.555 1212",
        "NonMatchingText": "07135551212|||7130125551212",
        "Description": "Here is a regular expression I wrote that validates U.S. phone numbers with area codes. You can't have a leading '0' or '1' but you can separate the number blocks with a space, a dot, a slash, or a hyphen. It also prevents a '0' or '1' for the first digit of the prefix. No extension is allowed and it must be 10 digits."
    },
    {
        "Pattern": "^100$|^\\s*(\\d{0,2})((\\.|\\,)(\\d*))?\\s*\\%?\\s*$",
        "MatchingText": "100 1.25 25,8% ",
        "NonMatchingText": "456 -8 7r ,",
        "Description": "Percent regulaar expression. "
    },
    {
        "Pattern": "^[0-9]{1,}(,[0-9]+){0,}$",
        "MatchingText": "1111|||47,26,2,1,1111,12|||25,1245,2122,23232",
        "NonMatchingText": "111,|||1a1,111,1212,23|||11aa,aaa,asas,asa",
        "Description": "It could be use to validate html input form (checkbox, optionbox, selectbox) when you have multiple numeric value under one field name. The validation is that the user have at lease chose one or more!"
    },
    {
        "Pattern": "^(1|2|3)((\\d{2}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229)(\\d{5})$",
        "MatchingText": "175123112345|||279020412345",
        "NonMatchingText": "479020412345|||275043112345",
        "Description": "This pattern matches a Valid Civil ID Number in Kuwait."
    },
    {
        "Pattern": "^[-+]?\\d+([.,]\\d{0,2}){0,1}$",
        "MatchingText": "123.45 -123,45 0,12 1234567,78",
        "NonMatchingText": "1.234 ,43 1,234,567.32 - 123,",
        "Description": "matches a number with maximum 2 digits after seperator. also american sepratar \".\" as german/european seperator \",\" is accepted"
    },
    {
        "Pattern": "^[^<^>]*$",
        "MatchingText": "hello world, &amp;lt;b&amp;gt;Hello World&lt;/b&gt;",
        "NonMatchingText": "<b>Hello World</b>",
        "Description": "I use this one as a simple way to disallow HTML code in form fields.  It simply doesn't allow the use of the &lt; and &gt; characters.  It does, however, allow the entities for these characters (&amp;lt; and &amp;gt;), which will print the characters to the screen appropriately, if needed.  I'm sure there are more complex expressions to block HTML, but none more concise."
    },
    {
        "Pattern": "\\{\\\\\\*\\\\bkmkstart\\s(.*?)\\}",
        "MatchingText": "{\\*\\bkmkstart TagAmountDigits}|||({\\*\\bkmkstart TagAmountText}",
        "NonMatchingText": "{\\*\\bkmkend TagAmountText}",
        "Description": "Applied to a .RTF document, returns all the names of the# bookmarks. Useful to  retrieve# dinamically#   the list of bookmarks from a document. "
    },
    {
        "Pattern": "^([9]{1})+(6|3|2|1{1})+([0-9]{7})$",
        "MatchingText": "965874512 935554789 911234567 924444445",
        "NonMatchingText": "950000000 215555555 986655541",
        "Description": "A regex for cellphone numbers in Portugal, for the three major operators (TMN, Optimus, Vodafone).\n\n2 numbers (91/96/93/92) + 7 others."
    },
    {
        "Pattern": "^([(]?[+]{1}[0-9]{1,3}[)]?[ .\\-]?)?[(]?[0-9]{3}[)]?[ .\\-]?([0-9]{3}[ .\\-]?[0-9]{4}|[a-zA-Z0-9]{7})([ .\\-]?[/]{1}[ .\\-]?[0-9]{2,4})?$",
        "MatchingText": "+000-000-000-0000 | (+000) 000 000 0000 | (+000) (000) 000-0000 | (000) 000-0000 |  +1-800-0000000 | +1-800-RLYCOOL",
        "NonMatchingText": "1-800-0000000 | 1-800-RLYCOOL",
        "Description": "An inefficient number validator. PHP and JavaScript compatible.\n\nDashes [-] can be replaced by \" \" or \".\"\n\nSupport for extention /000"
    },
    {
        "Pattern": "^[\\w\u00E0\u00E8\u00EC\u00F2\u00F9\u00C0\u00C8\u00CC\u00D2\u00D9\u00E1\u00E9\u00ED\u00F3\u00FA\u00FD\u00C1\u00C9\u00CD\u00D3\u00DA\u00DD\u00E2\u00EA\u00EE\u00F4\u00FB\u00C2\u00CA\u00CE\u00D4\u00DB\u00E4\u00EB\u00EF\u00F6\u00FC\u00FF\u00C4\u00CB\u00CF\u00D6\u00DC\u0178\u00E5\u00C5\u00E6\u00C6\u00E3\u00F1\u00F5\u00C3\u00D1\u00D5\u00E7\u00C7\u00F0\u00D0\u00F8\u00D8\u0153\u0161\u0160\u0152\u00DF\u00BF\u00A1]{1}[\\w \u00E0\u00E8\u00EC\u00F2\u00F9\u00C0\u00C8\u00CC\u00D2\u00D9\u00E1\u00E9\u00ED\u00F3\u00FA\u00FD\u00C1\u00C9\u00CD\u00D3\u00DA\u00DD\u00E2\u00EA\u00EE\u00F4\u00FB\u00C2\u00CA\u00CE\u00D4\u00DB\u00E4\u00EB\u00EF\u00F6\u00FC\u00FF\u00C4\u00CB\u00CF\u00D6\u00DC\u0178\u00E5\u00C5\u00E6\u00C6\u00E3\u00F1\u00F5\u00C3\u00D1\u00D5\u00E7\u00C7\u00F0\u00D0\u00F8\u00D8\u0153\u0161\u0160\u0152\u00DF\u00BF\u00A1\\']{4,62}$",
        "MatchingText": "Name | Name's | N\u00E0m\u00E9 | Name Jr",
        "NonMatchingText": "N_ame | Name\"s",
        "Description": "Validate Firstname or Lastname (PHP and JavaScript Compatible).\n\nSupport for Local characters. Max Length 63 characters."
    },
    {
        "Pattern": "^[\\w\u00E0\u00E8\u00EC\u00F2\u00F9\u00C0\u00C8\u00CC\u00D2\u00D9\u00E1\u00E9\u00ED\u00F3\u00FA\u00FD\u00C1\u00C9\u00CD\u00D3\u00DA\u00DD\u00E2\u00EA\u00EE\u00F4\u00FB\u00C2\u00CA\u00CE\u00D4\u00DB\u00E4\u00EB\u00EF\u00F6\u00FC\u00FF\u00C4\u00CB\u00CF\u00D6\u00DC\u0178\u00E5\u00C5\u00E6\u00C6\u00E3\u00F1\u00F5\u00C3\u00D1\u00D5\u00E7\u00C7\u00F0\u00D0\u00F8\u00D8\u0153\u0161\u0160\u0152\u00DF\u00BF\u00A1]{2,24}[_ \\-.]{1}[\\w \u00E0\u00E8\u00EC\u00F2\u00F9\u00C0\u00C8\u00CC\u00D2\u00D9\u00E1\u00E9\u00ED\u00F3\u00FA\u00FD\u00C1\u00C9\u00CD\u00D3\u00DA\u00DD\u00E2\u00EA\u00EE\u00F4\u00FB\u00C2\u00CA\u00CE\u00D4\u00DB\u00E4\u00EB\u00EF\u00F6\u00FC\u00FF\u00C4\u00CB\u00CF\u00D6\u00DC\u0178\u00E5\u00C5\u00E6\u00C6\u00E3\u00F1\u00F5\u00C3\u00D1\u00D5\u00E7\u00C7\u00F0\u00D0\u00F8\u00D8\u0153\u0161\u0160\u0152\u00DF\u00BF\u00A1\\']{1,32}$",
        "MatchingText": "Firstname Lastname | Company | Company's Name | F\u00ECrstn\u00E2m\u00E9_L\u00E0stn\u00E1m\u00E8 | F\u00ECrstn\u00E2m\u00E9.L\u00E0stn\u00E1m\u00E8",
        "NonMatchingText": "_Firstname L_astname | Company\"s Name",
        "Description": "Matches two words or One company name. (PHP and JavaScript compatible).\n\nSupport for local characters.\n"
    },
    {
        "Pattern": "(1 )?\\d{3} \\d{3}-\\d{4}",
        "MatchingText": "1 555 765-1234||555 765-1234",
        "NonMatchingText": "765-1234||123 456 9876",
        "Description": "This expression matches a US phone number with or without the leading 1."
    },
    {
        "Pattern": "^([0]\\d|[1][0-2])\\/([0-2]\\d|[3][0-1])\\/([2][01]|[1][6-9])\\d{2}(\\s([0-1]\\d|[2][0-3])(\\:[0-5]\\d){1,2})?$",
        "MatchingText": "12/30/2002|||01/12/1998 13:30|||01/28/2002 22:35:00",
        "NonMatchingText": "13/30/2002|||01/12/1998 24:30|||01/28/2002 22:35:64",
        "Description": "This is a regular expression to validate a date string in &quot;MM/DD/YYYY&quot; format, a date time string in &quot;MM/DD/YYYY HH:MM&quot; or a date time string in &quot;MM/DD/YYYY HH:MM:SS&quot; format.\nIt can validate date from 1600 to 2199.\n"
    },
    {
        "Pattern": "(^[0]{1}$|^[-]?[1-9]{1}\\d*$)",
        "MatchingText": "0|||123|||-123",
        "NonMatchingText": "001|||-012|||-002",
        "Description": "This is a regular expression I used to validate negative and positive WHOLE numbers, including 0."
    },
    {
        "Pattern": "(^((?P<salutation>[MRD]\\S+)[ ]+)?(?P<first>\\S+)[ ]+((?P<middle>\\S+)[ ]+)??(?P<last>\\S+)([ ]+(?P<suffix>(PHD|MD|RN|JR|II|SR|III)))?)",
        "MatchingText": "DR KENNETH L LEFEBVRE PHD|||KEN LEFEBVRE|||K L LEFEBVRE|||KENNETH LEFEBVRE PHD|||DR KENNETH LEFEBVRE",
        "NonMatchingText": null,
        "Description": "Parses a person's name such as MR KENNETH L LEFEBVRE PHD, allowing for optional salutation, middle name, and suffix.\n\nNOTE: The suffix must be one of a hard-coded list of suffixes."
    },
    {
        "Pattern": "/^[0-9a-fA-F]+$/",
        "MatchingText": "12FFc",
        "NonMatchingText": "12FGFc",
        "Description": "Will match valid Hexadecimal characters in a string. "
    },
    {
        "Pattern": "\\b([0-1]?\\d{1,2}|2[0-4]\\d|25[0-5])(\\.([0-1]?\\d{1,2}|2[0-4]\\d|25[0-5])){3}\\b",
        "MatchingText": "192.168.11.12 | 123.123.123.012 | 0.0.0.1",
        "NonMatchingText": "192.168.11 |  256.10.11.12 | 10.101.1.900 | 192.168.1. 2 | 192.168.10.0001",
        "Description": "Matches any IPv4."
    },
    {
        "Pattern": "^[-+]?\\d+(\\.\\d{2})?$",
        "MatchingText": "+1212.14||-12.13||122.45",
        "NonMatchingText": "1212.4564||-11.5858||12.000",
        "Description": "It accepts only two integer after a decimal point. The number may be in Positive or negative."
    },
    {
        "Pattern": "^[a-zA-Z0-9]+([_.-]?[a-zA-Z0-9]+)?@[a-zA-Z0-9]+([_-]?[a-zA-Z0-9]+)*([.]{1})[a-zA-Z0-9]+([.]?[a-zA-Z0-9]+)*$",
        "MatchingText": "I dnthave any idea",
        "NonMatchingText": "I dnt have any idea ",
        "Description": "Explain the following  regular expressions. Where would they be used? What potential problems do you foresee in using them?"
    },
    {
        "Pattern": "^[^<>&~\\s^%A-Za-z\\\\][^A-Za-z%^\\\\<>]{1,25}$",
        "MatchingText": "Dnt have any idea",
        "NonMatchingText": "Dnt have any idea..need an answer urgently",
        "Description": "Explain the following 2 regular expressions. Where would they be used? What potential problems do you foresee in using them?"
    },
    {
        "Pattern": "^[1-9]{1}[0-9]{3}\\s{0,1}?[a-zA-Z]{2}$",
        "MatchingText": "1234AB|||1234 AB|||1234 ab",
        "NonMatchingText": "0123AB|||123AA",
        "Description": "Used for dutch postalcodes; no leading zero. 4 numbers and 2 letters."
    },
    {
        "Pattern": "(^\\+?1[0-7]\\d(\\.\\d+)?$)|(^\\+?([1-9])?\\d(\\.\\d+)?$)|(^-180$)|(^-1[1-7]\\d(\\.\\d+)?$)|(^-[1-9]\\d(\\.\\d+)?$)|(^\\-\\d(\\.\\d+)?$)",
        "MatchingText": "141.44|||+179.99999|||-180 54",
        "NonMatchingText": "182|||1FS.45|||-999|||.54",
        "Description": "first regex put on site.\nlongitude must>=-180 & <180."
    },
    {
        "Pattern": "^((([1]\\d{2})|(22[0-3])|([1-9]\\d)|(2[01]\\d)|[1-9]).(([1]\\d{2})|(2[0-4]\\d)|(25[0-5])|([1-9]\\d)|\\d).(([1]\\d{2})|(2[0-4]\\d)|(25[0-5])|([1-9]\\d)|\\d).(([1]\\d{2})|(2[0-4]\\d)|(25[0-5])|([1-9]\\d)|\\d))$",
        "MatchingText": "192.168.0.1|||223.255.255.255|||9.0.0.0",
        "NonMatchingText": "0.10.2.52|||255.255.255.255|||127.0.257.1",
        "Description": "match ip \naddress from 1.0.0.0 to 223.255.255.255"
    },
    {
        "Pattern": "(.*\\.([wW][mM][aA])|([mM][pP][3])$)",
        "MatchingText": "thisfile.mp3|||tH@tfile.wma",
        "NonMatchingText": "whatever.exe|||somethingelse.mpa|||thisagain.wm3",
        "Description": "Matches a file name to be either a .wma or .mp3 file. This can be used to check file uploads to make sure they are of a certain type. Substitute letters where appropriate for specific file types. To include more simply add logical 'or' (|) operator and append."
    },
    {
        "Pattern": "([0-9]|[0-9][0-9])\\.\\s",
        "MatchingText": "\u2022\tTest|\u2022Test|\u2022 Test",
        "NonMatchingText": "1.\tTest|2.\tTest|3.\tTest",
        "Description": "Matches dot points e.g. when copying a dot point list from Word into plain text and you want to do a find and replace all."
    },
    {
        "Pattern": "^[-]?P($)(?:(?P<year>\\d+)+Y)?(?:(?P<month>\\d+)+M)?(?:(?P<days>\\d+)+D)?(?:T($)(?:(?P<hours>\\d+)+H)?(?:(?P<minutes>\\d+)+M)? (?:(?P<seconds>\\d+(?:\\.\\d+)?)+S)?)?$",
        "MatchingText": "P1Y2M3DT4H5M6S|||P2M3D|||-PT4H12.2S",
        "NonMatchingText": "1Y2M3DT4H|||P4H5M|||PT2M",
        "Description": "This expression was derived from Mike Cromwell's version, which matches the XSD schema duration built in type as defined by http://www.w3.org/TR/xmlschema-2/#duration.  This version adds named captured groups to assist with extracting the data."
    },
    {
        "Pattern": "(\\s*\\S*){2}(ipsum)(\\S*\\s*){2}",
        "MatchingText": "(\\s*\\S*){<2>}(TEXT)(\\S*\\s*){2} matches \"some TEXT to  ... word TEXT singled \u2026 word TEXT.\" in \"Here is some TEXT to match.  Let's see the word TEXT singled out, sans the words between the word TEXT.\"",
        "NonMatchingText": "n/a",
        "Description": "pass in to your search term, a number and an expression to match.  Replace the 2 and ipsum with those.  Use the \"matches\" array to return all match strings.  Is tolerant of word matches at start and end of string"
    },
    {
        "Pattern": "^(0|([1-9]\\d{0,3}|[1-5]\\d{4}|[6][0-5][0-5]([0-2]\\d|[3][0-5])))$",
        "MatchingText": "0|||1000|||65535",
        "NonMatchingText": "65536|||99999|||0123",
        "Description": "Matches TCP port numbers from 0 to 65535. Other than '0', no leading 0's are accepted."
    },
    {
        "Pattern": "/\\*.+?\\*/",
        "MatchingText": "/* This is a T-SQL comment! */",
        "NonMatchingText": "SELECT * FROM Customers",
        "Description": "Searches for SQL comments within a T-SQL statement..."
    },
    {
        "Pattern": "^([1-9]{1}(([0-9])?){2})+(,[0-9]{1}[0-9]{2})*$",
        "MatchingText": "123,123,123,123|||100,120,000,010,011|||1,123,123,123",
        "NonMatchingText": "012,123,123,123|||12343,1244,4,12|||,123,123,123",
        "Description": "Matchs comma delimited numbers. Easily changed to allow for other delimiters. (Edit &quot;,&quot;)\nDoes not allow a leading 0\nDoes not allow groups of numbers with less than 3 numbers, exculding the first group."
    },
    {
        "Pattern": "^(\\+?\\d{1,2}[ -]?)?(\\(\\+?\\d{2,3}\\)|\\+?\\d{2,3})?[ -]?\\d{3,4}[ -]?\\d{3,4}$",
        "MatchingText": "(+65) 8765 4321|||(+65) 87654321|||(+65) 8765-4321|||(+65)8765 4321|||(+65)87654321|||(+65)8765-4321|||+65 8765 4321|||+65 87654321|||+65 8765-4321|||+658765 4321|||+658765-4321|||+6876543215|||8765 4321|||87654321|||8765-4321|||(408) 765 4321|||(408) 7654321|||(408) 765-4321|||(408)765 4321|||(408)7654321|||(408)765-4321|||+1 (408) 765 4321|||+1 (408) 7654321|||+1 (408) 765-4321|||+1 (408)765 4321|||+1 (408)7654321|||+1 (408)765-4321|||+1 408 765 4321|||+1 4087654321|||+1(408) 765 4321|||+1(408) 7654321|||+1(408) 765-4321|||+1(408)765 4321|||+1(408)7654321|||+1(408)765-4321|||1 (408) 765 4321",
        "NonMatchingText": "(+65 8765-4321|||+65 87 432|||8765  4321|||8765+4321|||(-408) 765 4321|||+1 (1408) 765 4321",
        "Description": "Matches most common varieties of Singapore and US phone numbers, including toll-free numbers. Although untested, it should also match other international phone numbers."
    },
    {
        "Pattern": "[\\+]{0,1}(\\d{10,13}|[\\(][\\+]{0,1}\\d{2,}[\\13)]*\\d{5,13}|\\d{2,6}[\\-]{1}\\d{2,13}[\\-]*\\d{3,13})",
        "MatchingText": "123-12-1233||(02717)230464||+919427237800||+9427237800||02717-230464",
        "NonMatchingText": "23046||123456780123456790000",
        "Description": "This is useful for finding contact numbers, or mobile numbers or phone numbers while crawling websites."
    },
    {
        "Pattern": "<a[\\s]+[^>]*?href[\\s]?=[\\s\\\"\\']*(.*?)[\\\"\\']*.*?>([^<]+|.*?)?<\\/a>",
        "MatchingText": "&lt;a href='http://www.regexlib.com'&gt;Text&lt;/a&gt; ||| &lt;a href=\"...\"&gt;Text&lt;/a&gt; || &lt;a href=http://www.regexlib.com&gt;Text&lt;/a&gt;",
        "NonMatchingText": "all other html tags",
        "Description": "This pattern is a slight modification in pattern submitted by Jacek Sompel. Using this tag one can also match anchor tags not having ' (single quote) or \" (double quote) in href. This is useful for web crawler for crawling all links in a web page."
    },
    {
        "Pattern": "^(([0-1][0-9]|2[0-3])[0-5][0-9]\\-([0-1][0-9]|2[0-3])[0-5][0-9]|[C|c]losed)$",
        "MatchingText": "0700-1530|||1130-2310|||Closed|||closed|||0000-2359",
        "NonMatchingText": "0700|||Not open|||0700-2400|||3159-0761",
        "Description": "This allows for a single line input of open and close times (for a store/office)."
    },
    {
        "Pattern": "^\\{?[a-fA-F\\d]{32}\\}?$",
        "MatchingText": "09f8814c757a00f14efdb70e45f851d1",
        "NonMatchingText": "46345678901234567890aaaabbbbbbzj",
        "Description": "Matches only a 32 character hex string (Eg. MD5). Based off Chris Craft's expression:-)"
    },
    {
        "Pattern": "^\\b(29[0-9]|2[0-9][0-9]|[01]?[0-9][0-9]?)\\\\/(29[0-9]|2[0-9][0-9]|[01]?[0-9][0-9]?)$",
        "MatchingText": "172/58",
        "NonMatchingText": "200/ or 128/369",
        "Description": "Validates blood pressure in the format systolic/diastolic.\nboth systolic or diastolic can be any number between 1 and 299\n"
    },
    {
        "Pattern": "((www|http)(\\W+\\S+[^).,:;?\\]\\} \\r\\n$]+))",
        "MatchingText": "www.bmjpg.com/advice&search=?light+dark",
        "NonMatchingText": "www.bmjpg.com/advice&search=?light+dark?",
        "Description": "A regular expression which allows me to find strings of text floating around in free text that are in fact URLs. I need to tag these as &lt;url&gt;www.bmj.com/advice&lt;/url&gt;. The problem has been allowing special characters in the url, but not mixing them up with genuine punctuation marks at the end of the url in the text-e.g. '.' or '?' or ) or ';' etc)"
    },
    {
        "Pattern": "^(([A-Za-z0-9]+_+)|([A-Za-z0-9]+\\-+)|([A-Za-z0-9]+\\.+)|([A-Za-z0-9]+\\++))*[A-Za-z0-9]+@((\\w+\\-+)|(\\w+\\.))*\\w{1,63}\\.[a-zA-Z]{2,6}$",
        "MatchingText": "g_s+gav@com.com|||gav@gav.com|||jim@jim.c.dc.ca",
        "NonMatchingText": "gs_.gs@com.com|||gav@gav.c|||jim@--c.ca",
        "Description": "It verifies that: - Only letters, numbers and email acceptable symbols (+, _, -, .) are allowed - No two different symbols may follow each other - Cannot begin with a symbol - Ending domain must be at least 2 letters - Supports subdomains - TLD must be between 2 and 6 letters (Ex: .ca, .museum) - Only (-) and (.) symbols are allowed in domain, but not consecutively.\n\nProblems:\nSee comments below"
    },
    {
        "Pattern": "^\\s*([A-Z\\s])([a-z\\s]){1,30}([A-Z\\s])([a-z\\s]){1,30}\\s*$",
        "MatchingText": "First Name | Fi | Fi Na | Fi Name | First nName | ",
        "NonMatchingText": "First NAME | FIRST NAME | FiRsT NaMe | first name | Fi N | First Name Name",
        "Description": "I have come to this site several times through the years and could not ever find an expression that worked for what I wanted. So finally today I reached a point that I created what I needed. The expression is for name validation. The validation allows for the first letter of the first part of the name to be upper case and at least one upper case in the second part of the name. The second part of the name still allows for a lower case letter to start it off. If you add  a way to get rid of the lower case letter on the second part of the name, that would be great. Got tired of playing with it."
    },
    {
        "Pattern": "^(0{0,1}[1-9][0-9]){1}(\\s){0,1}(\\-){0,1}(\\s){0,1}[1-9]{1}([0-9]{3}|[0-9]{4})(\\-){0,1}(\\s){0,1}[0-9]{4}$",
        "MatchingText": "1142511992|||11 42511992|||11-42511992|||11 4251-1992|||11-4251-1992|||011 98989-9090",
        "NonMatchingText": "08 98989-9090|||083 4251.1010|||011 9898-90909",
        "Description": "Validation to Brazilian telephone number (mobile or not), including DDD and allowing \"9o D\u00EDgito\" (on all DDDs). It also accept 2 or 3 digit DDD (11 or 011).\n\n----- Valid to: ----- 11 98989-9090, 11 977777777, 83-8855-8981, 1199999888, 011 42511992, 01142511992, 011-42511992, 011 4251-1992, 011-4251-1992, 011 98989-9090, 011 977777777, 083-8855-8981, 011999998888, 083 4251-1010, 01192222-3333\n\n----- Invalid to: ----- 011 9898-90909, 08 98989-9090, 083 4251.1010"
    },
    {
        "Pattern": "[a-zA-Z][a-zA-Z0-9_\\-\\,\\.]{5,31}",
        "MatchingText": "this.is_a-match",
        "NonMatchingText": "this isn't_a$match",
        "Description": "Validate a Skype name based on the Skype faq: https://support.skype.com/en-us/faq/FA94/What-is-a-Skype-Name"
    },
    {
        "Pattern": "^(\\+){0,1}\\d{1,10}$",
        "MatchingText": "+9251123456        |        +9251123456        |      123456",
        "NonMatchingText": "1234567801       |       -12323242",
        "Description": "It will allow to enter 10 digits phone number. the number can start with + symbol or any number as well."
    },
    {
        "Pattern": "^((\\+92)|(0092))-{0,1}\\d{3}-{0,1}\\d{7}$|^\\d{11}$|^\\d{4}-\\d{7}$",
        "MatchingText": "03231234567        |         0345-1234567        |         +923211234567        |         +92324-1234567        |         +92-3331234567        |         +92-333-1234567        |         00923331234567        |         0092333-1234567        |         0092-3331234567        |         0092-333-1234567",
        "NonMatchingText": "3331234567        |         0333-123-4567        |         92513331234567",
        "Description": "The expression is used to validate all the number which follows the format of pakistani mobile companies cell phone number format.\ni.e. Ufone, Warid, Mobilink, Zong, telenor etc"
    },
    {
        "Pattern": "^[_a-zA-Z0-9-]+(\\.[_a-zA-Z0-9-]+)?@[a-zA-Z0-9-]+(((\\.[0-9]{1,3}){0,3})|((\\.(co|com|net|org|edu|gov|mil|aero|coop|info|museum|name|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|eh|er|es|et|fi|fj|fk|fm|fo|fr|fx|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nt|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|pt|pw|py|qa|re|ro|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|um|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zr|zw)){1,2}))$",
        "MatchingText": "qsdf.dfqsf@14.21.20.10  ||| sfdgfg@fds.co.uk ||| fgsdg.zz@free.fr",
        "NonMatchingText": "sfdgf.sfdg.sdfg@sfdgsfdG.fr ||| dfgs.sdf@fdg.02.01.sdf ||| sqf.bcv@xb.nbb",
        "Description": "This filter is able to filter a full of address. It uses extension definition"
    },
    {
        "Pattern": "(script)|(&lt;)|(&gt;)|(%3c)|(%3e)|(SELECT) |(UPDATE) |(INSERT) |(DELETE)|(GRANT) |(REVOKE)|(UNION)|(&amp;lt;)|(&amp;gt;)",
        "MatchingText": "http://www.domain.com/page.asp?param=&lt;/script&gt;|||https://www.domain.com/page.asp?param=;SELECT",
        "NonMatchingText": "https://www.domain.com/page.asp?param=RealParam",
        "Description": "This Blacklist RegEx is designed to search a user input for any malicious code or SQL injection attempts."
    },
    {
        "Pattern": "(^([0-9]+[.]+[0-9]+)|(0)$)",
        "MatchingText": "1.1|||12.12|||0",
        "NonMatchingText": ".|||.123|||123.",
        "Description": "Wrote this to accept either decimals or zero, but not whole numbers - for a particular project..."
    },
    {
        "Pattern": "^(100(\\.0{0,2}?)?$|([1-9]|[1-9][0-9])(\\.\\d{1,2})?)$",
        "MatchingText": "1 100.00 50.05 ",
        "NonMatchingText": "0 100.01 50.055",
        "Description": "Only positive values in the range 1.00 to 100.00 (2 decimal places maximum) are valid. The decimal precision is optional. The Percent char % is not used."
    },
    {
        "Pattern": "^((([0]?[1-9]|1[0-2])(:|\\.)[0-5][0-9]((:|\\.)[0-5][0-9])?( )?(AM|am|aM|Am|PM|pm|pM|Pm))|(([0]?[0-9]|1[0-9]|2[0-3])(:|\\.)[0-5][0-9]((:|\\.)[0-5][0-9])?))$",
        "MatchingText": "1:01 AM|||23:52:01|||03.24.36 AM",
        "NonMatchingText": "19:31 AM|||9:9 PM|||25:60:61",
        "Description": "Matches times seperated by either : or . will match a 24 hour time, or a 12 hour time with AM or PM specified. Allows 0-59 minutes, and 0-59 seconds. Seconds are not required."
    },
    {
        "Pattern": "(^1300\\d{6}$)|(^1800|1900|1902\\d{6}$)|(^0[2|3|7|8]{1}[0-9]{8}$)|(^13\\d{4}$)|(^04\\d{2,3}\\d{6}$)",
        "MatchingText": "0732105432|||1300333444|||131313",
        "NonMatchingText": "32105432|||13000456",
        "Description": "Australian phone numbers: Matches all known formats incl normal 10-digit landline numbers (valid area code mandatory) 13, 1300, 1800, 1900, 1902 plus mobile 10 and 11-digit formats. Use a Replace function first to remove non-numerics which are probably separators (E.g. newNum = number.replace(/[\\D]/g, &amp;quot;&amp;quot;).  Please contact me if you find any valid Aussie numbers being rejected."
    },
    {
        "Pattern": "(LOC[^']*')(GID[^']*')?(GDS[^']*')?(FTX[^']*'){0,9}(MEA[^']*'){1,9}(DIM[^']*'){0,9}(TMP[^']*')?(RNG[^']*')?(LOC[^']*'){0,9}(RFF[^']*')((EQD[^']*')(EQA[^']*'){0,9}(NAD[^']*')?){0,3}",
        "MatchingText": "fds",
        "NonMatchingText": "gdf",
        "Description": "Match Segments 2 and 3 of BAPLIE file.  May be repeating."
    },
    {
        "Pattern": "^((\\D*[a-z]\\D*[A-Z]\\D*)|(\\D*[A-Z]\\D*[a-z]\\D*)|(\\D*\\W\\D*[a-z])|(\\D*\\W\\D*[A-Z])|(\\D*[a-z]\\D*\\W)|(\\D*[A-Z]\\D*\\W))$",
        "MatchingText": "Sara,sA,%g,&HHJ,G(*,hgh%",
        "NonMatchingText": "Sa2,hjH7,7&h",
        "Description": "Password validation with any two of combinations: [A-Z],[a-z],Punctuation Symbols with minimum user requirement without digits.If digit is added , it wont validate.As per requirement add '.{n,m}' without quotes before the $ sign in the expression."
    },
    {
        "Pattern": "&lt;!\\[CDATA\\[([^\\]]*)\\]\\]&gt;",
        "MatchingText": "&lt;![CDATA[ gobbledy gook ]]&gt;|||&lt;![CDATA[ gobbledy &amp; more gook ]]&gt;",
        "NonMatchingText": "&lt;![CDATA[ gobbledy ] gook ]]&gt;|||&lt;![CDATA[ gobbledy ]] gook ]]&gt;",
        "Description": "for getting cdata from and xml document.\ncdata returns in $1.\nit's not perfect as you can see from the non-matching examples.  improvements needed - but this works for most scenario's.\n"
    },
    {
        "Pattern": "^(19|20)[0-9]{2}-((01|03|05|07|08|10|12)-(0[1-9]|[12][0-9]|3[01]))|(02-(0[1-9]|[12][0-9]))|((04|06|09|11)-(0[1-9]|[12][0-9]|30))$",
        "MatchingText": "2012-12-31 | 1999-01-29 | 1995-06-01",
        "NonMatchingText": "2012-02-30 | 1999-04-31 | 1872-06-01",
        "Description": "Checks for a MySQL valid date  formated as Y-M-D. January, March, May, July, August, Octobe and December are valid with max of 31 days, February is valid with max of 29 days, April, June, September and November are valis with max of 30 days. Valid for years from 1900 to 2099."
    },
    {
        "Pattern": "^((((0?[13578])|(1[02]))[\\-]?((0?[1-9]|[0-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-]?((0?[1-9]|[0-2][0-9])|(30)))|(0?[2][\\-]?(0?[1-9]|[0-2][0-9])))[\\-]?\\d{2}$",
        "MatchingText": "03-25-08|3-25-08|3-1-08",
        "NonMatchingText": "03-25-2008|3-25-2008|3/25/2008",
        "Description": "I was looking for a date format that allowed 1 or 2 digit Month and Days and 2 digit years. I found and tweak this one \nbased off Cliff Schneide Date example. "
    },
    {
        "Pattern": "(.*\\.jpe?g|.*\\.JPE?G)",
        "MatchingText": "*.JPG|||*.jpeg",
        "NonMatchingText": ".gif",
        "Description": "I just couldn't find any simple expression to check if an entered value is a jp(e)g.\n\nIf you're using this to check for e.g. mp3, just use the following:\n(.*\\mp3|.*\\.MP3)\n\nThis expression is not really stable, cause it will also match file.jpg.mp3 or stuff like that."
    },
    {
        "Pattern": "^(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])$",
        "MatchingText": "127.0.0.1|||255.255.255.0|||192.168.0.1",
        "NonMatchingText": "1200.5.4.3|||abc.def.ghi.jkl|||255.foo.bar.1",
        "Description": "RegExp for validating the format of IP Addresses. This works great with the ASP.NET RegularExpressionValidator server control."
    },
    {
        "Pattern": "^[a-zA-Z0-9\\-\\.]+\\.(com|org|net|mil|edu|COM|ORG|NET|MIL|EDU)$",
        "MatchingText": "3SquareBand.com|||asp.net|||army.mil",
        "NonMatchingText": "$SquareBand.com|||asp/dot.net|||army.military",
        "Description": "Domain names:\nThis regular expression tests the validity of a domain or hostname. It will match any valid domain name that does not contain characters which are invalid in URLs, and which ends in .com, .org, .net, .mil, or .edu. You can add additional valid TLDs by appending the | (pipe) character and the desired TLD to the list in the parens."
    },
    {
        "Pattern": "megaupload\\.com.*(?:\\?|&)(?:(?:folderi)?d|f)=([A-Z-a-z0-9]{8})",
        "MatchingText": "http://www.megaupload.com/?d=QDNFF02H|||http://www.megaupload.com/?f=TSNFLU2K|||http://www.megaupload.com/xml/folderfiles.php?folderid=1DGR6C4H",
        "NonMatchingText": "http://www.megaupload.com/?k=TSNFLU2K|||http://www.megaupload.com/?f=TSNFLU#@|||http://www.megaupload.com/xml/folderfiles.php?folderod=1DGR6C4H",
        "Description": "Detects megaupload files and folders links."
    },
    {
        "Pattern": "^([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3}$",
        "MatchingText": "128.115.12.255, 227.12.14.87, 14.23.120.8",
        "NonMatchingText": "111.56.045.78, 221.34.7.8.20, 75.45.301.14",
        "Description": "This regular expression validates an IP address within the range of 1.0.0.0 to 255.255.255.255"
    },
    {
        "Pattern": "^([a-z]+?\\.[a-z]+)+\\%$",
        "MatchingText": "aaa.bbb%   a.b.cccc.dd%   ",
        "NonMatchingText": "aa%   aaa.%   aaa.bbb.     aaa.bbb",
        "Description": "This can be used to validate package names ending with %. If % is not needed ^([a-z]+?\\.[a-z]+)+. (.....) can be used to make that part common. \"+\" is for more than one number of occurences. \"?\" is for one \".\" (dot) charactor\n"
    },
    {
        "Pattern": "^[0]*?[1-9]\\d*\\.?[0]*$",
        "MatchingText": "090, 089, 01 ||| 01.00  |||  08.0 |||  000056 ||| 0054.0 ||| 00055.000",
        "NonMatchingText": "0 ||| 0.00 ||| -1",
        "Description": "This matches Natural numbers with or without preceding zeros. \n^[0]+?[1-9]\\d*\\.?[0]*$ this states there should be atleast one zero"
    },
    {
        "Pattern": "\\b(((J(ANUARY|UNE|ULY))|FEBRUARY|MARCH|(A(PRIL|UGUST))|MAY|(SEPT|NOV|DEC)EMBER|OCTOBER))\\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\\s*(\\,)\\s*(200[0-9])\\b",
        "MatchingText": "JANUARY 26, 2007|||MARCH 1, 2001|||DECEMBER 31, 2005",
        "NonMatchingText": "JAN 26, 2001|||JULY 31 2005|||AUGUST 01, 08",
        "Description": "VALIDATE THE DATE FORMAT FULL MONTH DAY, CCYY i.e August 30, 2006"
    },
    {
        "Pattern": "\\b(((J(ANUARY|UNE|ULY))|FEBRUARY|MARCH|(A(PRIL|UGUST))|MAY|(SEPT|NOV|DEC)EMBER|OCTOBER))\\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\\s*(\\,)\\s*(0[0-9])\\b",
        "MatchingText": "JANUARY 26, 07|||MARCH 1, 01|||DECEMBER 31, 05",
        "NonMatchingText": "JAN 26, 01|||JULY 31 05|||AUGUST 01, 2008",
        "Description": "VALIDATE THE DATE FORMAT FULL MONTH DAY, YY i.e August 30, 06 (2006)"
    },
    {
        "Pattern": "\\b((J(AN|UN|UL))|FEB|MAR|(A(PR|UG))|MAY|SEP|NOV|DEC|OCT)\\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\\s*(\\,)\\s*(200[0-9])\\b",
        "MatchingText": "JAN 26, 2007|||MAR 1, 2001|||DEC 31, 2005",
        "NonMatchingText": "JANUARY 26, 2001|||JUL 31 2005|||AUGUST 01, 08",
        "Description": "VALIDATE THE DATE FORMAT SHORT MONTH DAY, CCYY i.e Aug 30, 2006\n"
    },
    {
        "Pattern": "\\b((J(AN|UN|UL))|FEB|MAR|(A(PR|UG))|MAY|SEP|NOV|DEC|OCT)\\s*(0?[1-9]|1[0-9]|2[0-9]|3[0-1])\\s*(\\,)\\s*(0[0-9])\\b",
        "MatchingText": "JAN 26, 07|||MAR 1, 01|||DEC 31, 05",
        "NonMatchingText": "JANUARY 26, 01|||JUL 31 05|||AUGUST 01, 08",
        "Description": "VALIDATE THE DATE FORMAT SHORT MONTH DAY, YY i.e Aug 30, 06 (2006)"
    },
    {
        "Pattern": "\\b4[0-9]\\b",
        "MatchingText": "40|||46|||49",
        "NonMatchingText": "4|||50|||39",
        "Description": "Validate the numbers in between 39 to 50 (i.e 40 to 49)"
    },
    {
        "Pattern": "^[0-9]{3}[-|/]{1}[0-9]{6}[-|/]{1}[0-9]{6}$",
        "MatchingText": "503-123456-123456",
        "NonMatchingText": "abc-abcdef-abcdef",
        "Description": "This Regular Expression is used to match the Companies House 503 Reference number that is given when a customer places an online order.www.companieshouse.gov.uk"
    },
    {
        "Pattern": "^[0-9]{8}$",
        "MatchingText": "01234567",
        "NonMatchingText": "01d34567",
        "Description": "Thie expression is used to match a United Kingdom Limited Company number in the UK. This is for Companies registered in England & Wales ONLY. This does not include Scotland."
    },
    {
        "Pattern": "^[SC]{2}[0-9]{6}$",
        "MatchingText": "SC123456",
        "NonMatchingText": "SC23561a",
        "Description": "Thie expression is used to match a United Kingdom Limited Company number in the UK. This is for Companies registered in Scotland. This is not for Companies registered in England & Wales."
    },
    {
        "Pattern": "^[A-Za-z]{2}[ ]{0,1}[0-9]{2}[ ]{0,1}[a-zA-Z]{3}$",
        "MatchingText": "AB06CDE or AB 06 CDE or AB06 CDE or AB 06CDE",
        "NonMatchingText": "Anything that's not in the above format",
        "Description": "This expression can be used to check against the format of a United Kingdom Vehicle Registration plate in the new style."
    },
    {
        "Pattern": "^[a-zA-z0-9]+[@]{1}[a-zA-Z]+[.]{1}[a-zA-Z]+$",
        "MatchingText": "test1@test.com or test@test1.com",
        "NonMatchingText": "test@test.co.uk",
        "Description": "Expression to check for .com email addresses"
    },
    {
        "Pattern": "<a[\\s]+[^>]*?.*?>([^<]+|.*?)?<\\/a>",
        "MatchingText": "<a href=\"http://www.tss-s.ru/index.php?option=com_content&amp;task=view&amp;id=170&amp;Itemid=75\">\u041A\u0410\u0417\u0410\u0425\u0421\u0422\u0410\u041D</a>",
        "NonMatchingText": "<a href=\"http://www.tss-s.ru/index.php?option=com_content&amp;task=view&amp;id=170&amp;Itemid=75\">\u041A\u0410\u0417\u0410\u0425\u0421\u0422\u0410\u041D< /a>",
        "Description": "for cut links on PHP\n $text = preg_replace(\"/<a[\\s]+[^>]*?.*?>([^<]+|.*?)?<\\/a>/s\",\"\",$text);"
    },
    {
        "Pattern": "(\\[b\\])([^\\[\\]]+)(\\[/b\\])",
        "MatchingText": "[b]this is important[/b]",
        "NonMatchingText": "[b]this is important[b]",
        "Description": "Checks only for valid ones. Always in lowercase. Separated Tags and contents in three groups for useful handling."
    },
    {
        "Pattern": "(\\[[abiu][^\\[\\]]*\\])([^\\[\\]]+)(\\[/?[abiu]\\])",
        "MatchingText": "[b]important[/b]; [i]italic[/i]; [u]underlined[/u]",
        "NonMatchingText": "[b]important[b]; [i class=\"example\"]italic[/i]; [u  ]underlined[/u]",
        "Description": "Only matches well-constructed tags."
    },
    {
        "Pattern": "(\\[a url=\\\"[^\\[\\]\\\"]*\\\"\\])([^\\[\\]]+)(\\[/a\\])",
        "MatchingText": "[a url=\"http://www.example-domain.com\"]link text[/a]; [a url=\"\"]link text[/a]",
        "NonMatchingText": "[a]link text[/a]; [a url= \"\"]link text[/a]",
        "Description": "Matches well-formed tags."
    },
    {
        "Pattern": "url=\\\"([^\\[\\]\\\"]*)\\\"",
        "MatchingText": "url=\"\"; url=\"http://www.example.eu\"; url=\"ftp://ftp.example.com\"",
        "NonMatchingText": "url =\"\"; url = \"\"",
        "Description": "Very useful to get a value, Value is in a capture group for best handling."
    },
    {
        "Pattern": "\\b\\w+\\b",
        "MatchingText": "any text",
        "NonMatchingText": "not a text",
        "Description": "This small regex is useful to count the number of words of a text."
    },
    {
        "Pattern": "<!*[^<>]*>",
        "MatchingText": "&lt;tr style=\"height: 1px; background-color: #ffffff\"&gt; &lt;td colspan=\"4\"&gt; &lt!-- comment --&gt; &lt;!DOCTYPE html PUBLIC ... &gt;",
        "NonMatchingText": "Any other text outside a tag symbols &lt; &gt;",
        "Description": "Mathes any HTML tag with any parameters and HTML Comments. Very useful to clean HTML of a text."
    },
    {
        "Pattern": "&[a-zA-Z]+\\d{0,3};",
        "MatchingText": "&amp;agrave; &amp;Ntilde; &amp;nbsp; &amp;frac14;",
        "NonMatchingText": "&amp;#375; &amp;#x1EF3; &amp;#x17B;",
        "Description": "This pattern matches any HTML special character code in the knowed friendly-code."
    },
    {
        "Pattern": "&#\\d{2,5};",
        "MatchingText": "&amp;#65; &amp;#273; &amp;#7691;",
        "NonMatchingText": "&amp;eth; &amp;#xE8; &amp;nbsp;",
        "Description": "This pattern matches any HTML special character in numerical code."
    },
    {
        "Pattern": "</?[a-z][a-z0-9]*[^<>]*>",
        "MatchingText": "&lt;tr style=\"height: 1px; background-color: #ffffff\"&gt; &lt;td colspan=\"4\"&gt; &lt;/br&gt;",
        "NonMatchingText": "Any other text outside a tag symbols &lt; &gt;",
        "Description": "Mathes any HTML tag with any parameters. Very useful to clean HTML of a text."
    },
    {
        "Pattern": "For IP-Address:(?P<First>2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.(?P<Second>2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.(?P<Third>2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.(?P<Fourth>2[0-4]\\d|25[0-5]|[01]?\\d\\d?)  For Number: (\\+|\\*{0,2})?(\\d*)",
        "MatchingText": "192.168.100.1 or +1124",
        "NonMatchingText": "192. or 1s",
        "Description": "i can use one regex one times, e.g. i can use regex: ip-address separatly. I can use also regex for NUMBER separatly. But how can i merge this 2 regex to one regex, that i can use my expression for numbers or for ip addresses together."
    },
    {
        "Pattern": "^(([1-9][0-9]*)|((([0])|([1-9][0-9]*))\\.[0-9]+)|((([1-9][0-9]*)|((([0])|([1-9][0-9]*))\\.[0-9]+))\\:)*(([1-9][0-9]*)|((([0])|([1-9][0-9]*))\\.[0-9]+)))$",
        "MatchingText": "1.2|||0.1:0.5:56:6.70|||3:6.78954:1:2:3",
        "NonMatchingText": "0.1:.5:56|||-6.70:3.|||5: 0.1:0",
        "Description": "Accepts a colon-delimited string of positive integers and/or decimal numbers in any combination. Spaces are not permitted. Decimal numbers of less than 1 must be prefixed with a zero (e.g. accepts 0.1, but not .1), and numbers with a trailing decimal point are not accepted (e.g. accepts 3.0, but not 3.). A lone zero is not accpeted (e.g. accepts 1.02:3:4.5, but not 1.02:0:4.5). Developed from a similar expression by Steven Smith on this site."
    },
    {
        "Pattern": "^(\\+\\d{2}[ \\-]{0,1}){0,1}(((\\({0,1}[ \\-]{0,1})0{0,1}\\){0,1}[2|3|7|8]{1}\\){0,1}[ \\-]*(\\d{4}[ \\-]{0,1}\\d{4}))|(1[ \\-]{0,1}(300|800|900|902)[ \\-]{0,1}((\\d{6})|(\\d{3}[ \\-]{0,1}\\d{3})))|(13[ \\-]{0,1}([\\d \\-]{5})|((\\({0,1}[ \\-]{0,1})0{0,1}\\){0,1}4{1}[\\d \\-]{8,10})))$",
        "MatchingText": "+61 02 9123 1234|||+61 3 8123 1234|||+61 7 9123 1234|||+61-04-9123-1234|||+61-2-9123-1234|||+61-8-9123-1234|||+61-7-9123-1234|||+61-(03)-9123-1234|||+61 (03) 9123-1234|||02 9123 1234|||03-9123-1234|||(03) 9123 1234|||(07) 9123 1234|||(03) 9123-1234|||1900-123-322|||1900 322 232|||1900322132|||1902222032|||1800-132 322|||1 800 322 222|||1300232322|||13 73 23|||132 221|||0400 111 222|||0400111222|||+61 400 111 222|||+61 (0)3 1234 4566|||+61 (0)411222333|||+61 (0)400-000-000",
        "NonMatchingText": "+61-05-9123-1234|||+61-6-9123-1234|||19021234567",
        "Description": "Intended to validate Australian Phone Numbers.\nVery loosely based on Bill Hely's regex, but allows for further options for Country code, (un)bracketed Area code, spaced/hyphenated 8-digit/ Mobile/1X00*/13*."
    },
    {
        "Pattern": "^\\d*\\d?((5)|(0))\\.?((0)|(00))?$",
        "MatchingText": "15.00|||20|||200.00",
        "NonMatchingText": "23.00|||12|||50.80",
        "Description": "Based on a pattern I found on this site, this pattern verifies that a number is a multiple of 5. Basically checks the last number before the decimal point to see if it's a 5 or 0. Also works on non-decimal numbers.\n\nThanks to Narsi V for the base pattern\nhttp://www.regxlib.com/REDetails.aspx?regexp_id=82"
    },
    {
        "Pattern": "AT&T customer service",
        "MatchingText": "http://attcustomerservicephonenumber.over-blog.com/2019/05/solutions-for-the-common-at-t-email-issues.html",
        "NonMatchingText": "..................",
        "Description": "Helpline 1-833-290-8999 Toll Free for At&t Email Issues\n\nAT&T or American Telegraph and Telephone Company is one of the largest communication service provider who are serving the people of America with their world class services like mobile network services, internet services, email services, broadband services, telephony services and much more. The organization is one of the earliest to start email services in America, thus, AT&T always has been relied upon by the customers. Today emails are one of the most essential tools for our communication needs. It is considered as one of the most sophisticated mode of business and professional communication due to its reliability and speed. However, modern innovation comes with modern technical problems. Especially when you find At&t email issues, things can get quite annoying because AT&T is very serious about their customer\u2019s privacy and security. If you are facing problem then call us on At&t support number to get accurate help right away.\n\n\nFind out why error occurs:\n\nAt http://attcustomerservicephonenumber.over-blog.com/ , our customer support executives get numerous reports about At&t email issues. Thus, we have set up a team of professional tech experts who are doing immense research on how to fix the common issues that our AT&T customers face with their email account. Our tech experts tried and tested different solutions for fixing each issue with the highest accuracy possible. We have only selected the finest solutions into our service process so that it can cure your email account safely. We found out that there are a few common issues that many user face trouble with. Let us tell you what those symptoms are:\n\nLogin page prompting email account not found.\n\nLogin denied while you are using correct User ID and Password to log in.\n\nAccount login requires a password change for security reasons.\n\nUser cannot change AT&T email password or forgot password related issues.\n\nLogin page is unable to verify two step authentication process of the account.\n\nLock down due to multiple attempts of using wrong User ID or Password to login to the account.\n\nLock down due to multiple attempts of hacking in to the users account.\n\nIf you are facing any of these At&t email issues then we recommend you to contact our At&t customer service number today. We will guide you with the accurate solutions from a knowledgeable tech expert. If you tamper with any settings related to your email account without any knowledge about it, things can be much more difficult to fix. You must consult only with people who has sufficient experience about how to fix these issue.\n\nHave no fear:\n\nYes, you heard it right. http://attcustomerservicephonenumber.over-blog.com/ is available 24*7 to the rescue of a customer who is experiencing technical trouble. We have been providing tech support and solution services throughout the years. Our tech executives are highly skilled and certified from reputed organizations. Thus they have managed to get thousands of positive feedback from our customers around the world. Whenever you are facing At&t email issues, just remember our toll free At&t support number is active all the time. Let your tech worries be our concern now."
    },
    {
        "Pattern": "AT&T customer service",
        "MatchingText": "http://att-phone-support-number.over-blog.com/2019/05/solve-att-common-issue-with-our-technical-support.html",
        "NonMatchingText": "..................",
        "Description": "How browser issue can be solved\n\nThe users should ensure that the browser that he/she is using supports the ATT email. If it is not supported then you have to change the browser for further usage. You will require specialized help for rolling out the required improvements in the settings. In that circumstance, you can take help of ATT Email Support group. Here are a few changes that can assist you in making the adjustments in the browser and empower you to get to your account once more:\n\nIn any case, you should close all the open browser windows and afterwards again revive them. This causes you to guarantee that there is not all that much or turning.\nYou can attempt to get to your email from some other browser. This may not understand the browser issues, but rather you can get to your email.\nAt times the caches and cookies may back off the browsing specs and strife with email. Clearing postulations treat and reserve may resolve the issue.\nIn the event that it is discovered that your browser devices struggle with your email gets to, at that point, it would be better than you debilitate them.\nThese means may push you to some degree to determine the issue. On the off chance that despite everything you confront comparative issue over and over, it would be better than you take help of our ATT Email Customer Service group.\n \n\nDistinct issues relating to ATT email\n\nThere are various other problems that can cause obstruction to your online working. One can avoid these situations with the help of our support such as ATT Email Hacked Account, ATT password recovery, sending email issue and others. This occurs in very rare circumstances. Hacking is cybercrime and one cannot ignore it as the hacker can misuse your information for own ends. This may, in turn, hurt your reputation. So, in order to stop these malicious activities, one needs to follow the process of ATT Email Password Reset for effective recovery without delay.\n\nWhy choose our experts\n\nOur technicians of ATT Email Customer Service never claim to be the best techies available in the market but they prove it with their actions. Whenever they receive a call from users, at first they listen to the issues carefully. The subsequent steps come to understanding the root cause of the problem and then solve it from the core. They don\u2019t stop there but also ensure the complete satisfaction of clients after getting a resolution to their problems. This turns out to be the positive point of our team.\n\nConclusion after considering all perspectives\n\nThe ATT Email Customer Service team has all the ability to analyze issues sans delay. The users can connect with technology executives at the toll-free AT&T Phone Number 1-833-290-8999. This number is accessible round the clock so that even the user in an emergency can talk to our experts through this number. They can connect at any point in time, may it be day and night.\n\n \n\n "
    },
    {
        "Pattern": "AT&T customer service",
        "MatchingText": "http://attcustomerservicephonenumber.over-blog.com/2019/05/how-to-contact-at-t-customer-service-number-for-help.html",
        "NonMatchingText": "..................",
        "Description": "AT&T Customer Service\n \n\nEmail AT&T customer service help at this email address for the fastest reply. Click to indicate what problem you are emailing about and we can share our best customer recommended talking points to include in your email so you get a faster reply and better results. This is the best email address for AT&T Customer Service Phone Number 1-833-290-8999.\n\nThis information is according to 220,254 who are also AT&T customers over the past 180 days. Email can be a convenient way to communicate with customer service; you can multi-task while you are doing it, and you may already be checking your inbox frequently anyways. But more often than not, AT&T customers want to talk to a real live human being as soon as possible and check it off their to-do list. And so they prefer calling AT&T at their 1-833-290-8999phone number instead. The Reporting Abuse department that replies to the emails you send is used to responding to a variety of customer service issues such as Cancel Service.\n\nWhen you email AT&T one of their customer service agents sitting in one of their call centers, likely located in California or Florida or Georgia or Idaho or Iowa or Louisiana or Missouri or Montana or Oklahoma or Philippines or Texas, will get your message in their inbox and reply to you on a first come, first serve basis. That department is open 24 hours, 7 days. If you send an email late at night, you probably won't get a reply until the next business day. It's sometimes hard to find information about how best to contact companies like AT&T by email, so gathers information like this from customers so we can share amongst ourselves.\n\n \n\nContacting AT&T\n\nAT&T provides customer service by email and also by phone. There are 23 ways to reach AT&T across 5 communication modes: phone, email, facebook, web, twitter. In case you didn't realize there was an alternative, the best phone number for AT&T Customer Service Number is 1-833-290-8999. With our free tools, you can check out the current wait time for AT&T and use our Have Them Call Me Instead tool. If you find any mistakes in this information, please let us know below.\n\n tries to source the best AT&T customer service information from customers so we can share our best hints and tricks with each other. Telling us about any imperfections is useful and helps all of us. Click here to see all the ways we know to contact AT&T currently."
    },
    {
        "Pattern": "AT&T customer service",
        "MatchingText": "http://att-phone-support-number.over-blog.com/2019/05/how-to-connect-at-t-email-support-number.html",
        "NonMatchingText": "..................",
        "Description": "AT&T Customer Service Email\n \n\nEmail AT&T customer service help at this email address for the fastest reply. Click to indicate what problem you are emailing about and we can share our best customer recommended talking points to include in your email so you get a faster reply and better results. This is the best email address for AT&T Email Support Phone Number 1-833-290-8999.\n\nThis information is according to 220,254 who are also AT&T customers over the past 180 days. Email can be a convenient way to communicate with customer service; you can multi-task while you are doing it, and you may already be checking your inbox frequently anyways. But more often than not, AT&T customers want to talk to a real live human being as soon as possible and check it off their to-do list. And so they prefer calling AT&T at their  phone number instead. The Reporting Abuse department that replies to the emails you send is used to responding to a variety of customer service issues such as Cancel Service. When you email AT&T one of their customer service agents sitting in one of their call centers, likely located in California or Florida or Georgia or Idaho or Iowa or Louisiana or Missouri or Montana or Oklahoma or Philippines or Texas, will get your message in their inbox and reply to you on a first come, first serve basis. That department is open 24 hours, 7 days. If you send an email late at night, you probably won't get a reply until the next business day. It's sometimes hard to find information about how best to contact companies like AT&T by email, so gathers information like this from customers so we can share amongst ourselves.\n\n \n\nContacting AT&T\n\nAT&T provides customer service by email and also by phone. There are 23 ways to reach AT&T across 5 communication modes: phone, email, facebook, web, twitter. In case you didn't realize there was an alternative, the best phone number for AT&T Email support is 1-833-290-8999.\n\nWith our free tools, you can check out the current wait time for AT&T and use our Have Them Call Me Instead tool. If you find any mistakes in this information, please let us know below. tries to source the best AT&T customer service information from customers so we can share our best hints and tricks with each other. Telling us about any imperfections is useful and helps all of us. Click here to see all the ways we know to contact AT&T currently."
    },
    {
        "Pattern": "AT&T Customer Service Phone Number ",
        "MatchingText": "http://att-customer-service-phone-number.customer-service-phonenumber.com/",
        "NonMatchingText": "http://att-customer-service-phone-number.customer-service-phonenumber.com",
        "Description": "In order to eradicate ATT-related issues, ATT Cuestomr Service 1-855-431-7111   can be the suitable solution which can be availed through a single call. All you need to do is to place an easy call at our toll-free helpline number through which you will be able to get the authentic ATT service with the help of professionals who are available 24/7. . http://att-customer-service-phone-number.customer-service-phonenumber.com  "
    },
    {
        "Pattern": "AT&T Customer Service Phone Number ",
        "MatchingText": "http://att-customer-service-phone-number.customer-service-phonenumber.com",
        "NonMatchingText": "http://att-customer-service-phone-number.customer-service-phonenumber.com",
        "Description": "Why don\u2019t you get in touch with a tech aid provider you can count on right at the moment you face any kind of problems? What you need to do is give a quick call at our toll free ATT Customer Service1-855-431-7111   phone number which will be immediately and directly responded by our technical support executive who will direct you with the right way to deal with your problems. http://att-customer-service-phone-number.customer-service-phonenumber.com"
    },
    {
        "Pattern": "AT&T Customer Service Phone Number ",
        "MatchingText": "http://att-customer-service-phone-number.customer-service-phonenumber.com/",
        "NonMatchingText": "http://att-customer-service-phone-number.customer-service-phonenumber.com",
        "Description": "Is there any easy and effective medium to tackle down all ATT related issues? Aren\u2019t you capable enough to deal with all sorts of issues with optimum level of ease? In such a critically troubling situation, place a call at our toll free ATT Customer Service helpline number which will connect you our experts who will help you to mend all your problems in no time. http://att-customer-service-phone-number.customer-service-phonenumber.com"
    },
    {
        "Pattern": "AT&T Customer Service Phone Number ",
        "MatchingText": "http://att-customer-service-phone-number.customer-service-phonenumber.com/",
        "NonMatchingText": "http://att-customer-service-phone-number.customer-service-phonenumber.com",
        "Description": "Do you have an AT&T phone? If your AT&T device is showing issues that you cannot solve on your own then you can take help from our experts. Our AT&T Customer Service Phone Number (1-855-431-7111) which is managed by AT&T professionals is running non-stop 24/7. Our AT&T support has professionals who are experienced and supportive. They can offer answers for any type of AT&T query. You just have to dial the number and share your AT&T concerns with our professionals. You know more information visit http://att-customer-service-phone-number.customer-service-phonenumber.com"
    },
    {
        "Pattern": "AT&T Customer Service Phone Number ",
        "MatchingText": "http://att-customer-service-phone-number.customer-service-phonenumber.com/",
        "NonMatchingText": "http://att-customer-service-phone-number.customer-service-phonenumber.com",
        "Description": "We at our AT&T support offer simple solutions which are best to clear your AT&T problems. Our AT&T Customer Service Phone Number is the perfect way to reach the executives within a quick span of time. Our AT&T help is running 24/7 for all the AT&T users who are struggling with its issues. You can dial the number 1-855-431-7111 and get in touch with the AT&T agents who are 24/7 working to help. In case your AT&T phone or internet is facing connectivity errors then we will resolve it through our techniques. If you want more information, you can visit this website http://att-customer-service-phone-number.customer-service-phonenumber.com"
    },
    {
        "Pattern": "AT&T Customer Service Phone Number ",
        "MatchingText": "http://att-customer-service-phone-number.customer-service-phonenumber.com/",
        "NonMatchingText": "http://att-customer-service-phone-number.customer-service-phonenumber.com",
        "Description": "Our AT&T customer support is round the clock addressing AT&T errors. We can tackle any kind of AT&T errors including troubleshooting, password reset, recovery, hacked account etc. Our AT&T support team is round the clock working through a number which is 1-855-431-7111 (toll-free) and you can call on it anytime. Our AT&T help is supporting you online while sorting out the issues within a short span of time. Call us at AT&T Customer Service Phone Number and get feasible answers! For take more information about this website you can visit http://att-customer-service-phone-number.customer-service-phonenumber.com"
    },
    {
        "Pattern": "AT&T Customer Service Phone Number ",
        "MatchingText": "http://att-customer-service-phone-number.customer-service-phonenumber.com/",
        "NonMatchingText": "http://att-customer-service-phone-number.customer-service-phonenumber.com",
        "Description": "In case your AT&T product is not working properly or internet connection is broken then you can call at our AT&T Customer Service Phone Number which is operational 24/7. Whatever are the issues you can discuss them all with us? We will resolve every issue which you will face with AT&T product or service. Our AT&T officials will listen to your queries and offer instant solutions right at that moment. You can dial our AT&T number which is 1-855-431-7111 (toll-free). You know more information visit http://att-customer-service-phone-number.customer-service-phonenumber.com"
    },
    {
        "Pattern": "AT&T Customer Service Phone Number ",
        "MatchingText": "http://att-customer-service-phone-number.customer-service-phonenumber.com/",
        "NonMatchingText": "http://att-customer-service-phone-number.customer-service-phonenumber.com",
        "Description": "You can dial our AT&T Customer Service Phone Number and speak to our AT&T officials which are working 24/7 and talking to you via phone. Our AT&T support has skilled technicians who can provide 100% reliable answers for AT&T problems. You can reach AT&T technicians by dialling 1-855-431-7111 which is our AT&T customer support number. In case you want to speak to a technician directly then you can ring us at the number mentioned. Get in touch with us at the earliest and seek an immediate response. If you want more information, you can visit this website http://att-customer-service-phone-number.customer-service-phonenumber.com."
    },
    {
        "Pattern": "AT&T Customer Service Phone Number ",
        "MatchingText": "http://att-customer-service-phone-number.customer-service-phonenumber.com/",
        "NonMatchingText": "http://att-customer-service-phone-number.customer-service-phonenumber.com",
        "Description": "If you are willing to weed out ATT related trouble within a couple of minutes, it would be good to approach our techies who are all the time available at your closet disposal. Here, the best in class ATT Customer Service 1-855-431-7111   will be provided to you, right from the comfort of your office or home, in a trouble free manner. http://att-customer-service-phone-number.customer-service-phonenumber.com"
    },
    {
        "Pattern": "AT&T Customer Service Phone Number ",
        "MatchingText": "http://att-customer-service-phone-number.customer-service-phonenumber.com/",
        "NonMatchingText": "http://att-customer-service-phone-number.customer-service-phonenumber.com",
        "Description": "Whether you are an experienced user or a novice user, it is recommended to avail our ATT Customer Service 1-855-431-7111   right at the moment you come across any kind of trouble pertaining to your ATT account. Here, you will be able to fetch the effective assistance through which you can deal with your problems with optimum ease. What you need to do is place a call at our toll free helpline number. http://att-customer-service-phone-number.customer-service-phonenumber.com"
    },
    {
        "Pattern": "AT&T Customer Service Phone Number ",
        "MatchingText": "http://att-customer-service-phone-number.customer-service-phonenumber.com/",
        "NonMatchingText": "http://att-customer-service-phone-number.customer-service-phonenumber.com",
        "Description": "Are you new to ATT account and you are facing technical problems with your account? Do you need a reliable yet effective source to get rid of the entire host of all such problems? In such a case, give a call at our toll free ATT Customer Service1-855-431-7111 phone number through which you will be able to fetch a feasible solution directly from the experts. http://att-customer-service-phone-number.customer-service-phonenumber.com"
    },
    {
        "Pattern": "^((?:\\+62|62)|0)[2-9]{1}[0-9]+$",
        "MatchingText": "+62817737669 | 62817737669 | 0817737669 | 6221995500 | 021995500 | 0401998866",
        "NonMatchingText": "+817737669 | 817737669 | 00817737669 | 0817 737 669 | 0817-737-669 | 021-995500",
        "Description": "Validate Indonesian \"Mobile Numbers Only\" with or without the country code, also base on regular phone number format at http://id.wikipedia.org/wiki/Daftar_kode_telepon_di_Indonesia. This regex only allowed characters that accepted by mobile phone/sms gateway only :D"
    },
    {
        "Pattern": "^([a-zA-Z0-9][-a-zA-Z0-9]*[a-zA-Z0-9]\\.)+([a-zA-Z0-9]{3,5})$",
        "MatchingText": "freshmeat.net|||123.com|||TempLate-toolkKt.orG",
        "NonMatchingText": "-dog.com|||?boy.net|||this.domain",
        "Description": "Host/Domain name validation for perl.\nShould be combined with a check for\nlength &lt;= 63 characters and that $2\nis in a list of top-level domains."
    },
    {
        "Pattern": "[a-zA-Z]{3,}://[a-zA-Z0-9\\.]+/*[a-zA-Z0-9/\\\\%_.]*\\?*[a-zA-Z0-9/\\\\%_.=&amp;]*",
        "MatchingText": "http://someserver|||http://www.someserver.com/|||http://www.someserver.com/somefile.txt",
        "NonMatchingText": "Thin|||Lizzy",
        "Description": "A simple url search pattern that works against the most generic cases. A little better in terms of matches than the other URL expressions listed."
    },
    {
        "Pattern": "(8[^0]\\d|8\\d[^0]|[0-79]\\d{2})-\\d{3}-\\d{4}",
        "MatchingText": "092-606-4900",
        "NonMatchingText": "800-233-2333",
        "Description": "this expression not allowed to enter toll free no."
    },
    {
        "Pattern": "((\\(\\d{2}\\) ?)|(\\d{2}/))?\\d{2}/\\d{4} ([0-2][0-9]\\:[0-6][0-9])",
        "MatchingText": "dd/mm/yyyy HH:MM format, 10/10/2010 05:30",
        "NonMatchingText": "dd/mm/yy HH:MM",
        "Description": "Regular expression for find date with time."
    },
    {
        "Pattern": "^(([\\da-fA-F]{2}[-:]){5}[\\da-fA-F]{2})$",
        "MatchingText": "00-25-86-DC-FD-3B ||| 00:25:86:DC:FD:3B ||| 00-25-86-dc-fd-3b ||| 00:25:86:dc:fd:3b",
        "NonMatchingText": "00 25 86 dc fd 3b ||| 002586dcfd3b ||| 00.25.86.dc.fd.3b",
        "Description": "Easiest way to describe a MAC Address."
    },
    {
        "Pattern": "((\\+44\\s?\\(0\\)\\s?\\d{2,4})|(\\+44\\s?(01|02|03|07|08)\\d{2,3})|(\\+44\\s?(1|2|3|7|8)\\d{2,3})|(\\(\\+44\\)\\s?\\d{3,4})|(\\(\\d{5}\\))|((01|02|03|07|08)\\d{2,3})|(\\d{5}))(\\s|-|.)(((\\d{3,4})(\\s|-)(\\d{3,4}))|((\\d{6,7})))",
        "MatchingText": "0121 111 1111|+44 (0)21 444 4444|07941 111 111|07941 111111|(+44) 121 222 3333",
        "NonMatchingText": "0121_111_3333",
        "Description": "Matches over 18 different combinations for UK phone numbers that I could find.  If there are any errors please get in touch."
    },
    {
        "Pattern": "^([0-9]( |-)?)?(\\(?[0-9]{3}\\)?|[0-9]{3})( |-)?([0-9]{3}( |-)?[0-9]{4}|[a-zA-Z0-9]{7})$",
        "MatchingText": "1-(123)-123-1234|||123 123 1234|||1-800-ALPHNUM",
        "NonMatchingText": "1.123.123.1234|||(123)-1234-123|||123-1234",
        "Description": "Matches US phone number format. 1 in the beginning is optional, area code is required, spaces or dashes can be used as optional divider between number groups. Also alphanumeric format is allowed after area code."
    },
    {
        "Pattern": "\\[([\\w \\.]+)\\]\\(([\\w\\.:\\/ ]*)\\)",
        "MatchingText": "[link title](www.sometinng.com)",
        "NonMatchingText": "[link title]woow(www.sometinng.com)",
        "Description": "Easy way to match a markdown link \n[link title](www.sometinng.com)"
    },
    {
        "Pattern": "^([A-Z]{1}\\w{1,3}) (\\d{1}[A-Z]{2})$",
        "MatchingText": "EC1A 2BB",
        "NonMatchingText": "111A 1BB",
        "Description": "simple validation of a UK postcode.\n\nExamples of valid:\nAA9A 9AA\nA9A 9AA \nA9 9AA\nA99 9AA\nAA9 9AA\nAA99 9AA"
    },
    {
        "Pattern": "([0369]*([147][0369]*([147][0369]*[258])*[0369]*[147][0369]*([258][0369]*[147])*[0369]*[0369]*([258][0369]*[147])*[0369]*[147]|[258][0369]*([258][0369]*[147])*[0369]*[258][0369]*([147][0369]*[258])*[0369]*[0369]*([147][0369]*[258])*[0369]*[258]|[147][0369]*([147][0369]*[258])*[0369]*[258]|[258][0369]*([258][0369]*[147])*[0369]*[147])*[0369]*)*",
        "MatchingText": "0|||3|||12|||129762",
        "NonMatchingText": "1|||2|||129761",
        "Description": "Matches any sequence of decimal digits that represent a positive denary multiple of three."
    },
    {
        "Pattern": "[+-]?(0|[1-9]([0-9]{0,2})(,[0-9]{3})*)(\\.[0-9]+)?",
        "MatchingText": "0|||1|||-999|||+1,001|||1,234,567.0",
        "NonMatchingText": "alpha|||0xFF|||1,2,345,678|||1,234.",
        "Description": "Matches any positive or negative number, with or without decimal places, where the digits are grouped in threes seperated by commas."
    },
    {
        "Pattern": "[ \\t]+$",
        "MatchingText": "    int i = 0;    |||    shutUp(); ",
        "NonMatchingText": "// a perfect comment...",
        "Description": "Use in Java programming code to find trailing spaces (a checkstyle warning). Replace All with the empty string to remove them."
    },
    {
        "Pattern": "<!--[\\d\\D]*?-->",
        "MatchingText": "&lt;!--testcomment-->, &lt;!-- Another test comment -->, &lt;!-- &lt;img src=\"test.jpg\"> -->",
        "NonMatchingText": "&lt;b>, &lt;a href=\"test.html\">...&lt;/a>, &lt;br>",
        "Description": "Removes HTML comments with ease. Based off of Chris Craft's /* ... */ comment removal."
    },
    {
        "Pattern": "(0[1-9]|[12][0-9]|3[01])\\s(J(anuary|uly)|Ma(rch|y)|August|(Octo|Decem)ber)\\s[1-9][0-9]{3}|\n(0[1-9]|[12][0-9]|30)\\s(April|June|(Sept|Nov)ember)\\s[1-9][0-9]{3}|\n(0[1-9]|1[0-9]|2[0-8])\\sFebruary\\s[1-9][0-9]{3}|\n29\\sFebruary\\s((0[48]|[2468][048]|[13579][26])00|[0-9]{2}(0[48]|[2468][048]|[13579][26]))",
        "MatchingText": "09 March 2005|||29 February 2004|||31 December 9999",
        "NonMatchingText": "32 March 2005|||29 February 2005|||2005-03-09",
        "Description": "Verifies all valid Gregorian dates of the form DD MONTH YY, taking days/month and leap years into account."
    },
    {
        "Pattern": "^(?P<title>.*\\.\\s)*(?P<firstname>([A-Z][a-z]+\\s*)+)(\\s)(?P<middleinitial>([A-Z]\\.?\\s)*)(?P<lastname>[A-Z][a-zA-Z-']+)(?P<suffix>.*)$",
        "MatchingText": "Mary, Mary White, Mary Jo White, Dr. Mary Jo White, Dr. Mary Jo T. White, Ph.D.",
        "NonMatchingText": "Mary Jo Thomas White",
        "Description": "Finds title, first name, middle initial, last name, and suffix of a name. Middle names are added to first name. Uses .Net capture group names."
    },
    {
        "Pattern": "^((((0[1-9]|[12][0-9]|3[01])(0[13578]|10|12)(\\d{2}))|(([0][1-9]|[12][0-9]|30)(0[469]|11)(\\d{2}))|((0[1-9]|1[0-9]|2[0-8])(02)(\\d{2}))|((29)(02)(00))|((29)(02)([2468][048]))|((29)(02)([13579][26])))[-]\\d{4})$",
        "MatchingText": "241283-1234|290204-1234",
        "NonMatchingText": "290206-1234",
        "Description": "Danish social security. [ddMMyy-0000]. Validates a correct date, but does not enforce the modulus 11 check (see www.cpr.dk for more information)."
    },
    {
        "Pattern": "[a-z]{1}[a-z0-9\\-_\\.]{2,24}@tlen\\.pl",
        "MatchingText": "test@tlen.pl|||anka19@tlen.pl",
        "NonMatchingText": "1rychu@tlen.pl|||cEgLa@tlen.pl|||t#ta@tlen.pl anka19@poczta.com",
        "Description": "determines if the selected string is valid tlen.pl communicator login"
    },
    {
        "Pattern": "[a-zA-Z_:][a-zA-Z0-9_,\\.\\-]*?",
        "MatchingText": "value|||name|||data-:_,.-funky",
        "NonMatchingText": ",non-attr|||:!attr|||-data-not-funky",
        "Description": "Matches valid html tag attribute name (without value)."
    },
    {
        "Pattern": "<.*\\b(bgcolor\\s*=\\s*[\\\"|\\']*(\\#\\w{6})[\\\"|\\']*).*>",
        "MatchingText": "table bgcolor=\"#A3A3A3\" | table bgcolor= #A3A3A3\" | td bgcolor= #A3A3A3 | td bgcolor=#A3A3A3 alt=\"somethingelse\"",
        "NonMatchingText": "tr bgcolor=\"\" test | tablebgcolor=\"#A3A3A3\" | table bgcolor=\"test2\" | td bgcolor=\"red\" | td bgcolor=\"#$%skis\"",
        "Description": "Variable 1 = \"complete attribute and value\".\nVariable 2 = \"attribute value only\".\nFor meeting compliance with W3C AA rules, I've been using this in a simple HTML parser to convert certain background tags from the deprecated 'bgcolor' attribute to now using a 'style=background:' and the passed colour. This had to be only on hexadecimal values for my current needs.\n\nLater modifications : \n1. Only for certain tags (eg. td,tr,table).\n2. If matching an opening apostrophe/quotation mark, only capture variable if there is a closing one.\n"
    },
    {
        "Pattern": "^(sip|sips)\\:\\+?([\\w|\\:?\\.?\\-?\\@?\\;?\\,?\\=\\%\\&]+)",
        "MatchingText": "sip:alice@atlanta.com|||sip:alice:secretword@atlanta.com;transport=tcp|||sips:alice@atlanta.com?subject=project%20x&priority=urgent|||sip:+1-212-555-1212:1234@gateway.com;user=phone|||sips:1212@gateway.com|||sip:alice@192.0.2.4|||sip:atlanta.com;method=REGISTER?to=alice%40atlanta.com|||sip:alice;day=tuesday@atlanta.com",
        "NonMatchingText": "alice@atlanta.com|||alice:secretword@atlanta.com;transport=tcp|||alice@atlanta.com?subject=project%20x&priority=urgent|||+1-212-555-1212:1234@gateway.com;user=phone|||1212@gateway.com|||alice@192.0.2.4|||atlanta.com;method=REGISTER?to=alice%40atlanta.com|||alice;day=tuesday@atlanta.com",
        "Description": "The sip/sips syntax is from http://www.ietf.org/rfc/rfc3261.txt?number=3261, seems the pattern works fine, but I worry about the performance"
    },
    {
        "Pattern": "[NS] \\d{1,}(\\:[0-5]\\d){2}.{0,1}\\d{0,},[EW] \\d{1,}(\\:[0-5]\\d){2}.{0,1}\\d{0,}",
        "MatchingText": "N 50:54:44.99,W 4:59:11.0; N 38:55:02.90,W 76:59:31.19; N 22:16:42,E 114:09:32",
        "NonMatchingText": "N 22:66:61,E 85:00:33; E 00:00:00.00,N 00:00:00.00; N00:00:00.00, E00:00:00.00",
        "Description": "Latitude and longitude coordinates separated by a comma in the form: \nN 0:59:59.99,E 0:59:59.99 No restriction on degrees. Use split on comma to separate Latitude and Longitude then on colon and space for parts to convert into a decimal value. "
    },
    {
        "Pattern": "^(\\d{4})\\D?(0[1-9]|1[0-2])\\D?([12]\\d|0[1-9]|3[01])(\\D?([01]\\d|2[0-3])\\D?([0-5]\\d)\\D?([0-5]\\d)?)?$",
        "MatchingText": "2006-12-31 17:58:00 ||| 20061231175800 ||| 2006-12-31",
        "NonMatchingText": "2006-13-36 25:61:62",
        "Description": "Regex to match the ISO Date Format. The time part is optional, including the seconds, as are all of the delimiters (although they must be non-numeric).  Each part of the date will be returned as a selection e.g. \\1 will contain the Year, \\2 will contain the Month."
    },
    {
        "Pattern": "(((0[1-9]|[12][0-9]|3[01])([/])(0[13578]|10|12)([/])(\\d{4}))|(([0][1-9]|[12][0-9]|30)([/])(0[469]|11)([/])(\\d{4}))|((0[1-9]|1[0-9]|2[0-8])([/])(02)([/])(\\d{4}))|((29)(\\.|-|\\/)(02)([/])([02468][048]00))|((29)([/])(02)([/])([13579][26]00))|((29)([/])(02)([/])([0-9][0-9][0][48]))|((29)([/])(02)([/])([0-9][0-9][2468][048]))|((29)([/])(02)([/])([0-9][0-9][13579][26])))",
        "MatchingText": "28/12/2003|||28/02/2003|||29/02/2000",
        "NonMatchingText": "28-02-2003|||30/02/2003|||28.02.2003",
        "Description": "Date in DD/MM/YYYY format.\nFecha en formato DD/MM/AAAA."
    },
    {
        "Pattern": "^([+]?\\d{1,4})?([\\s-.+]?\\(?\\d{3}\\)?)?([\\s-.]?\\d{3})([\\s-.]?\\d{4})\\s?([eE]?[xX]?[tT]?[\\s-.:]?\\s?\\d{4})?",
        "MatchingText": "1-123-456-7890 ext.1234, +1 (123) 456-7890 x: 1234, 1234567890 EXT 1234",
        "NonMatchingText": "1 (123) 456-7890 m: 1234, +123456-123-456-7890 T: 12356",
        "Description": "US phone regex which allows the country code prefix and extension suffix"
    },
    {
        "Pattern": "&lt;(?:[^&quot;']+?|.+?(?:&quot;|').*?(?:&quot;|')?.*?)*?&gt;",
        "MatchingText": "&lt;input type=button onclick='n&gt;5' value=test onmouseover=&quot;n&lt;5&amp;&amp;n&gt;8&quot; onm",
        "NonMatchingText": "haven't found any exceptions yet",
        "Description": "This will match all tags in a string, it's good for stripping HTML or XML tags to get the plain text.It works with attributes that include javascript or &quot;&lt;&gt;&quot;.\nIt will match all these\n    &lt;hr size=&quot;3&quot;\n        noshade\n        color=&quot;#000000&quot;\n        align=&quot;left&quot;&gt;\n\n    &lt;p style=&quot;margin-top:0px;margin-bottom:0px&quot;\n       align=&quot;center&quot;&gt;&lt;font face=&quot;Times New Roman&quot;\n          size=&quot;5&quot;&gt;&lt;b&gt;UNITED STATES&lt;/b&gt;&lt;/font&gt;&lt;/p&gt;\n&lt;input type=button onclick='if(n.value&gt;5)do_this();'&gt; not this &lt;br&gt; &lt;input type=button onclick=&quot;n&gt;5?a():b();&quot; value=test&gt; not this &lt;br&gt; &lt;input type=button onclick=&quot;n&gt;5?a(\\&quot;OK\\&quot;):b('Not Ok');&quot; value=test&gt; not this &lt;br&gt; &lt;input type=button onclick='n&gt;5' value=test onmouseover=&quot;n&lt;5&amp;&amp;n&gt;8&quot; onmouseout='if(n&gt;5)alert(\\'True\\');else alert(&quot;False&quot;)'&gt; not this &lt;br&gt;\n"
    },
    {
        "Pattern": "((http|ftp|https):\\/\\/w{3}[\\d]*.|(http|ftp|https):\\/\\/|w{3}[\\d]*.)([\\w\\d\\._\\-#\\(\\)\\[\\]\\\\,;:]+@[\\w\\d\\._\\-#\\(\\)\\[\\]\\\\,;:])?([a-z0-9]+.)*[a-z\\-0-9]+.([a-z]{2,3})?[a-z]{2,6}(:[0-9]+)?(\\/[\\/a-z0-9\\._\\-,]+)*[a-z0-9\\-_\\.\\s\\%]+(\\?[a-z0-9=%&amp;\\.\\-,#]+)?",
        "MatchingText": "www.yahoo.com|||ftp://user:pass@host.com:123|||http://localhost/page2.php?a=b&amp;c=d#hello",
        "NonMatchingText": "website.net",
        "Description": "Here is my first regexp. I hope you like it! It parses quite a few different urls, although it's not a high-quality regexp. Http, Ftp protocols are supported, parameters and anchors too."
    },
    {
        "Pattern": "0{3,}|1{3,}|2{3,}|3{3,}|4{3,}|5{3,}|6{3,}|7{3,}|8{3,}|9{3,}",
        "MatchingText": "122234567|||1234444444|||12345999",
        "NonMatchingText": "123456|||1335855|||1983464",
        "Description": "An expression to look for numbers that repeat 3 or more times in succession."
    },
    {
        "Pattern": "^(?P<hours>\\d{2}):(?P<minutes>\\d{2}):(?P<seconds>\\d{2}) (?P<month>[a-zA-Z]{3}) (?P<day>\\d{1,}), (?P<year>\\d{4}) (?P<timezone>[a-zA-Z]{3})$",
        "MatchingText": "18:30:30 Jan 1, 2009 PST|||05:04:50 Apr 12, 2009 EDT",
        "NonMatchingText": "2:30:41 Aug 9, 2007 EST|||10:30:41 August 9, 2007 EST",
        "Description": "Breaks a PayPal IPN (instant payment notification) into it's respective parts via Groups."
    },
    {
        "Pattern": "^(?P<dayOfWeek>\\w{3}) (?P<monthName>\\w{3}) (?P<day>\\d{1,2}) (?P<year>\\d{4})? ?(?P<hours>\\d{1,2}):(?P<minutes>\\d{1,2}):(?P<seconds>\\d{1,2}) (GMT|UTC)(?P<timeZoneOffset>[-+]?\\d{4}) (?P<year>\\d{4})?\\(?(?P<timeZoneName>[a-zA-Z\\s]+)?\\)?$",
        "MatchingText": "Wed Jan 19 2005 01:30:00 GMT-0500 (Eastern Standard Time)|||Wed, 19 Jan 01:30:00 GMT+0800 2005",
        "NonMatchingText": "anything else",
        "Description": "Breaks JavaScript Date.toString() out into groups to allow easy reassembly. Works in FireFox 3.0.8, IE 8, Maxthon, Safari, and Chrome"
    },
    {
        "Pattern": "(?P<protocol>(http|ftp|https|ftps):\\/\\/)?(?P<site>[\\w\\-_\\.]+\\.(?P<tld>([0-9]{1,3})|([a-zA-Z]{2,3})|(aero|arpa|asia|coop|info|jobs|mobi|museum|name|travel))+(?P<port>:[0-9]+)?\\/?)((?P<resource>[\\w\\-\\.,@^%:/~\\+#]*[\\w\\-\\@^%/~\\+#])(?P<queryString>(\\?[a-zA-Z0-9\\[\\]\\-\\._+%\\$#\\~',]*=[a-zA-Z0-9\\[\\]\\-\\._+%\\$#\\~',]*)+(&[a-zA-Z0-9\\[\\]\\-\\._+%\\$#\\~',]*=[a-zA-Z0-9\\[\\]\\-\\._+%\\$#\\~',]*)*)?)?",
        "MatchingText": "google.com | http://mysite.org:80/thispage.asp | ftp://ftp.upload.com/",
        "NonMatchingText": "nomatchcom",
        "Description": "Based on the work of N H (http://regexlib.com/REDetails.aspx?regexp_id=96). Adds named groups including port and top-level-domain (tld), added ftps protocol, makes protocol optional, makes slash after site optional. Suggestions welcome."
    },
    {
        "Pattern": "((http|ftp|https|ftps):\\/\\/)?[\\w\\-_\\.]+\\.(([0-9]{1,3})|([a-zA-Z]{2,3})|(aero|arpa|asia|coop|info|jobs|mobi|museum|name|travel))+(:[0-9]+)?\\/?(([\\w\\-\\.,@^%:/~\\+#]*[\\w\\-\\@^%/~\\+#])((\\?[a-zA-Z0-9\\[\\]\\-\\._+%\\$#\\=~',]*=[a-zA-Z0-9\\[\\]\\-\\._+%\\$#\\=~',]*)+(&[a-zA-Z0-9\\[\\]\\-\\._+%\\$#\\=~',]*=[a-zA-Z0-9\\[\\]\\-\\._+%\\$#\\=~',]*)*)?)?",
        "MatchingText": "google.com | http://mysite.org:80/thispage.asp | ftp://ftp.upload.com/",
        "NonMatchingText": "nomatchcom",
        "Description": "Based on the work of N H (http://regexlib.com/REDetails.aspx?regexp_id=96). Added ftps protocol, makes protocol optional, makes slash after site optional."
    },
    {
        "Pattern": "\\?<.+?>",
        "MatchingText": "(?<myname>[a-zA-Z])",
        "NonMatchingText": "([a-zA-Z])",
        "Description": "Matches the name portion of a named group. Useful for \"cleaning\" regular expressions for use with ASP controls (since they don't support named groups)."
    },
    {
        "Pattern": "(?P<username>#?[+_a-zA-Z0-9+-]+(\\.[+_a-zA-Z0-9+-]+)*)@(?P<domain>[a-zA-Z0-9]+(-(-)|[a-zA-Z0-9\\.])*?[a-zA-Z0-9]+\\.([0-9]{1,3}|[a-zA-Z]{2,3}|(aero|arpa|asia|coop|info|jobs|mobi|museum|name|travel)))",
        "MatchingText": "my.address@domain.com | gmail+junkfilter@gmail.com | abc123@dont_email_me.com",
        "NonMatchingText": "myINV@LIDemail@poof.com | badDomain@a.com",
        "Description": "Matches valid emails. Suggestions welcome."
    },
    {
        "Pattern": "\\(?(?P<areacode>[1]?[2-9]\\d{2})\\)?[\\s-]?(?P<prefix>[2-9]\\d{2})[\\s-]?(?P<linenumber>[\\d]{4})",
        "MatchingText": "9875551212 | (987) 555-1212 | 987-555-1212",
        "NonMatchingText": "1234567890 | 987-123-5555",
        "Description": "Matches VALID 10 digit US phone numbers. Formatting characters are optional. Valid area codes and prefixes never begin with 0 or 1."
    },
    {
        "Pattern": "^([DFIOQU])([ABCEGHJ-NPRSTVXY]\\d[A-Z][ ]\\d[A-Z]\\d)$",
        "MatchingText": "A9A 9A9 | T3P 6N1",
        "NonMatchingText": "D9U 1O5",
        "Description": "Validates Canadian postal codes.\nFormat: A9A 9A9\nCannot contain: DFIOQU\nFirst letter must be one of: ABCEGHJKLMNPRSTVXY"
    },
    {
        "Pattern": "^-?(?:90(?:(?:\\.0{1,6})?)|(?:[0-9]|[1-8][0-9])(?:(?:\\.[0-9]{1,6})?))$",
        "MatchingText": "-90; -90.0; -89.99; 0; 0.000; 89.99; 90.0; 90",
        "NonMatchingText": "-100; -90.1; 90.01; 100",
        "Description": "[-90.000000 ... 90.000000]\n\nDecimal places: up to 6.\nYou can increase precision by replacing {1,6} with {1,your_number}"
    },
    {
        "Pattern": "^-?(?:180(?:(?:\\.0{1,6})?)|(?:[0-9]|[1-9][0-9]|1[1-7][0-9])(?:(?:\\.[0-9]{1,6})?))$",
        "MatchingText": "-180; -180.0; -179.99; 0.000; 179.99; 180.0; 180",
        "NonMatchingText": "-200; -180.1; 180.1; 200",
        "Description": "[-180.000000 ... 180.000000]\n\nDecimal places: up to 6.\nYou can increase precision by replacing {1,6} with {1,your_number}"
    },
    {
        "Pattern": "<\\s*/?\\s*\\w+(\\s*\\w+\\s*=\\s*(['\"][^'\"]*['\"]|[\\w#]+))*\\s*/?\\s*>",
        "MatchingText": "Color is &lt;font color =#880000 &gt;red &lt; / font &gt;",
        "NonMatchingText": "12 is < 20 and > 6",
        "Description": "This pattern can find any HTML tag. It supports attributes whose values may be enclosed between single or double quotes. It aslo support spaces between delimeters."
    },
    {
        "Pattern": "How do find the phone number for Quicken support? ",
        "MatchingText": "Quicken customer technical support chat number",
        "NonMatchingText": "An effective Quicken customer",
        "Description": "The Quickensupportnumber247.com is the right destination for Quicken customer technical support chat number. This is an effective strategy & Business Support Call on 1-800-277-6571."
    },
    {
        "Pattern": "(\\s{1,})",
        "MatchingText": "    (one or more spaces)",
        "NonMatchingText": "non-space",
        "Description": "Matches all chars that are made up of one or more spaces. I found this useful when people were trying to make string length bypasses using consecutive spaces."
    },
    {
        "Pattern": "^[a-zA-Z_]{1}[a-zA-Z0-9_@$#]*$",
        "MatchingText": "upApplicationReadContacts|||_Application_ReadContacts|||a_45$#z",
        "NonMatchingText": "upApplication ReadContacts|||$Application_ReadContacts|||a_45%$#z",
        "Description": "This Regex matches valid SQL identifiers, including names for Stored Procedures and the like. Note that local variables/parameters (which begin with an &quot;@&quot;) will not match this Regex, nor will temporary objects (beginning with a &quot;#&quot;), or global temporary objects (beginning with &quot;##&quot;). All other valid identifiers/variables/table names/stored procedure names/columns etc., will match. Please let me know if you find this useful or have any complaints - trash@primalblaze.com."
    },
    {
        "Pattern": "^\\(?([0-9]{3})\\)?[\\s\\.\\-]*([0-9]{3})[\\s\\.\\-]*([0-9]{4})$",
        "MatchingText": "(000) 000-0000, 0000000000, 000.000.0000",
        "NonMatchingText": "000/000/0000, 00a.000.000, +000.000.0000",
        "Description": "Basically I didn't like any of the regular expressions that were available because they all failed at parsing them into variables correctly...  This regular expression gives you the full match and then the 3 sections of digits seperately."
    },
    {
        "Pattern": "^\\s*(\\d{0,2})(\\.?(\\d*))?\\s*\\%?\\s*$",
        "MatchingText": "  10.5%, 1%, 1, .5,  .0555%",
        "NonMatchingText": "100%, -1%, -1, 200, 200.1",
        "Description": "Basically this matches into variables for percentages..  It allows as much whitespace before and after the expression.  $1 = Percent before decimal, $2 = percentage after decimal inc decimal, $3 = percentage after decimal. Disallowed anything past 99.99999 repeating percent.  No negative percents either.  Easy to implement but I do not need it."
    },
    {
        "Pattern": "(:[a-z]{1}[a-z1-9\\$#_]*){1,31}",
        "MatchingText": ":x|||:x1|||:x#2$",
        "NonMatchingText": ":1x|||:@x|||:*ac",
        "Description": "This matches oracle binding variables in SQL.  Not sure if it is the same with other RDBMS'"
    },
    {
        "Pattern": "^((((([1-9])|(0[1-9])|(1\\d)|(2[0-8]))/(([1-9])|(0[1-9])|(1[0-2])))|((31/(((0[13578])|([13578]))|(1[02])))|((29|30)/(((0[1,3-9])|([1,3-9]))|(1[0-2])))))/((20[0-9][0-9]))|(((([1-9])|(0[1-9])|(1\\d)|(2[0-8]))/(([1-9])|(0[1-9])|(1[0-2])))|((31/(((0[13578])|([13578]))|(1[02])))|((29|30)/(((0[1,3-9])|([1,3-9]))|(1[0-2])))))/((19[0-9][0-9]))|(29/(02|2)/20(([02468][048])|([13579][26])))|(29/(02|2)/19(([02468][048])|([13579][26]))))$",
        "MatchingText": "1/2/2004, 01/2/2004, 1/02/2004, 01/02/2004, 29/2/2004, 29/02/2009",
        "NonMatchingText": "1/2/04, 1/2/4",
        "Description": "Australian date format d/m/yyyy or dd/m/yyyy, d/mm/yyyy or dd/mm/yyyy. Valid dates from 1900 to 2099 including leap year. "
    },
    {
        "Pattern": "^(0?[1-9]|1[0-2])\\/(0?[1-9]|[1-2][0-9]|3[0-1])\\/(0[1-9]|[1-9][0-9]|175[3-9]|17[6-9][0-9]|1[8-9][0-9]{2}|[2-9][0-9]{3})$",
        "MatchingText": "01/01/1753|||9/2/09|||12/02/1980|||12/31/9999",
        "NonMatchingText": "1/1/1|||13/1/01|||01/0/2001|||12/31/1752|||1-1-1900",
        "Description": "Matches all dates (mm/dd/yyyy or mm/dd/yy) greater than or equal to the SQL minimum date of 01/01/1753 and less than or equal to 12/31/9999.  Does not check for leap years.  "
    },
    {
        "Pattern": "^\\w+[\\w-\\.]*\\@\\w+((-\\w+)|(\\w*))\\.[a-z]{2,3}$",
        "MatchingText": "bob-smith@foo.com|||bob.smith@foo.com|||bob_smith@foo.com",
        "NonMatchingText": "-smith@foo.com|||.smith@foo.com|||smith@foo_com",
        "Description": "Email validation.  With this short expression you can validate for proper email format.  It's short and accurate."
    },
    {
        "Pattern": "(^(\\d{2}.\\d{3}.\\d{3}/\\d{4}-\\d{2})|(\\d{14})$)|(^(\\d{3}.\\d{3}.\\d{3}-\\d{2})|(\\d{11})$)",
        "MatchingText": "00.000.000/0000-00|||123.456.789-98|||12345678901234",
        "NonMatchingText": "12.123.123.0001.12|||123.456.789.89",
        "Description": "Validador de CPF ou CNPJ brasileiro. Utilizado em campos que podem receber os dois valores, como um campo de busca, que pode buscar por CPF ou CNPJ, como era o meu caso.\n[00.000.000/0000-00],   [123.456.789-98],[00000000000000] e [12345678998]\n\nEnjoy! =)"
    },
    {
        "Pattern": "^([1-9]{1}[\\d]{0,2}(\\.[\\d]{3})*(\\,[\\d]{0,2})?|[1-9]{1}[\\d]{0,}(\\,[\\d]{0,2})?|0(\\,[\\d]{0,2})?|(\\,[\\d]{1,2})?)$",
        "MatchingText": "123,02|||123.456,02|||123.456.789,02",
        "NonMatchingText": "123,003|||123,123.02",
        "Description": "Numera&#231;&#227;o usar para valores moeda brasileira e de outras regi&#245;es. Dinheiro, money...\n\nEnjoy! =)"
    },
    {
        "Pattern": "Juveniste serum Antioxidants protect against harmful poisons and other harmful allergens. Manuka honey, natural vitamin E, and witch hazel (for men) are extremely powerful antioxidants anyone stimulate your immune physique.   I suppose you could say you're getting an epidermis lightener to fade brown spots and an element that soothes your skin safely and effectively and still.   The best oil control foundation On the net is Cover Girl Clean Makeup Oil Control. The makeup is extensive clean, feels fresh, and continues to be able to fresh for hours on end. If I need a touchup I use Cover Girl Fresh Look Pressed Powdered ingredients.  Choosing The Cleanser For Acne Prone Skin Reading an anti aging skin care review will for sure give you so many details. When you consider an appropriate anti aging skin care system, the buyer has to be considered. What is your natural color? An individual been allergic to your of components? Wait, were you thinking of ordering something without reading the title?   Green tea has been known as the healthy drink for the body. This tea provides a collection of different of benefits especially for your skin. This is known avoid certain pores and skin cancers as it is loaded by using a variety of anti-oxidants. That is the common ingredient in Skin Care products.   At Skin Deep, I learned that lotions to make use of in Avon's and L'oreal's anti aging skin care system are ranked as highly harmful. I also learned that L'oreal uses animals for testing. I'm sure the requirement testing, but a cosmetic should be secure enough to attempt on human skin.   Whole grains are present in our diet almost day by day. They could be found utilizing some breads and cereals. These types of loaded with group B vitamins have got essential for normal skin functioning. They may be necessary for the growth most recent cells change those have got died. Whole grain products strengthen skin which helps with preventing peeling and fantastic.  https://beaudermaskincare.com/juveniste-serum/",
        "MatchingText": "5",
        "NonMatchingText": "5",
        "Description": "Juveniste serum\nAntioxidants protect against harmful poisons and other harmful allergens. Manuka honey, natural vitamin E, and witch hazel (for men) are extremely powerful antioxidants anyone stimulate your immune physique.\n \nI suppose you could say you're getting an epidermis lightener to fade brown spots and an element that soothes your skin safely and effectively and still.\n \nThe best oil control foundation On the net is Cover Girl Clean Makeup Oil Control. The makeup is extensive clean, feels fresh, and continues to be able to fresh for hours on end. If I need a touchup I use Cover Girl Fresh Look Pressed Powdered ingredients.\n\nChoosing The Cleanser For Acne Prone Skin\nReading an anti aging skin care review will for sure give you so many details. When you consider an appropriate anti aging skin care system, the buyer has to be considered. What is your natural color? An individual been allergic to your of components? Wait, were you thinking of ordering something without reading the title?\n \nGreen tea has been known as the healthy drink for the body. This tea provides a collection of different of benefits especially for your skin. This is known avoid certain pores and skin cancers as it is loaded by using a variety of anti-oxidants. That is the common ingredient in Skin Care products.\n \nAt Skin Deep, I learned that lotions to make use of in Avon's and L'oreal's anti aging skin care system are ranked as highly harmful. I also learned that L'oreal uses animals for testing. I'm sure the requirement testing, but a cosmetic should be secure enough to attempt on human skin.\n \nWhole grains are present in our diet almost day by day. They could be found utilizing some breads and cereals. These types of loaded with group B vitamins have got essential for normal skin functioning. They may be necessary for the growth most recent cells change those have got died. Whole grain products strengthen skin which helps with preventing peeling and fantastic.\n\nhttps://beaudermaskincare.com/juveniste-serum/"
    },
    {
        "Pattern": "^.+@[^\\.].*\\.[a-z]{2,}$",
        "MatchingText": "whatever@somewhere.museum|||foreignchars@myforeigncharsdomain.nu|||me+mysomething@mydomain.com",
        "NonMatchingText": "a@b.c|||me@.my.com|||a@b.comFOREIGNCHAR",
        "Description": "Most email validation regexps are outdated and ignore the fact that domain names can contain any foreign character these days, as well as the fact that anything before @ is acceptable. The only roman alphabet restriction is in the TLD, which for a long time has been more than 2 or 3 chars (.museum, .aero, .info). The only dot restriction is that . cannot be placed directly after @.\n\nThis pattern captures any valid, reallife email adress."
    },
    {
        "Pattern": "^0$|^0\\.{1}(\\d{1,2})$|^[1-9]{1}[0-9]*\\.?(\\d{1,2})$|^[1-9]+[0-9]*$",
        "MatchingText": "0.4 | 50.76 | 100 | 120.00 | 0 | 0.00",
        "NonMatchingText": "+5 | .32 | 00 | 15.123 | -5 | 4.",
        "Description": "Matches any non-negative, non-signed real number with maximum of 2 decimal spaces. The decimal is denoted by a . symbol."
    },
    {
        "Pattern": "^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w ]*))+\\.(txt|TXT)$",
        "MatchingText": "c:\\file.txt|||c:\\folder\\sub folder\\file.txt|||\\\\network\\folder\\file.txt",
        "NonMatchingText": "C:|||C:\\file.xls|||folder.txt",
        "Description": "This RE validates a path/file of type txt (text file)\nThis RE can be used as a filter on certain file types, while insuring the entire string is a fully qualified path and file. The filter value can be changed or added to as you need"
    },
    {
        "Pattern": "^\\$(\\d{1,3}(\\,\\d{3})*|(\\d+))(\\.\\d{2})?$",
        "MatchingText": "$0.84|||$123458|||$1,234,567.89",
        "NonMatchingText": "$12,3456.01|||12345|||$1.234",
        "Description": "This re matches US currency format with lead dollar sign. Dollar value must have at least one digit and may or may not be comma separated. Cents value is optional."
    },
    {
        "Pattern": "^(Sun|Mon|(T(ues|hurs))|Fri)(day|\\.)?$|Wed(\\.|nesday)?$|Sat(\\.|urday)?$|T((ue?)|(hu?r?))\\.?$",
        "MatchingText": "Sunday|||Mon|||Tu",
        "NonMatchingText": "day|||Wedday|||Payday",
        "Description": "This RE matches Days of the week or their abbreviations."
    },
    {
        "Pattern": "^(?:J(anuary|u(ne|ly))|February|Ma(rch|y)|A(pril|ugust)|(((Sept|Nov|Dec)em)|Octo)ber)$",
        "MatchingText": "January|||May|||October",
        "NonMatchingText": "Jan|||Septem|||Octo",
        "Description": "This RE validate the full name of the months."
    },
    {
        "Pattern": "^((0?[1-9]|1[012])(:[0-5]\\d){0,2}(\\ [AP]M))$|^([01]\\d|2[0-3])(:[0-5]\\d){0,2}$",
        "MatchingText": "1 AM|||23:00:00|||5:29:59 PM",
        "NonMatchingText": "13 PM|||13:60:00|||00:00:00 AM",
        "Description": "This RE validates times patterns."
    },
    {
        "Pattern": "^((?:[a-zA-Z]:)|(?:\\\\{2}\\w[-\\w]*)\\$?)\\\\(\\.)((?:([\\\\/:*?<>\"|])([.\\x20](?:\\\\|$))[\\x20-\\x7E])+\\\\(\\.))*((?:(?:([\\\\/:*?<>\"|])([ .]$)[\\x20-\\x7E])+)\\.((?:([\\\\/:*?<>\"|])([ .]$)[\\x20-\\x7E]){2,15}))?$",
        "MatchingText": "C:\\|||\\\\Server\\share\\path\\File.txt|||E:\\My Files\\Are\\#1\\",
        "NonMatchingText": "C:|||C:\\\\\\|||C:\\Trailing Space \\",
        "Description": "Matches drives, folders and file on a Windows OS. Folder matches must end with \\\nFolder and file names can not end with a space.\nI limited the file extension length to 15  though that not a restriction of a file's extension \nThis is a mod of Darren's regex http://www.regexlib.com/REDetails.aspx?regexp_id=357\nand my own http://www.regexlib.com/REDetails.aspx?regexp_id=137\n\nUpdated Feb 2005"
    },
    {
        "Pattern": "\\p{N}",
        "MatchingText": "123890|||?|||&#189;",
        "NonMatchingText": "AAABB|||IV|||Ten",
        "Description": "Matches numbers.  Note: the second match (?) and the second non-match (IV) are not the same. I cover this in more detail here http://blogs.regexadvice.com/mash/archive/2004/04/17/988.aspx"
    },
    {
        "Pattern": "\\p{Sm}",
        "MatchingText": "+=|||-|||&#177;  v  =",
        "NonMatchingText": "1|||-|||1x2",
        "Description": "Math Symbols.  NOTE: the second examples of match and non-match are not the same.  The non-match is the keyboard dash.  The match is the unicode minus sign.\n"
    },
    {
        "Pattern": "(<\\/?)(?i:(?P<element>a(bbr|cronym|ddress|pplet|rea)?|b(ase(font)?|do|ig|lockquote|ody|r|utton)?|c(aption|enter|ite|(o(de|l(group)?)))|d(d|el|fn|i(r|v)|l|t)|em|f(ieldset|o(nt|rm)|rame(set)?)|h([1-6]|ead|r|tml)|i(frame|mg|n(put|s)|sindex)?|kbd|l(abel|egend|i(nk)?)|m(ap|e(nu|ta))|no(frames|script)|o(bject|l|pt(group|ion))|p(aram|re)?|q|s(amp|cript|elect|mall|pan|t(r(ike|ong)|yle)|u(b|p))|t(able|body|d|extarea|foot|h|itle|r|t)|u(l)?|var))(\\s(?P<attr>.+?))*>",
        "MatchingText": "<HTML>|||<a href=\"link.html\">Link</a>",
        "NonMatchingText": "<xml>|||<phonytag>|||<image>",
        "Description": "This RE will match all the valid elements in HTML 4.01"
    },
    {
        "Pattern": "(?i:on(blur|c(hange|lick)|dblclick|focus|keypress|(key|mouse)(down|up)|(un)?load|mouse(move|o(ut|ver))|reset|s(elect|ubmit)))",
        "MatchingText": "onclick|||onsubmit|||onmouseover",
        "NonMatchingText": "click|||onandon|||mickeymouse",
        "Description": "This regex will match all the valid on event attributes in HTML 4.01/XHTML 1.0"
    },
    {
        "Pattern": "^(?-i:A[LKSZRAEP]|C[AOT]|D[EC]|F[LM]|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEHINOPST]|N[CDEHJMVY]|O[HKR]|P[ARW]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$",
        "MatchingText": "AL|||CA|||AA",
        "NonMatchingText": "New York|||California|||ny",
        "Description": "The RE match U.S. state abbreviation used by the U.S. Post Office."
    },
    {
        "Pattern": "\\b-?[1-9](?:\\.\\d+)?[Ee][-+]?\\d+\\b",
        "MatchingText": "3.7E-11|||-2.384E-03|||9.4608e15",
        "NonMatchingText": "3.7 X 10-11|||-23.84E-02|||9.4608 x 1015",
        "Description": "Matches standard scientific notation using E character\nScientific notation involves writing a number as the product of two numbers. The first one, the digit value, is always more than one and less than 10. The other, the exponential term, is expressed as a power of 10."
    },
    {
        "Pattern": "^(?:[ -~]{10,25}(?:$|(?:[\\w!?.])\\s))",
        "MatchingText": "This is just a simple sample",
        "NonMatchingText": "A sample",
        "Description": "Word Break.  This regex can be used to break a long line of text on a full word. The qualifiers specify the minimum and maximum number of character allow before the break and can be changed according to your need. Blogge about this here http://regexadvice.com/blogs/mash/archive/2005/02/09/324.aspx"
    },
    {
        "Pattern": "(a(?:[cdefgilmnoqrstuwxz]|ero|(?:rp|si)a)|b(?:[abdefghijmnorstvwyz]iz)|c(?:[acdfghiklmnoruvxyz]|at|o(?:m|op))|d[ejkmoz]|e(?:[ceghrstu]|du)|f[ijkmor]|g(?:[abdefghilmnpqrstuwy]|ov)|h[kmnrtu]|i(?:[delmnoqrst]|n(?:fo|t))|j(?:[emop]|obs)|k[eghimnprwyz]|l[abcikrstuvy]|m(?:[acdeghklmnopqrstuvwxyz]|il|obi|useum)|n(?:[acefgilopruz]|ame|et)|o(?:m|rg)|p(?:[aefghklmnrstwy]|ro)|qa|r[eosuw]|s[abcdeghijklmnortuvyz]|t(?:[cdfghjklmnoprtvwz]|(?:rav)?el)|u[agkmsyz]|v[aceginu]|w[fs]|y[etu]|z[amw])",
        "MatchingText": "all ccTLDs (Country-Code Top-Level Domains) | all gTLDs (Generic Top-Level Domains) | .arpa",
        "NonMatchingText": "n.o.n - e.x.i.s.t.i.n.g   T.L.D.s",
        "Description": "This regexp matches all existing TLDs (Top-Level Domains) according to IANA specifications as of 14/07/2007."
    },
    {
        "Pattern": "(?:-(0))?\\d+(?:(?: \\d+)?/\\d+)?",
        "MatchingText": "-1, 1, -1/2, 1/2, -1 2/3, 1 2/3 | 0, 0/1, 1/0, 1 0/2, 1 2/0",
        "NonMatchingText": "letters | negative zero | / | #/ | /# | # / | # #/ | # /#",
        "Description": "This regexp matches string which represents a fraction.\nThis fraction can be in these forms:<br />\n1. # or -# (not -0)<br />\n2. #/# or -#/# (not -0/#)<br />\n3. # #/# or -# #/# (not -0 #/#)"
    },
    {
        "Pattern": "([A-HJ-PR-Y]{2}([0][1-9]|[1-9][0-9])|[A-HJ-PR-Y]{1}([1-9]|[1-2][0-9]|30|31|33|40|44|55|50|60|66|70|77|80|88|90|99|111|121|123|222|321|333|444|555|666|777|888|999|100|200|300|400|500|600|700|800|900))[ ][A-HJ-PR-Z]{3}$",
        "MatchingText": "AB12 RCY|||CD07 TES|||S33 GTT|||Y999 FVB",
        "NonMatchingText": "ab12 rcy|||CD07 TIS|||S34 GTT|||Z999 FVB",
        "Description": "UK Vehicle Registration Plate / Number Plate format as specified by the DVLA. Accepts both \"Prefix\" and \"New\" style. Allows only valid DVLA number combinations as not all are supported. Registration number must be exactly as is displayed on car, hence all letters must be in uppercase and a space seperating the two sets of characters."
    },
    {
        "Pattern": "^((?:\\+27|27)|0)(\\d{2})-?(\\d{3})-?(\\d{4})$",
        "MatchingText": "0111231234|||011 123 1234|||011-123-1234|||0821231234|||+27821231234|||+2782-123-1234|||+2782 123 1234|||27111231234|||2711 123 1234|||2711-123-1234",
        "NonMatchingText": "(011)1231234|||(+2711) 123 1234|||(011) 123-1234",
        "Description": "Matches South African telephone/mobile numbers, with or without the country code. Can also include spaces or hyphens between values. Doesn't match brackets around the area code, but that would be easy to add in. Hope it helps someone..."
    },
    {
        "Pattern": "^\\d{3}-\\d{2}-\\d{4}$",
        "MatchingText": "333-22-4444|||123-45-6789",
        "NonMatchingText": "123456789|||SSN",
        "Description": "This regular expression will match a hyphen-separated Social Security Number (SSN) in the format NNN-NN-NNNN."
    },
    {
        "Pattern": "[0-9.\\-/+() ]{4,}",
        "MatchingText": "+49 (0)40/529 567-31; 529 567-31 ",
        "NonMatchingText": "529",
        "Description": "This regex supports international praefix, the national (0) and extension numbers."
    },
    {
        "Pattern": "[D]?[-D]?[0-9]{5}",
        "MatchingText": "D-25335; 25335",
        "NonMatchingText": "5335",
        "Description": "German postal code with or without national praefix. "
    },
    {
        "Pattern": "^(([A-Z]{1,2}[0-9]{1,2})|([A-Z]{1,2}[0-9][A-Z]))\\s?([0-9][A-Z]{2})$",
        "MatchingText": "A11AA|||AA1A 1AA|||AA11 1AA",
        "NonMatchingText": "AAA 1AA|||AA11A 1AA|||AAA1AA",
        "Description": "Matches UK postcodes of the below formats. The space is optional.\nAN NAA\nAAN NAA\nANN NAA\nANA NAA\nAANA NAA\nAANN NAA\n"
    },
    {
        "Pattern": "^09(73|74|05|06|15|16|17|26|27|35|36|37|79|38|07|08|09|10|12|18|19|20|21|28|29|30|38|39|89|99|22|23|32|33)\\d{3}\\s?\\d{4} ",
        "MatchingText": "09171234567 ||| 0905 123 4567",
        "NonMatchingText": "+639111111 ||| 09011234567 ||| 0915 1234 23 2",
        "Description": "Validates a Philippine mobile phone number without International code.\n\nIncludes country's six area codes for mobile phones: Express Telecom, Globe Telecom, Next Mobile, Red Mobile, Smart Communications and Sun Cellular"
    },
    {
        "Pattern": "^([A-Z|a-z|&amp;]{3})(([0-9]{2})([0][13456789]|[1][012])([0][1-9]|[12][\\d]|[3][0])|([0-9]{2})([0][13578]|[1][02])([0][1-9]|[12][\\d]|[3][01])|([02468][048]|[13579][26])([0][2])([0][1-9]|[12][\\d])|([1-9]{2})([0][2])([0][1-9]|[12][0-8]))(\\w{2}[A|a|0-9]{1})$|^([A-Z|a-z]{4})(([0-9]{2})([0][13456789]|[1][012])([0][1-9]|[12][\\d]|[3][0])|([0-9]{2})([0][13578]|[1][02])([0][1-9]|[12][\\d]|[3][01])|([02468][048]|[13579][26])([0][2])([0][1-9]|[12][\\d])|([1-9]{2})([0][2])([0][1-9]|[12][0-8]))((\\w{2})([A|a|0-9]{1})){0,3}$",
        "MatchingText": "ABCD790419 | ABC790419aa1 |ABC800229aa1",
        "NonMatchingText": "AB790419 | A12790419 | ABC791332",
        "Description": "Registro Federal de Contribuyentes (RFC) , used in Mexico as a unique set of characters for a person or corporation registration . Registro Federal de Contribuyentes utilizado en Mexico para el registro en hacienda\n\n(includes leap years)"
    },
    {
        "Pattern": "^(0[1-9]|[12][0-9]|3[01])[\\s\\.\\-/](J(anuary|uly|an|AN)|M(arch|ar|AR|ay|AY)|A(ugust|ug|UG)|(O(ctober|ct|CT)|(D(ecember|ec|EC))))[\\s\\.\\-/][1-9][0-9]{3}|(0[1-9]|[12][0-9]|30)[\\s\\.\\-/](A(pril|pr|PR)|J(une|un|UN)|S(eptember|ep|EP)|N(ovember|ov|OV))[\\s\\.\\-/][1-9][0-9]{3}|(0[1-9]|1[0-9]|2[0-8])[\\s\\.\\-/]F(ebruary|eb|EB)[\\s\\.\\-/][1-9][0-9]{3}|29[\\s\\.\\-/]F(ebruary|eb|EB)[\\s\\.\\-/]((0[48]|[2468][048]|[13579][26])00|[0-9]{2}(0[48]|[2468][048]|[13579][26]))$",
        "MatchingText": "05 March 2012 | 29-Feb-2012 | 31.DEC.2011",
        "NonMatchingText": "32 March 2012 | 29-Feb-2011 | 2011.DEC.31",
        "Description": "Verifies all valid Gregorian dates of the form DD MONTH YYYY, and short month names, taking days/month and leap years into account. Accepts space, -, . and / between paramters."
    },
    {
        "Pattern": "^([0-9]?[0-9]?[0-9]?\\\\.)?(\\\\d{3})$*(,\\\\d{2})",
        "MatchingText": "100,00 ||| 1.000,00 ||| 999.999,99",
        "NonMatchingText": "1 ||| 10 ||| 10.00 ||| 10,00 ||| 100 ||| 1000 ||| 1.000 ||| 1,000.00",
        "Description": "Match a number over 99,99 with the comma and dot mandatory."
    },
    {
        "Pattern": "^(((0?[1-9]|1[012])/(0?[1-9]|1\\d|2[0-8])|(0?[13456789]|1[012])/(29|30)|(0?[13578]|1[02])/31)/(19|[2-9]\\d)\\d{2}|0?2/29/((19|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$",
        "MatchingText": "01/31/1905|||1/9/1900|||2/29/1904",
        "NonMatchingText": "31/01/2005|||02/29/2005|||2/29/2005",
        "Description": "MM/dd/yyyy with 100% leap years. Valid since year 1900.\nMM and DD could have 1 or 2 digits : M/d/yyyy or MM/d/yyyy or M/dd/yyyy\n\nThis was a request from a user in http://www.regexlib.com/REDetails.aspx?regexp_id=1038"
    },
    {
        "Pattern": "^(((0[1-9]|[12]\\d|3[01])\\/(0[13578]|1[02])\\/((19|[2-9]\\d)\\d{2}))|((0[1-9]|[12]\\d|30)\\/(0[13456789]|1[012])\\/((19|[2-9]\\d)\\d{2}))|((0[1-9]|1\\d|2[0-8])\\/02\\/((19|[2-9]\\d)\\d{2}))|(29\\/02\\/((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "MatchingText": "29/02/2000|||30/04/2003|||01/01/2003",
        "NonMatchingText": "29/02/2001|||30-04-2003|||1/1/1899",
        "Description": "dd/MM/yyyy with leap years 100% integrated Valid years : from 1900 to 9999.\nAs usual, many tests have been made.\n\nThis was requested by a user :\nhttp://www.regexlib.com/REDetails.aspx?regexp_id=409"
    },
    {
        "Pattern": "^([2-9]\\d{3}((0[1-9]|1[012])(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|(([2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00))0229)$",
        "MatchingText": "20000101|||20051231|||20040229",
        "NonMatchingText": "19990101|||20053112|||20050229",
        "Description": "yyyyMMdd with leap year validation, starting from year 2000 only.\nThe length of the expression is minimized, but still validates all entries.\nIf you want it with years like 1600 or separators, just ask :)"
    },
    {
        "Pattern": "^(\\d{2}((0[1-9]|1[012])(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])(29|30)|(0[13578]|1[02])31)|([02468][048]|[13579][26])0229)$",
        "MatchingText": "001231|||000229|||040229",
        "NonMatchingText": "003112|||000431|||010229",
        "Description": "yyMMdd with leap years.\nMinimized expression.\nAs we have only 2 numbers for the years, dates 1600, 2000, etc are still validated."
    },
    {
        "Pattern": "^([01]\\d|2[0123])([0-5]\\d){2}$",
        "MatchingText": "235959|||000000|||012345",
        "NonMatchingText": "240000|||23:59:59|||236060",
        "Description": "HHmmss without any separators. Hours in 24h format."
    },
    {
        "Pattern": "^(((0[1-9]|1[012])/(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])/(29|30)|(0[13578]|1[02])/31)/[2-9]\\d{3}|02/29/(([2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$",
        "MatchingText": "02/29/2000|||02/29/2004|||12/31/2001",
        "NonMatchingText": "02/29/2100|||02/29/2001|||1/1/2001",
        "Description": "MM/dd/yyyy with 100% leap year validation starting from year 2000.\n\nIf this one doesn't fit your needs, just tell me.\nSorry for starting &quot;only&quot; from year 2000, this is so simple to change this, please ask if needed.\nEnjoy"
    },
    {
        "Pattern": "^((\\d{2}((0[13578]|1[02])(0[1-9]|[12]\\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\\d|30)|02(0[1-9]|1\\d|2[0-8])))|([02468][048]|[13579][26])0229)$",
        "MatchingText": "751231|||000229|||040229",
        "NonMatchingText": "750431|||010229|||050229",
        "Description": "Date expression validator with format YYMMDD\nValidates leap years.\nOf course, as year has only 2 digits, it's not possible to invalidate years like 2100, 2200, 2300, etc as a non-leap years !"
    },
    {
        "Pattern": "^((((0?[1-9]|[12]\\d|3[01])[\\.\\-\\/](0?[13578]|1[02])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|[12]\\d|30)[\\.\\-\\/](0?[13456789]|1[012])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|1\\d|2[0-8])[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|(29[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00)))|(((0[1-9]|[12]\\d|3[01])(0[13578]|1[02])((1[6-9]|[2-9]\\d)?\\d{2}))|((0[1-9]|[12]\\d|30)(0[13456789]|1[012])((1[6-9]|[2-9]\\d)?\\d{2}))|((0[1-9]|1\\d|2[0-8])02((1[6-9]|[2-9]\\d)?\\d{2}))|(2902((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00))))$",
        "MatchingText": "29.2.2004|||31121975|||29/2-00",
        "NonMatchingText": "29.2.2005|||32121975|||29.2/01",
        "Description": "Date with leap years. Accepts '.' '-' and '/' as separators\nd.m.yy to dd.mm.yyyy (or d.mm.yy, etc)\nEx: dd-mm-yyyy   d.mm/yy   dd/m.yyyy  etc etc\nAccept 00 years also."
    },
    {
        "Pattern": "^(((0[1-9]|[12]\\d|3[01])\\/(0[13578]|1[02])\\/((1[6-9]|[2-9]\\d)\\d{2}))|((0[1-9]|[12]\\d|30)\\/(0[13456789]|1[012])\\/((1[6-9]|[2-9]\\d)\\d{2}))|((0[1-9]|1\\d|2[0-8])\\/02\\/((1[6-9]|[2-9]\\d)\\d{2}))|(29\\/02\\/((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))$",
        "MatchingText": "29/02/2000|||30/04/2003|||01/01/2003",
        "NonMatchingText": "29/02/2001|||30-04-2003|||1/1/2003",
        "Description": "dd/MM/yyyy with leap years 100% integrated\nValid years : from 1600 to 9999\n\nAs usual, many tests have been made.\nI think this one should be fine.\n\n"
    },
    {
        "Pattern": "^(((0[1-9]|[12]\\d|3[01])\\/(0[13578]|1[02])\\/(\\d{2}))|((0[1-9]|[12]\\d|30)\\/(0[13456789]|1[012])\\/(\\d{2}))|((0[1-9]|1\\d|2[0-8])\\/02\\/(\\d{2}))|(29\\/02\\/((0[48]|[2468][048]|[13579][26])|(00))))$",
        "MatchingText": "31/12/75|||29/02/00|||29/02/04",
        "NonMatchingText": "01/13/01|||29/02/01|||29/02/2004",
        "Description": "Matching : dd/MM/yy\nLeap years compatible\nItalian style, just for more fun.\nPlease, don't forget to rate it if you use it. THX\n"
    },
    {
        "Pattern": "^(((0?[1-9]|[12]\\d|3[01])[\\.\\-\\/](0?[13578]|1[02])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|[12]\\d|30)[\\.\\-\\/](0?[13456789]|1[012])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|((0?[1-9]|1\\d|2[0-8])[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}))|(29[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00)))$",
        "MatchingText": "29.2.04|||29/02-2004|||3.4.05",
        "NonMatchingText": "29.2.03|||2902.2004|||12.31.1975",
        "Description": "DD.MM.YY or DD.MM.YYYY\nseparator could be on choice '.' '/' or '-'\n\nleap years compatible, 00 is treated as year 2000."
    },
    {
        "Pattern": "^(((0?[1-9]|[12]\\d|3[01])[\\.\\-\\/](0?[13578]|1[02])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}|\\d))|((0?[1-9]|[12]\\d|30)[\\.\\-\\/](0?[13456789]|1[012])[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}|\\d))|((0?[1-9]|1\\d|2[0-8])[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?\\d{2}|\\d))|(29[\\.\\-\\/]0?2[\\.\\-\\/]((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00)|00|[048])))$",
        "MatchingText": "1/1/2005|||29/02/12|||29/02/2400",
        "NonMatchingText": "29/2/2005|||29/02/13|||29/02/2200",
        "Description": "This regexp has been posted specialy for &quot;Mike O Shea&quot; as he requested a mono digit year validation.\n\nmatches DD/MM/Y or DD/MM/YYYY or D/M/Y or DD/M/YYYY\nLeap years treated. (Italian style with tomato)\nYears 0-9 equal years 2000 to 2009 for leap years"
    },
    {
        "Pattern": "((?P<strPOBox>((POBox|PO\\sBox)\\s*\\d*)),?\\s?)?(((?P<strUnit>([\\w\\d\\s\\,]*)),\\s?)?( (?P<strStreet>([\\w\\s\\-]*\\w\\s(st\\s)?[\\w]*\\s(street|st|road|rd|close|cl|avenue|ave|av|path|ph|drive|drv|LOOP|COURT|CT|CIRCLE|LANE|LN))  ),?\\s?))?((?P<strTown>([\\p{Ll}\\p{Lu}\\p{Lo}\\p{Pc}\\p{Lt}\\p{Lm}\\s]*)),?\\s?)?((?P<strState>(Victoria|VIC|New South Wales|NSW|South Australia|SA|Northern Territory|NT|West Australia|WA|Tasmania|TAS|ACT|Queensland|QLD))\\s*)?(?P<strPostalCode>(\\d{4}),?\\s?)?(?P<strCountry>(Australia))?",
        "MatchingText": "Shop S1, Sussex Centre, 401 Sussex St, Sydney|||28 Lidco Street, Arndell Park, Sydney 2148|||Level 1, 198 Elizabeth St, Surry Hills 2010|||Room 2, Level 1, 198 Elizabeth St, Surry Hills, NSW 2010|||541 Pittwater Rd, Brookvale 2100|||2 Maniangi Court, Macedon, 3440|||PO Box 1531, Keveland, QLD 4163|||St Lucia Golf Links, 22 St George St, St Lucia, QLD|||PO Box 1531, St Lucia, QLD 4163",
        "NonMatchingText": "No man land",
        "Description": "This regular expression using named groups returns semantic tokens and is designed for Australian addresses in one line. Any part of an address may be omitted, as long as parts are in minor to major order. It should not be difficult to modify the regular express for analysing multi-line addresses. With a little modification, this regex may work for other postal address formats in minor to major order. The syntax is based on dot Net regular expression, with \"options = RegexOptions.IgnoreCase | RegexOptions.Multiline | RegexOptions.IgnorePatternWhitespace\". The order is \n[POBox][ExtAdr][Street][Town][State][PostalCode][Country]."
    },
    {
        "Pattern": "(?:[Yy][Oo][Uu][Tt][Uu][Bb][Ee]\\.[Cc][Oo][Mm]/watch\\?v=)([\\w-]{11})",
        "MatchingText": "http://www.youtube.com/watch?v=pW2GSdxxwDg ||| http://www.youtube.com/watch?v=-7P7_kxZQ5I ||| http://www.youtube.com/watch?v=7sPKHwsupmQ&playnext=1&list=PL40CB7986D1A9A285 ||| http://www.youtube.com/watch?v=r-di4gJvq4Q&feature=channel_video_title",
        "NonMatchingText": "http://www.youtu.be/watch?v=pW2GSdxxwDg",
        "Description": ".NET 3.5 Tested. Used to extract the YouTubeID from a fully qualified YouTube URL.\n\nDim _Regex As New Regex(\"(?:[Yy][Oo][Uu][Tt][Uu][Bb][Ee]\\.[Cc][Oo][Mm]/watch\\?v=)([\\w-]{11})\", RegexOptions.IgnoreCase Or RegexOptions.Compiled)\nDim _RegexMatch As Match = _Regex.Match(\"http://www.youtube.com/watch?v=pW2GSdxxwDg\")\nDim _YouTubeVideoID As System.String = _RegexMatch.Groups(1).Value\n"
    },
    {
        "Pattern": "'('{2})*([^'\\r\\n]*)('{2})*([^'\\r\\n]*)('{2})*'",
        "MatchingText": "'''abc' | 'abc' | 'a''bc' | 'abc''' | ''''",
        "NonMatchingText": "abc | 'abc | '''ab",
        "Description": "Mach with constant string in SQL style."
    },
    {
        "Pattern": "(^\\([0]\\d{1}\\))(\\d{7}$)|(^\\([0][2]\\d{1}\\))(\\d{6,8}$)|([0][8][0][0])([\\s])(\\d{5,8}$)",
        "MatchingText": "(09)1234567 | (021)123456 | (021)1234567 | (027)123456 | 0800 12345 | 0800 123457 ",
        "NonMatchingText": "(09)123456  | (021)12345  | (031)1234567 | (027)12345  | 0800-12345 | 0800123457 ",
        "Description": "Matches New Zealand local, mobile and freecall (0800) phone numbers. "
    },
    {
        "Pattern": "^[0-9]%?$|^1[0-9]%?$|^2[0-9]%?$|^3[0-5]%?$|^[0-9]\\.\\d{1,2}%?$|^1[0-9]\\.\\d{1,2}%?$|^2[0-9]\\.\\d{1,2}%?$|^3[0-4]\\.\\d{1,2}%?$|^35%?$",
        "MatchingText": "32.34%, 32.34, 32, 32%",
        "NonMatchingText": "32.345%, 36, .34",
        "Description": "A range of numbers 0-35 optionally including a percent sign and 2 position decimal."
    },
    {
        "Pattern": "^(([0]?[1-9])|(1[0-2]))\\/(([0]?[1-9])|([1,2]\\d{1})|([3][0,1]))\\/[12]\\d{3}$",
        "MatchingText": "1/1/1999|||01/01/2001|||12/31/1900",
        "NonMatchingText": "00/12/0999|||13/1/2000|||10/0/2009",
        "Description": "This regular expression matches the format MM/DD/YYYY. Month and Day can have an optional leading 0. Months are from 01-12, days are from 01-31, and years are from 1000-2999."
    },
    {
        "Pattern": "(^(09|9)[1][1-9]\\\\d{7}$)|(^(09|9)[3][12456]\\\\d{7}$)",
        "MatchingText": "09122838473 | 9122838473 | 09369048504",
        "NonMatchingText": "+989122838473 | 22248016 | 12345",
        "Description": "This Regular Expression Chack Matching Persian Mobile Numbers\nIt is Checking MCI,MTN Irancell and Talya Operators\nFor Example In C#.NET:\nRegex.IsMatch(MobileNumber, \"(^(09|9)[1][1-9]\\\\d{7}$)|(^(09|9)[3][12456]\\\\d{7}$)\");\n"
    },
    {
        "Pattern": "<[^>]*>",
        "MatchingText": "<p> Hello Ali Delshad </p>",
        "NonMatchingText": "Hello Ali Delshad",
        "Description": "This Regex Will Remove All Html Tags And Return Simple Plain Text .\nFor Example In C#.NET :\nRegex.Replace(Html, \"<[^>]*>\", string.Empty);"
    },
    {
        "Pattern": "^([0-9a-fA-F]){8}$",
        "MatchingText": "8ECCA04F|||82E5AAA4|||82e5aaa4",
        "NonMatchingText": "8ECCAOF|||82E5AA4|||82e5aaa45",
        "Description": "Hex number/string validation method for the Electronic Serial Number(ESN) used in Cellular Phone products."
    },
    {
        "Pattern": "^([0-7])*$\n",
        "MatchingText": "1357|||445005|||101",
        "NonMatchingText": "900508|||7FFF|||599D",
        "Description": "Expression validating a octal string of any length."
    },
    {
        "Pattern": "^([0-9a-fA-F])*$",
        "MatchingText": "1E3|||82E5AAA4|||01ff",
        "NonMatchingText": "1g3|||4Z|||01x",
        "Description": "Expression validating a hex string of any length."
    },
    {
        "Pattern": "^(\\$|R\\$|\\-\\$|\\-R\\$|\\$\\-|R\\$\\-|-)?([0-9]{1}[0-9]{0,2}(\\.[0-9]{3})*(\\,[0-9]{0,2})?|[1-9]{1}[0-9]{0,}(\\,[0-9]{0,2})?|0(\\,[0-9]{0,2})?|(\\,[0-9]{1,2})?)$",
        "MatchingText": "R$1500,00|||-1.500,00|||-$5,5",
        "NonMatchingText": "$ 1500.00|||5.5|||-$6,666,3333.00",
        "Description": "This is a regex for Brazilian Reais, that can be transformed to another currencies. The main modification is the exchange of . and , plus the addition of the R matching R$."
    },
    {
        "Pattern": "Call +1(505) 384-8224 now",
        "MatchingText": "gmail support",
        "NonMatchingText": "facebook support",
        "Description": "Gmail is a standout amongst the most regularly utilized mail administrations. It is utilized both for family unit and business reason. Yet, there are sure circumstances when you need to confront different Gmail issues while getting to your Gmail account all things considered you ought not stress and contact in our Gmail technical support where you will get fitting answer for every one of the issues. You can contact our Gmail Customer Service for encourage and support identified with any issue with your Gmail account. You can call us at whatever time on our Gmail Support telephone number +1(505) 384-8224 to think about new and a wide range of parts. Visit http://www.gmailcustomerservicenumber.us for more info"
    },
    {
        "Pattern": "^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)*[a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?$",
        "MatchingText": "3com.com|||this.is.a.museum|||mail",
        "NonMatchingText": "notadomain-.com|||-helloworld.c-|||.oops.org",
        "Description": "Remi provided an example that would match all domain names (http://www.regexlib.com/REDetails.aspx?regexp_id=391).  I'm adding it so that it can be tested."
    },
    {
        "Pattern": "^([a-zA-Z\u00E1\u00E9\u00ED\u00F3\u00FA\u00E0\u00E8\u00EC\u00F2\u00F9\u00E3\u00F5\u00E2\u00EA\u00EE\u00F4\u00FB\u00FC\u00EF\u00E7\u00C1\u00C9\u00CD\u00D3\u00DA\u00C0\u00C8\u00CC\u00D2\u00D9\u00C2\u00CA\u00CE\u00D4\u00DB\u00C3\u00D5\u00DC\u00CF\u00C7\u00A3\u00A2$#,.\u00BA\u00AA\u00B0\\s/-[0-9]]){1,40}$",
        "MatchingText": "Rua XV de Novembro",
        "NonMatchingText": "Rua 15 de Novembro",
        "Description": "Esta express\u00E3o permite a entrada de nomes compostos com quaisquer letras (incluindo acentos), espa\u00E7os, alguns s\u00EDmbolos gr\u00E1fcos, com comprimento entre 1 e 40 posi\u00E7\u00F5es, mas bloqueia n\u00FAmeros.\n\u00DAtil para valida\u00E7\u00E3o pr\u00E9via de denomina\u00E7\u00F5es em geral, como nomes de ruas, bairros, produtos etc."
    },
    {
        "Pattern": "Validation of Mexican RFC for tax payers (individuals)",
        "MatchingText": "TERJ561231|TERJ561231WE3|TERJ561231789|TERJ5612311H1|TERJ561231REV",
        "NonMatchingText": "terj561232|TERJ561231ef5|terj5612313h3",
        "Description": "This is the expression to validate the personal key for tax payers in Mexico (called RFC) as individuals (not for enterprises)."
    },
    {
        "Pattern": "^([0-9a-zA-Z]+[-._+&amp;])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,6}$",
        "MatchingText": "test@test.com|||nerdy.one@science.museum|||ready&amp;set@go.com.au",
        "NonMatchingText": ".test.@test.com|||spammer@[203.12.145.68]|||bla@bla",
        "Description": "A short and sweet email address validator. Checks that the username starts and ends with an alphanumeric character, allows a few non-repeating 'special characters' (namely -, ., _, +, &amp;) and checks for a sensible domain name (2-6 character TLD required). Some unconventional, yet technically valid, addresses will not be matched, but this is only a simple expression ;-)"
    },
    {
        "Pattern": "^((ht|f)tp(s?))\\://([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(/\\S*)?$",
        "MatchingText": "http://www.site.com|||https://www.secure.com:10000|||ftp://ftp.site.com/pub/files/",
        "NonMatchingText": "www.site.com|||https://www.site.longtld|||ftp:/badformat.com",
        "Description": "Simple URL Validator -- allows http, https, ftp, ftps, 2-6 letter TLD, ports, any path. Sorry, no IP addresses. Not too fussy, but then, it's not too long either ;-)"
    },
    {
        "Pattern": "(?:[hH][tT]{2}[pP][sS]{0,1}:\\/\\/)?[wW]{0,3}\\.{0,1}[yY][oO][uU][tT][uU](?:\\.[bB][eE]|[bB][eE]\\.[cC][oO][mM])?\\/(?:(?:[wW][aA][tT][cC][hH])?(?:\\/)?\\?(?:.*)?[vV]=([a-zA-Z0-9--]+).*|([A-Za-z0-9--]+))",
        "MatchingText": "http://www.youtube.com/watch?v=something|||https://www.youtube.com/watch?v=something|||http://youtu.BE/something|||https://www.YOUTUBE.com/watch?en=gb&vari=abc&v=something&another=yes",
        "NonMatchingText": "http://www.anothersite.com/watch?v=something|||http://www.youtube.com/wat?v=something",
        "Description": "Verifies YouTube video links AND pulls the video ID from them in a matching group.\nWorks with all capitalizations.\nIt also matches the WHOLE link  but sorts the video ID into a group.\n\nWorks with JavaScript, PHP and Python. (Not tested with any other Regex engine)\n\nWARNING: youtu.be links have their ID group as the second group."
    },
    {
        "Pattern": "^(\\+971[\\s]{0,1}[\\-]{0,1}[\\s]{0,1}|[\\s]{0,1}0)(5[056]{1})[\\s]{0,1}[\\-]{0,1}[\\s]{0,1}[1-9]{1}[0-9]{6}$",
        "MatchingText": "+971503667367||+971 555563210||0561211210",
        "NonMatchingText": "+971 0503667367||+9710561211210||041211210||05551211210",
        "Description": "Validate UAE Mobile Numbers\n050,055,056 with/without country code."
    },
    {
        "Pattern": "(\\d{6}[-\\s]?\\d{12})|(\\d{4}[-\\s]?\\d{4}[-\\s]?\\d{4}[-\\s]?\\d{4})",
        "MatchingText": "5111 1111 1111 11118|||1234123412341324|||123456 123456789012",
        "NonMatchingText": "511a 1111 1111 11118",
        "Description": "Credit card validator \nWorks for switch card numbers too\n\nSwitch card bit is (\\d{6}[-\\s]?\\d{12})\nCredit card bit is (\\d{4}[-\\s]?\\d{4}[-\\s]?\\d{4}[-\\s]?\\d{4})\n\nI use this as a client side test before running a more comprehensive server side check."
    },
    {
        "Pattern": "(\\s*\\(?0\\d{4}\\)?\\s*\\d{6}\\s*)|(\\s*\\(?0\\d{3}\\)?\\s*\\d{3}\\s*\\d{4}\\s*)",
        "MatchingText": "01603 123123|||0207 1234567|||(0208) 123 1234",
        "NonMatchingText": "123 123132",
        "Description": "UK Phone Number Allows leading and trailing spaces and optional spaces after the dialing code.\n\nInitially the expression I posted was\n\\s*0\\d{4}\\s*\\d{6}\\s*|\\s*0\\d{3}\\s*\\d{7}\\s*\n\nBut this didn't include optional brackets e.g. (01603) 123123 or phone numbers in a London format e.g. 0208 123 1234"
    },
    {
        "Pattern": "\"{(<h)([1-6])(.id=\\\")(.+?\\\")(.+?)(</h[1-6])}\",'\\\\2~<a href=\"#\\\\4\\\\5</a'",
        "MatchingText": "&lt;h1 id=\"tag\"&gt;Caption&lt;/h1&gt;",
        "NonMatchingText": "&lt;H1 id=\"tag\"&gt;Caption&lt;/H1&gt;",
        "Description": "Easy way to transform header tag to its local referer. I use it to make TOC after reading headers.<br><b> &lt;h# id=\"identifier\"&gt;Caption&lt;/h#&gt; -&gt; #~&lt;a href=\"#identifier\"&gt;Caption&lt;/a&gt; </b><br>There is stored original heading's level in output."
    },
    {
        "Pattern": "^(\\$)?(\\s)?(\\-)?((\\d+)|(\\d{1,3})(\\,\\d{3})*)(\\.\\d{2,})?$",
        "MatchingText": "$1,000.00|||$-1,000.00|||100.8766",
        "NonMatchingText": "$1a|||$#100.00|||1,00.00",
        "Description": "Allows either inclusion of $ symbol or not. Allows a whitespace character after the $ sysmbol or not. Allows a negative symbol in front of the starting digit or not. Allows comma separators at thousands, but nowhere else. Allows more than two decimal places."
    },
    {
        "Pattern": "(ns=[0-9])?;?((i=[0-9]+)|s=[a-zA-Z.]+)",
        "MatchingText": "ns=1;i=3015 | i=884 | ns=2;s=Demo.Static.Scalar.String",
        "NonMatchingText": " | 10001 |\"Hallo\"",
        "Description": "Regex to check if a string is a OPC UA NodeId XML schema. Only works for Numeric and String NodeIds\n"
    },
    {
        "Pattern": "regexp {[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+}",
        "MatchingText": "192.168.10.10",
        "NonMatchingText": "256.256.256.256",
        "Description": "all ip address should be accepted within this range 0-255"
    },
    {
        "Pattern": "^(9\\d{2})([ \\-]?)([7]\\d|8[0-8])([ \\-]?)(\\d{4})$",
        "MatchingText": "900700000|||900 70 0000|||900-70-0000",
        "NonMatchingText": "899700000||||900-89-0000|||900-69-0000",
        "Description": "U.S. Individual Taxpayer Identification Number (ITIN) as defined in December 2006. The valid range is 900-70-0000 through 999-88-9999, all numeric values. This regular expression will accept anything in this range with space, dash or no separators."
    },
    {
        "Pattern": "/\\*((\\*/)[\\d\\D\\s])*\\*/",
        "MatchingText": "/* CSS comments */|||/* multi-line SQL/CSS/Etc comments */ ",
        "NonMatchingText": "&lt;!-- doesn't match --&gt;|||-- won't match and //won't match",
        "Description": "Matches /* style comments */. \nMatches whitespace (so can detect tabs, etc.)\n\nProblems with nested comments. "
    },
    {
        "Pattern": "((^\\d{8})|(^\\d{2}[ ]\\d{2}[ ]\\d{2}[ ]\\d{2})|(^\\d{4}[ ]\\d{4}))$",
        "MatchingText": "12345678|||1234 5678|||12 34 56 78",
        "NonMatchingText": "123 456 78|||12 3456 78|||1 23 45 67 8|||55 ab 66 xy",
        "Description": "A Danish phone number can be written in three ways (if you don't include the country code +45). Either\none block of 8 digits or two blocks of four digits or\nfour blocks of two digits."
    },
    {
        "Pattern": "^(?P<field1>[^,]+),(?P<field2>[^,]+),(?P<field3>[^,]+)$",
        "MatchingText": "A,B,C",
        "NonMatchingText": "???",
        "Description": "Parse Comma Delimited Strings\n----------------------\nhttp://regexlib.com/REDetails.aspx?regexp_id=538"
    },
    {
        "Pattern": "(\"(([a-zA-Z]:)|(\\\\\\\\[^/\\\\:\\*\\?\"\"<>\\|]+(\\\\[a-zA-Z]\\$)?))\\\\([^/\\\\:\\*\\?\"\"<>\\|]+\\\\)*[^/\\\\:\\*\\?\"\"<>\\|]+(\\.[^/\\\\:\\*\\?\"\"<>\\|]+[^/\\\\:\\*\\?\"\"<>\\|\\s])?\")|((([a-zA-Z]:)|(\\\\\\\\[^/\\\\:\\*\\?\"\"<>\\|\\s]+(\\\\[a-zA-Z]\\$)?))\\\\([^/\\\\:\\*\\?\"\"<>\\|\\s]+\\\\)*[^/\\\\:\\*\\?\"\"<>\\|\\s]+(\\.[a-zA-Z0-9]+)?)",
        "MatchingText": "C:\\test_for_spaces\\test_extension|||C:\\test_for_spaces\\test_extension.t92|||\"C:\\test for spaces\\New Text Document.txt\"|||\\\\machine1\\shared_2\\hello_world.txt|||\"\\\\machine1\\c$\\shared 4\\hello world.txt\"",
        "NonMatchingText": "\"\\\\machine1\\c$\\test|pipe:colon.txt\"|||C:\\random space\\test.txt|||C\\\\bad\\test.t",
        "Description": "Matches full windows paths and UNC paths (allowing spaces in quoted text).\n\nFor non quoted text, the extension of the file must  be alphanumeric."
    },
    {
        "Pattern": "(^\\+[0-9]{2}|^\\+[0-9]{2}\\(0\\)|^\\(\\+[0-9]{2}\\)\\(0\\)|^00[0-9]{2}|^0)([0-9]{9}$|[0-9\\-\\s]{10}$)",
        "MatchingText": "+31235256677|||+31(0)235256677|||023-5256677",
        "NonMatchingText": "+3123525667788999|||3123525667788|||232-2566778",
        "Description": "Regular expression to evaluate dutch-style phone numbers. Possible example prefixes: +31, +31(0), (+31)(0), 0, 0031\nfollowed by 9 numbers (which can contain a space or -)."
    },
    {
        "Pattern": "^[0-9]{4}\\s{0,1}[a-zA-Z]{2}$",
        "MatchingText": "2034AK|||2034 AK|||2034 ak",
        "NonMatchingText": "2034     AK|||321321 AKSSAA",
        "Description": "Regular expression to evaluate dutch zipcodes. This is an updated version of Roland Mensenkamp."
    },
    {
        "Pattern": "([^_.]([a-zA-Z0-9_]*[.]?[a-zA-Z0-9_]+[^_]){2})@([a-z0-9]+[.]([a-z]{2,3}|[a-z]{2,3}[.][a-z]{2,3}))",
        "MatchingText": "vj.joe.hi@gmail.com",
        "NonMatchingText": ".abc@xyz.com,_abc@xyz.com,ab.cd.ef.gh@xmail.com",
        "Description": "This is a cleanup of Vijay Joshi's \"Email\" pattern.  It matches the same characters that his does, but matches them anywhere in the line.  It adds useful substitution groups -- [1] - username portion of email (before @), [3] domain portion of email - after the @.  It also was a bit overly-complex, so I reduced this as well..  Remember -- if you're planning to use this with something that uses 1003.2 BREs, you'll have to backquote + | ? ( ) { and }."
    },
    {
        "Pattern": "^\\[0-9]{4}\\-\\[0-9]{2}\\-\\[0-9]{2}$",
        "MatchingText": "2012-20-10, yyyy-mm-dd",
        "NonMatchingText": "12-20-2012",
        "Description": "Validate date in mysql regexp."
    },
    {
        "Pattern": "(?:\\d|I{1,3})?\\s?\\w{2,}\\.?\\s*\\d{1,}\\:\\d{1,}-?,?\\d{0,2}(?:,\\d{0,2}){0,2}",
        "MatchingText": "Genesis 3:3-4,6|||II Sam 2:11,2|||2 Tim 3:16",
        "NonMatchingText": "Genesis chap 3, verse 3|||2nd Samuel 2",
        "Description": "This RE validates standard Bible verse notation."
    },
    {
        "Pattern": "(?:\\+?1[ .*-]?)?(?:\\(? ?)?\\d{3}(?: ?\\)?)? ?(?:\\*|(?:\\.|-){1,2})? ?\\d{3} ?(?:\\*|(?:\\.|-){1,2})? ?\\d{4} ",
        "MatchingText": "5555555555|||555 555 5555|||555-555-5555|||(555-555-5555|||( 555-555-5555|||555) 555-5555|||555 ) 555- 5555|||555 ) 555-5555|||(555)555-5555|||(555) 555-5555|||(555) 555 5555 |||(555) 555 - 5555|||(555) 555 -5555|||555 - 555 - 5555|||(555)-555-5555|||555 555-5555|||555 -555-5555|||555.555.5555|||555-555.5555|||555. 555.5555|||555. 555. 5555|||555*555*5555|||15555555555|||1 555 555 5555|||1-555-555-5555|||1.555-555-5555|||1*555*555*5555|||+1 555 555 5555|||+1-555-555-5555|||+1 555-555-5555|||+1.555-555-5555|||+1.555.555.5555|||1 (555) 555-5555|||+1 (555) 555-5555|||1 5555555555|||1.(555-555-555",
        "NonMatchingText": "anything else",
        "Description": "This regex matches US phone number formats that I found to be commonly used.\nThis regex is best used on scanning text. If html is present, strip out the html first."
    },
    {
        "Pattern": "[^A-Za-z0-9]",
        "MatchingText": "!@#$|||%^&amp;*|||'&gt;&lt;?.,&quot;",
        "NonMatchingText": "ABC123abc|||abc123ABC|||abc0132ABC",
        "Description": "To detect non-alphanumeric characters (for new username/password validation, for instance):\n\nmonkey(AT)greyledge.net\n14-Oct-2003 11:26"
    },
    {
        "Pattern": "[a-z0-9]{1,11}",
        "MatchingText": "abc123ABC|||123ABCabc|||abcABC123",
        "NonMatchingText": "#$@%$|||<>?|\" '|||_-+ =",
        "Description": "PHP/Perl based regular expression: find aplhanumeric only(alpha and numeric only) (string and numeric only)       \nbut it will not find the empty string as it has to find string between 1 to 11 length."
    },
    {
        "Pattern": "^[A-Za-z]{6}[0-9]{2}[A-Za-z]{1}[0-9]{2}[A-Za-z]{1}[0-9]{3}[A-Za-z]{1}$",
        "MatchingText": "SPGGRG73A02E625S|||czzdll74h18f205w",
        "NonMatchingText": "SP6FFFF3A02E625S|||czzdll74h18f205",
        "Description": "This pattern match italian fiscal code (codice fiscale)."
    },
    {
        "Pattern": "^([0-9]*\\-?\\ ?\\/?[0-9]*)$",
        "MatchingText": "02-343536|||02/343536|||02 343536",
        "NonMatchingText": "02a343536|||02+343536",
        "Description": "Match italian telephone number with prefix followed by &quot;/&quot;, &quot;-&quot; or blank and number. Usefull with numeric keybord!"
    },
    {
        "Pattern": "(^([A-Za-z])([-_.\\dA-Za-z]{1,10})([\\dA-Za-z]{1}))(@)(([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})|(([\\dA-Za-z{1}][-_.\\dA-Za-z]{1,25})\\.([A-Za-z]{2,4}))$)",
        "MatchingText": "abc45fgh90@abc.com|||abc45fg.90@abc.com|||xxxx@127.0.0.1||||||abc45fgh90@abc45.cx|||abc45fgh90@abc45.cxx|||abc45fgh90@abc45.cxxx||||||abc45fgh90@abc45.com|||abc45fgh90@abc45fgh90.com|||abc45fgh90@abc45fgh90abc45fgh90.com|||abc45fgh90@abc45fgh90.abc45fgh90.com",
        "NonMatchingText": "@.com|||a@a.com|||1@a.com|||w1@a.com|||1w@test.com|||wa@.com||||||abc45fgh90@a.com|||abc45fgh90@1b.com|||abc45fgh90@ab.com||||||abc45fgh90.@abc.com|||abc45fg.90@@abc.com||||||abc45fgh90@abc45.|||abc45fgh90@abc45.c|||abc45fgh90@abc45.c1x||||||abc45fgh90@@abc45.com|||abc45fgh90?@abc45.com|||abc45fgh90@abc45#.com|||abc45fgh90@abc45fgh90?.com|||abc45fgh90@abc45fgh90..com||||||blah@127.0.0|||blah@127.0.0.|||blah@127.0.0.g|||",
        "Description": "v allow Symbol [(_) (-) (DOT)] (number) (a-z and caps), X disallow symbol&number at begining (avoid bad sorting database, including bad subdomain name (1.example.com) & fake email) and ending (before \"@\") & other symbols are disallowed;\nusername min,max/maxout = 2, 25/27\n--- must exist \"@\" ---;\nafter \"@\" :\nFOR DOMAIN NAME :\nv Symbol [(_) (-) (DOT)] (number) (a-z and caps), X symbol at begining and ending (including before top level domain extension)\nv a-z (with/out caps) total min=2 max 4 in top level domain extension\nNOT SUPPORTED PORT NUMBER, if you the administrator ? self edit the database, DONT give user a chance for adding port number.\nmaximum 25 address length ; \nOR standard IP ADDRESS.\n\n\nWHITE SPACE IS NOT SUPPORTED."
    },
    {
        "Pattern": "^((?-i)A[cglmrstu]|B[aehikr]?|C[adeflmorsu]?|D[bsy]|E[rsu]|F[emf]?|G[ade]|H[efgos]?|I[nk]?|Kr?|L[airu]|M[dgnot]|N[abdeiop]|Os?|P[abdmortu]?|R[abefghnu]|S[bcegimnr]?|T[abcehil]|U(u[bhopqst])?|V|W|Xe|Yb?|Z[nr])$",
        "MatchingText": "Hg",
        "NonMatchingText": "HE",
        "Description": "Chemical elements of the periodic table from 1 to 118."
    },
    {
        "Pattern": "^([+a-zA-Z0-9_\\-\\.]+)@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.)|(([a-zA-Z0-9\\-]+\\.)+))([a-zA-Z]{2,6}|[0-9]{1,3})(\\]?)$",
        "MatchingText": "user.name_in_the-server+suffix@the.server-name.tld",
        "NonMatchingText": "bad@address@server.tld",
        "Description": "Checks if an email address is valid."
    },
    {
        "Pattern": "^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$",
        "MatchingText": "10.0.0.1, 192.168.1.1",
        "NonMatchingText": "10.020.3.10, 10.1111.23.1, 192.168.1.15_1",
        "Description": "Validates an IP Address. I use it in perl."
    },
    {
        "Pattern": "(?i)^((((0[1-9])|([12][0-9])|(3[01])) ((JAN)|(MAR)|(MAY)|(JUL)|(AUG)|(OCT)|(DEC)))|((((0[1-9])|([12][0-9])|(30)) ((APR)|(JUN)|(SEP)|(NOV)))|(((0[1-9])|([12][0-9])) FEB))) \\d\\d\\d\\d ((([0-1][0-9])|(2[0-3])):[0-5][0-9]:[0-5][0-9])$",
        "MatchingText": "01 JAN 2006 13:00:00",
        "NonMatchingText": "31 FEB 10 03:00:00 PM",
        "Description": "Validates datetimes in an internationally resilient form that is still readable by the average person."
    },
    {
        "Pattern": "(http|ftp|https):\\/\\/[\\w\\-_]+(\\.[\\w\\-_]+)+([\\w\\-\\.,@?^=%&amp;:/~\\+#]*[\\w\\-\\@?^=%&amp;/~\\+#])?",
        "MatchingText": "http://regxlib.com/Default.aspx|||http://electronics.cnet.com/electronics/0-6342366-8-8994967-1.html",
        "NonMatchingText": "www.yahoo.com",
        "Description": "*CORRECTED: Again thanks for all the comments below. If you want to include internal domain as well change the partial code (\\.[\\w-_]+)+ to (\\.[\\w-_]+)?  \nSee the comments below*\n\nThis is the regular expression I use to add links in my email program. It also ignores those suppose-to-be commas/periods/colons at the end of the URL, like this sentence &quot;check out http://www.yahoo.com/.&quot; (the period will be ignored) Note that it requires some modification to match ones that dont start with http."
    },
    {
        "Pattern": "^(([0-9]|1[0-9]|2[0-4])(\\.[0-9][0-9]?)?)$|([2][5](\\.[0][0]?)?)$",
        "MatchingText": "12|||13.1||23.99||8.99||25.00",
        "NonMatchingText": "26||25.01||-2||8.||",
        "Description": "this is reg expression for 0.00 to 25.00"
    },
    {
        "Pattern": "^(?:(?P<scheme>[a-z]+):\\/\\/)?(?:(?P<usern>[a-z0-9_.]*)(?::(?P<passw>[a-z0-9_.]*))?@)?(?P<domain>(?:(?:[a-z][a-z0-9_-]+\\.?)+|[0-9]{1,3}(?:\\.[0-9]{1,3}){3}))(?::(?P<port>[0-9]+))?(?P<path>(?:\\/[.%a-z0-9_]*)+)?(?:\\?(?P<query>(?:&?[][a-z0-9_]+(?:\\=?[a-z0-9_;]*)?)+))?(?:#(?P<fragment>[a-z0-9_]+))?$",
        "MatchingText": "domain ||| ftp://localhost:21/ ||| 192.168.254.0 ||| http://username:password@www.domain.com:1234/path1/pathX/filename.ext?query=string&example=v1#fragment",
        "NonMatchingText": "non-alpha://domain ||| domain:non-number",
        "Description": "Matches URI's!\n\"filename.ext\" is part of path. ER can't differ file name from directory name.\nonly domain is required.\nscheme://usern:passw@domain:port/path/file.ext?querystring#fragment"
    },
    {
        "Pattern": "^([9]{1})([234789]{1})([0-9]{8})$",
        "MatchingText": "9829373514",
        "NonMatchingText": "919829373514, 09829373514",
        "Description": "Its 10 digits Indian Mobile Number validation."
    },
    {
        "Pattern": "^[1-9]{1}$|^[0-9]{1}[0-9]{1}[0-9]{1}[0-9]{1}$|^9999$",
        "MatchingText": "1, 123, 9465, 9999",
        "NonMatchingText": "0, -1, -123, 99999",
        "Description": "This is only +ive numbers excluding 0. It takes 1 to 9999."
    },
    {
        "Pattern": "^(([0-2])?([0-9]))$",
        "MatchingText": "0 1 10 29 ",
        "NonMatchingText": "30 -1",
        "Description": "It is use for 0 to 29."
    },
    {
        "Pattern": "^.*([^\\.][\\.](([gG][iI][fF])|([Jj][pP][Gg])|([Jj][pP][Ee][Gg])|([Bb][mM][pP])|([Pp][nN][Gg])))",
        "MatchingText": "D:\\Documents and Settings\\Administrator\\Desktop\\New Folder\\60101-prep.png",
        "NonMatchingText": "D:\\Documents and Settings\\Administrator\\Desktop\\New Folder\\60101-prep.pdf",
        "Description": "By using this we can upload only images files. This is the simplest and its execution is fast."
    },
    {
        "Pattern": "^\\d{2}\\-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec|JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)\\-\\d{4}$",
        "MatchingText": "23-Apr-1982 , 23-APR-1982",
        "NonMatchingText": "23-04-1398",
        "Description": "By using this you can validate your date string in (dd-MMM-yyyy) format."
    },
    {
        "Pattern": "(?P<DATE>(?:(?:(?P<year1>(?:1[89])|(?:[2468][048]|[3579][26])\n(00))(?P<year2>00|[02468][1235679]|[13579][01345789])\n(?:(?:(?P<month>(?:[0][13578])|(?:1[02]))\n(?P<day>0[1-9]|[12][0-9]|3[01]))|\n(?:(?P<month>0[469]|11)(?P<day>0[1-9]|[12][0-9]|30))|\n(?:(?P<month>02)(?P<day>0[1-9]|1[0-9]|2[0-8])))|\n(?:(?:(?P<year1>(?:[2468][048]|[3579][26])00)|\n(?P<year1>(?:(?:1[89])|[2468][048]|[3579][26])\n(00))(?P<year2>[02468][048]|[13579][26]))\n(?:(?:(?P<month>(?:(?:[0][13578])|(?:1[02])))\n(?P<day>0[1-9]|[12][0-9]|3[01]))|\n(?:(?P<month>0[469]|11)\n(?P<day>(?:0[1-9]|[12][0-9]|30)))|\n(?:(?P<month>02)(?P<day>0[1-9]|[12][0-9])))))))",
        "MatchingText": "20010101 20000229 19960229 20010101 18101231",
        "NonMatchingText": "19000229 19980229 20071131",
        "Description": "Test a date in the format of YYYYMMDD. and returns a match with the grouped date parts. The groups are:\n(example 20001101)\nDATE - 20011201 (the full date)\nyear1- 20 (the century)\nyear2- 01 (the year of the century)\nmonth- 12 (the month)\nday  - 01 (the day of the month)\n"
    },
    {
        "Pattern": "^\\-?[0-9]{1,3}(\\,[0-9]{3})*(\\.[0-9]+)?$|^[0-9]+(\\.[0-9]+)?$",
        "MatchingText": "10,000,000.123|||3.14159265",
        "NonMatchingText": "2.7,1828183",
        "Description": "Formatted Number with \",\" as thousand separator and \".\" as decimal separator. now accept numbers without separators of thousands."
    },
    {
        "Pattern": "^\\$?(\\d{1,3},?(\\d{3},?)*\\d{3}(\\.\\d{1,3})?|\\d{1,3}(\\.\\d{2})?)$",
        "MatchingText": "10000|||10,000|||$1,000.00",
        "NonMatchingText": "0.002|||x.0",
        "Description": "Expression to handle US currency entry in .NET. Handy for regular expression validation controls where the user can be entering in a currancy value but you can't control explict entry values. Will accept a wide variety of values that can be easy cast to a double via the CDbl function. Expression is also compatible with default US string format for currency."
    },
    {
        "Pattern": "^\\d{0,2}(\\.\\d{1,4})? *%?$",
        "MatchingText": "4.0%|||0.45|||.0345",
        "NonMatchingText": "123|||%12",
        "Description": "An expression for .NET regular expression validation controls intended to faciliate the entry of percentage values both a whole numbers or as their decimal representations. Also compatible with the default US format for string formatting for percentages.\n\nRecommend that if you intended accept a value passing this express that you strip the percentage signs and take measures to ensure that any whole values are converted to percentages.\n"
    },
    {
        "Pattern": "(^\\d*\\.\\d{2}$)",
        "MatchingText": "12.56|||0.25|||156.56",
        "NonMatchingText": "-123.45|||1.023|||1.2",
        "Description": "If you need a textbox to allow only positive numbers with two decimal places, try this. I wanted the user to be able to enter any type of currency amount (US of course) but also have two decimal places for database field."
    },
    {
        "Pattern": "(((^[>]?1.0)(\\d)?(\\d)?)|(^[<]?1.0(([1-9])|(\\d[1-9])|([1-9]\\d)))|(^[<]?1.4(0)?(0)?)|(^[<>]?1.(([123])(\\d)?(\\d)?)))$",
        "MatchingText": ">1.0 ||| <1.001 ||| >1.399",
        "NonMatchingText": ">1.400 ||| 1. ||| 1.0011",
        "Description": "Range validator for urine lab panel specific gravity. The valid range is 1.000 to 1.400 inclusive. Sometimes < and > are used but not in the context of <1.000 nor >1.400. To 1, 2 or 3 decimals. Normal range is 1.003 to 1.03 but is left to the viewer."
    },
    {
        "Pattern": "(^(4|5)\\d{3}-?\\d{4}-?\\d{4}-?\\d{4}|(4|5)\\d{15})|(^(6011)-?\\d{4}-?\\d{4}-?\\d{4}|(6011)-?\\d{12})|(^((3\\d{3}))-\\d{6}-\\d{5}|^((3\\d{14})))",
        "MatchingText": "4111-1234-1234-1234|||6011123412341234|||3711-123456-12345",
        "NonMatchingText": "1234567890123456|||4111-123-1234-1234|||412-1234-1234-1234",
        "Description": "This provides an expression to calidate the four major credit cards.  It can be easily broken up to use for a specific type of card.  It does not validate the number being a potential real number, only in the correct format."
    },
    {
        "Pattern": "(\\\"(?P<word>[^\\\"]+|\\\"\\\")*\\\"|(?P<word>[^,]*))",
        "MatchingText": "\"test\",\"test this\",test,  test,test  ,\"123,456.12\"",
        "NonMatchingText": "'te, st'",
        "Description": "This will match fields in a row of a csv file.  Values can be double quoted or not.  If a value is double quoted it can have commas inside it.  Each value will be captured to word."
    },
    {
        "Pattern": "^(\\{1}[2-9]{1}[0-9]{2}\\){1}[ ]?[2-9]{1}[0-9]{2}(-| )?[0-9]{4}|[2-9]{1}[0-9]{2}[ ]{1}[2-9]{1}[0-9]{2}[ ]{1}[0-9]{4}|[2-9]{1}[0-9]{2}[2-9]{1}[0-9]{6}|[2-9]{1}[0-9]{2}-{1}[2-9]{1}[0-9]{2}-{1}[0-9]{4}){1}$",
        "MatchingText": "(233) 233-0000,2332330000,233-233-0000,233 233 0000, etc.",
        "NonMatchingText": "(233)-222-0000,(122)233-000, etc.",
        "Description": "This should be pretty complete phone number pattern. I use [0-9] when most people seem to use \\d because it is easier for me to read."
    },
    {
        "Pattern": "^((Sir|Dr.|Mr.|Mrs.|Ms.|Rev.){1}[ ]?)?([A-Z]{1}[.]{1}([A-Z]{1}[.]{1})?|[A-Z]{1}[a-z]{1,}|[A-Z]{1}[a-z]{1,}[-]{1}[A-Z]{1}[a-z]{1,}|[A-Z]{1}[a-z]{0,}[ ]{1}[A-Z]{1}[a-z]{0,}){1}$",
        "MatchingText": "Mr. Jon, Mr.Jon,Jon,J.D., J D, Mr. Jean-Guy etc.",
        "NonMatchingText": "JD, Mr Jon, MrJon, etc.",
        "Description": "This will allow to check to make sure the string is a First or Given Name and it can be initials and it can include a prefix."
    },
    {
        "Pattern": "<[^>]*>",
        "MatchingText": "<html>",
        "NonMatchingText": "abc",
        "Description": "HTML Pattern Matching\n\nPLEASE HELP\n\n/&lt;[^&gt;]*&gt;/ig\nThe above pattern is only successful when html tag are simple (they don't include any javascript).  This mean that the pattern will fail if something like this is within the tag &lt;input type=button value=test onclick='if(n.value&gt;5)do_this();'&gt;.  It will not match the entire open n close sign.\n\nHow do you write a pattern that will pass all these tag so that the pattern will match from the open to the close sign and not when it just see a &gt; within a '' or &quot;&quot;.\n\n&lt;input type=button onclick='if(n.value&gt;5)do_this();'&gt; not this &lt;br&gt;\n&lt;input type=button onclick=&quot;n&gt;5?a():b();&quot; value=test&gt; not this &lt;br&gt;\n&lt;input type=button onclick=&quot;n&gt;5?a(\\&quot;OK\\&quot;):b('Not Ok');&quot; value=test&gt; not this &lt;br&gt;\n&lt;input type=button onclick='n&gt;5' value=test onmouseover=&quot;n&lt;5&amp;&amp;n&gt;8&quot; onmouseout='if(n&gt;5)alert(\\'True\\');else alert(&quot;False&quot;)'&gt; not this &lt;br&gt;\n\n\nAny help would be greatly appreciate.  Thanks a whole lot.\n\nLogan"
    },
    {
        "Pattern": "&lt;(.*?)&gt;",
        "MatchingText": "&lt;test a&gt;",
        "NonMatchingText": "none",
        "Description": "Can anyone help me with this problem?  I want X to give me the correct index of &gt;.  For example if this is my code:\n\nvar MsgString=&quot;&lt;button onclick='4&gt;5?a():b();'&gt;&quot;;\nX=MsgString.search(/&gt;/ig);\n\nX will give me 18 instead of 30.  How can I get it to ignore &gt; that are within quotes?  Please help.  I would really appreciate it if anybody could give me some advice.  Thanks so much.\n\n-Logan"
    },
    {
        "Pattern": "^([0-9]{6}[\\s\\-]{1}[0-9]{12}|[0-9]{18})$",
        "MatchingText": "000000 000000000000|||000000-000000000000|||000000000000000000",
        "NonMatchingText": "000000_000000000000",
        "Description": "This regular expression matches 'Switch' card numbers - a payment method used extensively in the UK."
    },
    {
        "Pattern": "^(0\\d)([0-9]{1,}(,[0-9]{2}))$",
        "MatchingText": "0,00 | 12,34 | 2014,08",
        "NonMatchingText": "00,00 | 12 | 12,3 |12,345 | 08,20",
        "Description": "No leading zeroes. Must have 2 digits after the decimal comma ','"
    },
    {
        "Pattern": "(^[1-9]\\d{2}\\s*-\\s*\\d{3}\\s*-\\s*\\d{4}$|^[2-9]\\d{9}|^\\x28\\s*[2-9]\\d{2}\\s*\\x29\\s*\\d{3}\\s*-\\s*\\d{4}$)",
        "MatchingText": "2345678901 | (234) 567-8901 | 234-567-8901 | (234) 567-8901",
        "NonMatchingText": "1234567890 | 2345678901 | 234 567 8901",
        "Description": "Matches properly formatted US phone numbers. Based on: http://regexlib.com/REDetails.aspx?regexp_id=22"
    },
    {
        "Pattern": "^ ?(([BEGLMNSWbeglmnsw][0-9][0-9]?)|(([A-PR-UWYZa-pr-uwyz][A-HK-Ya-hk-y][0-9][0-9]?)|(([ENWenw][0-9][A-HJKSTUWa-hjkstuw])|([ENWenw][A-HK-Ya-hk-y][0-9][ABEHMNPRVWXYabehmnprvwxy])))) ?[0-9][ABD-HJLNP-UW-Zabd-hjlnp-uw-z]{2}$",
        "MatchingText": "SW112LE | SW11 2LE | sw112le",
        "NonMatchingText": "12CR0LE | 12CR 0LE | SWLE05",
        "Description": "Matches valid UK post codes in both upper and lower case, allowing for one or zero spaces between outcode and incodes."
    },
    {
        "Pattern": "^#?(([a-fA-F0-9]{3}){1,2})$",
        "MatchingText": "#ff9900|||#abc|||#92fea5",
        "NonMatchingText": "ab|||#92a2|||32z",
        "Description": "Matches any valid 3 or 6 digit hexadecimal colour value."
    },
    {
        "Pattern": "(^\\d{20}$)|(^((:[a-fA-F0-9]{1,4}){6}|::)ffff:(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})(\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})){3}$)|(^((:[a-fA-F0-9]{1,4}){6}|::)ffff(:[a-fA-F0-9]{1,4}){2}$)|(^([a-fA-F0-9]{1,4}) (:[a-fA-F0-9]{1,4}){7}$)|(^:(:[a-fA-F0-9]{1,4}(::)?){1,6}$)|(^((::)?[a-fA-F0-9]{1,4}:){1,6}:$)|(^::$)",
        "MatchingText": "::5:aef1:ffff|||::ffff:240.65.238.22|||0:0:0:0:0:0:0:1",
        "NonMatchingText": "79250:9a0:|||8|||91cf91d3da9",
        "Description": "This matches all valid forms of an IPv6 address. Including the compatibility form used to map IPv4 addresses. As well as the base-85 encoded integer form.\n\nIt takes care of value range checking on the ipv4 part (components cannot exceed 0-255).\n\nThis has been tested quite thoroughly, but considering the complexity and possibilities in the formation of an IPv6 address, matching errors are not guaranteed to be absent."
    },
    {
        "Pattern": "^[+-]?[0-9]+$",
        "MatchingText": "12|||-2|||+3213",
        "NonMatchingText": "abc|||@41|||43.12",
        "Description": "Single- or multi-digit signed Integer."
    },
    {
        "Pattern": "^[+-]?\\d*(([,.]\\d{3})+)?([,.]\\d+)?([eE][+-]?\\d+)?$",
        "MatchingText": "-4,233.2832e12|||+232|||-0.12e-5",
        "NonMatchingText": "abc|||@41|||0x423",
        "Description": "Matches any integer or decimal number with either dot (.) or comma (,) as decimal- and thousands-separator. Also accepts Scientific notation."
    },
    {
        "Pattern": "^(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})(\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]{1,2})){3}$",
        "MatchingText": "97.67.44.20|||199.154.37.214|||127.0.0.1",
        "NonMatchingText": "63.125.94.287|||140.370.a.187|||94.923.1",
        "Description": "This matches any valid IPV4 IP Address. It includes 0-255 range checks since none of the IP components may exceed 255."
    },
    {
        "Pattern": "^(\\(?[0-9]{3}[\\)-\\.]?\\ ?)?[0-9]{3}[-\\.]?[0-9]{4}$",
        "MatchingText": "(555) 555-5555|||555.555.5555|||555-5555",
        "NonMatchingText": "(555)-555-5555",
        "Description": "Simple US phone number matching, allowing area code or not. Allows spaces, dashes, dots, or none of the above. Area code, if entered, can be surrounded by parenthesis or not."
    },
    {
        "Pattern": "\\w*$",
        "MatchingText": "\\\\domain\\user",
        "NonMatchingText": "I want lots of $$",
        "Description": "Finds the last word in a string eg. the user in \\\\domain\\user or the extension/file type in a file name."
    },
    {
        "Pattern": "\\w*$",
        "MatchingText": "\\\\domain\\user",
        "NonMatchingText": "I wan't lots of $$",
        "Description": "Finds the last word in a string eg. the user in \\\\domain\\user or the extension/file type in a file name."
    },
    {
        "Pattern": "\\d+([\\.|\\,][0]+?[1-9]+)?",
        "MatchingText": "129.29|||129.000000029|||129.000000",
        "NonMatchingText": "123.90|||123.789878979879870|||asd...",
        "Description": "remove the tailling zero (0)\nawfully cannot resolve the .00000 problem"
    },
    {
        "Pattern": "(<(!--.*|script)(.|\\n[^<])*(--|script)>)|(<|&lt;)(/?[\\w!?]+)\\s?[^<]*(>|&gt;)|(\\&[\\w]+\\;)",
        "MatchingText": "<HTML> ||| <!-- ||| <script>",
        "NonMatchingText": "plainText",
        "Description": "This regex will match all text inside angle brackets and HTML comments."
    },
    {
        "Pattern": "^(\\d{5}-\\d{4}|\\d{5})$|^([a-zA-Z]\\d[a-zA-Z] \\d[a-zA-Z]\\d)$",
        "MatchingText": "78754|||78754-1234|||G3H 6A3",
        "NonMatchingText": "78754-12aA|||7875A|||g3h6a3",
        "Description": "This is a modification of the zip code regular expression submitted by Steven Smith (ssmith@aspalliance.com) \n\nIt no longer matches 78754-12aA"
    },
    {
        "Pattern": "^(user=([a-z0-9]+,)*(([a-z0-9]+){1});)?(group=([a-z0-9]+,)*(([a-z0-9]+){1});)?(level=[0-9]+;)?$",
        "MatchingText": "user=foo,bar,quux;group=manager,admin;level=100;|||group=nobody;level=24;",
        "NonMatchingText": "user=foo|||blahh",
        "Description": "This re was used for a security routine. The format is:\n[user=name1,name2,...,nameN;][group=group1,group2,...,groupN;][level=number;]\nEach component is optional, but they must appear the in order listed if applicable."
    },
    {
        "Pattern": "\"^[0-9]{2}\"",
        "MatchingText": "22",
        "NonMatchingText": "anyother char.  or numeric more thn 2",
        "Description": "It will compare no. from zero to Nine lenght == 2"
    },
    {
        "Pattern": "^([a-zA-Z0_\\-\\.]+)@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.)|(([a-zA-Z0-9\\-]+\\.)+))([a-zA-Z]{2,3}|[0-9]{1,3})(\\]?)$",
        "MatchingText": "jagnarain@jns.com, jagnarain@jns.coms",
        "NonMatchingText": "jagnarain@jns.comss, 123jagnarain@jns.comss",
        "Description": "Simple email expression. Doesn't allow numbers in the email name."
    },
    {
        "Pattern": "^((((((0[1-9])|(1\\d)|(2[0-8]))\\.((0[123456789])|(1[0-2])))|(((29)|(30))\\.((0[13456789])|(1[0-2])))|((31)\\.((0[13578])|(1[02]))))\\.\\d{4})|((29)\\.(02)\\.\\d{2}(([02468][048])|([13579][26]))))(\\s((0\\d)|(1\\d)|(2[0-3]))\\:([0-5]\\d)\\:([0-5]\\d)\\.\\d{7})$",
        "MatchingText": "29.02.2008 23:50:45.1234567|||31.03.2007 00:01:01.0000001|||30.04.1999 01:02:03.0000000",
        "NonMatchingText": "29.02.2009 23:50:45.1234567|||31.04.2007 00:01:01.0000001|||30.04.1999 01:02:03.0000",
        "Description": "Oracle like time stamp with format:\ndd.MM.yyyy HH.mm.SS.xxxxxxx\nBased on European full proved date format with easy changeable dot separator.\nOptimized regular expresion."
    },
    {
        "Pattern": "^(([0-9])|([0-2][0-9])|(3[0-1]))\\/(([1-9])|(0[1-9])|(1[0-2]))\\/(([0-9][0-9])|([1-2][0,9][0-9][0-9]))$",
        "MatchingText": "30/10/1967  30/10/67 1/1/1967",
        "NonMatchingText": "32/12/1967 30/13/67",
        "Description": "Simple UK Date Format dd/mm/yy or dd/mm/yyyy."
    },
    {
        "Pattern": "^(3[0-1]|2[0-9]|1[0-9]|0[1-9])(0[0-9]|1[0-9]|2[0-3])([0-5][0-9])\\sUTC\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s[0-9]{2}$",
        "MatchingText": "312359 UTC Jun 99",
        "NonMatchingText": "322567 UTC June 1999",
        "Description": "In military messages and communications (e.g. on naval charts, or maps showing troop movements) the format is DDHHMMZ Mon YY, so for instance, \"271545Z FEB 08\" represents 15:45 Zulu time (which is to say UTC) on the 27th of February, 2008.\nFor Radio Navigational Warnings (RNWs), the international format is slightly different, using the explicit UTC text instead of the Zulu character, becoming \"DDhhmm UTC Jun YY\". E.g. \"240923 UTC Jun 10\" is \"9:23am on 24th June 2010\".\n"
    },
    {
        "Pattern": "^\\.{1}",
        "MatchingText": ".net|||.blah|||.anything",
        "NonMatchingText": "net|||net.stuff|||netstuff.",
        "Description": "simply checks to see if the first charactor is a . (dot)"
    },
    {
        "Pattern": "^(\\d*\\s*\\-?\\s*\\d*)$",
        "MatchingText": "\"10\"   \"27 \"  \"5 - 10\" \"27-29\" \"30 40\"",
        "NonMatchingText": "\"10 Hello\"",
        "Description": "For numbers such as 27 or a range using spaces and/or a hyphen such as 5 - 10 (meaning between 5 and 10)."
    },
    {
        "Pattern": "^(((\\+44\\s?|0044\\s?)?|(\\(?0))((2[03489]\\)?\\s?\\d{4}\\s?\\d{4})|(1[23456789]1\\)?\\s?\\d{3}\\s?\\d{4})|(1[23456789][234578][0234679]\\)?\\s?\\d{6})|(1[2579][0245][0467]\\)?\\s?\\d{5})|(11[345678]\\)?\\s?\\d{3}\\s?\\d{4})|(1[35679][234689]\\s?[46789][234567]\\)?\\s?\\d{4,5})|([389]\\d{2}\\s?\\d{3}\\s?\\d{4})|([57][0-9]\\s?\\d{4}\\s?\\d{4})|(500\\s?\\d{6})|(7[456789]\\d{2}\\s?\\d{6})))$",
        "MatchingText": "+44 20 xxxx xxxx | 0044 20 xxxx xxxx | 020 xxxx xxxx  | (020) xxxx xxxx | (020)xxxxxxx |020 xxxx xxxxx | (01xxx) xxxxxx | (01xxx) xxxxx | (01x1) xxx xxxx | (011x) xxx xxxx | (02x) xxxx xxxx | (01xxxx) xxxxx and (01xxxx) xxxx | 05x xxxx xxxx | 03xx xxx xxxx | 07xxx xxxxxx | 08xx xxx xxxx and 09xx xxx xxxx",
        "NonMatchingText": "+44 020 xxxx xxxx | +44 (20) xxxx xxxx",
        "Description": "UK phone number for both Geographic (landline) and Non-Geographic (Cell) numbering. It validates a complete range of combination of area code, location and formate , it also allows international number starting from +44 or 0044 and it also allows () with area code and spaces."
    },
    {
        "Pattern": "^0*(\\d{1,3}(\\.?\\d{3})*)\\-?([\\dkK])$",
        "MatchingText": "12.348-k|||00012348-k|||12348K",
        "NonMatchingText": "123.48-k|||1.2-4||| 12348-k ",
        "Description": "Matches any-length chilean RUT (Rol Unico Tributario) and RUN (RUT (Rol Unico Nacional), with or without dots as thousand separator, and with or without hyphen as verification digit separator. Grab 1st and 3rd match for best results. Delete the dots from 1st match\n===\nCalza con RUT chileno (Rol Unico Tributario) y RUN (RUT (Rol Unico Nacional) de cualquier largo, con o sin puntos separadores de miles, y con o sin guion como separador de digitos verificador. Considerar el 1er y 3er calce para mejores resultados. Eliminar los puntos del 1er calce"
    },
    {
        "Pattern": "[0-9]{4}-([0][0-9]|[1][0-2])-([0][0-9]|[1][0-9]|[2][0-9]|[3][0-1])",
        "MatchingText": "1981-10-16",
        "NonMatchingText": "1981-13-10",
        "Description": "This function does basic testing for the YYYY-MM-DD date format."
    },
    {
        "Pattern": "^\\$?\\d{1,2}\\,\\d{3}?\\,\\d{3}?(\\.(\\d{2}))$|^\\$?\\d{1,3}?\\,\\d{3}?(\\.(\\d{2}))$|^\\$?\\d{1,3}?(\\.(\\d{2}))$",
        "MatchingText": "1.99|111,111.99|11,111,111.99",
        "NonMatchingText": "1.999|1111|1111111|11.9",
        "Description": "Needed to verify a currency amount entered has commas and two decimal spaces to the right. This has a range between 1.99 to the tens of millions. If you want to make the decimal side optional, add a question mark before the final $ in each expression."
    },
    {
        "Pattern": "^(((0?[1-9]|1[012])/(0?[1-9]|1\\d|2[0-8])|(0?[13456789]|1[012])/(29|30)|(0?[13578]|1[02])/31)/(19|[2-9]\\d)\\d{2}|0?2/29/((19|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$",
        "MatchingText": "02/29/1984;10/9/2000;1/1/2009",
        "NonMatchingText": "02/02/1899;13/02/2000;02/29/2001;02-29-2000",
        "Description": "This Expression verifies all the valid date in the US Date Format.It also checks the leap year.we can use this expression with or with out the prefix of zero in the date column and month column Eg[01/02/2008 or 1/2/2008].It accepts date which are greater than the year 1900.I can assure that this will be useful for all the developers who are searching for Date entry"
    },
    {
        "Pattern": "&lt;img .+ src[ ]*=[ ]*\\&quot;(.+)\\&quot;",
        "MatchingText": "&lt;img src=&quot;test.jpg&quot;&gt;|||&lt;img align = &quot;left&quot; src = &quot;test.jpg&quot;&g",
        "NonMatchingText": "unknown",
        "Description": "Gets the image url in an HTML &lt;IMG&gt; tag."
    },
    {
        "Pattern": "[ ]*=[ ]*[\\&quot;]*cid[ ]*:[ ]*([^\\&quot;&lt;&gt; ]+)",
        "MatchingText": "&lt;img src=&quot;cid:00a601c57cba$14028d40$ed5cc23e&quot;&gt;|||background=cid:034701c5d97f$7c12fba",
        "NonMatchingText": "&lt;img src=&quot;no.jpg&quot;&gt;",
        "Description": "This is a Microsoft .NET/Mono regular expression that can be used to find the address of an embedded image inside an HTML email body.\n\nThe address will be the 2nd group found in the match."
    },
    {
        "Pattern": "^-?\\d*(\\.\\d+)?$",
        "MatchingText": "4.4|||.4|||-.4",
        "NonMatchingText": ".|||...|||zero",
        "Description": "Matches all positive &amp; negative decimal floating point numbers, to any magnitude. Allows empty string."
    },
    {
        "Pattern": "<img([^>]*[^/])>",
        "MatchingText": "<img src=\"bob\">",
        "NonMatchingText": "<img src=\"bob\" />",
        "Description": "Use this along with this replacement string &lt;img\\1 /&gt; to convert image tags to XHTML compliant image tags.\n\n"
    },
    {
        "Pattern": "^((\\d{2}(([02468][048])|([13579][26]))[-]?((((0?[13578])|(1[02]))[-]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[-]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[-]?((0?[1-9])|([1-2][0-9])))))|(\\d{2}(([02468][1235679])|([13579][01345789]))[-]?((((0?[13578])|(1[02]))[-]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[-]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[-]?((0?[1-9])|(1[0-9])|(2[0-8]))))))(\\s((([0-1]?[0-9])|([2][0-3]))\\:([0-5][0-9])))?$",
        "MatchingText": "2009-12-30 00:00|||2009-02-30 00:00 ||| 2009-12-30 12:00",
        "NonMatchingText": "2009 10 10 23:59|||2009-10-10 25:50|||2009 10 10 23:59",
        "Description": "This expression will validate date format to be yyyy-mm-dd hh:mm."
    },
    {
        "Pattern": "^[a-zA-Z0-9]+(([_][a-zA-Z0-9])?[a-zA-Z0-9]*)*$",
        "MatchingText": "Employee ||| Employee_Test ||| Employee_Dept",
        "NonMatchingText": "Employee.Test ||| Employee$Test ||| Employee@Test",
        "Description": "This Regular Expression. I have used with ASP.NET Regular expression for validating that input string should not have special characters(e.g. $,#,@ etc.]"
    },
    {
        "Pattern": "(^\\d{5}$)|(^\\d{5}-\\d{4}$)",
        "MatchingText": "12345|||12345-6789|||01234",
        "NonMatchingText": "1A234|||12345-aaaa|||12345 1234",
        "Description": "I know its probaly in the library, but i did not see it.\n\nUS zip pattern\n\n5 digits 01234 or 5 digits + 4 01234-1234"
    },
    {
        "Pattern": "^(\\$)?((\\d{1,5})|(\\d{1,3})(\\,\\d{3})*)(\\.\\d{1,2})?$",
        "MatchingText": "80,000.00|||80,000|||80000|||80.00|||$80000.00",
        "NonMatchingText": "800,00.00|||80.000|||$8,0000.00",
        "Description": "This regular expression is used for validating five digit numeric value which can be an amount $ separated with , sign."
    },
    {
        "Pattern": "\\b[\\w]+[\\w.-][\\w]+@[\\w]+[\\w.-]\\.[\\w]{2,4}\\b",
        "MatchingText": "test@test.com ; t3st.t3st@host.host.com testname@testhost.testsubsite.com ; te_st@h3st.de",
        "NonMatchingText": "sadsa.....@xyz.com ; dasd.deasd@asdasd@e.de ; test@host.toolong; te3-st@hosting.com ",
        "Description": "Validates some common email-adresses."
    },
    {
        "Pattern": "'^((0[1-9])|(1[0-2]))\\/*((2011)|(20[1-9][1-9]))$'",
        "MatchingText": "12/2011 12/2099",
        "NonMatchingText": "12/2020 12/2030",
        "Description": "It is useful to validate Expiry date in mm/yyyy format. But it not support when year comes like 2020,2030,2040etc"
    },
    {
        "Pattern": "X-Spam-Level:\\s[*]{11}",
        "MatchingText": "X-Spam-Level: ************",
        "NonMatchingText": "X-Spam-Level: **",
        "Description": "Matches SpamAsssasin score above an arbitrary number.  Allows sorting of spam based on SpamAssassin score.  * should be replaced the symbol configured in SpamAssassin.  "
    },
    {
        "Pattern": "^([(][1-9]{2}[)] )?[0-9]{4}[-]?[0-9]{4}$",
        "MatchingText": "(11) 1234-5678  |  1234-5678  |  12345678",
        "NonMatchingText": "(11)1234-5678  |  (10) 1234.5678  |  123-45678",
        "Description": "This expression matches brazilian's phone numbers with area codes or not."
    },
    {
        "Pattern": "^(1?(-?\\d{3})-?)?(\\d{3})(-?\\d{4})$",
        "MatchingText": "15615552323|||1-561-555-1212|||5613333",
        "NonMatchingText": "1-555-5555|||15553333|||0-561-555-1212",
        "Description": "US Telephone Reg expression that allows 7, 10 or 11 digits with or without hyphens."
    },
    {
        "Pattern": "(((0[123456789]|10|11|12)([/])(([1][9][0-9][0-9])|([2][0-9][0-9][0-9]))))",
        "MatchingText": "01/1900|||10/1990|||12/2999",
        "NonMatchingText": "1/1900|||12/1899|||01/3000",
        "Description": "This is an new data Validation to MM/YYYY from 1900 to 2999 this is an validation expression  to Client From MOnth/Year."
    },
    {
        "Pattern": "(((0[1-9]|[12][0-9]|3[01])([/])(0[13578]|10|12)([/])([1-2][0,9][0-9][0-9]))|(([0][1-9]|[12][0-9]|30)([/])(0[469]|11)([/])([1-2][0,9][0-9][0-9]))|((0[1-9]|1[0-9]|2[0-8])([/])(02)([/])([1-2][0,9][0-9][0-9]))|((29)(\\.|-|\\/)(02)([/])([02468][048]00))|((29)([/])(02)([/])([13579][26]00))|((29)([/])(02)([/])([0-9][0-9][0][48]))|((29)([/])(02)([/])([0-9][0-9][2468][048]))|((29)([/])(02)([/])([0-9][0-9][13579][26])))",
        "MatchingText": "29/02/2004|||31/01/1900|||31/01/2999",
        "NonMatchingText": "29/02/2003|||12042004|||20/04/04",
        "Description": "This is the Brazilian Date Format.\nDD/MM/YYYY with the right days per month.\nDates &gt;=1900 &lt;=2999."
    },
    {
        "Pattern": "(^\\d{3,5}\\,\\d{2}$)|(^\\d{3,5}$)",
        "MatchingText": "100,00|||100|||99999,99",
        "NonMatchingText": "99,99|||999999|||1,00",
        "Description": "Expression to validate values to fields Decimal 5,2 or 5 numbers. values &gt;=100,00 &lt;=99999,99\n\n100,00=100\n5000,00 = 5000"
    },
    {
        "Pattern": "^\\s*[a-zA-Z0-9&amp;\\-\\./,\\s]+\\s*$",
        "MatchingText": "A-9|||b&amp;56-8.2",
        "NonMatchingText": "*u7|||R$25.12",
        "Description": "Valida&#231;&#227;o para letras maiusculas e minusculas sem acentos, incluinto os caracteres . - &amp; e /"
    },
    {
        "Pattern": "(^(\\d{2}.\\d{3}.\\d{3}/\\d{4}-\\d{2})|(\\d{14})$)",
        "MatchingText": "00.000.000/0000-00|||00000000000000",
        "NonMatchingText": "000.000.000/0000-00",
        "Description": "Express&#227;o para a Valida&#231;&#227;o do CNPJ contendo ou n&#227;o os caracteres de separa&#231;&#227;o . e /."
    },
    {
        "Pattern": "((([7-9])(\\d{3})([-])(\\d{4}))|(([7-9])(\\d{7})))",
        "MatchingText": "9999-9595|||88888787|||7777-6589",
        "NonMatchingText": "44445555|||2222-9658|||22223658",
        "Description": "Express&#227;o para a Valida&#231;&#227;o de Telefones Celulares sem o DDD valida celulares com inicio igual a 7,8 e 9."
    },
    {
        "Pattern": "(^(\\d{3}.\\d{3}.\\d{3}-\\d{2})|(\\d{11})$)",
        "MatchingText": "00000000000|||123.456.789-98|||12345678998",
        "NonMatchingText": "0000.000.000-00",
        "Description": "Valida&#231;&#227;o de CPF Brasileiro com ou sem os divisores."
    },
    {
        "Pattern": "^([a-z0-9]+)@([a-z0-9]+)\\\\.([a-zA-Z0-9]+)",
        "MatchingText": "abc@xooxle.com  |  tiger01@xooxleschool07.edu | 1@0xooxle0.70 .",
        "NonMatchingText": "@xooxle.com  |  helloworld  |  x@abc .",
        "Description": "A@A.A\nwith A is any lowercase English letter or Arabic digit or both together."
    },
    {
        "Pattern": "^\\d{0,2}(\\.\\d{1,2})?$",
        "MatchingText": "99.99|||99|||.99",
        "NonMatchingText": "999.999|||999|||.999",
        "Description": "This regular expression validates that the data entered is a number with a maximum of two integers and two decimals and a minimum of one integer or one decimal."
    },
    {
        "Pattern": "\\\\red([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\\\green([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\\\blue([01]?\\d\\d?|2[0-4]\\d|25[0-5]);",
        "MatchingText": "\\red76\\green157\\blue76;|||\\red0\\green0\\blue0;|||\\red120\\green120\\blue120;",
        "NonMatchingText": "\\red0\\green\\257\\blue120;|||\\red0\\green0\\blue0|||red120\\green120\\blue120;",
        "Description": "This RegEx will match a RTF color taken from a color tabel in a RTF document (having the form '\\redXXX\\greenXXX\\blueXXX;', where XXX is a number between 0 and 255)."
    },
    {
        "Pattern": "^http\\://[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}(/\\S*)?$",
        "MatchingText": "http://psychopop.org|||http://www.edsroom.com/newUser.asp|||http://unpleasant.jarrin.net/markov/inde",
        "NonMatchingText": "ftp://psychopop.org|||http://www.edsroom/|||http://un/pleasant.jarrin.net/markov/index.asp",
        "Description": "Verifies URLs.  Checks for the leading protocol, a good looking domain (two or three letter TLD; no invalid characters in domain) and a somwhat reasonable file path."
    },
    {
        "Pattern": "\n1-844-788-4223",
        "MatchingText": "00",
        "NonMatchingText": "Quicken ",
        "Description": "Using Quicken is always concerning as this application comes with a lot of components. Otherwise, the software is quite advanced as well as seamless for budget planning purposes. \n\nMore info : http://digitalaccountingsolutions.com"
    },
    {
        "Pattern": "^[http|ftp|wap|https]{3,5}:\\//\\www\\.\\w*\\.[com|net]{2,3}$",
        "MatchingText": "http://www.google.com",
        "NonMatchingText": "httpp://wwww.go.com.in",
        "Description": "it validates a simple URL like http://www.google.com , ftp://www.soso.com"
    },
    {
        "Pattern": "^(([0-9]{2})|([a-zA-Z][0-9])|([a-zA-Z]{2}))[0-9]{6}$",
        "MatchingText": "12345678, OC123456, SC058132, R7654321",
        "NonMatchingText": "1234567, AB1324567",
        "Description": "Matches a UK company number. According to HMRC these must have 8 digits, of which up to the first two may be an alpha prefix. This doesn't test for validity of the prefix."
    },
    {
        "Pattern": "^([A-Z0-9]{5})$",
        "MatchingText": "AAAA1, 1111A, AW12A",
        "NonMatchingText": "aAAAA, 1111a, AAAA, AAAAAA",
        "Description": "Simply match to a combination of 5 characters, using capital letters and numbers only. No special characters or lower case letters."
    },
    {
        "Pattern": "(1[8,9]|20)[0-9]{2}",
        "MatchingText": "1821, 1950, 2050, 2010",
        "NonMatchingText": "1700, 2100",
        "Description": "Valid for years 1800-2099. Can be easily modified to extend the range"
    },
    {
        "Pattern": "(refs|references|re|closes|closed|close|see|fixes|fixed|fix|addresses) #(\\d+)(( and |, | & | )#(\\d+))*",
        "MatchingText": "fix #313|||references #1024 and #1337",
        "NonMatchingText": "fixed 313|||refer #1024",
        "Description": "This expression can be used to set the bugtraq:logrexep property of a subversion repository. It uses the format supported by trac and enables for example tortoisesvn to transform the issue numbers used in the commit messages into links pointing to the issue in the bugtracker."
    },
    {
        "Pattern": "\\b[^aeiou]+[aeiou][^aeiou]+\\b",
        "MatchingText": "cat match",
        "NonMatchingText": "paper vehicle",
        "Description": "Finds all one syllable words. the letters in brackets are vowels and they can be changed depending on the language."
    },
    {
        "Pattern": "^([0-9A-Za-z@.]{1,255})$",
        "MatchingText": "BigBlue|||1234.1411|||bob@bob.com",
        "NonMatchingText": "&amp;lt;&amp;gt;'&amp;amp;amp&amp;amp;lt&amp;amp;rt*^%$",
        "Description": "This is an update of Paul Miller's RegEx.  It will cut out literal &amp;lt;&amp;gt; but I haven't fully tested it, it's just a quick fix since his didn't work all that well.\n\nI also took out the \\s.  You could add this back in but I use this for very simple password verification, and I certainly have no use for spaces in my passwords."
    },
    {
        "Pattern": "(&#200;|&#201;|&#202;|&#203;|&#232;|&#233;|&#234;|&#235;|&amp;#069;|&amp;#101;|&amp;#200;|&amp;#201;|&amp;#202;|&amp;#203;|&amp;Egrave;|&amp;Eacute;|&amp;Ecirc;|&amp;Euml;|&amp;#232;|&amp;#233;|&amp;#234;|&amp;#235;|&amp;egrave;|&amp;eacute;|&amp;ecirc;|&amp;euml;)",
        "MatchingText": "&#203;very one|||&#203;nlarg&#235;m&#234;nt|||b&#234;st &#235;ver",
        "NonMatchingText": "Every one|||Enlargement|||best ever",
        "Description": "Spam stopper, catches non english characters used in flocks."
    },
    {
        "Pattern": "^(\\d|,)*\\d*$",
        "MatchingText": "1234|||1,234|||1,234,567",
        "NonMatchingText": "1234.0|||-1234|||$1234",
        "Description": "matches 0 and all positive integers only. will accept comma formatting only."
    },
    {
        "Pattern": "\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])(?:.\\d{7})?[+|-](0[0-9]|1[0-2]):(00|15|30|45)",
        "MatchingText": "2004-10-31T22:06:00+12:00 ||| 2006-04-31T12:31:39.6230000+05:45 ||| 2009-01-08T20:25:26-03:00",
        "NonMatchingText": "2009-01-09T12:23:34 ||| 2009-01-09 17:45:22 ||| 2009-05-32T12:67:23-15:00 ||| 2009-13-32T25:76:23",
        "Description": "Complete date-time format according to the ISO 8601 standard."
    },
    {
        "Pattern": "^[^-]{1}?[^\\\"\\']*$",
        "MatchingText": "65 ghf, 65% - consumed, hello, 64 - 56",
        "NonMatchingText": "-65 ghf, -164, 65% - \"consumed\"",
        "Description": "to accept only alphanumeric with all special characters except (double/single Quotes). and if numbers then only positive numbers"
    },
    {
        "Pattern": "([^a-zA-Z0-9])",
        "MatchingText": "Test!|||This will match|||H3llo$",
        "NonMatchingText": "Test|||Thiswillnotmatch|||H3llo",
        "Description": "(Corrected)\nThis pattern will match 1 instance of a NON-alphanumeric character. This is very handy to use when y\nou want to filter input only by alphanumeric characters, by using Regex.Replace.\n\nHowever, when used in a Regex.Replace, it will replace all instances of non-alphanumeric characters \nwith specified character."
    },
    {
        "Pattern": "^(\\d?)*\\.?(\\d{1}|\\d{2})?$",
        "MatchingText": "153 | 33.48 | 786.1 | 1567863483.33",
        "NonMatchingText": "-123 | 8524.258 | eo45",
        "Description": "Expression to validate currency formatted numbers without the currency symbol. This is an updated version of my previous expression and now works in ASP.NET regular expression validators."
    },
    {
        "Pattern": "^(((\\+|00)?44|0)([123578]{1}))(((\\d{1}\\s?\\d{4}|\\d{2}\\s?\\d{3})\\s?\\d{4})|(\\d{3}\\s?\\d{2,3}\\s?\\d{3})|(\\d{4}\\s?\\d{4,5}))$",
        "MatchingText": "0XX XXXX XXXX | 0XXX XXX XXXX | 0XXXX XXXXXX ",
        "NonMatchingText": "04XXX XXXXXX | 06XXX XXXXXX | 0XXXXXXX",
        "Description": "Validates UK phone numbers based on the Wikipedia page http://en.wikipedia.org/wiki/Telephone_numbers_in_the_United_Kingdom including the international dialing code 0044/+44/44"
    },
    {
        "Pattern": "^(0[1-9]|1[0-2])\\/((0[1-9]|2\\d)|3[0-1])\\/(19\\d\\d|200[0-3])$",
        "MatchingText": "12/31/2003|||01/01/1900|||11/31/2002",
        "NonMatchingText": "1/1/2002|||01/01/02|||01/01/2004",
        "Description": "This expression is an attempt to match the most obvious features of a valid date in American/US format of the form mm/dd/yyyy for any year 1900 through 2003.  It can easily be adapted for different date ranges.  It matches any date where the day part is any number 01-31, the month part is any number 01-12, and the year part is any number 1900-2003.  The only invalid dates that it matches are ones where the day part may be in the range 01-31 but that range might not be valid for the specified month.  An example of an invalid date that it would allow to pass through would be 11/31/2002.  This date is invalid because 11/31 of any year does not exist, but this expression would allow it pass through since the day part is in the range 01-31.\n\nThis regular expression has been used successfully in ASP with VBScript using the windows scripting library RegExp object."
    },
    {
        "Pattern": "^((\\+)?(\\d{2}[-]))?(\\d{10}){1}?$",
        "MatchingText": "+91-9822345654,9822345654",
        "NonMatchingText": "+923-9855777897,6463466",
        "Description": "This Pattern is to Validate Mobile Number with 10 digit Number and Countrycode as Optional."
    },
    {
        "Pattern": "^((\\+)?(\\d{2})[-])?(([\\(])?((\\d){3,5})([\\)])?[-])|(\\d{3,5})(\\d{5,8}){1}?$",
        "MatchingText": "+91-020-2344533,020-2344533.+91-(020)-2344533,-(020)-2344533",
        "NonMatchingText": "5444474445,",
        "Description": "Telephone Number Validation with Country code Optional but Mandatory Area Code."
    },
    {
        "Pattern": "^([a-zA-Z](?:(?:(?:\\w[\\.\\_]?)*)\\w)+)([a-zA-Z0-9])$",
        "MatchingText": "amey_p, swars.k, anand5_king, addy_tom.16",
        "NonMatchingText": "_amol.p, raj__vega5, 4aman_p, ashish..p",
        "Description": "This Pattern is used to validate Login Name with . and _ seprators only."
    },
    {
        "Pattern": "^[a-zA-Z]([a-zA-Z[._][\\d]])*[@][a-zA-Z[.][\\d]]*[.][a-z[.][\\d]]*",
        "MatchingText": "amol_pande@rediffmail.com, sachin.patin@yahoo.co.in, raj55_Dec83@yahoo.co.in, am.4_be4@rediff.com",
        "NonMatchingText": "2_ash@in.com, a_be4@rediff.com",
        "Description": "This Pattern used to Validate single Email Address .with first character as Alphabate and allowing . and _ as seprator more that once."
    },
    {
        "Pattern": "^(ht|f)tp(s?)\\:\\/\\/[a-zA-Z0-9\\-\\._]+(\\.[a-zA-Z0-9\\-\\._]+){2,}(\\/?)([a-zA-Z0-9\\-\\.\\?\\,\\'\\/\\\\\\+&amp;%\\$#_]*)?$",
        "MatchingText": "http://www.thedaddy.org|||http://forum.thedaddy.org/index.html|||ftp://hows.it.going_buddy/checkit/o",
        "NonMatchingText": "www.thedaddy.org|||http://hello|||ftp://check.it",
        "Description": "Cheap and cheerful URL checker. Requires a http/https/ftp at the start and will then allow anything starting with at least a &lt;something&gt;.&lt;something&gt;.&lt;something&gt; then valid characters separated by dots and slashes"
    },
    {
        "Pattern": "^([1-9]+[0-9]*|\\d*[.,]\\d)$",
        "MatchingText": "51|||0.5|||14,7",
        "NonMatchingText": "0|||.5|||1.54|||015|||,4|||-1.5",
        "Description": "This RegEx allow every positive number except 0 with a limit of 1 decimal.\nYou can use coma or dot."
    },
    {
        "Pattern": "^([_a-zA-Z0-9-]+\\.[_a-zA-Z0-9-]*)\\@((([a-zA-Z0-9-]{2,255})\\.(ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|de|di|dk|dm|do|dz|ec|ee|eg|eh|er|es|et|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|in|io|iq|ir|is|it|jo|jm|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|an|nc|ne|nf|ng|ni|nl|no|np|nr|nt|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|pt|pw|py|qa|re|ro|ru|rw|sa|sb|sc|sd|se|sq|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|um|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zr|zw|arpa|arts|biz|com|edu|firm|gov|info|int|mil|nato|net|nom|org|rec|store|web))|((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])))$",
        "MatchingText": "john.doe@texas.com john_doe@texas.com john.doe@192.168.0.1 john_doe@192.168.0.1",
        "NonMatchingText": "john.doe@123.123.123 john.does@256.123.256.123",
        "Description": "This Regular Expression searches for a valid eMail address. It uses a list of all the known top-level-domains to verify that the domain is correct. Also Possible to find the IP Address"
    },
    {
        "Pattern": "^(([a-zA-Z]\\:)|(\\\\))(\\\\{1}|((\\\\{1})[^\\\\]([^/:*?<>\"|]*))+)$",
        "MatchingText": "C:\\SomeFilePatt|\\\\SomeServer\\SomeShare",
        "NonMatchingText": "C:|\\SomeServer",
        "Description": "Checks for a valid Filepath, either located on a local drive or a UNC share on the network. Use the following string to include the regex within a XML defintion file: RegEx=\"^([a-zA-Z]\\:)|(\\\\)(\\\\{1}|((\\\\{1})[^\\\\]([^/:*?&lt;&gt;&quot;|]*(?&lt;!\\[\\])))+)$\"/> (encode the appropiate HTML characters like <,>,\" with the appropiate HTML codes < = (ampersand)lt; > = (ampersand)gt; \" = (ampersand)quote;"
    },
    {
        "Pattern": "^(^(100{1,1}$)|^(100{1,1}\\.[0]+?$))|(^([0]*\\d{0,2}$)|^([0]*\\d{0,2}\\.(([0][1-9]{1,1}[0]*)|([1-9]{1,1}[0]*)|([0]*)|([1-9]{1,2}[0]*)))$)$",
        "MatchingText": "100.00000000,0033.0000,45.55000,45.01",
        "NonMatchingText": "45.020,0100.00,15.006",
        "Description": "This pattern is designed to allow user to enter percentage values. "
    },
    {
        "Pattern": "((\\d|([a-f]|[A-F])){2}:){5}(\\d|([a-f]|[A-F])){2}",
        "MatchingText": " 00:00:39:F9:3C:59|||00:90:83:6A:B3:B7|||00:00:39:59:30:5C",
        "NonMatchingText": "00:0H:39:59:30:5C|||00:39:59:30:5C|||00:39:59:30:5C:BZ",
        "Description": "Deisgned to verify a MAC address with hex values seperated by a colon."
    },
    {
        "Pattern": "(\\+1 )?\\d{3} \\d{3} \\d{4} ",
        "MatchingText": "+1 808 555 1234",
        "NonMatchingText": "808-555-1234  |  +1 (808) 555-1234",
        "Description": "This simple expression validates a USA phone number format where the +1 is required and that the phone number must only consist of numbers and spaces."
    },
    {
        "Pattern": "\\+44\\s\\(0\\)\\s\\d{2}\\s\\d{4}\\s\\d{4}",
        "MatchingText": "+44 (0) 55 4444 3333",
        "NonMatchingText": "+44 (0) 5555555555  |  55 4444 3333",
        "Description": "Simple expression to validate a UK phone number including country code and area code.  Requires spacing."
    },
    {
        "Pattern": "\\+353\\(0\\)\\s\\d\\s\\d{3}\\s\\d{4}",
        "MatchingText": "+353(0) 5 444 3333",
        "NonMatchingText": "+353(0) 55555555  | 5 444 3333",
        "Description": "This simple expression evaluates an Ireland phone number.  It requires the country code and dialing instructions for an international call plus spaces within the number. "
    },
    {
        "Pattern": "/\\/\\*[\\d\\D]*?\\*\\//",
        "MatchingText": "/** A comment **/|/* A commment */| /* */",
        "NonMatchingText": "// A comment|//",
        "Description": "If you are caching PHP code you may want to remove long comments from the code before caching it.  This expression will remove all /* */ style comments."
    },
    {
        "Pattern": "[v,V,(\\\\/)](\\W|)[i,I,1,l,L](\\W|)[a,A,@,(\\/\\\\)](\\W|)[g,G](\\W|)[r,R](\\W|)[a,A,@,(\\/\\\\))]",
        "MatchingText": "Viagra|||v1@G R /\\|||\\/iagr@",
        "NonMatchingText": "viaagra|||vi  agra|||v1  gra",
        "Description": "Spam trap\nCatches many and many way to write viagra (replacing letters with similar chars, spacing chars with one space, etc)."
    },
    {
        "Pattern": "^0$|^[1-9][0-9]*$|^[1-9][0-9]{0,2}(,[0-9]{3})$",
        "MatchingText": "1234|||0|||12,345",
        "NonMatchingText": "12,3245|||-1|||1234.23",
        "Description": "I need a pattern to match the whole number / integer (0-99999...), but also allow users to put comma in the thousand positions. \n\nThis is what I got."
    },
    {
        "Pattern": "^(429496729[0-6]|42949672[0-8]\\d|4294967[01]\\d{2}|429496[0-6]\\d{3}|42949[0-5]\\d{4}|4294[0-8]\\d{5}|429[0-3]\\d{6}|42[0-8]\\d{7}|4[01]\\d{8}|[1-3]\\d{9}|[1-9]\\d{8}|[1-9]\\d{7}|[1-9]\\d{6}|[1-9]\\d{5}|[1-9]\\d{4}|[1-9]\\d{3}|[1-9]\\d{2}|[1-9]\\d|\\d)$",
        "MatchingText": "0, 32768, 4294967296, 11111",
        "NonMatchingText": "-65535, 123.23, 4294967297, 01024",
        "Description": "Validates a 32bit integer from 0 through 4294967296 without leading zeros. An expansion of the 16 bit version http://regexlib.com/REDetails.aspx?regexp_id=1427"
    },
    {
        "Pattern": "<[\\w\\\"\\ '\\#\\* \\=\\',\\.\\\\\\(\\)\\/\\-\\$\\{\\}\\[\\]\\|\\*\\?\\+\\^\\&\\:\\%\\;\\!]+>",
        "MatchingText": "Any html tag with or without attributes and events",
        "NonMatchingText": "literal text",
        "Description": "This regular expression allows you to extract literal text from an HTML (SGML compliant?) document. i believe it will also work for XML. using code to replace the HTML element you can extract the literal text only."
    },
    {
        "Pattern": "[0](\\d{9})|([0](\\d{2})( |-|)((\\d{3}))( |-|)(\\d{4}))|[0](\\d{2})( |-|)(\\d{7})|(\\+|00|09)(\\d{2}|\\d{3})( |-|)(\\d{2})( |-|)((\\d{3}))( |-|)(\\d{4})",
        "MatchingText": "073-386-2612 , 0443862612 , 076 858 7777 , +27 76 858 7777 , 0027 765877777 , 0956 33 8881234",
        "NonMatchingText": "invalid numbers",
        "Description": "allows validation of phone numbers in different formats, including local dialing code (eg 033 or 076) or international dialing code in the formats +12 or 0012 or 0912. "
    },
    {
        "Pattern": "(^0[87][23467]((\\d{7})|( |-)((\\d{3}))( |-)(\\d{4})|( |-)(\\d{7})))",
        "MatchingText": "0848298477|||084 829 8477|||084-829 8477",
        "NonMatchingText": "084829 8477",
        "Description": "only allows valid cell phones from south african service providers. to date i havent seen a cell phone number starting 079 or 089 but i think the networks might support it..."
    },
    {
        "Pattern": "[\\s]a[\\s]|[\\s]about[\\s]|[\\s]an[\\s]|[\\s]are[\\s]|[\\s]as[\\s]|[\\s]at[\\s]|[\\s]be[\\s]|[\\s]by[\\s]|[\\s]for[\\s]|[\\s]from[\\s]|[\\s]how[\\s]|[\\s]in[\\s]|[\\s]is[\\s]|[\\s]it[\\s]|[\\s]of[\\s]|[\\s]on[\\s]|[\\s]or[\\s]|[\\s]that[\\s]|[\\s]the[\\s]|[\\s]this[\\s]|[\\s]to[\\s]|[\\s]was[\\s]|[\\s]what[\\s]|[\\s]when[\\s]|[\\s]where[\\s]|[\\s]who[\\s]|[\\s]will[\\s]|[\\s]with[\\s]|[\\s]the[\\s]|[\\s]www[\\s]",
        "MatchingText": "matched words listed between the whitespace character class",
        "NonMatchingText": "the words not included in the white space character class",
        "Description": "use this to produce search strings in your programs that run more efficiently. use the replace of the regex class to remove the characters from the user input then use the resulting string to query the database..."
    },
    {
        "Pattern": "^(?P<Assembly>(?P<AssemblyName>[^\\W/\\\\:*?\"<>|,]+)(?:(?:,\\s?(?:(?P<Version>Version=(?P<VersionValue>(?:\\d{1,2}\\.?){1,4}))|(?P<Culture>Culture=(?P<CultureValue>neutral|\\w{2}-\\w{2}))|(?P<PublicKeyToken>PublicKeyToken=(?P<PublicKeyTokenValue>[A-Fa-f0-9]{16})))(?:,\\s?)?){3}|))$",
        "MatchingText": "mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
        "NonMatchingText": "mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=INVALIDTOKEN",
        "Description": "Matches a .Net assembly name and groups each part of the name using named groups (not supported by all regex engines)."
    },
    {
        "Pattern": "^(?P<Namespace>(?:[\\w][\\w\\d]*\\.?)*)\\.(?P<Class>[\\w][\\w\\d<>]*(?:(?:\\+[\\w][\\w\\d<>]*)+|))(?:|,\\W?(?P<Assembly>(?P<AssemblyName>[^\\W/\\\\:*?\"<>|]+)(?:$|(?:,\\W?(?:(?P<Version>Version=(?P<VersionValue>(?:\\d{1,2}\\.?){1,4}))|(?P<Culture>Culture=(?P<CultureValue>neutral|\\w{2}-\\w{2}))|(?P<PublicKeyToken>PublicKeyToken=(?P<PublicKeyTokenValue>[A-Fa-f0-9]{16})))(?:,\\W?)?){3})))$",
        "MatchingText": "System.Collections.Generic.List<T>+Enumerator<T>, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
        "NonMatchingText": "System.Int32, ",
        "Description": "Matches a full .Net type name and breaks all the parts of the type and assembly into named groups (not supported by all regex engines)"
    },
    {
        "Pattern": "^(([A-Za-z][A-Za-z0-9.+]*?){1,}?)(,\\s?([^/\\\\:*?\"<>|]*((,\\s?(Version=(\\d\\.?){1,4}|Culture=(neutral|\\w{2}-\\w{2})|PublicKeyToken=[a-f0-9]{16})(,\\s?)?){3}|))){0,1}$",
        "MatchingText": "Namespace.Class, Assembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=0000000000000000",
        "NonMatchingText": "Namespace.Class, Assembly, Version=1.0.0.0, Culture=neutral",
        "Description": "Matches a .Net Framework type name. This expression also matches non-strong named types such as:\n\nNamespace.Class\n\nand\n\nNamespace.Class, Assembly"
    },
    {
        "Pattern": "^([a-zA-Z0-9]+[._-])*[a-zA-Z0-9]+@(([a-zA-Z0-9]+|([a-zA-Z0-9]+[.-])+)[a-zA-Z0-9]+\\.[a-zA-Z]{2,4}|([a-zA-Z]\\.com))$",
        "MatchingText": "a.b-c_d@x.y-z.zz",
        "NonMatchingText": "xx@mm.c | x@n.cc | a..b@x-y.zz",
        "Description": "Validates format of email addresses including q.com but not q.net"
    },
    {
        "Pattern": "/^([A-Za-z]){1}([A-Za-z0-9-_.\\:])+$/",
        "MatchingText": "site-section.1",
        "NonMatchingText": "#section",
        "Description": "Validate a proper HTML ID attribute. By definition, this must start with a letter, and only include letters, numbers, colons, underscores, hyphens and periods"
    },
    {
        "Pattern": "(1)?-?\\(?\\s*([0-9]{3})\\s*\\)?\\s*-?([0-9]{3})\\s*-?\\s*([0-9]{4})\\s*",
        "MatchingText": "(123)456-7890|||1234567890|||123 456 7890|||123-456-7890|||(123)4567890|||123-4567890",
        "NonMatchingText": "123456789|||(1234)567890|||(12-3)4567890",
        "Description": "A very simple regex to parse 10-digit US phone numbers.  Captures the leading 1 in $1, the area code in $2, the 3-digit prefix in $3, and the four-digit postfix in $4.\n\nThis expression DOES allow for reserved area codes (001,etc) which are not typically in use."
    },
    {
        "Pattern": "^([a-zA-Z,#/ \\.\\(\\)\\-\\+\\*]*[0-9]){7}[0-9a-zA-Z,#/ \\.\\(\\)\\-\\+\\*]*$",
        "MatchingText": "1234567 ||| 12345678 ||| (555) 987-6543 ext 210 ||| 999-666-7777-x1967",
        "NonMatchingText": "123456 ||| 555-123",
        "Description": "Very flexible phone number entry. -- There are many valid ways to enter a phone number, and often there is other data that a restrictive Regex pattern will not abide. -- This pattern accepts any number of letters, commas, pound signs, slashes, spaces, periods, parenthesis, hyphens, plus signs, and asterisks... but amongst it scans for a minimum of 7 digits (modify {7} to adjust the minimum number of required digits (i.e. 10 for area code + phone number, 18 for long international numbers). -- This pattern does not attempt to restrict the entered phone number format in any way, but instead just verfies that enough digits for one was entered. -- Data in excess of the 7 required digits is allowed. -- I've posted another submission that forces compliance for US phone numbers."
    },
    {
        "Pattern": "^([a-zA-Z,#/ \\.\\(\\)\\-\\+\\*]*[2-9])([a-zA-Z,#/ \\.\\(\\)\\-\\+\\*]*[0-9]){2}([a-zA-Z,#/ \\.\\(\\)\\-\\+\\*]*[2-9])([a-zA-Z,#/ \\.\\(\\)\\-\\+\\*]*[0-9]){6}[0-9a-zA-Z,#/ \\.\\(\\)\\-\\+\\*]*$",
        "MatchingText": "987-654-3210 ||| (555) 555-1212 ||| (555) 487-1391 x652 ||| phn (555) 987-6743 ext. 21012",
        "NonMatchingText": "123 456-7890 ||| (555) 000-1111",
        "Description": "Very flexible US phone number entry. -- There are many valid ways to enter a phone number, and often there is other data that a restrictive Regex pattern will not abide. -- This pattern accepts any number of letters, commas, pound signs, slashes, spaces, periods, parenthesis, hyphens, plus signs, and asterisks... but amongst it scans for a minimum of 10 digits, the first and fourth of which cannot be 0 or 1 (per US phone number standards in 2006). -- Data in excess of the 10 required digits is allowed."
    },
    {
        "Pattern": "^[\\w-]+(\\.[\\w-]+)*@([a-z0-9-]+(\\.[a-z0-9-]+)*?\\.[a-z]{2,6}|(\\d{1,3}\\.){3}\\d{1,3})(:\\d{4})?$",
        "MatchingText": "username@domain.com|||u-s_e.r1@s-ub2.domain-name.museum:8080|||user_name@123.123.123.12",
        "NonMatchingText": "user@domain|||user@domain.c|||user.@domain.com",
        "Description": "Matches a valid email address including ip's which are rarely used. Allows for a-z0-9_.- in the username, but not ending in a full stop i.e user.@domain.com is invalid and a-z0-9- as the optional sub domain(s) with domain name and a 2-7 char (a-z) tld allowing for short tld's like ca and new ones like museum."
    },
    {
        "Pattern": "^([A-PR-UWYZ0-9][A-HK-Y0-9][AEHMNPRTVXY0-9]?[ABEHMNPRVWXY0-9]? {1,2}[0-9][ABD-HJLN-UW-Z]{2}|GIR 0AA)$",
        "MatchingText": "DN3 6GB|||SW42 4RG|||GIR 0AA",
        "NonMatchingText": "SEW4 5TY|||AA2C 4FG|||AA2 4CV",
        "Description": "Regular expression to match valid UK postcodes.\n\nIn the UK postal system not all letters are used in all positions (the same with vehicle registration plates) and there are various rules to govern this.  This regex takes into account those rules.\n\nDetails of the rules:\n\nFirst half of postcode  \n    Valid formats   \n        [A-Z][A-Z][0-9][A-Z]  \n        [A-Z][A-Z][0-9][0-9]  \n        [A-Z][0-9][0-9]  \n        [A-Z][A-Z][0-9]  \n        [A-Z][A-Z][A-Z]  \n        [A-Z][0-9][A-Z]  \n        [A-Z][0-9]                 \n\n\n    Exceptions  \n\n        Position - First.  \n\n        Contraint - QVX not used    \n\n        Position - Second.  \n\n        Contraint - IJZ not used except in GIR 0AA  \n\n        Position - Third.  \n        Constraint - AEHMNPRTVXY only used  \n\n        Position - Forth.  \n        Contraint - ABEHMNPRVWXY  \n\n\n\nSecond half of postcode       \n    Valid formats     \n        [0-9][A-Z][A-Z]  \n\n\n    Exceptions  \n        Position - Second and Third.  \n        Contraint - CIKMOV not used  \n"
    },
    {
        "Pattern": "^([0-9]*)+(,[0-9]+)+$",
        "MatchingText": "100,200,300",
        "NonMatchingText": "100,200,",
        "Description": "This regular expression is used to validate only comma separated numbers."
    },
    {
        "Pattern": "&lt;[aA][ ]{0,}([a-zA-Z0-9&quot;'_,.:;!?@$&amp;()%=/ ]|[-]|[\t\\f]){0,}&gt;((&lt;(([a-zA-Z0-9&quot;'_,.:;!?@$&amp;()%=/ ]|[-]|[\t\\f]){0,})&gt;([a-zA-Z0-9&quot;'_,.:;!?@$&amp;()%=/ ]|[-]|[\t\\f]){0,})|(([a-zA-Z0-9&quot;'_,.:;!?@$&amp;()%=/ ]|[-]|[\t\\f]){0,})){0,}",
        "MatchingText": "&lt;a href='javascript:functionA();'&gt;&lt;i&gt;this text is italicized&lt;/i&gt;&lt;/a&gt;",
        "NonMatchingText": "&lt;A href='#'&gt;&lt;P&lt;/A&gt;&lt;/P&gt;",
        "Description": "I wrote this sweet little (well, not so little really) reg to extract links from an HTML source....  it is very robust, give it a try.\nThe only limitation I have discovered is that it can't match invalid HTML..."
    },
    {
        "Pattern": "https?://[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*(?:\\.[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)*/\\S*",
        "MatchingText": "http://www.example.com/ https://localhost/whatever",
        "NonMatchingText": "http://www.example.com ftp://localhost/whatever",
        "Description": "HTTP(S) URL validator with embededded multi-part host name validator, RFC-compliant but does not validate length of components or overall length.  Path portion after host name is free-form and will need refinement if you want to validate it."
    },
    {
        "Pattern": "[A-Za-z0-9!#$%&'*+\\-/=?^_`{|}~]+(?:\\.[A-Za-z0-9!#$%&'*+\\-/=?^_`{|}~]+)*@[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*(?:\\.[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)*",
        "MatchingText": "mike@localhost sue@example.com",
        "NonMatchingText": "mike @localhost sue.@example.com",
        "Description": "Email address validator with embededded multi-part host name validator, RFC-compliant but does not validate length of components or overall length."
    },
    {
        "Pattern": "^(((19|20)(([0][48])|([2468][048])|([13579][26]))|2000)[\\-](([0][13578]|[1][02])[\\-]([012][0-9]|[3][01])|([0][469]|11)[\\-]([012][0-9]|30)|02[\\-]([012][0-9]))|((19|20)(([02468][1235679])|([13579][01345789]))|1900)[\\-](([0][13578]|[1][02])[\\-]([012][0-9]|[3][01])|([0][469]|11)[\\-]([012][0-9]|30)|02[\\-]([012][0-8])))$",
        "MatchingText": "1900-01-01|||2099-12-31|||2004-02-29",
        "NonMatchingText": "20060526|||1900-02-29|||2100-01-01",
        "Description": "This regex match dates in the international standard date notation by ISO (IS0 8601). It can validate any dates between 1900-01-01 and 2099-12-31 ant take account of leap years. The format is mandatory and the hyphen is needed.  You could easily change it to accept other separators.  It has been tested with Regex Coach and PHP."
    },
    {
        "Pattern": "^(^(([0-9A-F]{1,4}(((:[0-9A-F]{1,4}){5}::[0-9A-F]{1,4})|((:[0-9A-F]{1,4}){4}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,1})|((:[0-9A-F]{1,4}){3}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,2})|((:[0-9A-F]{1,4}){2}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,3})|(:[0-9A-F]{1,4}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,4})|(::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,5})|(:[0-9A-F]{1,4}){7}))$|^(::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,6})$)|^::$)|^((([0-9A-F]{1,4}(((:[0-9A-F]{1,4}){3}::([0-9A-F]{1,4}){1})|((:[0-9A-F]{1,4}){2}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,1})|((:[0-9A-F]{1,4}){1}::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,2})|(::[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,3})|((:[0-9A-F]{1,4}){0,5})))|([:]{2}[0-9A-F]{1,4}(:[0-9A-F]{1,4}){0,4})):|::)((25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{0,2})\\.){3}(25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{0,2})$$",
        "MatchingText": "::0:0:0:FFFF:129.144.52.38|||FEDC:BA98::3210:FEDC:BA98:7654:3210|||::13.1.68.3",
        "NonMatchingText": "FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:1234|||3210:FEDC:BA98:7654:3210:1234|||:FEDC:BA98:7654:3210:",
        "Description": "Matches all IPv6 text representations as defined within RFC 2373. Fairly verbose"
    },
    {
        "Pattern": "^\\+[0-9]{1,3}\\([0-9]{3}\\)[0-9]{7}$",
        "MatchingText": "+555(555)5555555||+1(800)5555555",
        "NonMatchingText": "555",
        "Description": "The OAGIS standard has a format for phone and fax as +###(###)#######. For details on standard see the open applications group."
    },
    {
        "Pattern": "([^\\.\\?\\!]*)[\\.\\?\\!]",
        "MatchingText": "This is a series of sentences. They end predictably! Where would we be without punctuation?",
        "NonMatchingText": "This sentence just trails off",
        "Description": "Finds sentences (assuming they end with a full stop, question mark or exclamation mark)."
    },
    {
        "Pattern": "(([0-1][0-9])|([2][0-3])):([0-5][0-9]):([0-5][0-9])",
        "MatchingText": "09:30:00|||17:45:20|||23:59:59",
        "NonMatchingText": "24:00:00",
        "Description": "Validates time in MySQL time format.  24 hour time colon seperated hours:minutes:seconds"
    },
    {
        "Pattern": "^(9|2{1})+([1-9]{1})+([0-9]{7})$",
        "MatchingText": "265000000 960000000 930000000 910000000 920000000",
        "NonMatchingText": "95xxxxxxx 200xxxxxx 900000000",
        "Description": "A regex for phone numbers in Portugal. For the three major operators (TMN, Optimus, Vodafone) and landline number. 1 number (2/9) + 1 number (1-9) + 7 others (0-9)."
    },
    {
        "Pattern": "^\\$?([1-9][0-9]{3,}(\\.\\d{2})?|(\\d{1,3}\\,\\d{3}|\\d{1,3}\\,\\d{3}(\\.\\d{2})?)|(\\d{1,3}\\,\\d{3}|\\d{1,3}\\,\\d{3}\\,\\d{3}(\\.\\d{2})?)*)?$\n",
        "MatchingText": "$1000|||$1,000,000.00|||9,999",
        "NonMatchingText": "999.00|||$1,000,000,000.00|||5.00",
        "Description": "Currency which cannot be less than $1000 and lower than a billion."
    },
    {
        "Pattern": "(?i)0b(?:_?[01])+|0o(?:_?[0-7])+|0x(?:_?[0-9a-f])+|[1-9](?:_?\\d)*|0(?:_?0)*",
        "MatchingText": "0|1|12|123_456|0b0|0b1|0b01|0o0|0o12|0x0|0x12f",
        "NonMatchingText": "01|0__1|0b32|0o98|0xhi",
        "Description": "A python-style integer, with support for decimal, binary, octal and decimal, and underscore group separator."
    },
    {
        "Pattern": "^(([-\\w$%&'*+\\/=?^_`{|}~.]+)@(([-a-zA-Z0-9_]+\\.)*)([-a-zA-Z0-9]+\\.)([a-zA-Z0-9]{2,7}))?$",
        "MatchingText": "john.o'malley@mail.example.org",
        "NonMatchingText": "aoluser1",
        "Description": "RFC2822 compliant email matching regex that doesn't assume TLDs are set for all time. Clearly this means that someone could get a 2 letter country code wrong, but since no TLD is set in stone, I prefer to match future possibilities as well. This also conforms to what traditional DNS can do w/r/t hostnames and domain names."
    },
    {
        "Pattern": "^(([0]?[1-9]|[1][0-2])[\\/|\\-|\\.]([0-2]\\d|[3][0-1]|[1-9])[\\/|\\-|\\.]([2][0])?\\d{2}\\s+((([0][0-9]|[1][0-2]|[0-9])[\\:|\\-|\\.]([0-5]\\d)\\s*([aApP][mM])?)|(([0-1][0-9]|[2][0-3]|[0-9])[\\:|\\-|\\.]([0-5]\\d))))$",
        "MatchingText": "01/01/2002 04:42|||5-12-02 04:42 AM|||01.01/02    04-42aM",
        "NonMatchingText": "01-12-1999 4:50PM|||01-12-2002 15:10PM|||01-12-002 8:20PM",
        "Description": "MM-DD-20YY HH:MM AP\nMM-DD-20YY H:MM AP\nMM-DD-20YY HH:MM\nMM-DD-20YY H:MM\nMM-DD-YY HH:MM AP\nMM-DD-YY H:MM AP\nMM-DD-YY HH:MM\nMM-DD-YY H:MM\nM-D-YY HH:MM AP\nM-D-YY H:MM AP\nM-D-YY HH:MM\nM-D-YY H:MM\n\nwhere - can be / or - or .\nwhere : can be : or - or .\n\nDefinition:\n^(                       ;Start of Line\n([0]?[1-9]|[1][0-2])     ;00-09 or 10-12 or 1-9\n[\\/|\\-|\\.]               ;/ or - or .\n([0-2]\\d|[3][0-1]|[1-9]) ;00-29 or 30-31 or 1-9\n[\\/|\\-|\\.]               ;/ or - or .\n([2][0])?\\d{2}           ;2000-2099 or 00-99\n\\s+                      ;one or more spaces\n(                        ;must be either 12H notation w/AM|PM\n (\n ([0][0-9]|[1][0-2]|[0-9])\n [\\:|\\-|\\.]              ;: or - or .\n ([0-5]\\d)               ;01 thru 59\n \\s*                     ;zero or more spaces\n ([aApP][mM])?           ;nothing or AM or PM (case insensitive)\n )\n|                        ;or 24H notation w/out AM|PM\n (\n ([0-1][0-9]|[2][0-3]|[0-9]) ;00-19 or 20-23\n [\\:|\\-|\\.]              ;: or - or .\n ([0-5]\\d)               ;00-59\n )\n)\n)$                       ;End of Line\n"
    },
    {
        "Pattern": "^(([8]))$|^((([0-7]))$|^((([0-7])).?((25)|(50)|(5)|(75)|(0)|(00))))$",
        "MatchingText": "0.25|||7.75|||8",
        "NonMatchingText": "8.25|||7.15|||0.15",
        "Description": "Time off hours edit for quarter hour(s) less than eight."
    },
    {
        "Pattern": "^([a-zA-Z][a-zA-Z0-9+-.]*):((\\/\\/(((([a-zA-Z0-9\\-._~!$&'()*+,;=':]|(%[0-9a-fA-F]{2}))*)@)?((\\[((((([0-9a-fA-F]{1,4}:){6}|(::([0-9a-fA-F]{1,4}:){5})|(([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:){4})|((([0-9a-fA-F]{1,4}:)?[0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:){3})|((([0-9a-fA-F]{1,4}:){0,2}[0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:){2})|((([0-9a-fA-F]{1,4}:){0,3}[0-9a-fA-F]{1,4})?::[0-9a-fA-F]{1,4}:)|((([0-9a-fA-F]{1,4}:){0,4}[0-9a-fA-F]{1,4})?::))((([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4}))|(([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5])))))|((([0-9a-fA-F]{1,4}:){0,5}[0-9a-fA-F]{1,4})?::[0-9a-fA-F]{1,4})|((([0-9a-fA-F]{1,4}:){0,5}[0-9a-fA-F]{1,4})?::))|(v[0-9a-fA-F]+\\.[a-zA-Z0-9\\-._~!$&'()*+,;=':]+))\\])|(([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5]))\\.([0-9]|(1[0-9]{2})|(2[0-4][0-9])|(25[0-5])))|(([a-zA-Z0-9\\-._~!$&'()*+,;=']|(%[0-9a-fA-F]{2}))*))(:[0-9]*)?)((\\/([a-zA-Z0-9\\-._~!$&'()*+,;=':@]|(%[0-9a-fA-F]{2}))*)*))|(\\/?(([a-zA-Z0-9\\-._~!$&'()*+,;=':@]|(%[0-9a-fA-F]{2}))+(\\/([a-zA-Z0-9\\-._~!$&'()*+,;=':@]|(%[0-9a-fA-F]{2}))*)*)?))(\\?(([a-zA-Z0-9\\-._~!$&'()*+,;=':@\\/?]|(%[0-9a-fA-F]{2}))*))?((#(([a-zA-Z0-9\\-._~!$&'()*+,;=':@\\/?]|(%[0-9a-fA-F]{2}))*)))?$",
        "MatchingText": "http://user:pwd@domain.com:123/dir/subdir/?qp1=v%d3&qp2=98#frag|||http://192.168.0.0:123/dir/subdir/?qp1=v%d3&qp2=98#frag|||svn+ssh://[D456::1234:4321]:123/dir/subdir/?qp1=v%d3&qp2=98#frag",
        "NonMatchingText": "http://user:pwddomain.com:123/dir/subdir/?qp1=v%d3&qp2=98#frag|||http://192.168.0.0:123/dir/subdir/?qp1=v%d&qp2=98#frag|||svn+ssh://[D456::12344321]:123/dir/subdir/?qp1=v%d3&qp2=98#frag",
        "Description": "Manually derived this from the grammar in Appendix A of RFC3986 (Uniform Resource Identifier (URI): Generic Syntax).\n\nMatches anything that fits the generic syntax of a URI. Supports IPv6 hosts."
    },
    {
        "Pattern": "[-'a-zA-Z]",
        "MatchingText": "Jhon's",
        "NonMatchingText": "0-9 and Special Characters",
        "Description": "Best For First Name or Middle Name or Last Name\n\nThis Expression Allows only alphabets with apostrophe (').\n"
    },
    {
        "Pattern": "(?P<word>([\\w]*))(?P<prep>([\\,\\.\\!\\?\\-\\:\\;\\\"\"\\(\\)])?)",
        "MatchingText": "\u041A\u0443\u0440\u043E\u043F\u0430\u0442\u043A\u0430 \u0443\u043F\u0430\u043B\u0430, \u0442\u044F\u0436\u0435\u043B\u043E \u0434\u044B\u0448\u0430.",
        "NonMatchingText": "None",
        "Description": "Parse the sentence to separated words and signs of preposition."
    },
    {
        "Pattern": "^([A-Z0-9?.+-])+([,]([A-Z0-9?.+-])+)*$",
        "MatchingText": "?-MM1, 45.NN2-45.NN50,C015+,?,NA",
        "NonMatchingText": "?-mm1,N/A,\"C001+,\"",
        "Description": "This Expression validates alfanumeric values. This was created to validate a range of values that could start with ?. \nIt is case sensitive, this means the characters need to be uppercase."
    },
    {
        "Pattern": "^((00|\\+)49)?(0?[2-9][0-9]{1,})$",
        "MatchingText": "0049891567|||+49891234567|||0891234567",
        "NonMatchingText": "004312345678||4912345678|||(+49)1234567",
        "Description": " Validates an German area dial code and telephone number."
    },
    {
        "Pattern": "^((00|\\+)49)?(0?1[5-7][0-9]{1,})$",
        "MatchingText": "004915112367|||+491601234567|||01721234567 etc...",
        "NonMatchingText": "(+49)1511234567|| (0)1741234567||160134567",
        "Description": "Validates all German area dial code and telephone numbers."
    },
    {
        "Pattern": "^[A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF '\\-\\.]{1,22}$",
        "MatchingText": "Jill St. John|||J\u00F8rn\u00E7|||Mc O'Donald-\u00D6zt\u00FCrk",
        "NonMatchingText": "abc123|||Nobody!|||@#$%^&",
        "Description": "Should match just about any real name, either first\nname or last name -- even Jill St. John.  \n\nCan't think of a name that has more than 22 characters.\n\nMy home page:\n&lt;A HREF=&quot;http://www.US-Webmasters.com/best-start-page/&quot;&gt;http://www.US-Webmasters.com/best-start-page/&lt;/A&gt;\n\n\n"
    },
    {
        "Pattern": "^[abceghjklmnprstvxyABCEGHJKLMNPRSTVXY][0-9][abceghjklmnprstvwxyzABCEGHJKLMNPRSTVWXYZ] {0,1}[0-9][abceghjklmnprstvwxyzABCEGHJKLMNPRSTVWXYZ][0-9]$",
        "MatchingText": "G3M 5T9|||C3M5T9",
        "NonMatchingText": "Z3M 5T9|||W3M 5T9|||5T9 C3M",
        "Description": "Canadian Postal Code / Codes / Canada / Zip\n\nGoogle for DFIOQU and you'll see where I got the\ninfo for this.\n\nCan anyone simplify this?\n"
    },
    {
        "Pattern": "^[01]?[- .]?\\(?[2-9]\\d{2}\\)?[- .]?\\d{3}[- .]?\\d{4}$",
        "MatchingText": "18008793262|||800-879-3262|||0-800.879.3262",
        "NonMatchingText": "879 3262|||077 879 3262|||879-3262",
        "Description": "U. S. or Canadian telephone number regular expression. &lt;BR&gt;\n&lt;BR&gt;\n   //           # Checks phone numbers for validity                           &lt;BR&gt;\n   //  [01]?    # optional '0', or '1'                                        &lt;BR&gt;\n   //  [- .]?   # optional separator is either a dash, a space, or a period.  &lt;BR&gt;\n   //  \\(?      # optional parentheses                                        &lt;BR&gt;\n   //  [2-9]    # first # of the area code must not be a '0' or '1'           &lt;BR&gt;\n   //  \\d{2}    # next 2 digits of area code can be 0-9                       &lt;BR&gt;\n   //  \\)?      # optional parentheses                                        &lt;BR&gt;\n   //  [- .]?   # optional separator is either a dash, a space, or a period.  &lt;BR&gt;\n   //  \\d{3}    # 3-digit prefix                                              &lt;BR&gt;\n   //  [- .]?   # optional separator is either a dash, a space, or a period.  &lt;BR&gt;\n   //  \\d{4}    # 4-digit station number                                      &lt;BR&gt;\n"
    },
    {
        "Pattern": "(?i)^(((\\\\\\\\(\\?\\\\(UNC\\\\)?)?)([A-Z]:\\\\|([^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\.\\s][^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|]+[^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\.\\s]\\\\){2}))|[A-Z]:\\\\)([^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\s][^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|]+[^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\s]\\\\)*([^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\.\\s][^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\.]+[^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\.\\s])(\\.[^\\\\\\/\\:\\*\\?\\\"\\<\\>\\|\\.\\s]+)*?$",
        "MatchingText": "C:\\Program Files\\RegEx\\RegEx.exe.manifest",
        "NonMatchingText": "C:\\Filename.*",
        "Description": "Matches valid Windows filenames using local, network and UNC formats."
    },
    {
        "Pattern": "^(0\\.|([1-9]([0-9]+)?)\\.){3}(0|([1-9]([0-9]+)?)){1}$",
        "MatchingText": "1.2.3.4",
        "NonMatchingText": "1.2.3|||01.02.03.04|||1.2.3.4Beta",
        "Description": "A simple regex to check a version information string of the style 1.0.0.0"
    },
    {
        "Pattern": "^[+-]?\\d+(\\,\\d{2})? *?$",
        "MatchingText": "0,00   0,99    -99,99    999999   -9    0   999999999,99",
        "NonMatchingText": "9,9  0,0 ",
        "Description": "This regex accepts decimal number with exactly 2 numbers after comma and  without point."
    },
    {
        "Pattern": "^[a-zA-Z]+((\\s|\\-)[a-zA-Z]+)?$",
        "MatchingText": "Bobbie Sue|||Ana-Claire|||BobbyJoe",
        "NonMatchingText": "Billy - Joe|||Billy Jr.|||Thos.",
        "Description": "This regex validates a persons first name. Acceptable names include compound names with a hyphen or a space in them."
    },
    {
        "Pattern": "^[a-zA-Z]+((((\\-)|(\\s))[a-zA-Z]+)?(,(\\s)?(((j|J)|(s|S))(r|R)(\\.)?|II|III|IV))?)?$",
        "MatchingText": "Jones, Jr|||Casey-Jones|||Casey-Jones, IV",
        "NonMatchingText": "Jones, IV.|||Jones , Jr|||Casey-Jones-Hall",
        "Description": "This regex validates a persons last name. Acceptable names can include compound names seperated by a hyphen or a space."
    },
    {
        "Pattern": "^[a-zA-Z0-9\\-\\.]+\\.([a-zA-Z]{2,3})$",
        "MatchingText": "yahoo.com|ABC.COM|abc.au",
        "NonMatchingText": "yahoo.c|ABC.argv",
        "Description": "validates after dot operator. matches atleast 2 char and max 3 char.www dot is rejected."
    },
    {
        "Pattern": "\\$(\\d)*\\d",
        "MatchingText": "$300 | $12900",
        "NonMatchingText": "$300.50 | $12900.00 | 300 |12900",
        "Description": "This Expression is used to Validate the US curreny."
    },
    {
        "Pattern": "^\\d{4}\\/\\d{1,2}\\/\\d{1,2}$",
        "MatchingText": "1394/01/3 | 1365/12/31 | 1397/02/01",
        "NonMatchingText": "1394/1/555 | 139/1/4 | 1/11/1394",
        "Description": "This regular expressions matches jalali dates of the form YYYY/XX/XX where XX can be 1 or 2 digits long and YYYY is always 4 digits long."
    },
    {
        "Pattern": "^(\\+(1 ?(2(4[2,6]|6[4,8]|84)|34(0|5)|4(41|73)|6(49|64|7[0,1]|84)|7(58|67|8[4,7])|8(09|29|6[8,9]|76)|939)?|2(0|1[1-4,6,8]|2[0-9]|3[0-9]|4[0-9]|5[0-8]|6[0-9]|7|9[0,1,7-9])|3([0-4]|5[0-9]|6|7[0-9]|8[0-7,9]|9)|4(0|1|2[0,1,3]|[3-9])|5(0[0-9]|[1-8]|9[0-9])|6([0-6]|7[0,2-9]|8[0-3,5-9]|9[0-2])|7|8([1,2,4]|5[0,2,3,5,6]|6|8[0,6])|9([0-5]|6[0-8]|7[0-7]|8|9([2-6]|8))))",
        "MatchingText": "+1 340 | +82 | +1 | +20 ",
        "NonMatchingText": "1 | 1340 | 82 ",
        "Description": "Get Country Code from International phone number.\n\nUse Country Code at Wikipedia\nhttps://en.wikipedia.org/wiki/List_of_country_calling_codes "
    },
    {
        "Pattern": "^([_a-zA-Z0-9-]+(\\.[_a-zA-Z0-9-]+)*@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*\\.(([0-9]{1,3})|([a-zA-Z]{2,})))(;[ ]?[_a-zA-Z0-9-]+(\\.[_a-zA-Z0-9-]+)*@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*\\.(([0-9]{1,3})|([a-zA-Z]{2,})))*$",
        "MatchingText": "jdude@yahoo.com|||jdude@yahoo.com; janedoe@hotmail.com|||jdude@yahoo.com; janedoe@hotmail.com; billybob@127.0.0.1",
        "NonMatchingText": "jdudeyahoo.com|||jdude@yahoo.com or janedoe@hotmail.com|||jdude@yahoo.com, janedoe@hotmail.com, billybob@127.0.0.1",
        "Description": "Matches a semi-colon-delimited string of email addresses.  Delimiter can include a space after the semi-colon.  Based on/thanks to David Huyck's pattern, with the domain extension opened up and specific extensions removed."
    },
    {
        "Pattern": "^((([A-PR-UWYZ](\\d([A-HJKSTUW]|\\d)?|[A-HK-Y]\\d([ABEHMNPRVWXY]|\\d)?))\\s*(\\d[ABD-HJLNP-UW-Z]{2})?)|GIR\\s*0AA)$",
        "MatchingText": "M1 1AA|||EC1A 1BB|||DN55 1PT",
        "NonMatchingText": "SW17 8CB",
        "Description": "matches uk postcodes according to specifications found at: http://www.govtalk.gov.uk/gdsc/html/noframes/PostCode-2-1-Release.htm"
    },
    {
        "Pattern": "^(0|1)+$",
        "MatchingText": "01001010101001",
        "NonMatchingText": "010102002010010",
        "Description": "A stupid REGEXP that validate a binary number on more rows."
    },
    {
        "Pattern": "^((0?[1-9])|(([1|2]\\d)|(3[0|1])))(/|-)((0?[1-9])|(1[0|1|2]))(/|-)(((19|20)\\d\\d)|(\\d\\d))",
        "MatchingText": "09-8-2014 3-9-2012",
        "NonMatchingText": "31-28-1903",
        "Description": "My first date validator."
    },
    {
        "Pattern": "(^\\s*(?P<firstname>(st\\.?\\s+)\\w+\\S*)\\s+(?P<middlename>(st\\.?\\s+)\\w+\\S*)\\s+(?P<lastname>(st\\.?\\s+)?\\w+[^, ]*)(?:(,| ))*\\s+(?P<suffix>\\w+\\S*)\\s*$)|(^\\s*(?P<firstname>(st\\.?\\s+)\\w+\\S*)\\s+(?P<lastname>(st\\.?\\s+)?\\w+\\S*)\\s+(?P<suffix>(jr)|(sr)|(ii)|(iii)||(iv)|(v)|(vi)|(vii)|(viii))\\s*$)|(^\\s*(?P<firstname>(st\\.?\\s+)\\w+\\S*)\\s+(?P<middlename>(st\\.?\\s+)\\w+\\S*)\\s+(?P<lastname>(st\\.?\\s+)?\\w+\\S*)\\s*$)|(^\\s*(?P<firstname>(st\\.?\\s+)\\w+\\S*)\\s+(?P<lastname>(st\\.?\\s+)?\\w+\\S*)\\s*$)|(^\\s*(?P<lastname>(st\\.?\\s+)?\\w+\\S*)\\s*$)",
        "MatchingText": "Loretta M.J.H Mac-Hogan-O'Brien, Jr.",
        "NonMatchingText": "John Jacob JingleHeimer Smith Jr.",
        "Description": "Matches parts of a name. Last name only; first and last names; first, middle, and last names; first, middle, and last names and suffix; first and last names and suffix. This is very permissive so it's good for isolating name parts but doesn't validate whether a string is a reasonable name."
    },
    {
        "Pattern": ">(?:(?P<t>[^<]*))",
        "MatchingText": "<b>|||</b>|||<p><b>some text</b></p>",
        "NonMatchingText": "<",
        "Description": "Detects HTML tags open and/or closed with and without whitespace or characters in between. Good for stripping all tags from a string."
    },
    {
        "Pattern": "/^(\\d{1,2})(\\/)(\\d{1,2})(\\/)(\\d{4})(T|\\s{1,2})(([0-1][0-9])|(2[0-3])):([0-5][0-9])+$/;",
        "MatchingText": "02/03/2008 19:08 || 02/26/2009  19:17",
        "NonMatchingText": "02/26/2009  ",
        "Description": "date and time. mm/dd/yyyy 00:00 format"
    },
    {
        "Pattern": "(([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{2}==)?){1}",
        "MatchingText": "AAAAAA==",
        "NonMatchingText": "AAAAAA",
        "Description": "The expression evaluates a Base64 string as a sequence of 4-byte blocks with a possible tail of 2 or 3-byte block with valid padding.\n"
    },
    {
        "Pattern": "&amp;#([0-9]{1,5}|x[0-9a-fA-F]{1,4});",
        "MatchingText": "&amp;#160; | &amp;#xa0;",
        "NonMatchingText": "&amp;nbsp;",
        "Description": "Find all html encoded  characters as dec &amp;#[0-9]{1,5}; or hex &amp;#x[0-9a-fA-F]{1,4}; values. Remember to remove \"amp;\" which is used for making this post possible."
    },
    {
        "Pattern": "(Jan(uary)?|Feb(ruary)?|Mar(ch)?|Apr(il)?|May|Jun(e)?|Jul(y)?|Aug(ust)?|Sep(tember)?|Oct(ober)?|(Nov|Dec)(ember)?)",
        "MatchingText": "Jan | April",
        "NonMatchingText": "Febr",
        "Description": "The expression matches any month name (english) in short or full style. Use it with case insensitive mode in your date matching expressions."
    },
    {
        "Pattern": "(Mo(n(day)?)?|Tu(e(sday)?)?|We(d(nesday)?)?|Th(u(rsday)?)?|Fr(i(day)?)?|Sa(t(urday)?)?|Su(n(day)?)?)",
        "MatchingText": "Mo | Sun",
        "NonMatchingText": "Any",
        "Description": "The expression matches any weekday name (english) in short (2 or 3 characters) or full style. Use it with case insensitive mode in your date matching expressions."
    },
    {
        "Pattern": "(GB-?)?([1-9][0-9]{2}\\ ?[0-9]{4}\\ ?[0-9]{2})|([1-9][0-9]{2}\\ ?[0-9]{4}\\ ?[0-9]{2}\\ ?[0-9]{3})|((GD|HA)[0-9]{3})",
        "MatchingText": "GB123 1234 12|||GBGD123|||123 1234 12 123",
        "NonMatchingText": "GB123123412|||GBGD1234|||023 1234 12 123",
        "Description": "VAT Numbers format verification (United Kingdom) with support for optional member state definition.  \n"
    },
    {
        "Pattern": "(IE-?)?[0-9][0-9A-Z\\+\\*][0-9]{5}[A-Z]",
        "MatchingText": "IE4*12345Z|||0012345K",
        "NonMatchingText": "IE4-12345Z|||00123456",
        "Description": "VAT Numbers format verification (Ireland) with support for optional member state definition.  \n"
    },
    {
        "Pattern": "(LT-?)?([0-9]{9}|[0-9]{12})",
        "MatchingText": "LT123456789|||123456789012",
        "NonMatchingText": "LX123456789|||123466789O12",
        "Description": "VAT Numbers format verification (Lithuania) with support for optional member state definition."
    },
    {
        "Pattern": "(NL-?)?[0-9]{9}B[0-9]{2}",
        "MatchingText": "NL123456789B12",
        "NonMatchingText": "NL123456789012",
        "Description": "VAT Numbers format verification (The Netherlands) with support for optional member state definition.  \n"
    },
    {
        "Pattern": "((0|1[0-9]{0,2}|2[0-9]?|2[0-4][0-9]|25[0-5]|[3-9][0-9]?)\\.){3}(0|1[0-9]{0,2}|2[0-9]?|2[0-4][0-9]|25[0-5]|[3-9][0-9]?)",
        "MatchingText": "10.0.0.0|||195.167.1.119|||255.255.255.255",
        "NonMatchingText": "010.0.0.0|||195.167.01.119|||256.20.55.23",
        "Description": "Accurate IP address verification...\n\nEach numeric part of an IP address must be between 0 and 255. All patterns I have seen on the net cover this range but they allow leading zeros. The valid cases are:\n* 0\n* 1, 10-19 and 100-199 aka 1[0-9]{0,2}\n* 2 and 20-29 aka 2[0-9]?\n* 200-249 aka 2[0-4][0-9]\n* 250-255 aka 25[0-5]\n* 3-9 and 30-99 aka [3-9][0-9]?"
    },
    {
        "Pattern": "(0[289][0-9]{2})|([1345689][0-9]{3})|(2[0-8][0-9]{2})|(290[0-9])|(291[0-4])|(7[0-4][0-9]{2})|(7[8-9][0-9]{2})",
        "MatchingText": "0200|||7312|||2415",
        "NonMatchingText": "0300|||7612|||2915",
        "Description": "Accurate Australian postal code verification.\n\nAustralia has 4-digit numeric postal codes with the following state based specific ranges. \nACT: 0200-0299 and 2600-2639. \nNSW: 1000-1999, 2000-2599 and 2640-2914. \nNT: 0900-0999 and 0800-0899. \nQLD: 9000-9999  and 4000-4999. \nSA: 5000-5999. \nTAS: 7800-7999  and 7000-7499. \nVIC: 8000-8999 and 3000-3999. \nWA: 6800-6999 and 6000-6799."
    },
    {
        "Pattern": "([ABCEGHJKLMNPRSTVXY][0-9][ABCEGHJKLMNPRSTVWXYZ])\\ ?([0-9][ABCEGHJKLMNPRSTVWXYZ][0-9])",
        "MatchingText": "M1R 4B0|||L0R 1B1|||L0R1B9",
        "NonMatchingText": "W1R 4B0|||L0R 1D1|||LOR1B9",
        "Description": "Accurate Canadian postal code format verification.\n\nThe format of a Canadian postal code is LDL DLD where L are alpha characters and D are numeric digits. But there are some exceptions. The letters D, F, I, O, Q and U never appear in a postal code because of their visual similarity to 0, E, 1, 0, 0, and V respectively. In addition to avoiding the six &quot;forbidden&quot; letters W and Z also do not appear as the first letter of a postal code (at least not at present)."
    },
    {
        "Pattern": "((0[13-7]|1[1235789]|[257][0-9]|3[0-35-9]|4[0124-9]|6[013-79]|8[0124-9]|9[0-5789])[0-9]{3}|10([2-9][0-9]{2}|1([2-9][0-9]|11[5-9]))|14([01][0-9]{2}|715))",
        "MatchingText": "01125",
        "NonMatchingText": "34125",
        "Description": "Accurate German postal code verification. \n\nGermany has 5-digit numeric postal codes. The expression evaluates a postal code within state based specific ranges."
    },
    {
        "Pattern": "(([A-Z]{1,2}[0-9][0-9A-Z]?)\\ ([0-9][A-Z]{2}))|(GIR\\ 0AA)",
        "MatchingText": "M2 5BQ|||EC1A 1HQ|||GIR 0AA",
        "NonMatchingText": "M2 BQ5|||E31A 1HQ|||GIR0AA",
        "Description": "Accurate UK postal code format verification.\n\nUK postal codes have two parts. The right part is formatted as DLL (L:letter D:digit) and the left part has six alternative formats: LD, LDL, LDD, LLD, LLDL and LLDD. There is only one exception to these formats: GIR 0AA."
    },
    {
        "Pattern": "((EE|EL|DE|PT)-?)?[0-9]{9}",
        "MatchingText": "DE123456789|||224466880",
        "NonMatchingText": "DE12345678|||22446688B",
        "Description": "VAT Numbers format verification (Estonia, Germany, Greece, Portugal) with support for optional member state definition."
    },
    {
        "Pattern": "((FI|HU|LU|MT|SI)-?)?[0-9]{8}",
        "MatchingText": "HU12345678|||22446688",
        "NonMatchingText": "HU1234567|||224466BB",
        "Description": "VAT Numbers format verification (Finland, Hungary, Luxemburg, Malta, Slovenia) with support for optional member state definition."
    },
    {
        "Pattern": "((PL|SK)-?)?[0-9]{10}",
        "MatchingText": "PL1234567890|||1234567890",
        "NonMatchingText": "PL123456789|||123456789O",
        "Description": "VAT Numbers format verification (Poland, Slovakia) with support for optional member state definition."
    },
    {
        "Pattern": "((IT|LV)-?)?[0-9]{11}",
        "MatchingText": "IT12345678901|||12345678901",
        "NonMatchingText": "IT1234567890|||1234567890I",
        "Description": "VAT Numbers format verification (Italy, Latvia) with support for optional member state definition."
    },
    {
        "Pattern": "(SE-?)?[0-9]{12}",
        "MatchingText": "SE123456789012|||123456789012",
        "NonMatchingText": "SE12345678901|||123456789O12",
        "Description": "VAT Numbers format verification (Sweden) with support for optional member state definition.\n"
    },
    {
        "Pattern": "(BE-?)?0?[0-9]{9}",
        "MatchingText": "BE123456789|||0123456789",
        "NonMatchingText": "BE12345678|||O123456789",
        "Description": "VAT Numbers format verification (Belgium) with support for optional member state definition."
    },
    {
        "Pattern": "(CY-?)?[0-9]{8}[A-Z]",
        "MatchingText": "CY12345678A|||12345678A",
        "NonMatchingText": "CY1234567A|||123456789",
        "Description": "VAT Numbers format verification (Cyprus) with support for optional member state definition.  \n"
    },
    {
        "Pattern": "(CZ-?)?[0-9]{8,10}",
        "MatchingText": "CZ12345678|||1234567890",
        "NonMatchingText": "CZ1234567|||12345678901",
        "Description": "VAT Numbers format verification (Czech Republic) with support for optional member state definition.  \n"
    },
    {
        "Pattern": "(DK-?)?([0-9]{2}\\ ?){3}[0-9]{2}",
        "MatchingText": "DK11 22 33 44",
        "NonMatchingText": "DK11223344",
        "Description": "VAT Numbers format verification (Denmark) with support for optional member state definition."
    },
    {
        "Pattern": "(ES-?)?([0-9A-Z][0-9]{7}[A-Z])|([A-Z][0-9]{7}[0-9A-Z])",
        "MatchingText": "ES01234567A|||A12345678",
        "NonMatchingText": "ES012345678|||AB2345678",
        "Description": "VAT Numbers format verification (Spain) with support for optional member state definition.  \n"
    },
    {
        "Pattern": "(FR-?)?[0-9A-Z]{2}\\ ?[0-9]{9}",
        "MatchingText": "FRAB 123456789|||L7 123456789",
        "NonMatchingText": "FRAB123456789|||L7 L23456789",
        "Description": "VAT Numbers format verification (France) with support for optional member state definition.\n"
    },
    {
        "Pattern": "^(1|1(\\s|\\s?-\\s?|\\s?\\.\\s?|\\s?/\\s?))?((\\(?[2-9]{1}[\\d]{2}\\)?(\\s|\\s?-\\s?|\\s?\\.\\s?|\\s?/\\s?)?))?(\\d{3})(\\s|\\s?-\\s?|\\s?\\.\\s?|\\s?/\\s?)?(\\d{4})$\n",
        "MatchingText": "555-5555 1-555-555-5555 1-(555)-555-5555",
        "NonMatchingText": "0 or 1 starts area code, 1 isn't the country code, non-valid US numbers",
        "Description": "USA Phone number with dash, periods, slashes, spaces, () and only last 7 digit is required but everything else is checked\n\nHere it is broken down feel free to add too it or use it\n\nBegin String: ^\nCountry Code 1: (1|1(\\s|\\s?-\\s?|\\s?\\.\\s?|\\s?/\\s?))?\nArea Code FirstDigit cannot be 0 or 1:((\\(?[2-9]{1}[\\d]{2}\\)?(\\s|\\s?-\\s?|\\s?\\.\\s?|\\s?/\\s?)?))?\n3Digit Prefix: (\\d{3})\nSpace/-/. between: (\\s|\\s?-\\s?|\\s?\\.\\s?|\\s?/\\s?)?\n4Digit Suffix: (\\d{4})\nEnd String $\n\n\n*can add country code with out area code!!"
    },
    {
        "Pattern": "^[-\\w'+*$^&%=~!?{}#|/`]{1}([-\\w'+*$^&%=~!?{}#|`.]?[-\\w'+*$^&%=~!?{}#|`]{1}){0,31}[-\\w'+*$^&%=~!?{}#|`]?@(([a-zA-Z0-9]{1}([-a-zA-Z0-9]?[a-zA-Z0-9]{1}){0,31})\\.{1})+([a-zA-Z]{2}|[a-zA-Z]{3}|[a-zA-Z]{4}|[a-zA-Z]{6}){1}$",
        "MatchingText": "3tt3rsAndNumb3rs@domain.com has-dash@domain.com hasApostrophe.o'leary@domain.org uncommonTLD@domain.museum uncommonTLD@domain.travel uncommonTLD@domain.mobi countryCodeTLD@domain.uk countryCodeTLD@domain.rw lettersInDomain@911.com underscore_inLocal@domain.net subdomain@sub.domain.com local@dash-inDomain.com dot.inLocal@foo.com a@singleLetterLocal.org singleLetterDomain@x.org &*=?^+{}'~@CharsInLocal.net",
        "NonMatchingText": "missingDomain@.com @missingLocal.org missingatSign.net missingDot@com two@@signs.com .localStartsWithDot@domain.com localEndsWithDot.@domain.com two..consecutiveDots@domain.com domainStartsWithDash@-domain.com domainEndsWithDash@domain-.com ",
        "Description": "For Email Inputs checks to RFC 5322 Standards (no IP address though Didn't Want them)\nlocalhost:\ncannot start or end with .\ncannot have .. in it\nDomain:\ncannot start with - or .\n\nKnown problems:\nTLDDoesntExist@domain.moc\ndomains can be longer then 255. But each Domain can only be 63 then a . is required"
    },
    {
        "Pattern": "^(000-)(\\\\d{5}-){2}\\\\d{3}$",
        "MatchingText": "000-00386-67627-142",
        "NonMatchingText": "00-12345-12345-142, 001-12345-12345-123, 000-12345-12345-12",
        "Description": "When working w/ Moto STB, we need to sometimes use the unit address instead of the mac address. The format is always 000-12345-12345-123"
    },
    {
        "Pattern": "</?(a|abbr|acronym|address|applet|area|b|base|basefont|bdo|big|blockquote|body|br|button|caption|center|cite|code|col|colgroup|dd|del|dir|div|dfn|dl|dt|em|fieldset|font|form|frame|frameset|h[1-6]|head|hr|html|i|iframe|img|input|ins|isindex|kbd|label|legend|li|link|map|menu|meta|noframes|noscript|object|ol|optgroup|option|p|param|pre|q|s|samp|script|select|small|span|strike|strong|style|sub|sup|table|tbody|td|textarea|tfoot|th|thead|title|tr|tt|u|ul|var|xmp)\\b((\\\"[^\\\"]*\\\"|\\'[^\\']*\\')*|[^\\\"\\'>])*>",
        "MatchingText": "</a> <h2 > </a asdfs> </h2 asfsdf> <a href=\"abc>>123\">",
        "NonMatchingText": "< /a> </h 2 asfsdf> <ahref=\"abc\"123\">",
        "Description": "This is very similar to my other expression, except it only matches tags that a browser would read, so if you have an extra \" in the tag, it will not count it, and move onto the next possibility."
    },
    {
        "Pattern": "<(/)?(a|abbr|acronym|address|applet|area|b|base|basefont|bdo|big|blockquote|body|br|button|caption|center|cite|code|col|colgroup|dd|del|dir|div|dfn|dl|dt|em|fieldset|font|form|frame|frameset|h[1-6]|head|hr|html|i|iframe|img|input|ins|isindex|kbd|label|legend|li|link|map|menu|meta|noframes|noscript|object|ol|optgroup|option|p|param|pre|q|s|samp|script|select|small|span|strike|strong|style|sub|sup|table|tbody|td|textarea|tfoot|th|thead|title|tr|tt|u|ul|var|xmp){1}(\\s(\\\"[^\\\"]*\\\"*|[^>])*)*>",
        "MatchingText": "</a> <h2      > </h2 asfsdf> <a href=\"abc>>123\">",
        "NonMatchingText": "< /a> </h 2 asfsdf> <ahref=\"abc123\">",
        "Description": "This should match all valid HTML 4.01 tags as a browser would recognize. If you miss a 2nd \" it will continue until it finds one to pair with, so if it doesn't find one, it continues until the end. This is how most browsers work I believe. It does have a few flaws, it will match </img> and </input> which is weird, but perhaps I'll fix that eventually."
    },
    {
        "Pattern": "(?i:[aeiou]+)\\B",
        "MatchingText": "remove all interior vowels",
        "NonMatchingText": "A",
        "Description": "This regular expression matches all interior vowels.\nIf used as a replace, the following strings would result:\nLets meet tomorrow -&gt; Lts mt tmrrw\nPlease come to my party -&gt; Plse cme to my prty\nI like your style -&gt; I lke yr style"
    },
    {
        "Pattern": "(^[0-9]{1,8}|(^[0-9]{1,8}\\.{0,1}[0-9]{1,2}))$",
        "MatchingText": "1.00|||2345|||332.3",
        "NonMatchingText": ".00|||23333333333.00|||j22.00",
        "Description": "Matches number in format XX.XX Please note that this expression allows maximum of 8 digits before the dot and 2 (optional) digits after the dot."
    },
    {
        "Pattern": "^([1-9]{0,1})([0-9]{1})(\\.[0-9])?$",
        "MatchingText": "1|||1.1|||0.1",
        "NonMatchingText": "01|||01.1|||0.10",
        "Description": "Matches numbers 0 through 99.9 \nAllows only one preceding zero and does not require the decimal point"
    },
    {
        "Pattern": "[-+]((0[0-9]|1[0-3]):([03]0|45)|14:00)",
        "MatchingText": "+00:00|||-05:00|||+13:45",
        "NonMatchingText": "+14:30|||+01:14|||-09:55",
        "Description": "This matches timezone offsets. Also matches non-hour offsets like India (+05:30) and Nepal (+5:45}. See for more timezone information: http://en.wikipedia.org/wiki/Time_zone"
    },
    {
        "Pattern": "^[^#]([^ ]+ ){6}[^ ]+$",
        "MatchingText": "1111 2222 33 44444 55 6 7777",
        "NonMatchingText": "#IIS Logfile header",
        "Description": "We've come across the situation where we had to extract the IIS-Log entries without the header information. The data is far more complex than the sample given.\nExplanation:\n^[^#] = lines not beginnin with #\n([^ ]+ ){6} = 6 times no space until one space\n[^ ]+ = no spaces allowed...\n$ = ...until end of line\n\nFor further explanation don't hesitate to write E-Mail."
    },
    {
        "Pattern": "(?:(?:(?P<Feet>\\d+)[ ]*(?:'|ft)){0,1}[ ]*(?P<Inches>\\d*([/\\w])){0,1}(?:[ ,\\-]){0,1}(?P<Fraction>(?P<FracNum>\\d*)\\/(?P<FracDem>\\d*)){0,1}(?P<Decimal>\\.\\d*){0,1}(?:\\x22| in))|(?:(?P<Feet>\\d+)[ ]*(?:'|ft)[ ]*){1}",
        "MatchingText": "1ft 2-3/4 in, 2' 3 4/5\", 3ft, 4', 5 in, 6\", 7.125 in, 3ft 4.5 in",
        "NonMatchingText": "1ft 2-3/4in, 4in",
        "Description": "I needed an expression that would break down a written measurement, like 12' 2-15/16\", into groups of feet, inches, fractional inches (num/dem). This is a modified expression based on Trevor Braun's orginal regex. Added the \"ft\" & \"in\" suffixes and the fraction's Numerator & Denominator groups.  "
    },
    {
        "Pattern": "^((\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*)\\s*[,]{0,1}\\s*)+$",
        "MatchingText": "Test@host.com|email1@host.com,email2@host.com,email3@host.com|email1@host.com, email2@host.com , email3@host.com",
        "NonMatchingText": "test@test|test@host.com,test@|test@ host.com",
        "Description": "This will validate multiple email addresses that are comma delimited.  You can change it to use commas or semilcolons.  If you have to worry about a lot of special characters, you may have to edit it a little bit.  It allows white space before and after the comma."
    },
    {
        "Pattern": "(\\<!--\\s*.*?((--\\>)|$))",
        "MatchingText": "<!-- comment <!-- continuing --   >and ends now-->",
        "NonMatchingText": "< !-- not comment -->, <a href=\"--\">, all other html code",
        "Description": "matches comments <!-- --> in string. Singleline option must be enabled. It works well also with multiple comment start tags such as: <!--this is comment <!--and this as well and end-- of comment\nis!-- >right now-->. It also matches comments in between script or style tags <script> <!-- --> </script>"
    },
    {
        "Pattern": "(\\<\\?php\\s+.*?((\\?\\>)|$))",
        "MatchingText": "<?php this is code in php ?>",
        "NonMatchingText": "text outside php tag",
        "Description": "Get code in between php tag <?php and ?> or until end of string if end of tag not found. Singleline option must be enabled!  "
    },
    {
        "Pattern": "[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+(?:[A-Z]{2}|com|org|net|gov|biz|info|name|aero|biz|info|jobs|museum)\\b",
        "MatchingText": "abc@yatra.com",
        "NonMatchingText": "hgf@ghjg@jkh.com.fgh.df.dfdf.dfdf",
        "Description": "Just a try...."
    },
    {
        "Pattern": "^([1-9]|1[0-2]|0[1-9]){1}(:[0-5][0-9][aApP][mM]){1}$",
        "MatchingText": "08:00AM|||10:00am|||7:00pm",
        "NonMatchingText": "13:00pm|||12:65am",
        "Description": "Very simple expression to validate time on a 12 hour clock, this expression is valid for client-side script validations (RegularExpressionValidator - ASP.NET)."
    },
    {
        "Pattern": "^[a-zA-Z0-9_\\s-]+$",
        "MatchingText": "123Testing|||123_Testing|||123-Testing This",
        "NonMatchingText": "!@#Testing|||Testing &quot;This&quot;|||Don't Forget to Write",
        "Description": "This tests an input string for only a-z and A-Z and only allows underscores, hyphens and spaces.  The purpose is to force users to generate legitimate, readable file names that can be streamed from the web."
    },
    {
        "Pattern": "^((([\\+][\\s]{0,1})|([0]{2}[\\s-]{0,1}))([358]{3})([\\s-]{0,1})|([0]{1}))(([1-9]{1}[0-9]{0,1})([\\s-]{0,1})([0-9]{2,4})([\\s-]{0,1})([0-9]{2,4})([\\s-]{0,1}))([0-9]{0,3}){1}$",
        "MatchingText": "003589999999 | 00 358 999 999 | 00 358 9999 999 | 00 358 999 9999 | 091212 | 09 99 99 99",
        "NonMatchingText": "050 999 9999 9999 999 | 151212",
        "Description": "General phone number validation for Finland.\nIt will pass old and new format numbers.\nBetween numbers space or dash can be used ones. \nnumber has to start\n+358 or 00358 or 0 \nare code can be 2 or 3 digit. I could not come with better idea then this"
    },
    {
        "Pattern": "^(-?\\$?([1-9]\\d{0,2}(,\\d{3})*|[1-9]\\d*|0|)(.\\d{1,2})?|\\(\\$?([1-9]\\d{0,2}(,\\d{3})*|[1-9]\\d*|0|)(.\\d{1,2})?\\))$",
        "MatchingText": "112.12 $1,112.15 (15555.5) $.12 0.1 ",
        "NonMatchingText": "$111,1.15  52.121 (123.12 s123",
        "Description": "Handles any kind of money entry. With $ sign or not, with commas or not. With bracket, negative sign or none. Max of 2 decimal points. It's perfect :)"
    },
    {
        "Pattern": "^((000)(666)([0-6]\\d{2}|7[0-2][0-9]|73[0-3]|7[5-6][0-9]|77[0-1]))(\\s|\\-)((00)\\d{2})(\\s|\\-)((0000)\\d{4})$",
        "MatchingText": "455-55-4444|333 22-1111|733 11 1111",
        "NonMatchingText": "734-00-1111|749-11-0000|666-11-1111",
        "Description": "Used Tim Cartwright example and added \\s or - for separators."
    },
    {
        "Pattern": "^([0-9a-zA-Z]([-.\\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\\w]*[0-9a-zA-Z]\\.)+[a-zA-Z]{2,9})$",
        "MatchingText": "e@eee.com|||eee@e-e.com|||eee@ee.eee.museum",
        "NonMatchingText": ".@eee.com|||eee@e-.com|||eee@ee.eee.eeeeeeeeee",
        "Description": "regex to validate email address\n\nnoteworthy: \n(1) It allows usernames with 1 or 2 alphanum characters, or 3+ chars can have -._ in the middle. username may NOT start/end with -._ or any other non alphanumeric character. \n\n(2) It allows heirarchical domain names (e.g. me@really.big.com). Similar -._ placement rules there. \n\n(3) It allows 2-9 character alphabetic-only TLDs (that oughta cover museum and adnauseum :&gt;). \n\n(4) No IP email addresses though -- I wouldn't Want to accept that kind of address. "
    },
    {
        "Pattern": "^(\\d)?[ ]*[\\(\\.\\-]?(\\d{3})[\\)\\.\\-]?[ ]*(\\d{3})[\\.\\- ]?(\\d{4})[ ]*(x|ext\\.?)?[ ]*(\\d{1,7})?$",
        "MatchingText": "1 (123) 123-1234 ext. 1234567 ||| 1 (123) 123-1234 ||| (123) 123-1234 ||| (123)123.1234 ||| 1-123-123-1234 ||| 1231231234",
        "NonMatchingText": "123/1234 L. 12345678",
        "Description": "Requires area code.  Allows extension.  Any common US format works.  If you prefer not to require area code, use this:   ^(\\d)?[ ]*[\\(\\.\\-]?(\\d{3})?[\\)\\.\\-]?[ ]*(\\d{3})[\\.\\- ]?(\\d{4})[ ]*(x|ext\\.?)?[ ]*(\\d{1,7})?$"
    },
    {
        "Pattern": "^[a-zA-Z0-9&#192;&#193;&#194;&#195;&#196;&#197;&#198;&#199;&#200;&#201;&#202;&#203;&#204;&#205;&#206;&#207;&#208;&#209;&#210;&#211;&#212;&#213;&#214;&#216;&#217;&#218;&#219;&#220;&#221;&#223;&#224;&#225;&#226;&#227;&#228;&#229;&#230;&#231;&#232;&#233;&#234;&#235;&#236;&#237;&#238;&#239;&#241;&#242;&#243;&#244;&#245;&#246;&#248;&#249;&#250;&#251;&#252;&#253;&#255;\\.\\,\\-\\/\\']+[a-zA-Z0-9&#192;&#193;&#194;&#195;&#196;&#197;&#198;&#199;&#200;&#201;&#202;&#203;&#204;&#205;&#206;&#207;&#208;&#209;&#210;&#211;&#212;&#213;&#214;&#216;&#217;&#218;&#219;&#220;&#221;&#223;&#224;&#225;&#226;&#227;&#228;&#229;&#230;&#231;&#232;&#233;&#234;&#235;&#236;&#237;&#238;&#239;&#241;&#242;&#243;&#244;&#245;&#246;&#248;&#249;&#250;&#251;&#252;&#253;&#255;\\.\\,\\-\\/\\' ]+$",
        "MatchingText": "v.le dell'industria 45/a|||via genova 45-3-d|||p.zza Garibaldi, 48",
        "NonMatchingText": "[NULL]",
        "Description": "This simple regexp should match any possible italian address entry and doesn't match NULL entries (good if address is required). Should work well for any other address (it's been verified against 250 addresses from most european countries, usa and australia. Please mail me if there's something missing"
    },
    {
        "Pattern": "^((\\+44\\s?\\d{4}|\\(?\\d{5}\\)?)\\s?\\d{6})|((\\+44\\s?|0)7\\d{3}\\s?\\d{6})$",
        "MatchingText": "01902123456|||01902 123456|||(01902)123456|||(01902) 123456|||+441902123456|||+441902 123456|||+44 1902123456|||+44 1902 123456|||07807123456|||07807 123456|||+447807123456|||+447807 123456|||+44 7807123456|||+44 7807 123456",
        "NonMatchingText": "11902123456|||(+441902)123456|||441902123456|||(078)07123456",
        "Description": "Allows both mobile and landline UK Telephone Numbers. Allows either Brackets or international prefix. Allows spaces after international prefix and regional code. No brackets for mobile numbers. Please report any problems. Thanks"
    },
    {
        "Pattern": "^(net.tcp\\://|(ht|f)tp(s?)\\://)\\S+",
        "MatchingText": "http://ww.nancy.net/Servicios/ProxyWSService.svc|net.tcp://testwcf02.com:808/Tasacion|ftps://nancy.inet:/ProxyFTP",
        "NonMatchingText": "C: | C:\\inetpub\\wwwroot\\file.asmx | file.svc",
        "Description": "For validate uri directions that must occur at the beginning of the string net.tcp|http|https|ftp|ftps://"
    },
    {
        "Pattern": "^(?:(?:\\(|)0|\\+27|27)(?:1[12345678]|2[123478]|3[1234569]|4[\\d]|5[134678])(?:\\) | |-|)\\d{3}(?: |-|)\\d{4}$",
        "MatchingText": "+27121234567 +2712 123 4567 012 123 4567 (012) 123 4567 (012) 123-4567",
        "NonMatchingText": "27621234567",
        "Description": "Limited by proper dialing codes as per http://en.wikipedia.org/wiki/Telephone_numbers_in_South_Africa. It will match phone numbers in most common formats that users normally type their phone number.\n\nTested with Perl engine regex in PHP."
    },
    {
        "Pattern": "[^0-9]((\\(?(\\+420|00420)\\)?( |-)?)?([0-9]{3} ?(([0-9]{3} ?[0-9]{3})|([0-9]{2} ?[0-9]{2} ?[0-9]{2})))|([0-9]{3}-(([0-9]{3}-[0-9]{3})|([0-9]{2}-[0-9]{2}-[0-9]{2}))))[^0-9|/]",
        "MatchingText": "+420 123 456 789, 00420 123 456 789, 123456789",
        "NonMatchingText": "+420 1234567899, 100420 123 456 789, 123456789/0000",
        "Description": "Regexp for czech telephone number format. Fix to bank account number"
    },
    {
        "Pattern": "AT&T Email Customer Service Number +1-844-444-4174",
        "MatchingText": "email support service",
        "NonMatchingText": "offline customer support",
        "Description": "We are one of the most reasonable service providers to help the AT&T Email users. If you have a problem with Emails, like AT&T email hacked or SMTP errors occurred or Unable to receive and send new Email? then you do not have to worry about anything. Call AT&T Email Customer Service Number +1-844-444-4174 and solve your problem. We are 24*7 hrs actively available to serve best technical support to all users around the United State region."
    },
    {
        "Pattern": "AT&T Email Support Number +1-844-444-4174",
        "MatchingText": "AT&T Email Support Number +1-844-444-4174",
        "NonMatchingText": "offline customer care",
        "Description": "We are one of the most Reliable and Result Oriented Services providers to help the AT&T Email users. If you have any issues while using AT&T Email Services, just call at AT&T Email Support Number +1-844-444-4174 to solve your problems like ATT password issue or error with iPhone, ATT app setting on Gmail or likewise. We are 24*7 actively available to serve best technical support to all users around the United State region."
    },
    {
        "Pattern": "^(([0-2]*[0-9]+[0-9]+)\\.([0-2]*[0-9]+[0-9]+)\\.([0-2]*[0-9]+[0-9]+)\\.([0-2]*[0-9]+[0-9]+))$",
        "MatchingText": "113.173.40.255|||171.132.248.57|||79.93.28.178",
        "NonMatchingText": "189.57.135|||14.190.193999|||A.N.D.233",
        "Description": "Matches simple IP addresses. It's not too complex or long, but it does the job if you want something short/simple."
    },
    {
        "Pattern": "^(\\{|\\[|\\().+(\\}|\\]|\\)).+$",
        "MatchingText": "{CLaN}nick|||[Clan]Nick|||(Clan)Nick",
        "NonMatchingText": "Nick",
        "Description": "Matches &quot;clan&quot; nicks/names."
    },
    {
        "Pattern": "^\\s*-?(\\d*\\.)?([0-2])?[0-9]:([0-5])?[0-9]:([0-5])?[0-9](\\.[0-9]{1,7})?\\s*$",
        "MatchingText": "10:12:34|||932323.9:00:32.3420",
        "NonMatchingText": "10:20:80",
        "Description": "This should be the pattern described in the documentation for the .NET TimeSpan.Parse method - generally parses time spans.\nFrom the .NET docs:\n\npublic static TimeSpan Parse(string s);\n\nThe s parameter contains a specification of the form:\n\n[ws][-][d.]hh:mm:ss[.ff][ws]\n\nItems in square brackets ([ and ]) are optional, colons and periods (: and .) are literal characters, and other items are as follows.\n\nItem Description \nws optional white space \n&quot;-&quot; optional minus sign indicating a negative time \n&quot;d&quot; optional days \n&quot;hh&quot; hours, ranging from 0 to 23 \n&quot;mm&quot; minutes, ranging from 0 to 59 \n&quot;ss&quot; seconds, ranging from 0 to 59 \n&quot;ff&quot; optional fractional seconds, from 1 to 7 decimal digits \n"
    },
    {
        "Pattern": "^-?((\\d*\\.\\d+)|(\\d+\\.\\d*)|(\\d+\\.\\d+))$",
        "MatchingText": "2.5  .5   2.  5335332.3533  -.2 -5. -42.53  ",
        "NonMatchingText": ".  2.4.   ..2  2   6434   -.  -  6-3.4",
        "Description": "A number with a single decimal point in it.\n\nGet rid of the ^'s and $'s if it can bump a word."
    },
    {
        "Pattern": "(([a-z']?[a-z' ]*)|([a-z][\\.])?([a-z][\\.]))",
        "MatchingText": "van 't | von | v.d. |  auf dem",
        "NonMatchingText": "v.'t | VON | van d.",
        "Description": "Tests the most common prefixes as used in The Netherlands and Germany . Commom abbreviations \"v.\" and \"v.d.\" are also covered."
    },
    {
        "Pattern": "^[0-9]{4} {0,1}[A-Z]{2}$",
        "MatchingText": "9999 AA|||9999AA",
        "NonMatchingText": "9999 aa|||9999?AA",
        "Description": "Check the Dutch postal code offical format of \"9999 AA\". Since it is often stored in a database without the space, this pattern allows 0 or 1 space."
    },
    {
        "Pattern": "^-?(\\d+(,\\d{3})*(\\.\\d+)?|\\d?(\\.\\d+))$",
        "MatchingText": "123|||9,001|||-123,456,789.123|||3.14159|||.25",
        "NonMatchingText": "abc|||-|||123,456,78|||0.123.456|||234.567,890|||,123,456",
        "Description": "Matches any floating point numeric string with or without commas."
    },
    {
        "Pattern": "^([0-9]{2})?((\\([0-9]{2})\\)|[0-9]{2})?([0-9]{3}|[0-9]{4})(\\-)?[0-9]{4}$",
        "MatchingText": "552123236699|||212323-6699|||2323-6699",
        "NonMatchingText": "[3434-3432]|||[4(23)232-3232]|||[55(2)232-232]",
        "Description": "A simple expression to brazilian phone number code modified expression of Rafael, beyond international code, simple DDI without &quot;+&quot; 99 plus simple DDD (99) plus simple and whitout parentheses em trace, local phone number 3 or 4 digits plus &quot;-&quot; plus 4 digits."
    },
    {
        "Pattern": "^(((((((0?[13578])|(1[02]))[\\.\\-/]?((0?[1-9])|([12]\\d)|(3[01])))|(((0?[469])|(11))[\\.\\-/]?((0?[1-9])|([12]\\d)|(30)))|((0?2)[\\.\\-/]?((0?[1-9])|(1\\d)|(2[0-8]))))[\\.\\-/]?(((19)|(20))?([\\d][\\d]))))|((0?2)[\\.\\-/]?(29)[\\.\\-/]?(((19)|(20))?(([02468][048])|([13579][26])))))$",
        "MatchingText": "02-29-2004|||1/31/1997|||1-2-03",
        "NonMatchingText": "02-29-2003|||04-31-2003|||31-03-05",
        "Description": "Simple American date format mm-dd-yyyy or mm-dd-yy, no time. Date range is 1900 --&gt; 2099. Is enough for my purposes. Incorectly validates 02-29-1900. I created this to validate dates on a web form where the likely range will be 2000--&gt;2020. Seperators can be '.','/' or '-'\nAnyone know the rules for operator precedence for regex syntax?"
    },
    {
        "Pattern": "\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b",
        "MatchingText": "127.0.0.1 | 64.125.39.85 | 192.168.8.50",
        "NonMatchingText": "255.143.20.3 | 300.23.105.3 | 29.100.340.23",
        "Description": "This regex expression validates IP addresses when processed as a string."
    },
    {
        "Pattern": "[^(\\&amp;)](\\w*)+(\\=)[\\w\\d ]*",
        "MatchingText": "name1=value1&amp;name2=value2&amp;...",
        "NonMatchingText": "anyoldstring",
        "Description": "Query string parser matches and tokenizes each name/value pair for a valid query string."
    },
    {
        "Pattern": "/^(?:(?:1\\d?\\d|[1-9]?\\d|2[0-4]\\d|25[0-5])\\.){3}(?:1\\d?\\d|[1-9]?\\d|2[0-4]\\d|25[0-5])$/",
        "MatchingText": "192.168.1.2 || 127.0.0.1",
        "NonMatchingText": "192.168.01.2 || 1921.68.1.2",
        "Description": "It matches an IP address only in the correct format. There was a previous regex send which matches 192.168.01.2 but this code won't match preceeding 0's"
    },
    {
        "Pattern": "BV_SessionID=@@@@0106700396.1206001747@@@@&BV_EngineID=ccckadedjddehggcefecehidfhfdflg.0",
        "MatchingText": "BV_SessionID=@@@@0106700396.1206001747@@@@&BV_EngineID=ccckadedjddehggcefecehidfhfdflg.0",
        "NonMatchingText": "BV_SessionID=@@@@0106700396.1206001747@@@@&BV_EngineID=ccckadedjddehggcefecehidfhfdflg.0",
        "Description": "www.irctc.co.in"
    },
    {
        "Pattern": "^((\\d{2}(([02468][048])|([13579][26]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])))))|(\\d{2}(([02468][1235679])|([13579][01345789]))[\\-\\/\\s]?((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))(\\s(((0?[1-9])|(1[0-2]))\\:([0-5][0-9])((\\s)|(\\:([0-5][0-9])\\s))([AM|PM|am|pm]{2,2})))?$",
        "MatchingText": "2004-2-29|||2004-02-29 10:29:39 pm|||2004/12/31",
        "NonMatchingText": "2003-2-29|||2003-13-02|||2003-2-2 10:72:30 am",
        "Description": "Matches ANSI SQL date format YYYY-mm-dd hh:mi:ss am/pm.  You can use / - or space for date delimiters, so 2004-12-31 works just as well as 2004/12/31. Checks leap year from 1901 to 2099."
    },
    {
        "Pattern": "^((((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|([1-2][0-9]))))[\\-\\/\\s]?\\d{2}(([02468][048])|([13579][26])))|(((((0?[13578])|(1[02]))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\\-\\/\\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\\-\\/\\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))[\\-\\/\\s]?\\d{2}(([02468][1235679])|([13579][01345789]))))(\\s(((0?[1-9])|(1[0-2]))\\:([0-5][0-9])((\\s)|(\\:([0-5][0-9])\\s))([AM|PM|am|pm]{2,2})))?$",
        "MatchingText": "2/29/2004|||04/01/2003 10:01:23 am|||03-20-1999",
        "NonMatchingText": "2/29/2003|||13/30/2001 10:05:00 pm|||12/32/2003",
        "Description": "This regex will match SQL Server datetime values, allowing date only, allowing zero padded digits in month, day and hour, and will match leap years from 1901 up until 2099."
    },
    {
        "Pattern": "((ht|f)tp(s?))(:((\\/\\/)(\\/)))(((w){3}\\.)?)([a-zA-Z0-9\\-_]+(\\.(com|edu|gov|int|mil|net|org|biz|info|name|pro|museum|co\\.uk)))(\\/(\\/))(([a-zA-Z0-9\\-_\\/]*)?)([a-zA-Z0-9])+\\.((jpg|jpeg|gif|png)((\\w|\\W)))",
        "MatchingText": "http://www.location.com/images/image1.gif|||http://www.location.com/images/mainImgs/image1.png",
        "NonMatchingText": "/images/image1.jpeg|||http://www.location.com/images/image1.swf|||http://www.something.com/hello/..j",
        "Description": "This expression matches valid image URLs. The main use for this would be in UBBC tags.\n\nWritten by RyanJ and Jick for FWD (http://flexwebdev.thenamesdan.com/)"
    },
    {
        "Pattern": "^(\\d{4})[.](0{0,1}[1-9]|1[012])[.](0{0,1}[1-9]|[12][0-9]|3[01])[.](\\d{2})$",
        "MatchingText": "2006.10.09.05",
        "NonMatchingText": "06.13.32.123",
        "Description": "capture labels having format yyyy.mm.dd.nn here nn is for number s from 00 to 99"
    },
    {
        "Pattern": "^([Aa][LKSZRAEPlkszraep]|[Cc][AOTaot]|[Dd][ECec]|[Ff][LMlm]|[Gg][AUau]|[Hh][Ii]|[Ii][ADLNadln]|[Kk][SYsy]|[Ll][Aa]|[Mm][ADEHINOPSTadehinopst]|[Nn][CDEHJMVYcdehjmvy]|[Oo][HKRhkr]|[Pp][ARWarw]|[Rr][Ii]|[Ss][CDcd]|[Tt][NXnx]|[Uu][Tt]|[Vv][AITait]|[Ww][AIVYaivy])$",
        "MatchingText": "MN | tx | Tx",
        "NonMatchingText": "M | 23 | Alaska | zz",
        "Description": "This is just a simple US states and territories in 2 character regex. Requires valid 2 letter abbreviations. It accepts the Lower and Upper Case Entries."
    },
    {
        "Pattern": "^([A-Z]{2}\\s?(\\d{2})?(-)?([A-Z]{1}|\\d{1})?([A-Z]{1}|\\d{1})?( )?(\\d{4}))$",
        "MatchingText": "RJ21-CA 1232",
        "NonMatchingText": "RJ21-CA1232",
        "Description": "Ex.- RJ21-CA 1232\nPB08-PA 4354"
    },
    {
        "Pattern": "\\S*?[\\[\"].*?[\\]\"]|\\S+",
        "MatchingText": "any [strings matched] \"any at\" all",
        "NonMatchingText": "^\\s*$",
        "Description": "Given that you have a string that is comprised characters/words separated by spaces and you want to creates matches of those words/characters but you also have substring groups of words/characters/spaces enclosed in [] and \"\" that you want treated as a single match, this pattern is what worked for me.  Feel free to modify this regex to fit your needs if your string groups are not grouped by [] or \"\".  Please let me know if this doesn't test well for you. ********** Example Test String:\n212.183.143.4 - - [03/May/2007:21:03:27 +0100]  \"GET mp4-amrnb.3gp RTSP/1.0\" 200 155527 [RealOnePlayer_s60.26.25.01_21-Jun-2005_13:02:43_epoc_av21_thumb] [3e546ed1-f9b1-11db-eb72-1d98b80ca9f5] [UNKNOWN] 454492 102 47 0 0 [0 0 0 0] [03/May/2007:21:02:38] 192.168.0.2 24245 55 ********** Matches:\nMatches(0) = \"212.183.143.4\"\nMatches(1) = \"-\"\nMatches(2) = \"-\"\nMatches(3) = \"[03/May/2007:21:03:27 +0100]\"\nMatches(4) = \"\"GET mp4-amrnb.3gp RTSP/1.0\"\"\nMatches(5) = \"200\"\nMatches(6) = \"155527\"\nMatches(7) = \"[RealOnePlayer_s60.26.25.01_21-Jun-2005_13:02:43_epoc_av21_thumb]\"\nMatches(8) = \"[3e546ed1-f9b1-11db-eb72-1d98b80ca9f5]\"\nMatches(9) = \"[UNKNOWN]\"\nMatches(10) = \"454492\"\nMatches(11) = \"102\"\nMatches(12) = \"47\"\nMatches(13) = \"0\"\nMatches(14) = \"0\"\nMatches(15) = \"[0 0 0 0]\"\nMatches(16) = \"[03/May/2007:21:02:38]\"\nMatches(17) = \"192.168.0.2\"\nMatches(18) = \"24245\"\nMatches(19) = \"55\" \n********** ASP Test Code:\nSet regEx = New RegExp\nregEx.Global = True\nregEx.IgnoreCase = True\nregEx.MultiLine = True\nteststring = \"<<your string>>\"\nregEx.Pattern = \"\\S*?[\\[|\\\"\"].*?[\\]|\\\"\"]|\\S+\"\nSet Matches = regEx.Execute(teststring)"
    },
    {
        "Pattern": "(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.)|(^127\\.0\\.0\\.1)",
        "MatchingText": "10.12.0.19|||172.21.0.23|||192.168.0.2",
        "NonMatchingText": "222.12.3.24|||172.12.0.12",
        "Description": "It matches private IP addresses. Private IP addresses (as defined by RFC 1918) are not routable on public Internet. This would help if you want to grant some previlege only to the users from within local network. ***Importnat*** This pattern assumes that the input is a valid IP address. You many need to make sure the input is a valid IP address. "
    },
    {
        "Pattern": "(((0[1-9]|[12][0-9]|3[01])([.])(0[13578]|10|12)([.])([1-2][0,9][0-9][0-9]))|(([0][1-9]|[12][0-9]|30)([.])(0[469]|11)([.])([1-2][0,9][0-9][0-9]))|((0[1-9]|1[0-9]|2[0-8])([.])(02)([.])([1-2][0,9][0-9][0-9]))|((29)(\\.|-|\\/)(02)([.])([02468][048]00))|((29)([.])(02)([.])([13579][26]00))|((29)([.])(02)([.])([0-9][0-9][0][48]))|((29)([.])(02)([.])([0-9][0-9][2468][048]))|((29)([.])(02)([.])([0-9][0-9][13579][26])))",
        "MatchingText": "01.01.2004|||30.12.2005",
        "NonMatchingText": "01/01/2004|||1.1.2004|||01-01-2004",
        "Description": "Usefull for SQL update and insert sentence.."
    },
    {
        "Pattern": "(((^\\s*)*\\S+\\s+)|(\\S+)){1,5} ",
        "MatchingText": "Hello, this is five words",
        "NonMatchingText": "Hello, this is not five words",
        "Description": "This is used to validate a word count of input with an asp.net RegularExpressionValidator."
    },
    {
        "Pattern": "^[1-9][0-9]{3}[ ]?(([a-rt-zA-RT-Z]{2})|([sS][^dasDAS]))$",
        "MatchingText": "3545CA",
        "NonMatchingText": "3534 SS",
        "Description": "Dutch zipcode. The non-matching code does not match because lettercombinations SS, SA and SD are not allowed. (historic reasons ?). \n"
    },
    {
        "Pattern": "http://\\([a-zA-Z0-9_\\-]\\+\\(\\.[a-zA-Z0-9_\\-]\\+\\)\\+\\)\\+:\\?[0-9]\\?\\(/*[a-zA-Z0-9_\\-#]*\\.*\\)*?\\?\\(&*[a-zA-Z0-9;_+/.\\-%]*-*=*[a-zA-Z0-9;_+/.\\-%]*-*\\)*",
        "MatchingText": "http://domain.com/ ||| http://www.domain.com/results?page=2&var=1 ||| http://www.domain.com/results.html#here ||| http://www.domain.com:8888/results.html",
        "NonMatchingText": "/results?page=2 ||| index.html ||| www.domain.com",
        "Description": "Find http:// urls.\n\nYou can replace at the beginning the http:// with a protocol you like as https:// ftp:// etc."
    },
    {
        "Pattern": "^([\\da-fA-f]{2}[:-]){5}[\\da-fA-f]{2}$",
        "MatchingText": "98-CE-d0-a2-0a-68 | 98:cE:d0:a2:0a:68",
        "NonMatchingText": "98-cE-d0-a2-0a | 98-cE-d0-a2-0a-68-f0",
        "Description": "Matches mixed case, colon or hypen hexadecimal notation. Discards string too short or long, or with invalid characters. Needs extended grep."
    },
    {
        "Pattern": "^\\d{10}$",
        "MatchingText": "0123456789, any 10 digit number.",
        "NonMatchingText": "01245, 01234567899, Less than or greater than 10 digits will fail.",
        "Description": "I needed an expression to allow only a 10 digit number to be entered. No () or dashes or spaces. Cisco IP phones only like the 10 digit number. So here's what I came up with. Very short and simple!\n"
    },
    {
        "Pattern": "\\d[\\d\\,\\.]+",
        "MatchingText": "123.00",
        "NonMatchingText": "1 123123",
        "Description": "This regex will match any price, what so ever, if it's uses a comma as a 1000 seperator, or a dot, and if it uses comma as a decimal seperator or a dot, or if it do not use any seperator what so ever."
    },
    {
        "Pattern": "^(\\+86)(13[0-9]|145|147|15[0-3,5-9]|18[0,2,5-9])(\\d{8})$",
        "MatchingText": "+8613812345678 | +8613012345678 | +8618212345678",
        "NonMatchingText": "+8614012345678 | +8615412345678 | +8619012345678",
        "Description": "This expression is pretty simple. It validates for mobile phone numbers in mainland China. I needed phone numbers in a certain format for use with an SMS gateway. The formatting is rather strict.\n\nArea codes taken from here: http://en.wikipedia.org/wiki/Telephone_numbers_in_China#Mobile_phones"
    },
    {
        "Pattern": "^[ABCEGHJKLMNPRSTVXYabceghjklmnprstvxy]{1}\\d{1}[A-Za-z]{1}[ ]{0,1}\\d{1}[A-Za-z]{1}\\d{1}$",
        "MatchingText": "K4A3Z5 ||| K4A 3Z5 ||| k4a3z5 ||| k4a 3z5",
        "NonMatchingText": "D1G 1T9 ||| abc def ||| 123 456 ||| f1g4t0",
        "Description": "Matches the Canadian postal code with or without space between.\nAlso matches uppercase and lower case letters."
    },
    {
        "Pattern": "^([0-1]([\\s-./\\\\])?)?(\\(?[2-9]\\d{2}\\)?|[2-9]\\d{3})([\\s-./\\\\])?(\\d{3}([\\s-./\\\\])?\\d{4}|[a-zA-Z0-9]{7})$",
        "MatchingText": "1.222.333.1234|||1-223-123-1232|||12223334444",
        "NonMatchingText": "1.1.123123.123|||12-1322-112-31|||11231321131",
        "Description": "It checks for Valid US Phone numbers. \nAccepts &amp;amp;amp;quot;.&amp;amp;amp;quot;,Space,\\,/,- as delim."
    },
    {
        "Pattern": "^N[1-9][0-9]{0,4}$|^N[1-9][0-9]{0,3}[A-Z]$|^N[1-9][0-9]{0,2}[A-Z]{2}$",
        "MatchingText": "N12345",
        "NonMatchingText": "N123456",
        "Description": "FAA Tail Numbers as described here: http://www.faa.gov/licenses_certificates/aircraft_certification/aircraft_registry/special_nnumbers/"
    },
    {
        "Pattern": "/^(?i)[a-z0-9]+([\\.-][a-z0-9]+){0,}@[a-z0-9]+([\\.-][a-z0-9]{2,})+$/i",
        "MatchingText": "valid@email.com|||valid@email.ca|||TheBigCorp@expensive.protecction|||NicholasJohnDoe@company.com.us|||Johny.Bravo@i.cartoon-network.com",
        "NonMatchingText": "Nice.try.@badguys.com|||nice.try@.com|||Not eeven an email|||Seriously?@china.cn|||NiceBad@mexico|||notMeNotU.@usa.gov|||-a-a-a@russia.ru",
        "Description": "Used for a personal project. Hope you find it useful."
    },
    {
        "Pattern": "^(\\-)?\\d*(\\.\\d+)?$",
        "MatchingText": "0.55|||21232.00|||-89.20",
        "NonMatchingText": "asdf|||+0.33",
        "Description": "Matches all positive decimal floating negative/non-negative numbers. Allows empty string. "
    },
    {
        "Pattern": "^(?P<tipo>.{1,3})\\s+(?P<endereco>.+),\\s+(?P<numero>\\w{1,10})\\s*(?P<complemento>.*)$",
        "MatchingText": "Rua Jos\u00E9 Batista dos Santos, 934 Casa 2|Rua Jos\u00E9 Batista dos Santos, SN|Av Paulista, 1234567890 Ro\u00E7a Grande",
        "NonMatchingText": "Jos\u00E9 Batista dos Santos, 934 Casa 2|Rua Jos\u00E9 Batista dos Santos, 12345678901|Caixa Postal 5000",
        "Description": "Quebra um endere\u00E7o em TIPO LOGRADOURO, ENDERECO, N\u00DAMERO e COMPLEMENTO.\n\nSegue norma da Prefeitura Municipal de Curitiba"
    },
    {
        "Pattern": "((0[1-9]|[12]\\d|3[01])(0[1-9]|1[0-2])\\d{3}\\d{2}\\d{4})",
        "MatchingText": "0101006500006",
        "NonMatchingText": "none",
        "Description": "Regex to match the \"Unique Master Citizen Number\" based on the wikipedia description.\nIt doesn't keep in account the checksum, but it matches the example on wikipedia."
    },
    {
        "Pattern": "^((00)?\\+?[389]{3})?[\\/\\-\\s*\\.]?(((\\(0\\))|0)?\\s*7\\d{1})[\\/\\-\\s*\\.\\,]?([\\d]{3})[\\/\\-\\s*\\.\\,]?([\\d]{3})$",
        "MatchingText": "+389 078 443 246 +389 078-443-246 +389 078/443/246 +389(0)78443246 0038978123456 +389078499039 +38978499039 +389 078.443.246",
        "NonMatchingText": "02 4432 246",
        "Description": "Simple regular expression for Macedonian cell phone numbers."
    },
    {
        "Pattern": "^(eth[0-9]$)|(^eth[0-9]:[1-9]$)",
        "MatchingText": "eth0|||eth0:4|||eth4:9",
        "NonMatchingText": "eth0:|||eth0:0|||eth0:1d",
        "Description": "regex to validate unix device names (linux). useful for scripts using ifconfig or stuff"
    },
    {
        "Pattern": "(?P<value>([\\+-]?((\\d*\\.\\d+)|\\d+))(E[\\+-]?\\d+)?)( (?P<prefix>[PTGMkmunpf])?(?P<unit>[a-zA-Z]+)?)?",
        "MatchingText": "1 uW, 1 mW, 1 W, 1 m, 1.5 W, .5 W, 5E-12 F, 5 nF",
        "NonMatchingText": "mW, 5- mW, 5mW",
        "Description": "Used for matching measurement expressions with or without scientific notation, with or without a list of known prefixes, and with an option component of a unit. Known limitations include that a measurement term cannot lack a prefix and also start with a letter that could be mistaken for a prefix. For instance, \"5 m\" is parsed as 5 with a prefix of m, not 5 with a base prefix and a unit of m."
    },
    {
        "Pattern": "^[\\w-]+(?:\\.[\\w-]+)*@(?:[\\w-]+\\.)+[a-zA-Z]{2,7}$",
        "MatchingText": "joe.tillis@unit.army.mil|||jack_rabbit@slims.com|||foo99@foo.co.uk",
        "NonMatchingText": "find_the_mistake.@foo.org|||.prefix.@some.net",
        "Description": "Matches 99.99% of e-mail addresses (excludes IP e-mails, which are rarely used).  The {2,7} at the end leaves space for top level domains as short as .ca but leaves room for new ones like .museum, etc.  The ?: notation is a perl non-capturing notation, and can be removed safely for non-perl-compatible languages.  See also email."
    },
    {
        "Pattern": "^(([0-9])|([0-2][0-9])|([3][0-1]))\\/(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\/\\d{4}$",
        "MatchingText": "1/Feb/2007|||03/Jun/2007|||31/Dec/2007",
        "NonMatchingText": "1/2/2007|||03/Jun/07|||31-Dec-2007",
        "Description": "This regular expressions matches dates of the form dd/MMM/yyyy where dd can be 1 or 2 digits long, MMM is a month abbreviation, and yyyy is always 4 digits long."
    },
    {
        "Pattern": "((?:[^\",]|(?:\"(?:\\\\{2}|\\\\\"|[^\"])*?\"))*)",
        "MatchingText": "this is ,a,\"line,\\\"in\\\",a\",csv,file",
        "NonMatchingText": "\"",
        "Description": "Very simple (but very useful!) regex to split CSV files.  It does not drop the commas - you have to do that manually.  Quotes are dealt with properly and escaped quotes are ignored.  Matches from sample:this is ;a;\"line,\\\"in\\\"a\";csv;file"
    },
    {
        "Pattern": "&(amp;)",
        "MatchingText": "var1=val1&amp;var2=test",
        "NonMatchingText": "var1=val1&amp;amp;var2=test",
        "Description": "Used to replace lone ampersands in query strings with their &amp;amp; counterparts.  "
    },
    {
        "Pattern": "^([\\+][0-9]{1,3}[\\.][0-9]{1,12})([x]?[0-9]{1,4}?)$",
        "MatchingText": "+800.4453377x4444|||+80.4453377|||+8.123456789123x1111",
        "NonMatchingText": "181823884499|||+800.4453377x|||2486994x11",
        "Description": "Validates on the following standards:\n\n+CCC.ZZZZZZZZZZxYYYY, where 'C' is the numeric \ncountry phone code (up to three digits), 'Z' is the phone number (up to \n12 digits) and 'Y' is the extension (up to 4 digits); max length overall is \n20 characters, including the '+', '.', and 'x' (if extension is present). \n\nUseful for people communicating with the OpenSRS API"
    },
    {
        "Pattern": "^[a-zA-Z]+(([\\'\\,\\.\\-][a-zA-Z])?[a-zA-Z]*)*$",
        "MatchingText": "Sameul|||O'Conner|||Mary-Kate",
        "NonMatchingText": "David Bugel|||Robert1|||Robert M. Larry",
        "Description": "This allows you to validate first names and last names in seperate fields.  Instead of validating a full name in one field."
    },
    {
        "Pattern": "$(\\n|\\r\\n)",
        "MatchingText": "It always match.||| It always match.||| It always match.",
        "NonMatchingText": "It always match.||| It always match.||| It always match.",
        "Description": "Multi-line mode.\nExtract each paragraph in the text. Using split."
    },
    {
        "Pattern": "\\.\\s|$(\\n|\\r\\n)",
        "MatchingText": "Any sentence without abbreviations on it.",
        "NonMatchingText": "In this sentences e.g. it does not work.",
        "Description": "It does not work in sentences with abbreviations."
    },
    {
        "Pattern": "\\b(1(27\\.0\\.0\\.1)\\d{1,2}|2[0-4][0-9]|25[0-4]|\\d{1,2})\\.(?:\\d{1,3}\\.){2}(25[0-5]|2[0-4][0-9]|1\\d{2}|\\d{2}|[1-9])\\b",
        "MatchingText": "172.21.134.89 127.1.1.1 7.0.0.1 214.214.214.214",
        "NonMatchingText": "127.0.0.1 192.168.1.0 255.255.255.255",
        "Description": "Match all IP addresses other than 127.0.0.1. It dose not match an IP has 0 at the last number"
    },
    {
        "Pattern": "[\\\\\"\"=:;,](([\\w][\\w\\-\\.]*)\\.)?([\\w][\\w\\-]+)(\\.([\\w][\\w\\.]*))?\\\\sql\\d{1,3}[\\\\\"\"=:;,]",
        "MatchingText": "=abc\\sql022,  =abc.e.f.g\\sql078, =192.168.1.1\\sql001, =234\\sql003,",
        "NonMatchingText": "sql .\\sql003 ",
        "Description": "This expression is ideal used for \"identifying some plain application configuration files that contain any form of MSSQL database/instance reference in connection string\". Dose not match .\\sql. [\\\\\"\"=/] can be removed on both ends to seach server/instance in text files, but with it, it has better accuracy"
    },
    {
        "Pattern": "[\\\\\"\"=/>](25[0-4]|2[0-4][0-9]|1\\d{2}|\\d{2})\\.((25[0-4]|2[0-4][0-9]|1\\d{2}|\\d{1,2})\\.){2}(25[0-4]|2[0-4][0-9]|1\\d{2}|\\d{2}|[1-9])\\b[\\\\\"\"=:;,/<]",
        "MatchingText": "/172.21.134.89: /127.0.0.1: \"14.14.14.14\"",
        "NonMatchingText": "\"255.255.255.255\" \"243.243.2.0\" \"2.222.222.222\" /2224.2224.2224.2224:",
        "Description": "This expression is ideal used for \"identifying some plain application configuration files that contain any form of ip addresses, with or without port number followed and with protocol at the beginning\".\n[\\\\\"\"=/] can be removed on both ends to seach IPs in text files, but with it, it has better accuracy - there are version numbers in the application configuration files.\n\nIt also does not match IPs that have one digit at the first number."
    },
    {
        "Pattern": "^(([1-9]\\d{0,2}(\\,\\d{3})*|([1-9]\\d*))(\\.\\d{2})?)|([0]\\.(([0][1-9])|([1-9]\\d)))$",
        "MatchingText": "1,234,567.89|||1234567.89|||9.99|||0.34|||0.10 ||| 1234",
        "NonMatchingText": "1,2345,67.89|||1234,345,678.0|||0|||0.00 ||| 123. ||| .123",
        "Description": "Building on Joe Lynwood's Regex which makes use of a combination of Michael Ash's US Dollar amount and Bri Gipson's eliminating zero input, I've added support for values between 0 and 1. Being relatively new to regex, I hope someone would be able to spot any discrepancies with the code and its supposed function.\nEdit 1: Corrected mis-match with non-decimal numbers."
    },
    {
        "Pattern": "^\\d{8,8}$|^[SC]{2,2}\\d{6,6}$",
        "MatchingText": "12345678 | SC123456",
        "NonMatchingText": "123456789 | AB123456 | a2345678",
        "Description": "Matches against a valid UK Limited company numer, either Scotland, Wales England or Northern Ireland. Either 8 numerical digits or SC followed by 6 numerical digits are allowed"
    },
    {
        "Pattern": "\\.txt$",
        "MatchingText": "testfile.txt|||.txt|||this is a file.txt",
        "NonMatchingText": "this is not a file.trt|||.tst|||.text",
        "Description": "Matches a file extention."
    },
    {
        "Pattern": "^(([1-9]{1})|([0-1][0-9])|([1-2][0-3])):([0-5][0-9])$",
        "MatchingText": "00:00|||23:59|||10:10",
        "NonMatchingText": "24:00|||00:60|||25:61",
        "Description": "Matches 24 hour time format."
    },
    {
        "Pattern": "^(?-i:A[DEFGILMNOQRSTUWZ]|B[ABDEFGHIJMNORSTVWYZ]|C[ACDFGHIKLMNORSUVXYZ]|D[EJKMOZ]|E[CEGHRST]|F[IJKMOR]|G[ABDEFHILMNPQRSTUWY]|H[KMNRTU]|I[DELNOQRST]|J[MOP]|K[EGHIMNPRWYZ]|L[ABCIKRSTUVY]|M[ACDGHKLMNOPQRSTUVWXYZ]|N[ACEFGILOPRUZ]|O[M]|P[AEFGHKLMNRSTWY]|QA|R[EOUW]|S[ABCDEGHIJKLMNORTVYZ]|T[CDFGHJKLMNORTVWZ]|U[AGMSYZ]|V[ACEGINU]|W[FS]|Y[ET]|Z[AMW])$",
        "MatchingText": "US|||CA|||MX",
        "NonMatchingText": "NX|||12|||USA",
        "Description": "Matches against the two character country abbreviations (as of 2010).\n\n\"AD\",\"AE\",\"AF\",\"AG\",\"AI\",\"AL\",\"AM\",\"AN\",\"AO\",\"AQ\",\"AR\",\"AS\",\"AT\",\"AU\",\"AW\",\"AZ\",\"BA\",\"BB\",\"BD\",\"BE\",\"BF\",\"BG\",\"BH\",\"BI\",\"BJ\",\"BM\",\"BN\",\"BO\",\"BR\",\"BS\",\"BT\",\"BV\",\"BW\",\"BY\",\"BZ\",\"CA\",\"CC\",\"CD\",\"CF\",\"CG\",\"CH\",\"CI\",\"CK\",\"CL\",\"CM\",\"CN\",\"CO\",\"CR\",\"CS\",\"CU\",\"CV\",\"CX\",\"CY\",\"CZ\",\"DE\",\"DJ\",\"DK\",\"DM\",\"DO\",\"DZ\",\"EC\",\"EE\",\"EG\",\"EH\",\"ER\",\"ES\",\"ET\",\"FI\",\"FJ\",\"FK\",\"FM\",\"FO\",\"FR\",\"GA\",\"GB\",\"GD\",\"GE\",\"GF\",\"GH\",\"GI\",\"GL\",\"GM\",\"GN\",\"GP\",\"GQ\",\"GR\",\"GS\",\"GT\",\"GU\",\"GW\",\"GY\",\"HK\",\"HM\",\"HN\",\"HR\",\"HT\",\"HU\",\"ID\",\"IE\",\"IL\",\"IN\",\"IO\",\"IQ\",\"IR\",\"IS\",\"IT\",\"JM\",\"JO\",\"JP\",\"KE\",\"KG\",\"KH\",\"KI\",\"KM\",\"KN\",\"KP\",\"KR\",\"KW\",\"KY\",\"KZ\",\"LA\",\"LB\",\"LC\",\"LI\",\"LK\",\"LR\",\"LS\",\"LT\",\"LU\",\"LV\",\"LY\",\"MA\",\"MC\",\"MD\",\"MG\",\"MH\",\"MK\",\"ML\",\"MM\",\"MN\",\"MO\",\"MP\",\"MQ\",\"MR\",\"MS\",\"MT\",\"MU\",\"MV\",\"MW\",\"MX\",\"MY\",\"MZ\",\"NA\",\"NC\",\"NE\",\"NF\",\"NG\",\"NI\",\"NL\",\"NO\",\"NP\",\"NR\",\"NU\",\"NZ\",\"OM\",\"PA\",\"PE\",\"PF\",\"PG\",\"PH\",\"PK\",\"PL\",\"PM\",\"PN\",\"PR\",\"PS\",\"PT\",\"PW\",\"PY\",\"QA\",\"RE\",\"RO\",\"RU\",\"RW\",\"SA\",\"SB\",\"SC\",\"SD\",\"SE\",\"SG\",\"SH\",\"SI\",\"SJ\",\"SK\",\"SL\",\"SM\",\"SN\",\"SO\",\"SR\",\"ST\",\"SV\",\"SY\",\"SZ\",\"TC\",\"TD\",\"TF\",\"TG\",\"TH\",\"TJ\",\"TK\",\"TL\",\"TM\",\"TN\",\"TO\",\"TR\",\"TT\",\"TV\",\"TW\",\"TZ\",\"UA\",\"UG\",\"UM\",\"US\",\"UY\",\"UZ\",\"VA\",\"VC\",\"VE\",\"VG\",\"VI\",\"VN\",\"VU\",\"WF\",\"WS\",\"YE\",\"YT\",\"ZA\",\"ZM\",\"ZW\""
    },
    {
        "Pattern": "^-?\\d{1,3}\\.(\\d{3}\\.)*\\d{3},\\d\\d$|^-?\\d{1,3},\\d\\d$",
        "MatchingText": "-23.456.789,01|||5,01|||123.123.123.123.123.123.123,45|||0,23",
        "NonMatchingText": "1|||1,234|||+1,23|||12345,67|||1,|||,23",
        "Description": "Inspired by Dalibor Kalna's regexp, this one accepts numbers with the dot as required thousands separator, comma as decimal separator, and exactly digits after the comma. Minus as sign is optional."
    },
    {
        "Pattern": "^(([A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^_\\`\\{\\|\\}\\~]+\\.*)*[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^_\\`\\{\\|\\}\\~]+@((\\w+\\-+)|(\\w+\\.))*\\w{1,63}\\.[a-zA-Z]{2,6})$",
        "MatchingText": "info@domain.com",
        "NonMatchingText": "Abc.example.com, A@b@c@example.com , ()[]\\;:,<>@example.com ",
        "Description": "An email that should work in accordance to the RFC standard (see http://en.wikipedia.org/wiki/Email_address#Syntax)"
    },
    {
        "Pattern": "^((Fred|Wilma)\\s+Flintstone|(Barney|Betty)\\s+Rubble)$",
        "MatchingText": "Fred Flintstone|||Barney Rubble|||Betty Rubble",
        "NonMatchingText": "The Great Gazoo|||Mr. Slate|||Dino",
        "Description": "Match the full names of the four main characters of The Flintstones."
    },
    {
        "Pattern": "\\<script[^>]*>[\\w|\\t|\\r\\|\\W]*?</script>",
        "MatchingText": "<script type=\"text/javascript\" src=\"test.js\"></script> <script> test </script",
        "NonMatchingText": "<%=Get(\"Configurator\")%>",
        "Description": "match all script blocks in html file or aspx file."
    },
    {
        "Pattern": "^((\\d(\\x20)\\d{2}(\\x20)\\d{2}(\\x20)\\d{2}(\\x20)\\d{3}(\\x20)\\d{3}((\\x20)\\d{2}|))|(\\d\\d{2}\\d{2}\\d{2}\\d{3}\\d{3}(\\d{2}|)))$",
        "MatchingText": "181049520156962|||1 81 04 95 201 569 62|||1 81 04 95 201 569",
        "NonMatchingText": "1 81049520156962|||181049520156962fds|||1810495201569ds",
        "Description": "It is an expression to valide a french num&#233;ro de s&#233;curit&#233; social (social security number translate is not sure) with or without the key."
    },
    {
        "Pattern": "(^(((\\d)|(\\d\\d)|(\\d\\d\\d))(\\xA0|\\x20))*((\\d)|(\\d\\d)|(\\d\\d\\d))([,.]\\d*)?$)",
        "MatchingText": "1 200|||1 241 588.14567|||123",
        "NonMatchingText": "az|||1254.456|||1234",
        "Description": "For who use a space as thousands separator like french, deutsch ...."
    },
    {
        "Pattern": "^[ \\w\\.]{3,}([A-Za-z]\\.)?([ \\w]*\\##\\d+)?(\\r\\n| )[ \\w]{3,},\\x20([A-Z]{2}\\.)\\x20\\d{5}(-\\d{4})?$",
        "MatchingText": "123 Anywhere Dr. apt #99 Somewhere, ST 55789 | 123 Anywhere Dr. Somewhere, ST 55789 | 123 Anywhere D | 1234 W. Anywhere St. City, IN. 12345",
        "NonMatchingText": "123 Anywhere Drive #99 Somewhere, ST 55789 - 1234 | 123 Anywhere Dr. apt. #99 Somewhere, ST 55789",
        "Description": "The original pattern was:\n^[ \\w]{3,}([A-Za-z]\\.)?([ \\w]*\\#\\d+)?(\\r\\n| )[ \\w]{3,},\\x20[A-Za-z]{2}\\x20\\d{5}(-\\d{4})?$\n\nI changed the regular expression to allow a few different options. I like what you created here, but wanted to change the pattern to only allow for the capitol letters with an ending period after the state. I also thought it would be nice to allow the expression to show the possible option of direction with for example North, South, East or West with an ending period at the end of it. ^[ \\w\\.]{3,}([A-Za-z]\\.)?([ \\w]*\\##\\d+)?(\\r\\n| )[ \\w]{3,},\\x20([A-Z]{2}\\.)\\x20\\d{5}(-\\d{4})?$ Although the code was not altered much, it reflects the changes I find necessary for my needs."
    },
    {
        "Pattern": "^((([1][1-2]|[0][1|3|5|7|8])[-|\\\\|\\/|\\.]([0][1-9]|[1][0-9]|[2][0-9]|[3][0-1])[-|\\\\|\\/|\\.]([1][9][0-9][2|4|8]|[2][0][0][2|4|8]|[2][0][1][2])|[0][2][-|\\\\|\\/|\\.]([0][1-9]|[1][0-9]|[2][0-9])[-|\\\\|\\/|\\.]([1][9][0-9][2|4|8]|[2][0][0][2|4|8]|[2][0][1][2])|([1][1]|[0][4|6|9])[-|\\\\|\\/|\\.]([0][1-9]|[1][0-9]|[2][0-9]|[3][0])[-|\\\\|\\/|\\.]([1][9][0-9][2|4|8]|[2][0][0][2|4|8]|[2][0][1][2]))|(([1][1-2]|[0][1|3|5|7|8])[-|\\\\|\\/|\\.]([0][1-9]|[1][0-9]|[2][0-9]|[3][0-1])[-|\\\\|\\/|\\.]([1][9][0-9][0|1|3|5|6|7|9]|[2][0][0][0|1|3|5|6|7|9]|[2][0][1][0|1|3])|[0][2][-|\\\\|\\/|\\.]([0][1-9]|[1][0-9]|[2][0-9])[-|\\\\|\\/|\\.]([1][9][0-9][0|1|3|5|6|7|9]|[2][0][0][0|1|3|5|6|7|9]|[2][0][1][0|1|3])|([1][1]|[0][4|6|9])[-|\\\\|\\/|\\.]([0][1-9]|[1][0-9]|[2][0-9]|[3][0])[-|\\\\|\\/|\\.]([1][9][0-9][0|1|3|5|6|7|9]|[2][0][0][0|1|3|5|6|7|9]|[2][0][1][0|1|3])))$",
        "MatchingText": "02-29-2012|||02-28-2013|||04-30-1994",
        "NonMatchingText": "00-00-0000|||02-29-2013|||04-31-1994",
        "Description": "Perfect Date Regex. Contains all leap years. And Separators like \"-\",\"\\\",\"/\" and \".\". In the Format MM-DD-YYYY. Date Range from 01-01-1900 to 12-31-2013"
    },
    {
        "Pattern": "^(\\+[1-9][0-9]*(\\([0-9]*\\)|-[0-9]*-))?[0]?[1-9][0-9\\- ]*$",
        "MatchingText": "+123(45)678-910|||+123-045-67 89 10|||01-234-56-78",
        "NonMatchingText": "123(45)678 91011|||(12)345-678|||+0(12)345-6789",
        "Description": "International phone number check - optional country code followed by area code surrounded with '-' or '(' and ')', or just an area code optionally starting with 0, followed by phone numder. The number itself may contain spaces and '-'"
    },
    {
        "Pattern": "[1-9][0-9]{3}[ ]?(([a-rt-zA-RT-Z][a-zA-Z])|([sS][bce-rt-xBCE-RT-X]))",
        "MatchingText": "1234HG|||3454 FG|||1000 AA|||3456 sg",
        "NonMatchingText": "0987 SE|||8767 SD|||6756 ss",
        "Description": "Most RegExpr for dutch zip codes are too simple. For historic reasons, the two-letter combinations SS, SA and SD are not allowed.\nThere should be one space between the numbers and letters, but I allow any number of spaces. Also I allow lowercase. In the early days of dutch zip codes, some letters were not allowed to avoid confusion (F,I,Q, O etc). Nowadays, they are not excluded anymore, because we ran out of letter combinations. \nIt should be easy to make the RegExpr more strict, by prescribing ONE mandatory space and allowing only uppercase."
    },
    {
        "Pattern": "(\\{\\\\f\\d*)\\\\([^;]+;)",
        "MatchingText": "{\\f0\\Some Font names here;|||{\\f1\\fswiss\\fcharset0\\fprq2{\\*\\panose 020b0604020202020204}Arial;|||{\\f",
        "NonMatchingText": "{f0fs20 some text}",
        "Description": "This pattern returns the font section from an RTF document. The first parenthetical subexpression captures the font number, the second returns the actual font enumeration. Lame-o, but fun! :-)"
    },
    {
        "Pattern": "\\d{1,3}.?\\d{0,3}\\s[a-zA-Z]{2,30}\\s[a-zA-Z]{2,15}",
        "MatchingText": "2\\34 Wodonga Ave|||54a Beechworth Rd|||47/675 WODONGA DRIVE",
        "NonMatchingText": "aaa Beechworth Rd|||65       Beechworth Rd|||65 Beechworth/ Rd",
        "Description": "Street Address. While far from perfect it validates street addresses reasonably. Created with absolutely no experience using a cool tool downloaded from http://www.codeproject.com/dotnet/expresso.asp?target=e%20xpresso"
    },
    {
        "Pattern": "^(0?[1-9]|1[0-2])(\\:)([0-5][0-9])(\\:)([0-5][0-9]) (AM|PM)$",
        "MatchingText": "12:13:10 AM, 01:42:59 PM, 1:36:22 PM",
        "NonMatchingText": "13:19:41, 2:52, 3:19 PM",
        "Description": "This regex validates time strings to ensure they're in the format HH:MM:SS. It accepts from 1:00:00-12:59:59"
    },
    {
        "Pattern": "^((0?[2])/(0?[1-9]|[1-2][0-9])|(0?[469]|11)/(0?[1-9]|[1-2][0-9]|30)|(0?[13578]|1[02])/(0?[1-9]|[1-2][0-9]|3[0-1]))/([1][9][0-9]{2}|[2-9][0-9]{3})$",
        "MatchingText": "1/31/2010, 11/04/1941, 04/30/2991",
        "NonMatchingText": "4/31/2003, 13/22/1999, 2/30/2010",
        "Description": "Accepts dates in the format MM/DD/YYYY. Month and day can have preceeding 0 if less than 10, year is 1900-9999 and months accept 30/31 days appropriately. February accepts 29 (leap year not factored in)."
    },
    {
        "Pattern": "^((0?[2])/(0?[1-9]|[1-2][0-9])|(0?[469]|11)/(0?[1-9]|[1-2][0-9]|30)|(0?[13578]|1[02])/(0?[1-9]|[1-2][0-9]|3[0-1]))/([1][9][0-9]{2}|[2-9][0-9]{3}) (00|0?[1-9]|1[0-9]|2[0-3])\\:([0-5][0-9])\\:([0-5][0-9])$",
        "MatchingText": "12/31/2001 10:30:00, 3/19/1988 19:41:25",
        "NonMatchingText": "4/31/2010 09:31:00, 1/30/1999 24:00:00",
        "Description": "This regex accepts date and time values, taking into account 29/30/31 day months. 00 hours (midnight) must have both zeros, but hours 01-09 can leave 0 off, months 1-9 can also leave 0 off."
    },
    {
        "Pattern": "^(00|0?[1-9]|1[0-9]|2[0-3])\\:([0-5][0-9])\\:([0-5][0-9])$",
        "MatchingText": "00:23:41, 12:31:19, 2:29:33",
        "NonMatchingText": "0:19:38, 24:00:00, 02:2:31",
        "Description": "This regex accepts time in 24-hour format (00:00:00 - 23:59:59). Hours 01-09 can leave the 0 off, but 00 has to have both zeros."
    },
    {
        "Pattern": "^[2-9][0-8]\\d[2-9]\\d{6}$",
        "MatchingText": "2223334444,4443332222",
        "NonMatchingText": "1231231234,0251241549",
        "Description": "Matches U.S. and Canadian phone numbers, without punctuation, that follow the NANP numbering scheme."
    },
    {
        "Pattern": "^((\\d{5})|(\\d{5}-\\d{4})|([A-CEGHJ-NPR-TV-Z]\\d[A-CEGHJ-NPR-TV-Z]\\s\\d[A-CEGHJ-NPR-TV-Z]\\d))$",
        "MatchingText": "01234,01234-1234,1A1-A1A",
        "NonMatchingText": "123456,12345-12345,1D1-D1D",
        "Description": "Matches U.S. and Canadian postal codes that follow the proper numbering schemes."
    },
    {
        "Pattern": "^\\{[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}\\}$",
        "MatchingText": "{4CC3A325-9885-48B4-B451-147C2D523646}, {4cc3a325-9885-48b4-b451-147c2d523646}",
        "NonMatchingText": "{44CC3A325-9885-48B4-B451-147C2D523646}, {4CC3A3259885-48B4-B451-147C2D523646}, {4CC3A325-9885-48B4-B451-147C2D523646, {4CC3A325-9885-48B4-B451-147Z2D523646}",
        "Description": "Matches class ids (CLSID) including the pre & post curly brackets."
    },
    {
        "Pattern": "^([A-Z]|[a-z]|[0-9])([A-Z]|[a-z]|[0-9]|([A-Z]|[a-z]|[0-9]|(%|&|'|\\+|\\-|@|_|\\.|\\ )[^%&'\\+\\-@_\\.\\ ]|\\.$|([%&'\\+\\-@_\\.]\\ [^\\ ]|\\ [%&'\\+\\-@_\\.][^%&'\\+\\-@_\\.])))+$",
        "MatchingText": "AccountName_123|||ABC & DEF Inc.|||me@myemail.com",
        "NonMatchingText": "-=superman=-|||$$ Money Man $$|||Lord -- Foo",
        "Description": "This works good for account names where u don't want your users to create ugly account names. 3 rules apllied in it:\n1. an account name must start with Letter or Number\n2. the only valid signs are : ^%&amp;'+-@. and (space (chr32))\n3. a sign can't be repeated by any sign execept space which can't be repeated as well."
    },
    {
        "Pattern": "^([1-9]|0[1-9]|1[0-2]):([0-5][0-9])$",
        "MatchingText": "12:50, 1:00, 01:00",
        "NonMatchingText": "00:59, 13:40, 01:69, 1:00pm",
        "Description": "Simple 12 hour time, no am pm added, no 24 hour clock, 1 or 2 digits for hour. "
    },
    {
        "Pattern": "^(?P<prov>10)(?P<tipo>(AV))?-(?P<tomo>\\d{1,4})-(?P<folio>\\d{1,5})|^(?P<prov>[1-9])(?P<tipo>(AV))?-(?P<tomo>\\d{1,4})-(?P<folio>\\d{1,5})|^(?P<tipo>(E|N|PE))-(?P<tomo>\\d{1,4})-(?P<folio>\\d{1,5})",
        "MatchingText": "PE-233-782, N-233-782, E-233-875, 10AV-4568-12234, 8AV-1234-78456, 4-233-782, 10-233-782",
        "NonMatchingText": "8N-123-456",
        "Description": "The Panamanian \"cedula\" is the equivalent of the USA's Social Security Number or the Dutch SOFI number. It is composed of three groups. The 2nd and 3rd groups are digits only. The first group  typically has a number between 1-10 only. But in some cases it has N (naturalized) or E (foreigner) or PE (panamanian born abroad). And in some ocassions a number followed by AV meaning the person was born before the \"cedula\" system came into existence..\n\nShortcomings of this long regex are: a)any character beyond the 3rd group is not flagged as a non-match"
    },
    {
        "Pattern": "^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)\\d\\d$",
        "MatchingText": "01/02/2015|||5-7-1915|||12.8.2035|||7 15 1963",
        "NonMatchingText": "11-11-1845|||31/12/2000|||10-17-85",
        "Description": "Date in MM/DD/YYYY (USA Format). Allows for 1 or 2 digit month and day. Requires 4 digit year between 1900-2999. Allows for dash, slash, period or space for separators."
    },
    {
        "Pattern": "^([a-zA-Z].*|[1-9].*)\\.(((j|J)(p|P)(g|G))|((g|G)(i|I)(f|F)))$",
        "MatchingText": "filename.jpg|||FileName.JPG|||filename.gif",
        "NonMatchingText": "filename.png|||filename.xxx|||filename.bmp",
        "Description": "Regular expression to limit types of files accepted. This example matches .jpg and .gif files only."
    },
    {
        "Pattern": "\\b(((0[13578]|1[02])[\\/\\.-]?(0[1-9]|[12]\\d|3[01])[\\/\\.-]?(19|20)?(\\d{2}))|(0[13456789]|1[012])[\\/\\.-]?(0[1-9]|[12]\\d|30)[\\/\\.-]?(19|20)?(\\d{2}))|(02[\\/\\.-]?(0[1-9]|1\\d|2[0-8])[\\/\\.-]?(19|20)?(\\d{2}))|(02[\\/\\.-]?29[\\/\\.-]?(19|20)?((0[48]|[2468][048]|[13579][26])|(00)))\\b",
        "MatchingText": "032103|02/29/2008|10.31.1990|010102",
        "NonMatchingText": "2-29-00|11.31.1992|063178|02/29/2005",
        "Description": "I needed to have a way where users could type in any date format like the following:  mm/dd/yyyy, mm/dd/yy, mmddyy, mmddyyyy with the ability to use \"/\" and \".\" and \"-\" or nothing as separation characters.  I use this in a RegularExpression Validator control in ASP.NET"
    },
    {
        "Pattern": "(^\\d{1,3}$)|(\\d{1,3})\\.?(\\d{0,0}[0,5])",
        "MatchingText": "444.5||444||1||2||3||3.5",
        "NonMatchingText": "444.6||444.09||444.999",
        "Description": "This is used to match the values that are multiples of 0.5 upto single digit decimal number."
    },
    {
        "Pattern": "(.|[\\r\\n]){1,5}",
        "MatchingText": "r,rr,rrr,rrrr,rrrrr",
        "NonMatchingText": "rrrrrr",
        "Description": "count the space and new line character also .. pass first parameter for minimun and next for maximum character"
    },
    {
        "Pattern": "^(.|\\r|\\n){1,10}$",
        "MatchingText": "ChandanKum ",
        "NonMatchingText": "ChandanKuma",
        "Description": "This expression can be use to define the maximum length to a textBox.\n\nU can change the maximum character by replacing the last numeric value that is 10 in my example.\nJust change this number to your desired number like\n^(.|\\r|\\n){1,10}$   : for max 10 character \n^(.|\\r|\\n){1,20}$   : for max 20 character \n\n\n"
    },
    {
        "Pattern": "^\\d+(?:\\.\\d{0,2})?$",
        "MatchingText": "100,100.1,100.11",
        "NonMatchingText": "100.123 , 100.1234",
        "Description": "This will validatet the Number for Max Tow decimal place after a number.. it will validate like 12, 12.1, 12.23; but it will invalidate 12.326"
    },
    {
        "Pattern": "^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w].*))+(.pdf)$",
        "MatchingText": "C:\\Documents and Settings\\chandan.kumar\\Desktop\\1004.pdf",
        "NonMatchingText": "C:\\Documents and Settings\\All Users\\Documents\\My Pictures\\Sample Pictures\\Sunset.jpg",
        "Description": "You can use this to check the valid file type you have given to the last in the expression\nlike\n^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w].*))+(.pdf)$\nThis will accept .pdf only\nOR\n^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w].*))+((.pdf)|(.doc))$\nThis will accept .pdf and .doc\nOR\n^(([a-zA-Z]:)|(\\\\{2}\\w+)\\$?)(\\\\(\\w[\\w].*))+((.pdf)|(.doc)|(.txt))$\nThis will accept .pdf , .doc and .txt"
    },
    {
        "Pattern": "^([0-9]*|\\d*\\.\\d{1}?\\d*)$",
        "MatchingText": ".123, 123.1, 1.0",
        "NonMatchingText": "1.1.1; 1.., 0.., .000.1 ",
        "Description": "This Expression will allow to accept the float or decimal values only. We always got stuck to allow only a decimal in the text area at any index along with numbers "
    },
    {
        "Pattern": "/[a-zA-Z]/",
        "MatchingText": "chandan kumar",
        "NonMatchingText": "chandan9",
        "Description": "To accept only charactes only for both the cases i.e the Upper Case and the Lower Case"
    },
    {
        "Pattern": "\\.(?i:)(?:jpg|gif)$",
        "MatchingText": "mypicture.jpg, MYPICTURE.JPG, MYPICTURE.GIF, mypicture.gif ",
        "NonMatchingText": "mypicture.png, mypicture.bmp  ",
        "Description": "This expression will only allow the .jpg and .gif file to get uploaded.\n\nThis handles the case of the file type i.e. it will accept .gif and .GIF both and so on .JPG and .jpg."
    },
    {
        "Pattern": "['`~!@#&$%^&*()-_=+{}|?><,.:;{}\\\"\\\\/\\\\[\\\\]]",
        "MatchingText": "chandan`~Kumar@#Singh&*^",
        "NonMatchingText": "chandan kumar singh",
        "Description": "This Regular Expression Pattern can be used to replace any special character in a string by any other specific character or string.\n--------------------\nCode Example:(in C#)\n--------------------\nstring SourceString = TextBox1.Text;                \nstring rgPattern = \"['`~!@#&$%^&*()-_=+{}|?><,.:;{}\\\"\\\\/\\\\[\\\\]]\";\nRegex objRegEx = new Regex(rgPattern);\n"
    },
    {
        "Pattern": "\\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b",
        "MatchingText": "192.168.10.210",
        "NonMatchingText": "192.168.10.256.21",
        "Description": "To check a valid IP Address. It will check the valid IP address on the logic of three dots max three digits in each section"
    },
    {
        "Pattern": "^\\d*[1-9]\\d*$",
        "MatchingText": "01, 100, 990",
        "NonMatchingText": "0, 00,000",
        "Description": "For a WHOLE number in a text box greater than ZERO. Can start with a Zero, contain Zero in between and end with zero"
    },
    {
        "Pattern": "([Cc][Hh][Aa][Nn][Dd][Aa][Nn].*?)",
        "MatchingText": "Chandan Kumar, Kumar Chandan, Kumar Chandan Singh",
        "NonMatchingText": "Chanda Kumar, Kumar Chand",
        "Description": "To find a match pattern in a string not matter where the position of the pattern in the string and even no matter what is the suffix and what will be the prefix."
    },
    {
        "Pattern": "^[-]?([1-9]{1}[0-9]{0,}(\\.[0-9]{0,2})?|0(\\.[0-9]{0,2})?|\\.[0-9]{1,2})$",
        "MatchingText": "123|||123.54|||-.54",
        "NonMatchingText": "123.543|||0012|||1,000.12",
        "Description": "This regular expression will match on a real / decimal / floating point / numeric string with no more than 2 digits past the decimal.  The negative sign (-) is allowed.  No leading zeroes or commas.  It is based on a currency regular expression by Tom Persing."
    },
    {
        "Pattern": "^(0)$|^([1-9][0-9]*)$",
        "MatchingText": "12|||0|||1200",
        "NonMatchingText": "-12|||0012",
        "Description": "This regular expression matches on postive whole numbers and 0.  Whole numbers that are left padded with 0's are not a match."
    },
    {
        "Pattern": "^[-|\\+]?[0-9]{1,3}(\\,[0-9]{3})*$|^[-|\\+]?[0-9]+$",
        "MatchingText": "1,234|1234|-1,234|-1234",
        "NonMatchingText": "12,34|1.234|abc",
        "Description": "Integer with or without commas.  Signed or unsigned."
    },
    {
        "Pattern": "^(((\\+?64\\s*[-\\.]?[3-9]|\\(?0[3-9]\\)?)\\s*[-\\.]?\\d{3}\\s*[-\\.]?\\d{4})|((\\+?64\\s*[-\\.\\(]?2\\d{1}[-\\.\\)]?|\\(?02\\d{1}\\)?)\\s*[-\\.]?\\d{3}\\s*[-\\.]?\\d{3,5})|((\\+?64\\s*[-\\.]?[-\\.\\(]?800[-\\.\\)]?|[-\\.\\(]?0800[-\\.\\)]?)\\s*[-\\.]?\\d{3}\\s*[-\\.]?(\\d{2}|\\d{5})))$",
        "MatchingText": "6402123456|||+64.800.12345678|||(03) 123 4567|||021123456|||027-123-456|||+64-027-123-123",
        "NonMatchingText": "02.123.4567|||+64031234567|||64.024.123.4567|||800.123456",
        "Description": "This phone pattern matches all New Zealand phone numbers with formatting and returns a single formatted string as the first return in the array. Does not take into account all specific exclusions, though, in case of changes (like 025 to 027 in 2007). Based off of  CGRdevelopment's New Zealand regex."
    },
    {
        "Pattern": "^(0[1-9]|1[0-9]|2[0-9]|3[01])\\/([2-9]|1[0-2]?)\\/(([1]{1}[9]{1}[9]{1}\\d{1})|([2-9]{1}\\d{3}))$",
        "MatchingText": "01/02/2000, 31/12/9999",
        "NonMatchingText": "1/12/1990, 01/1/1990. 01/01/1989",
        "Description": "UK Date dd/MM/YYYY from 1990 - 9999 with leading 0s.\nUpdated from other methods"
    },
    {
        "Pattern": "(^(p[\\s|\\.|,]*|\n^post[\\s|\\.]*)(o[\\s|\\.|,]*|\noffice[\\s|\\.]*))|\n(^box[.|\\s]*\\d+)",
        "MatchingText": "PO Box|||p.o. box|||box 123",
        "NonMatchingText": "123 Some Street",
        "Description": "This expression filters all variations of Post Office Box or PO Box."
    },
    {
        "Pattern": "^[_a-zA-Z0-9-]+(\\.[_a-zA-Z0-9-]+)*@(co.uk)[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*\\.(([0-9]{1,3})|([a-zA-Z]{2,3})|(aero|coop|info|museum|name))$",
        "MatchingText": "steve.b@abc.co.uk, steve.b@abc.com, steve.b@times.org",
        "NonMatchingText": "steve.b@com, steve.b@@abc.co.uk, steve.b@co.uk",
        "Description": "This regex enable the user to enter all valid email addresses apart from when the user input 'co.uk' immediately after the '@' without stating a domain before it (e.g. 'freeserve.co.uk')"
    },
    {
        "Pattern": "^[a-zA-Z0-9_.-@$]*$",
        "MatchingText": "gcccbb@ghg$",
        "NonMatchingText": "bb#Dntn^b,m",
        "Description": "User name which will allow _ . @$And -"
    },
    {
        "Pattern": "^(\\+27|27)?(\\()?0?[87][23467](\\))?( |-|\\.|_)?(\\d{3})( |-|\\.|_)?(\\d{4})",
        "MatchingText": "(085)465-2627 +27(74)876_3212 27845678124",
        "NonMatchingText": "(172)896-3782 +34(43)857_5783 01245678124",
        "Description": "Allows most formats for entering valid South African mobile / cellular phone numbers."
    },
    {
        "Pattern": "^[a-z0-9][a-z0-9_\\.-]{0,}[a-z0-9]@[a-z0-9][a-z0-9_\\.-]{0,}[a-z0-9][\\.][a-z0-9]{2,4}$",
        "MatchingText": "az@er.tr|||a_zer-ty@az.er.ty|||123-456_789.0@1.2.3iuyt.azer",
        "NonMatchingText": "a@a.a|||a.@_1.com|||azerty_@domain-com",
        "Description": "for validate a email, but with this regex it 's possible : a._-z@a_.....____---.com"
    },
    {
        "Pattern": "((mailto\\:|(news|(ht|f)tp(s?))\\://){1}\\S+)",
        "MatchingText": "http://www.aspemporium.com|||mailto:dominionx@hotmail.com|||ftp://ftp.test.com",
        "NonMatchingText": "www.aspemporium.com|||dominionx@hotmail.com|||bloggs",
        "Description": "Regular Expression matches any internet URLs. Used with the replace method it comes in very handy."
    },
    {
        "Pattern": "^(\\d{4}-((0[1-9]|1[012])-(0[1-9]|1\\d|2[0-8])|(0[13456789]|1[012])-(29|30)|(0[13578]|1[02])-31)|(\\d{2}[02468][048]|[13579][26])-02-29) (0[0-9]|1[0-9]|2[0-4]):(60|[0-5][0-9]):(60|[0-5][0-9])$",
        "MatchingText": "2014-08-07 16:52:14 ||| 2004-02-29 00:00:59 ||| 1800-01-01 23:31:59",
        "NonMatchingText": "2014-08-07 25:52:14 ||| 2004-02-30 00:00:59 ||| 1800-30-01 23:31:59",
        "Description": "This pattern allows for full DateTime entry using yyyy-MM-dd hh:mm:ss format."
    },
    {
        "Pattern": "^((100)|(\\d{0,2}))$",
        "MatchingText": "100|||0|||99",
        "NonMatchingText": "101|||1x|||-1",
        "Description": "Matches any positive integer (and blank) between 1 and 100 useful for validating input of a percentage, or nothing."
    },
    {
        "Pattern": "&lt;a\\s*.*?href\\s*=\\s*['&quot;](http:\\/\\/).*?&gt;(.*?)&lt;\\/a&gt;",
        "MatchingText": "&lt;a href='locallink.htm'&gt;my local link&lt;/a&gt;|||&lt;a title='click here' href=&quot;/a/local",
        "NonMatchingText": "&lt;a href='http://www.site.com/page.htm'&gt;www.site.com&lt;/a&gt;|||&lt;a href='http://www.site.co",
        "Description": "Finds all local links, but doesnt match on external links. \nUse replace with $1 to leave the link text but remove the link."
    },
    {
        "Pattern": "(^0?[1-9]|^1[0-2])\\/(0?[1-9]|[1-2][0-9]|3[0-1])\\/(19|20)?[0-9][0-9](\\s(((0?[0-9]|1[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?)|((0?[0-9]|1[0-2]):[0-5][0-9](:[0-5][0-9])?\\s(AM|PM))))?$",
        "MatchingText": "01/28/08 22:34:12 | 10/23/1952 5:23:01 PM | 6/2/02 22:59 | 5/13/04",
        "NonMatchingText": "1/32/08 | 12/29/005 | 6/14/05 23:00:02 PM | 10/2/02 13:00 AM",
        "Description": "Expression to validate a date with or without time in standard or 24 hour format with optional milliseconds (01/12/08 23:31:05 or 5/12/1974 11:59 PM)."
    },
    {
        "Pattern": "(?:(?:(?P<Feet>\\d+)[ ]*\\'){0,1}[ ]*(?P<WholeInches>\\d*([/\\w])){0,1}(?:[ ,\\-]){0,1}(?P<Fraction>\\d*\\/\\d*){0,1}(?P<Decimal>\\.\\d*){0,1}\\\")|(?:(?P<Feet>\\d+)[ ]*\\'[ ]*){1}",
        "MatchingText": "1/4\" x 2.125\" Flat 44W x 20'3.5\"|||1/8\" x 4\" C-1018 flat x 14' 5-1/4\"",
        "NonMatchingText": "44W|||8 @ 21 W.F. beam|||1/4 x 2.125 Flat 44W x 20",
        "Description": "I needed an expression to extract measurements from text to extract steel sizes from product descriptions, and I came up with this.  It will only match on measurements that have complete dimensions (i.e. measurements with foot and inch marks in the positions you'd expect them).  My personal experience required that I also be a little lax and allow measurements such as: .125 (for wall thicknesses and sheet metal thicknesses) with no inch marks.  You can accomplish this by including:\n|(?&lt;Decimal&gt;\\.\\d{3}\\&quot;*)\nto the end of the expression\n\nHope it helps you."
    },
    {
        "Pattern": "\"^[A-Z]{1}\\d{7}$",
        "MatchingText": "N1234567|||A1234567|||C1234567",
        "NonMatchingText": "123A4567|||1234567A|||AAA12345",
        "Description": "Matches California Drivers License Numbers. A Letter followed by 7 Numbers. I have not been able to find a site that shows only the number/letters CA uses, so this will have to do for now."
    },
    {
        "Pattern": "^\\d{1,6}\\040([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^\\d{1,6}\\040([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^\\d{1,6}\\040([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$",
        "MatchingText": "123456 My Street|||123 West Main St|||12345 Via De La Rosa",
        "NonMatchingText": "123 Street|||1234 W Side Street",
        "Description": "This will accept any 6 digit street address only, with min of two and up to four street names."
    },
    {
        "Pattern": "\\(714|760|949|619|909|951|818|310|323|213|323|562|626\\)\\040\\d{3}-\\d{4}",
        "MatchingText": "(714) 123-4567|||(949) 555-5555|||(323) 467-1070",
        "NonMatchingText": "(808) 666-6666|||(111)123-4567|||Any Non SoCal Area Code",
        "Description": "Phone Numbers Format (###) ###-#### with only SoCal Area Codes. Use or replace with Area Codes You need."
    },
    {
        "Pattern": "714|760|949|619|909|951|818|310|323|213|323|562|626-\\d{3}-\\d{4}",
        "MatchingText": "714-333-3333|||818-222-2222|||323-333-3333",
        "NonMatchingText": "808-123-4567|||(808) 123-4567|||Any Non So Cal Area Code",
        "Description": "Phone Number in ###-###-#### Format Only with Southern California Area Codes. Use or Replace Area Codes"
    },
    {
        "Pattern": "[a-z0-9]+([-+._][a-z0-9]+){0,2}@.*?(\\.(a(?:[cdefgilmnoqrstuwxz]|ero|(?:rp|si)a)|b(?:[abdefghijmnorstvwyz]iz)|c(?:[acdfghiklmnoruvxyz]|at|o(?:m|op))|d[ejkmoz]|e(?:[ceghrstu]|du)|f[ijkmor]|g(?:[abdefghilmnpqrstuwy]|ov)|h[kmnrtu]|i(?:[delmnoqrst]|n(?:fo|t))|j(?:[emop]|obs)|k[eghimnprwyz]|l[abcikrstuvy]|m(?:[acdeghklmnopqrstuvwxyz]|il|obi|useum)|n(?:[acefgilopruz]|ame|et)|o(?:m|rg)|p(?:[aefghklmnrstwy]|ro)|qa|r[eosuw]|s[abcdeghijklmnortuvyz]|t(?:[cdfghjklmnoprtvwz]|(?:rav)?el)|u[agkmsyz]|v[aceginu]|w[fs]|y[etu]|z[amw])\\b){1,2}",
        "MatchingText": "bob.wintson@hotmail.com bob.wintson@middlesex.lenovix.com bob.c.wintson@mysite.middlesex.hotmail.com bob_c_wintson@mysite.middlesex.hotmail.com",
        "NonMatchingText": "bob_d_c_wintson@mysite.middlesex.hotmail.com bob_c_wintson@mysite.middlesex.hotmail.cop",
        "Description": "SUMMARY: Very selective email address Regex\nUSE: intended for finding emails in text.\nDETAILS: regex is terminated by a match for all possible Top-Level-Domains, so regex can even differentiate the terminating end of the email string from other text (including letters) "
    },
    {
        "Pattern": "^[0-9A-Za-z_ ]+(.[jJ][pP][gG]|.[gG][iI][fF])$",
        "MatchingText": "good.gif|||go d.GIf|||goo_d.jPg",
        "NonMatchingText": "junk|||bad.bad.gif|||slash\\gif.",
        "Description": "Matches HTML image leaf filenames."
    },
    {
        "Pattern": "^\\$?\\d+(\\.(\\d{2}))?$",
        "MatchingText": "$2.43|||2.02|||$2112",
        "NonMatchingText": "2.1|||$.14|||$2,222.12",
        "Description": "To evaluate an amount with or without a dollar sign where the cents are optional.\n"
    },
    {
        "Pattern": "&lt;script[\\s\\S]*?&lt;/script([\\s\\S]*?)&gt;",
        "MatchingText": "&lt;script language=&quot;Javascript&quot;&gt;&lt;!-- alert(); --&gt;&lt;/script&gt;",
        "NonMatchingText": "&lt;script&gt;",
        "Description": "This pattern is intended to remove all javascript blocks from a chunk of code.  EDIT: a bug is cutting off additional matches."
    },
    {
        "Pattern": "^(\\+|-)?(\\d\\.\\d{1,6}|[1-8]\\d\\.\\d{1,6}|90\\.0{1,6})$",
        "MatchingText": "12.345678 -90.000000 0.345 +32.9",
        "NonMatchingText": "62 90.1 -90.000001 13.1234567 04.123",
        "Description": "Matches decimal latitude notation (like that used by Google maps)  Matches -90.000000 through +90.000000 with maximum of 6 decimal places, minimum of 1 decimal place."
    },
    {
        "Pattern": "^(\\+|-)?(\\d\\.\\d{1,6}|[1-9]\\d\\.\\d{1,6}|1[1-7]\\d\\.\\d{1,6}|180\\.0{1,6})$",
        "MatchingText": "180.0 -180.000000 +0.123 -34.675421",
        "NonMatchingText": "09.123 181.345678 -190.000000",
        "Description": "Matches decimal longitude format like that returned by Google maps.  Matches from -180.000000 to +180.000000 with between one and six decimal places."
    },
    {
        "Pattern": "^[A-Z0-9]{8}-[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{12}$",
        "MatchingText": "4D28C5AD-6482-41CD-B84E-4573F384BB5C|||B1E1282C-A35C-4D5A-BF8B-7A3A51D9E388|||91036A4A-A0F4-43F0-8CD",
        "NonMatchingText": "{B1E1282C-A35C-4D3A-BF8B-7A3A51D9E388}|||AAAAAAAAAAAAAAAAA|||B;E1282C-A35C-4D3A-BF8B-7A3A51D9E38",
        "Description": "GUID Tester. It tests SQL Server GUIDs, which are alphanumeric characters grouped 8-4-4-4-12 (with the dashes). Make sure they don't have the brackets around them before you check them and have fun!"
    },
    {
        "Pattern": "(219( |\\.|\\-|)??09( |\\.|\\-|)??9999|078( |\\.|\\-|)??05( |\\.|\\-|)??1120)(666|000|9\\d{2})\\d{3}( |\\.|\\-|)??(00)\\d{2}( |\\.|\\-|)??(0{4})\\d{4}",
        "MatchingText": "001-23-1123|||377.42.1423|||389551234|||389 55.1234",
        "NonMatchingText": "078051120|||900 20 2211|||389.00.4411",
        "Description": "Advanced SSN regular expression.  Matches 9 digits separated by mixed spaces, hyphens, or periods.  Excludes:\n- Values containing all 0's in any group\n- Values beginning with 900-999\n- 078-05-1120 (Woolworth's Wallet)\n- Values beginning with 666\n\nGuidelines can be seen at: https://www.ssa.gov/kc/SSAFactSheet--IssuingSSNs.pdf"
    },
    {
        "Pattern": "^v=spf1[ \\t]+[+?~-]?(?:(?:all)|(?:ip4(?:[:][0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})?(?:/[0-9]{1,2})?)|(?:ip6(?:[:]([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})?(?:/[0-9]{1,2})?)|(?:a(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+)?(?:/[0-9]{1,2})?)|(?:mx(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+)?(?:/[0-9]{1,2})?)|(?:ptr(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+))|(?:exists(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+))|(?:include(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+))|(?:redirect(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+))|(?:exp(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+))|)(?:(?:[ \\t]+[+?~-]?(?:(?:all)|(?:ip4(?:[:][0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})?(?:/[0-9]{1,2})?)|(?:ip6(?:[:]([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})?(?:/[0-9]{1,2})?)|(?:a(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+)?(?:/[0-9]{1,2})?)|(?:mx(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+)?(?:/[0-9]{1,2})?)|(?:ptr(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+))|(?:exists(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+))|(?:include(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+))|(?:redirect(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+))|(?:exp(?:[:][A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?:\\.[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?)+))|))*)?$",
        "MatchingText": "v=spf1 +a +mx -all|||v=spf1 +a +mx +ip4:192.168.0.0/24 +ptr:mydomain.com -all|||v=spf1 include:spf.alternative.com",
        "NonMatchingText": "v=spf1|||v=spf2 -all|||v=spf1 *all",
        "Description": "I use \"preg_match\" function on PHP with this expression.\nDetects a valid SPF expression.\n\nWarnings:\nip6 register only works in \"no compressed\" form.\n\n\"trim\" the string before use the expression (or add [ \\t]+ after ^ and before $)"
    },
    {
        "Pattern": "(((\\+44)? ?(\\(0\\))? ?)|(0))( ?[0-9]{3,4}){3}",
        "MatchingText": "+44 (0) 1234 567890 or +44 1234 567890 or 01234 567890 or 0123 456 7890",
        "NonMatchingText": "Numbers not beginning with 0 or +44 and numbers with less than 9 digits",
        "Description": "This regex matches UK phone numbers in multiple formats, including those that begin with the international dial code and optionally bracket the leading zero of the area code. To match a number must begin with either +44 or 0 and have 9-12 following digits."
    },
    {
        "Pattern": "&lt;asp:requiredfieldvalidator(\\s*\\w+\\s*=\\s*\\&quot;?\\s*\\w+\\s*\\&quot;?\\s*)+\\s*&gt;\\s*&lt;\\/asp:requiredfieldvalidator&gt;",
        "MatchingText": "&lt;asp:requiredfieldvalidator id=rfvtReg runat=&quot;server&quot; CssClass=&quot;rlt&quot; ErrorMes",
        "NonMatchingText": "&lt;asp:requiredfieldvalidator id=rfvtNewUserReg runat=&quot;server&quot; CssClass=&quot;copyright&a",
        "Description": "ASP.NET required field validator control."
    },
    {
        "Pattern": "\\b((([&quot;'/,&amp;%\\:\\(\\)\\$\\+\\-\\*\\w\\000-\\032])|(-*\\d+\\.\\d+[%]*))+[\\s]+)+\\b[\\w&quot;',%\\(\\)]+[.!?](['&quot;\\s]|$)",
        "MatchingText": "This is an example.|||&quot;Matching sentence.&quot;|||A 9.7% increase over the last 10+ years.|||The vehicle has a 5.2 liter, four-wheel drive engine.",
        "NonMatchingText": "Class.Function",
        "Description": "Focused on scraping English sentences from HTML/Java (without having to parse).\n\nCorrectly matches the vast majority of English sentences. There are undoubtedly a number of cases which do not match, but I felt they were oblique enough to be omitted.\n\n(Surely, the fellow that commented on this script had some sentences not match, but the example he describes does correctly match, and I provide it as the fourth example.) \n\nCheers"
    },
    {
        "Pattern": "^([\\(]{1}[0-9]{3}[\\)]{1}[ |\\-]{0,1}|^[0-9]{3}[\\-| ])?[0-9]{3}(\\-| ){1}[0-9]{4}$",
        "MatchingText": "(111) 223-2332|||(222)233-2332|||232-323-3233",
        "NonMatchingText": "(ddd) 223-2332|||222-232/2333|||322-3223-222",
        "Description": "Validates US phone numbers. Phone number can be delimited with dashes or spaces. Area code can optionally include parentheses. To optionally validate area codes, try this expression.\n\n^([\\(]{1}[0-9]{3}[\\)]{1}[ |\\-]{0,1}|^[0-9]{3}[\\-| ])?[0-9]{3}(\\-| ){1}[0-9]{4}$"
    },
    {
        "Pattern": "^(((0?[1-9]|1\\d|2[0-8])|(0?[13456789]|1[012])/(29|30)|(0?[13578]|1[02])/31)/(0?[1-9]|1[012])/(19|[2-9]\\d)\\d{2}|0?29/0?2/((19|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|(([2468][048]|[3579][26])00)))$",
        "MatchingText": "21/01/1972|||21/1/1972|||1/1/1972|||29/2/2012|||29/02/2012",
        "NonMatchingText": "21-01-1972|||21-01-1972|||29/02/2011",
        "Description": "DD/MM/YYYY with leap year detection as most of the date regex are in MM/DD/YYYY format. Allows MM and DD to be 1 or 2 digits, eg. D/M/YYYY, D/MM/YYYY or DD/M/YYYY"
    },
    {
        "Pattern": "^([1-9][0-9]?|100)%$",
        "MatchingText": "1% | 52% | 100%",
        "NonMatchingText": "0% | 100  | 101% | 52 | 52.4%  ",
        "Description": "Matches a percentage between 1 and 100. Accepts up to 2 decimal places. No decimal places accepted."
    },
    {
        "Pattern": "^([\\(]{1}[0-9]{3}[\\)]{1}[\\.| |\\-]{0,1}|^[0-9]{3}[\\.|\\-| ]?)?[0-9]{3}(\\.|\\-| )?[0-9]{4}$",
        "MatchingText": "5551212|||614555-1212|||(614)555-1212",
        "NonMatchingText": "A12-5555|||(614-555-1212|||555*1212",
        "Description": "More permissive than others on the site, this one allows you to let a user enter US phone numbers in the way they most commonly use, without letting them enter non-valid combinations."
    },
    {
        "Pattern": "^(http|https|ftp|ftps)\\://([a-zA-Z0-9\\-]+)(\\.[a-zA-Z0-9\\-]+)*(\\.[a-zA-Z]{2,3})(:[0-9]*)?(/[a-zA-Z0-9_\\-]*)*(\\.?[a-zA-Z0-9#]{1,10})?([\\?][a-zA-Z0-9\\-\\._\\,\\'\\+&amp;%\\$#\\=~]*)?$",
        "MatchingText": "http://example.com   https://www.example.com:8080/path/path/   http://www.example.com/path/page.html?p1=param1&p2=param2",
        "NonMatchingText": "example.com   http://example.c   http://example.com/page.",
        "Description": "Matches basic URL strings with optional query string.\n\nRemarks: to use this expression in JavaScript you should do the following:\n1) when using RegExp(\"pattern\") object you should escape all '\\' instances, because they appear in double quotes.\n2) when using /pattern/flags syntax, you should escape all '/' instances, because this character indicates an end of an expression."
    },
    {
        "Pattern": "^(0?[1-9]|1[012])$",
        "MatchingText": "05|||5|||12",
        "NonMatchingText": "0|||1a|||13",
        "Description": "This will match numbers between 0 and 12.  The 0? at the beginning will allow &quot;01&quot; as a valid match.  This is useful for validation the month only component of a date part."
    },
    {
        "Pattern": "^([12]?[0-9]|3[01])$",
        "MatchingText": "1|||20|||31",
        "NonMatchingText": "1a|||32|||01",
        "Description": "This will match numbers in the range 1-31.  This is useful for matching the day component of a datetime part."
    },
    {
        "Pattern": "^((18[5-9][0-9])|((19|20)[0-9]{2})|(2100))$",
        "MatchingText": "1850|||1977|||2100",
        "NonMatchingText": "1800|||a|||2101",
        "Description": "Will check to ensure the data is between 1850 and 2100."
    },
    {
        "Pattern": "(([\\n,  ])*((<+)([^<>]+)(>*))+([\\n,  ])*)+",
        "MatchingText": "<a id = al> ||| <blahblah> ||| <<div>something>",
        "NonMatchingText": "9>3 ||| normaltext ||| <<<<<<<<",
        "Description": "finds all HTML tags (<___>) in text and leaves normal text alone. Also matches all extra spaces and empty lines next to html tag, if any.Ragex has extra parentheses for orientation.\nUsefull to delete all unwanted html from, lets say, wikipedia souce code."
    },
    {
        "Pattern": "^((29\\/0?2\\/[0-9]{0,2}(04|08|92|96|([1|3|5|7][2|6])|[2|4|6|8][0|4|8]))|(((28|[12][0-7]|0?[1-9])\\/0?2)|((30|[12][0-9]|0?[1-9])\\/(0?(4|6|9)|11))|((31|[12][0-9]|0?[1-9])\\/(0?(1|3|5|7|8))|(10|12)))\\/(\\d{2}|\\d{4}))$",
        "MatchingText": "31/01/2012 | 30/4/2012 | 10/01/12 | 29/2/2012",
        "NonMatchingText": "31/01/013 | 31/4/2013 | 29/2/2002 | 29/2/2000",
        "Description": "Datas com os anos bissextos. Anos de 2 ou 4 digitos \nDates with leap years. Years 2 or 4 digits"
    },
    {
        "Pattern": "^(\\(\\d{2}\\)?\\s?|\\d{2}(\\-|\\s))?\\d{2,4}(\\-|\\s)?\\d{4,5}$",
        "MatchingText": "(11) 9876-5432 | (11)9876-5432 | (11) 9876-54321 | 11-9876-54321 |  11 9876-5432 | 11 987654321 |  98765432 | 9876-5432",
        "NonMatchingText": "(11) | (11-9876-5432 | (11) 9876 | 1198765432",
        "Description": "N\u00FAmero de telefones Brasileiros inclusive celular de S\u00E3o Paulo"
    },
    {
        "Pattern": "Last.*?(\\d+.?\\d*)",
        "MatchingText": "&lt;TR&gt;&lt;TD ALIGN=RIGHT&gt;&amp;nbsp;&lt;/TD&gt;&lt;TD&gt;Last&lt;/TD&gt;&lt;TD ALIGN=RIGHT NOW",
        "NonMatchingText": "[AADDSS]",
        "Description": "Plucks the last quote of a Stock from the MSN MoneyCentral WebQuote page for any given stock symbol. The URL of the web page where this RegEx should be applied is:\nhttp://localhost/asp/webquote.htm?ipage=qd&amp;Symbol=,give the stock symbol here&gt; You must also use the singleline option."
    },
    {
        "Pattern": "^(GIR ?0AA|(?:[A-PR-UWYZ](?:\\d|\\d{2}|[A-HK-Y]\\d|[A-HK-Y]\\d\\d|\\d[A-HJKSTUW]|[A-HK-Y]\\d[ABEHMNPRV-Y])) ?\\d[ABD-HJLNP-UW-Z]{2})$",
        "MatchingText": "M1 1AA|||M60 1NW|||CR2 6XH|||DN55 1PT|||W1A 1HQ|||\tEC1A 1BB|||GIR 0AA",
        "NonMatchingText": "Q1 1AA|||M60 1CW|||5R2 6XH|||DJ55 1PT|||W1M 1HQ|||EC1D 1BB|||GIR 1AA",
        "Description": "This regex matches all valid, current UK Postcodes, including Girobank and non-geographic postcodes, irrespective of whether they contain a space.  It does not include overseas territories.\n\nAdapted from the BS7666 postcode rules at: http://www.cabinetoffice.gov.uk/govtalk/schemasstandards/e-gif/datastandards/address/postcode.aspx"
    },
    {
        "Pattern": "^([0-9]{2})(00[1-9]|0[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-6])$",
        "MatchingText": "99366|||00001",
        "NonMatchingText": "74000|||04367",
        "Description": "Matches a Julian date in the format YYDDD.  Two digit year followed by a number from 1 - 366 indicating the day of the year."
    },
    {
        "Pattern": "^([0-1]?\\d|2[0-3])([:]?[0-5]\\d)?([:]?|[0-5]\\d)?\\s?(A|AM|P|p|a|PM|am|pm|pM|aM|Am|Pm)?$",
        "MatchingText": "1100 , 1100P,11:30A,11:30,11,11A,11:30AM",
        "NonMatchingText": "11@,abc",
        "Description": "Its a very flexible time entry regular expression. It can accept all valid combination of time entry"
    },
    {
        "Pattern": "^(\\d{5}((|-)-\\d{4})?)|([A-Za-z]\\d[A-Za-z][\\s\\.\\-]?(|-)\\d[A-Za-z]\\d)|[A-Za-z]{1,2}\\d{1,2}[A-Za-z]? \\d[A-Za-z]{2}$",
        "MatchingText": "N9B.1Y8|||90210-1234|||NE21 6EQ",
        "NonMatchingText": "NN8 Y83",
        "Description": "Allows Canadian, American and UK postal/zip codes. Allowing hyphens, periods, or spaces to separate."
    },
    {
        "Pattern": "^((unit|u|)\\s*)?(?P<unit>\\d*\\w?)?(\\s+|/)?(?P<streetNo>\\d+(\\-\\d+)?)\\s+(?P<streetName>\\w+)\\s+(?P<streetType>\\w+)\\s+(?P<suburb>\\w+(\\s+\\w+)?)\\s+(?P<state>\\w+)\\s+(?P<postcode>\\d{4})$",
        "MatchingText": "unit 10/11-15 Miller St North Sydney  NSW 2068",
        "NonMatchingText": "11-15 Somewhere Ave Suburb NSW 2068",
        "Description": "It is not very strong and I am still working on that. Would like to put it up so that people can help to complete it.\nThe problem is with addresses that do not have unit number, it picks the first digit of the street number as the unit number."
    },
    {
        "Pattern": "^([2-9])(\\d{2})(-?|\\040?)(\\d{4})( ?|\\040?)(\\d{1,4}?|\\040?)$",
        "MatchingText": "263-8854|||5660578 1235|||622-4588 21",
        "NonMatchingText": "1227585|||4224586 50124|||0554499",
        "Description": "A regular expression that validates the any format of fixed telephone numbers inside Lima - Peru, including an optional extension of at least one number up to four numbers."
    },
    {
        "Pattern": "^([8-9])([1-9])(\\d{2})(-?|\\040?)(\\d{4})$",
        "MatchingText": "8874-2544|||99106800|||84509955",
        "NonMatchingText": "6540-9985|||77329390|||725-2763",
        "Description": "A regular expression that validates the any of the new formats of cellular phones numbers in Peru, allows an optional dash in the middle of the number."
    },
    {
        "Pattern": "^([A-Za-z]{6}[0-9lmnpqrstuvLMNPQRSTUV]{2}[abcdehlmprstABCDEHLMPRST]{1}[0-9lmnpqrstuvLMNPQRSTUV]{2}[A-Za-z]{1}[0-9lmnpqrstuvLMNPQRSTUV]{3}[A-Za-z]{1})|([0-9]{11})$",
        "MatchingText": "VRDGPP13R10B293P|||VRDGPP13R10B29PP|||12345678901",
        "NonMatchingText": "VRDGPP13R10B293|||VRDGPP13R10B29BP|||1234567890",
        "Description": "Pattern to verify Codice Fiscale Italiano (TIN, Tax Identification Number). \nInclude verification of Codice Fiscale to natural, artificial, legal and juristic person, with and without OMOCODIA (verifica del codice fiscale per persone fisiche e persone giuridiche, anche in caso di omocodia). \nCodice Fiscale, CF, omocodia, persone fisiche, persone giuridiche, italian fiscal code, TIN, Tax Identification Number."
    },
    {
        "Pattern": "^[0-9a-zA-Z]+([0-9a-zA-Z]*[-._+])*[0-9a-zA-Z]+@[0-9a-zA-Z]+([-.][0-9a-zA-Z]+)*([0-9a-zA-Z]*[.])[a-zA-Z]{2,6}$",
        "MatchingText": "john-smith@example.com|||john.smith@example.com|||john_smith@x-ample.com",
        "NonMatchingText": ".john-smith@example.com|||@example.com|||johnsmith@example.",
        "Description": "Pattern to verify email addresses. Take a look at match / not match. It works very well. E-mail, email, mail, e-mail address, email address, mail address."
    },
    {
        "Pattern": "(?P<Year>(?:\\d{4}|\\d{2}))-(?P<Month>\\d{1,2})-(?P<Day>\\d{1,2})",
        "MatchingText": "2007-02-23 ",
        "NonMatchingText": "2007/02/23 ",
        "Description": "match the date pattren start with year and seprated by (-)."
    },
    {
        "Pattern": "(\\+?237)?(23|6[6578])\\d{7}",
        "MatchingText": "+237654020651 | 237233459485 | 699710947",
        "NonMatchingText": "67645345 | 6764534545 | 6764534545s",
        "Description": "Will match the phone numbers according to the phone number patterns of the various networks in Cameroon (i.e Camtel, MTN, Orange, NextTel)"
    },
    {
        "Pattern": "^(\\d{1,2})(\\s?(H|h)?)(:([0-5]\\d))?$",
        "MatchingText": "1h|||1:45|||45",
        "NonMatchingText": "1a|||145|||1:99",
        "Description": "Validates hours and minutes. Allows for entry in the form of hours:minutes with optional minutes and optional hours indicator (H or h)."
    },
    {
        "Pattern": "[^a-zA-Z0-9]+",
        "MatchingText": "!@#$%^&*()_+",
        "NonMatchingText": "WORD word 123456778",
        "Description": "This RE will identify all the special characters(non alpha/numeric)."
    },
    {
        "Pattern": "([A-Z]|[a-z])|\\/|\\?|\\-|\\+|\\=|\\&|\\%|\\$|\\#|\\@|\\!|\\||\\\\|\\}|\\]|\\[|\\{|\\;|\\:|\\'|\\\"|\\,|\\.|\\>|\\<|\\*|([0-9])|\\(|\\)|\\s",
        "MatchingText": "a to z, A to Z, all numerics and special characters",
        "NonMatchingText": "\u00C3\u20AC\u00E1\u0161\u00F3 etc..",
        "Description": "This regex will eliminate all diacritics characters. To make it clear, if this is embedded in a javascript or any other coding it will not accept diacritics"
    },
    {
        "Pattern": "(\\<(.*?)\\>)(.*?)(\\<\\/(.*?)\\>)",
        "MatchingText": "<td>city</td> <head>ok</head>",
        "NonMatchingText": "content without tags",
        "Description": "This will identify all the characters in between html tags irrespective of the length of the character or intiger. If scenario emerges to extract content between tags a replacement string  can be used: $3 "
    },
    {
        "Pattern": "\\b ?(a|A)ppoint(s|ing|ment(s)?|ed)?| ?(J|j)oin(s|ed|ing)| ?(R)?recruit(s|ed|ing(s)?)?| (H|h)(is|er)(on)? dut(y|ies)?| ?(R)?replace(s|d|ment)?| (H)?hire(s|d)?| ?(P|p)romot(ed|es|e|ing)?| ?(D|d)esignate(s|d)| (N)?names(d)?| (his|her)? (P|p)osition(ed|s)?| re(-)?join(ed|s)|(M|m)anagement Changes|(E|e)xecutive (C|c)hanges| reassumes position| has appointed| appointment of| was promoted to| has announced changes to| will be headed| will succeed| has succeeded| to name| has named| was promoted to| has hired| bec(a|o)me(s)?| (to|will) become| reassumes position| has been elevated| assumes the additional (role|responsibilit(ies|y))| has been elected| transferred| has been given the additional| in a short while| stepp(ed|ing) down| left the company| (has)? moved| (has)? retired| (has|he|she)? resign(s|ing|ed)| (D|d)eceased| ?(T|t)erminat(ed|s|ing)| ?(F|f)ire(s|d|ing)| left abruptly| stopped working| indict(ed|s)| in a short while| (has)? notified| will leave| left the| agreed to leave| (has been|has)? elected| resignation(s)?",
        "MatchingText": "resigns, joins, joined, recruited, appointed etc..",
        "NonMatchingText": "non-related content",
        "Description": "This regex is really helpful if you are trying to find out executive moves. For instance you have 100 docs with company details but you need to find out the newly joined executives and resigned executives, you can do it with this. "
    },
    {
        "Pattern": "\\b([A-Za-z0-9]+)(-|_|\\.)?(\\w+)?@\\w+\\.(\\w+)?(\\.)?(\\w+)?(\\.)?(\\w+)?\\b",
        "MatchingText": "fgisgfuisd@usdfhsd.com uipadhfusdhfuihsduihf@dfduif.com.in 12sdbfisdbfuib-dbfidbfi@bfiusdbh.com.in.us jfljsdlfjlsdj@jhdfjhsd.com fhdhofhdsohoahfohsdo-fsdjfj@ioahdf.com 2ndfdifn_uidhfuisdh@djfiojd.com ",
        "NonMatchingText": "non emails.",
        "Description": "This RE will be useful in identifying emails. "
    },
    {
        "Pattern": "\\b([A-Za-z0-9]+)( )([A-Za-z0-9]+)\\b",
        "MatchingText": "(ABC CBA) (abc cba) (123 321) (aBc123 123Abc)",
        "NonMatchingText": "(wordswithoutspaceinbetween)",
        "Description": "Replaces the space character with an underscore, this regex replacement will be useful if you have change the naming convention for DB field names. The replacement string will be: $1_$3 (you can opt anything instead of \"_\" in the replacement string  for instance, $1-$2"
    },
    {
        "Pattern": "(\\n\\r)   replacement string---->\\n",
        "MatchingText": "blank\\empty lines",
        "NonMatchingText": "non-blank\\non-empty lines",
        "Description": "(\\n\\r) removes single or multiple blank\\empty lines. The replacement string will be \\n\n\nSimple but powerful and really useful"
    },
    {
        "Pattern": "^[ \\t]+|[ \\t]+$",
        "MatchingText": "(      dfdfd       ) (dfd     ) (     dfdfddf)",
        "NonMatchingText": "(dfdf dfdf dfdf) (d d) (343cfdfd dfdfd)",
        "Description": "This RE will identify leading and trailing spaces. To trim this just replace with nothing."
    },
    {
        "Pattern": "^([\\.\\\"\\'-/ \\(/)\\s\\[\\]\\\\\\,\\<\\>\\;\\:\\{\\}]?)([0-9]{3})([\\.\\\"\\'-/\\(/)\\s\\[\\]\\\\\\,\\<\\>\\;\\:\\{\\}]?)([0-9]{3})([\\,\\.\\\"\\'-/\\(/)\\s\\[\\]\\\\\\<\\>\\;\\:\\{\\}]?)([0-9]{4})$",
        "MatchingText": "(123)-123/2345 1234567890 123-123-2345 123/234\\8976 333.334,3456 ",
        "NonMatchingText": "(1234567890 jdfojsdoj) (       3456789098) (sdfhdih 675-576-9087)",
        "Description": "This RE recognizes unformatted US phone numbers. The replacement string is $2-$4-$6. Helps when you want to normalize the phone numbers in a DB field.This also identifies a single space given before are after the part of first, second 3 digits and before the last 4 digits. The replaced format will be \"123-456-7890\""
    },
    {
        "Pattern": "^[^a-zA-Z0-9]+$",
        "MatchingText": "[{}[-=+_ !@#$%^&*()_+",
        "NonMatchingText": "++++match+++ -) (*&^%$#@!233434dfdjb*(&R%^^%^)",
        "Description": "This RE will be very useful if you want to eliminate non-alpha\\numeric containing lines. For example, you have 10000 records in a DB field and you need to identify and eliminate fully unwanted character containing lines, this will help you."
    },
    {
        "Pattern": "^(http(s)?\\:\\/\\/\\S+)\\s",
        "MatchingText": "http://abci.com http://www.abc.co.uk",
        "NonMatchingText": "www.dfkdpkf.com http:/dkfjdkjfkldj.com ",
        "Description": "This RE will identify URLS only starting with http or https. Please test this before using."
    },
    {
        "Pattern": "^(http|https|ftp)\\://[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}(:[a-zA-Z0-9]*)?/?([a-zA-Z0-9\\-\\._\\?\\,\\'/\\\\\\+&amp;%\\$#\\=~])*[^\\.\\,\\)\\(\\s]$",
        "MatchingText": "https://www.restrictd.com/~myhome/",
        "NonMatchingText": "http://www.krumedia.com.|||(http://www.krumedia.com)|||http://www.krumedia.com,",
        "Description": "This Regex (can be used e.g. in PHP with eregi) will match any valid URL. Unlike the other exapmles here, it will NOT match a valid URL ending with a dot or bracket. This is important if you use this regex to find and &quot;activate&quot; Links in an Text"
    },
    {
        "Pattern": "\\B(\\s)((?:[^\"]*\"[^\"]*\")*[^\"]*$)",
        "MatchingText": "\"        \"",
        "NonMatchingText": "\"abc 123\"",
        "Description": "This expression finds a string of nothing but spaces between double quotes."
    },
    {
        "Pattern": "/\\*[\\d\\D]*?\\*/",
        "MatchingText": "/* my comment */|||/* my multiline comment */|||/* my nested comment */",
        "NonMatchingText": "*/ anything here /*|||anything between 2 seperate comments|||\\* *\\",
        "Description": "If you need to extract or remove any /* */ sytle comments from any Java, JavaScript, C, C++, CSS, etc code you have this regular expression can help."
    },
    {
        "Pattern": "^#?([a-f]|[A-F]|[0-9]){3}(([a-f]|[A-F]|[0-9]){3})?$",
        "MatchingText": "#00ccff|||#039|||ffffcc",
        "NonMatchingText": "blue|||0x000000|||#ff000",
        "Description": "Tests for valid HTML hexadecimal color codes. The # symbol is optional. And it will except either the 3 digit form for the 216 Web safe colors, or the full 6 digit form. I am use it on my site to allow users to customize the site's colors."
    },
    {
        "Pattern": "(AUX|PRN|NUL|COM\\d|LPT\\d)+\\s*$",
        "MatchingText": "COM1|||AUX|||LPT1",
        "NonMatchingText": "image.jpg|||index.html|||readme.txt",
        "Description": "&quot;Be careful when opening or creating files by using Scripting File System Object. If the filename is based on the user's input, the user might attempt to open a serial port or printer.&quot;"
    },
    {
        "Pattern": "var phonePattern = /^(([^\\.\\-\\,a-wy-z]([\\(]?(\\+|[x])?\\d+[\\)]?)?[\\s\\.\\-\\,]?([\\(]?\\d+[\\)]?)?[\\s\\.\\-\\,]?(\\d+[\\s\\.\\-\\,]?)+[^\\.\\-\\,a-z])|((\\+|[x])?\\d+))$/i",
        "MatchingText": "201-654-5932|||201 654 5932|||(201)-654-5932|||201.654.5932|||X201.654.5932|||+1 201.654.5932|||1.123.123.123|||020 1234 5678|||02-9323-1234|||(02) 9323 1234|||1-561-555-1212|||12345-1234|||(913) 451-6461|||(+447222)555555|||+44 7222 555 555|||+91-98-44111112|||+91-9844111112|||+44(7222)555555|||1(240) 652-5009|||(0833)1234567-8888|||+974-584-5656|||+44 07222 555555|||1.2123644567|||1-(212)-123 4567|||1212-364,4321|||0-212364345|||(658)154-1122|||123131312312|||875 (489 1568)|||(+91)(240) 652-5009",
        "NonMatchingText": "+()-|||(+)-,.|||493 -- 3227341|||240/752-5009|||(+91)(240)(876867) 652-5009|||+974-5dadad32d84-5656|||++44 07222 555555|||0-234.567/8912|||0212\\345/6789|||652-5009.|||652-5009-|||652-5009,|||.652-5009|||-652-5009|||,652-5009|||1-800-ALPHNUM|||a-12-3|||(658 154 1122||| 658 154 1122)|||",
        "Description": "This pattern will address almost most of the country phone patterns like UK, US, eurpoe, india etc. "
    },
    {
        "Pattern": "Kaspersky Support Canada | 1-844-888-3870",
        "MatchingText": "Kaspersky Antivirus Customer Support Number",
        "NonMatchingText": "Kaspersky Customer Support Number ",
        "Description": " Kaspersky Antivirus is one of the largest selling antiviruses in the Canada.It helps in protecting your data from different malware, spyware & dangerous websites,.if you are facing any issue related Kaspersky Antivirus then Dial Kaspersky Support Canada 1-844-888-3870 ."
    },
    {
        "Pattern": "(\\[[Ii][Mm][Gg]\\])(\\S+?)(\\[\\/[Ii][Mm][Gg]\\])",
        "MatchingText": "[IMG]http://bleh.jpg[/IMG]|||[ImG]bleh[/imG]|||[img]ftp://login:pass@bleh.gif[/img]",
        "NonMatchingText": "&lt;img src=&quot;bleh.jpg&quot;&gt;",
        "Description": "easy when you want to allow your users to post images, but in a controlled way. I used it like this (in php):\n\n$text = preg_replace(&quot;/(\\[IMG\\])(\\S+?)(\\[\\/IMG\\])/is&quot;, &quot;&lt;a href=\\&quot;\\\\2\\&quot; target=\\&quot;_blank\\&quot;&gt;&lt;IMG SRC=\\&quot;\\\\2\\&quot; align=\\&quot;center\\&quot; height=\\&quot;100\\&quot; border=\\&quot;0\\&quot;&gt;&lt;/a&gt;&quot;,$text);\n\nso whenever they use\n\n[img]http://www.foo.com/bleh.jpg[/img]\n\nit will be converted to\n\n&lt;a href=&quot;http://www.foo.com/bleh.jpg&quot; target=&quot;_blank&quot;&gt;&lt;IMG SRC=&quot;http://www.foo.com/bleh.jpg&quot; align=&quot;center&quot; height=&quot;100&quot; border=&quot;0&quot;&gt;&lt;/a&gt;\n\nso you get a 100 pixels high picture, and when they click on it it opens in a new window...\n\n(to prevent users from posting huge pictures and stuff)"
    },
    {
        "Pattern": "^((192\\.168\\.0\\.)(1[7-9]|2[0-9]|3[0-2]))$",
        "MatchingText": "192.168.0.17 | 192.168.0.24 | 192.168.0.32",
        "NonMatchingText": "192.168.0.16 | 192.168.0.33",
        "Description": "This expression matches IP Addresses between 192.168.0.17 - 192.168.0.32 which is a block range of 16 addresses. I created this expression for Google Analytics to filter out hits from our companies office."
    },
    {
        "Pattern": "^(\\d{3}-\\d{2}-\\d{4})|(\\d{3}\\d{2}\\d{4})$",
        "MatchingText": "123-45-6789|||123456789|||456-63-6666",
        "NonMatchingText": "123-45-459a|||222-2-2222|||222-222222",
        "Description": "This will accept SSN in the form of 123-45-6789 OR 123456789."
    },
    {
        "Pattern": "^((29-02-(19|20)(([02468][048])|([13579][26])))|(31-((0[13578])|(1[02]))|(30-((0[13456789])|(1[0-2])))|(29-((0[13456789])|(1[0-2])))|(((0[1-9]|)|(1[0-9])|(2[0-8]))-((0[1-9])|(1[0-2])))-((19|20)[0-9][0-9])))$",
        "MatchingText": "29-02-2008|||30-04-2007|||01-01-1975",
        "NonMatchingText": "29-02-2007|||31-11-2008|||31-13-1999",
        "Description": "This expression can be used to validate any date entered in correct DD-MM-YYYY format. Takes care of Leap Years too.."
    },
    {
        "Pattern": "^[a-zA-Z0-9\\_\\-]+[a-zA-Z0-9\\.\\_\\-]*@([a-zA-Z0-9\\_\\-]+\\.)+([a-zA-Z]{2,4}|travel|museum)$",
        "MatchingText": "test@my_domain.com",
        "NonMatchingText": "wrong.com, @wrong.com, wrong@.com, wrong@hot.network wrong@mail..com wrong@mail.com.  .wrong@mail.com",
        "Description": "Simple Email check, ideal for a quick mail check."
    },
    {
        "Pattern": "%[\\-\\+0\\s\\#]{0,1}(\\d+){0,1}(\\.\\d+){0,1}[hlI]{0,1}[cCdiouxXeEfgGnpsS]{1}",
        "MatchingText": "%s%02d|||%s|||%04lX ",
        "NonMatchingText": "%5.f |||%++X|||%@d",
        "Description": "This regular expression matches &quot;c&quot; format strings for printf/scanf functions. "
    },
    {
        "Pattern": "\\b[1-9]\\d{3}\\ +[A-Z]{2}\\b",
        "MatchingText": "\"1484 EE\"",
        "NonMatchingText": "\"1484EE\",  \"0111 AB\", \"1484 ee\", \"1234 ABC\"",
        "Description": "Dutch postal codes are ranged from \"1000 AA\" to \"9999 ZZ\"."
    },
    {
        "Pattern": "^(([+]|00)39)?((3[1-6][0-9]))(\\d{7})$",
        "MatchingText": "+393319991220 ; 00393319991220 ; 3319991220",
        "NonMatchingText": "393319991220 ; 331999122044 ;",
        "Description": "Check if the number is a valid italian mobile number. Note: even though 35X is non given yet, this regular expression consider it a valid number just in case it will be!"
    },
    {
        "Pattern": "^(?:(w){3}\\.)?[0-9a-zA-Z]+\\.[A-Za-z]{2,4}$",
        "MatchingText": "www.example.com example.com example.net  wwwww.com ",
        "NonMatchingText": "ftp://example.com ex@ample.com example.cooom ",
        "Description": "This is just a simple URL to put in form validation. the domaine extension is unlimited (not limited to com net.. ).\nany comments are welcome\n"
    },
    {
        "Pattern": "^-?([1-8]?[0-9]\\.{1}\\d{1,6}$|90\\.{1}0{1,6}$)",
        "MatchingText": "-90.0 -77.284382 89.999999 1.0001",
        "NonMatchingText": "-90.1 90.12345 91 -20.1234567 -90 90",
        "Description": "Matches a latitude in the range of -90 to 90 degrees, with between 1 and 6 trailing decimal places."
    },
    {
        "Pattern": "^-?((([1]?[0-7][0-9]|[1-9]?[0-9])\\.{1}\\d{1,6}$)|[1]?[1-8][0]\\.{1}0{1,6}$)",
        "MatchingText": "-180.0 180.0 -179.010293 1.123456 -45.012 0.12",
        "NonMatchingText": "180 -180 180.1 -180.1 0.1234567 190.1",
        "Description": "Matches a longitude in the range of -180 to 180 degrees, with between 1 and 6 trailing decimal places."
    },
    {
        "Pattern": "^(0,?\\d)([0-9]{2}[0-9]{0,}(\\.[0-9]{2}))$",
        "MatchingText": "10.00|||32.50",
        "NonMatchingText": "01.00|||12|||12.0",
        "Description": "Validates currency, must have two leading and two digits following a decimal point. Does not accept leading zero's."
    },
    {
        "Pattern": "@([_a-zA-Z]+)",
        "MatchingText": "SELECT COUNT(pk) FROM Employees WHERE TypeID = @Type",
        "NonMatchingText": "SELECT COUNT(pk) FROM Employees WHERE TypeID = 1",
        "Description": "Can be used to find SQL Server parmeters in a SQL string.  Does not attempt to weed-out \"@\" characters in embedded string values."
    },
    {
        "Pattern": "^(http\\://){1}(((www\\.){1}([a-zA-Z0-9\\-]*\\.){1,}){1}|([a-zA-Z0-9\\-]*\\.){1,10}){1}([a-zA-Z]{2,6}\\.){1}([a-zA-Z0-9\\-\\._\\?\\,\\'/\\\\\\+&amp;%\\$#\\=~])*",
        "MatchingText": "http://www.pass.com http://sub.pass.com http://www.sub.pass.com  http://sub.sub.pass.com http://www.sub.sub.pass.com",
        "NonMatchingText": "fail.com ||| www.fail.com ||| www.www.fail.com ||| http://fail.com ||| http://http://fail.com ||| http://http://www.fail.com ||| sub.fail.com ||| www.sub.fail.com ||| sub.sub.fail.com ||| www.sub.sub.fail.com",
        "Description": "This checks to see if a URL has http:// in it, and if it has either www or a subdomain before the domain and tld. Without (http\\://) it only does the latter check. Replace http by (http|https|ftp) for other protocols. Still not happy about this: http://www.www.passshouldfail.com"
    },
    {
        "Pattern": "((file|gopher|news|nntp|telnet|http|ftp|https|ftps|sftp)\\:\\/\\/([a-zA-Z0-9\\.\\-]+(\\:[a-zA-Z0-9\\.&amp;%\\$\\-]+)*@){0,1}((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])|localhost|([a-zA-Z0-9\\-]+\\.)*[a-zA-Z0-9\\-]+\\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))(:[0-9]{2,5}[^:]){0,1}(\\/(\\s+|$|[a-zA-Z0-9\\.\\,\\?\\'\\\\\\+&amp;%\\$#\\=~_\\-]+)){0,1})",
        "MatchingText": "file://test.com/|||http://www.test.com:80/|||ftp://user@localhost/dir",
        "NonMatchingText": "test.com|||www.test.com:80:80|||https://user@user@test.com",
        "Description": "Modified version of Brian Bothwell's valid url submission. Eliminates a couple of the user discovered bugs, expands protocol recognition and considers trailing /"
    },
    {
        "Pattern": "^([\\w]+@([\\w]+\\.)+[a-zA-Z]{2,9}(\\s*;\\s*[\\w]+@([\\w]+\\.)+[a-zA-Z]{2,9})*)$ ",
        "MatchingText": "test1@site.sub.edu  ;user@site2.com",
        "NonMatchingText": "test1site.sub.edu  ;@site2.com",
        "Description": "Validates a semi colon delimited list of email addresses.  Appropriate for use with .NET Web.Mail.MailMessage fields (To, BCC, CC)"
    },
    {
        "Pattern": "\\w{5,255}",
        "MatchingText": "aa123_ter12|||aa4587|||784566",
        "NonMatchingText": "123*-/  mksj",
        "Description": "This is User Name &amp; Password validation expression. It does not allow blank spaces as well as special characters like $#%@&amp;*(){}+"
    },
    {
        "Pattern": "^(http(s?):\\/\\/)(www.)?(\\w|-)+(\\.(\\w|-)+)*((\\.[a-zA-Z]{2,3})|\\.(aero|coop|info|museum|name))+(\\/)?$",
        "MatchingText": "http://www.google.com, http://www.google.co.uk, http://images.google.ie",
        "NonMatchingText": "www.google.com, http://www.google",
        "Description": "Matches simple root website URLs.\nHttps and some new domains supported."
    },
    {
        "Pattern": "^[a-zA-Z0-9][a-zA-Z0-9-_.]{2,8}[a-zA-Z0-9]$",
        "MatchingText": "1.ma  |  user  |  ma_mo-on.r  ",
        "NonMatchingText": "_user  |  asfd@12  |  user. ",
        "Description": "This expression will validate user name with the following rules\n1- It must start and end with a digit or character\n2- It must be exactly 4 to 10 character long\n3- Allowed Special Characters are _.-"
    },
    {
        "Pattern": "^(\\+27|27)?(\\()?0?([7][1-9]|[8][2-4])(\\))?( |-|\\.|_)?(\\d{3})( |-|\\.|_)?(\\d{4})",
        "MatchingText": "0710999999 +27710999999 +2771 099 9999 078 099 1234 (078) 099-1234",
        "NonMatchingText": "Land-line numbers ( Telkom ) & 0860 numbers",
        "Description": "Regular expression to match South African Mobile network ( Range allocated to SPs until Dec'2011 ). "
    },
    {
        "Pattern": "^[\\\\(]{0,1}([0-9]){3}[\\\\)]{0,1}[ ]?([^0-1]){1}([0-9]){2}[ ]?[-]?[ ]?([0-9]){4}[ ]*((x){0,1}([0-9]){1,5}){0,1}$",
        "MatchingText": "(910)456-7890|||(910)456-8970 x12|||(910)456-8970 1211",
        "NonMatchingText": "(910) 156-7890|||(910) 056-7890|||(910) 556-7890 x",
        "Description": "US Telephone Number where this is regular expression excludes the first number, after the area code,from being 0 or 1; it also allows an extension\nto be added where it does not have to be prefixed by 'x'."
    },
    {
        "Pattern": "/url\\(\\s*(?:(?:(\"((['\"]+))((((data|http(s)*):)|\\s*\"))[^'\"]*\")|(?:('((['\"]+))((((data|http(s)*):)|\\s*'))[^'\"]*'))|(?:(((['\"\\s]+))((((data|http(s)*):)|\\s*')).*[^'\"]))))\\s*\\)/g",
        "MatchingText": "url('/asdf/foo/bar.jpg'); url(\"foo/bar.jpg\");  url(' /asdf/foo/bar.jpg '); url(\" foo/bar.jpg \");  url(\" n \"); url(' n '); url(/asdf/foo/bar.jpg); url(../bar.jpg); url( bar.jpg ); url( \"data.jpg\" ); url(\"data.jpg\"); url('data.jpg'); url( 'data.jpg' ); url(data.jpg); url(' data '); url('data' ); url('data'); url( data ); url(data ); url(data);",
        "NonMatchingText": "url('/asdf/fo'o/bar.jpg'); url('/asdf/f\"oo/bar.jpg'); url(\"foo/b'ar.jpg\");  url(\"fo\"o/bar.jpg\");  url(\" \"/asdf/foo/bar.jpg\" \"); url(\"\"/asdf/foo/bar.jpg\"\"); url(' '/asdf/foo/bar.jpg' '); url(\"'/asdf/foo/bar.jpg'\"); url(\"/asdf/foo/bar.jpg'\"); url(\"' \"); url(\" \"); url(\"\"); url(\" '); url(' '); url( ); url(); url(\"/asdf/foo/bar.jpg'); url(/asdf/foo/bar.jpg'); url('/asdf/foo/bar.jpg);   url(\"http://remote.com/asdf/foo/bar.jpg\"); url( \"http://remote.com/asdf/foo/bar.jpg\" ); url('https://remote.com/asdf/foo/bar.jpg'); url(http://remote.com/asdf/foo/bar.jpg); url('http://remote.com/asdf/foo/bar.jpg\"); ",
        "Description": "Match ONLY relative URLs in CSS file, ignore data and absolute urls.\n\nhttps://github.com/FabioVergani/regex-Snippet/blob/master/css/MatchOnlyRelativeURLs-in-CSS.rgx\n\nmatch:\nurl('/asdf/foo/bar.jpg');\nurl(\"foo/bar.jpg\"); \nurl(' /asdf/foo/bar.jpg ');\nurl(\" foo/bar.jpg \"); \nurl(\" n \");\nurl(' n ');\nurl(/asdf/foo/bar.jpg);\nurl(../bar.jpg);\nurl( bar.jpg );\nurl( \"data.jpg\" );\nurl(\"data.jpg\");\nurl('data.jpg');\nurl( 'data.jpg' );\nurl(data.jpg);\nurl(' data ');\nurl('data' );\nurl('data');\nurl( data );\nurl(data );\nurl(data);\n\n\nnot:\nurl('/asdf/fo'o/bar.jpg');\nurl('/asdf/f\"oo/bar.jpg');\nurl(\"foo/b'ar.jpg\"); \nurl(\"fo\"o/bar.jpg\"); \nurl(\" \"/asdf/foo/bar.jpg\" \");\nurl(\"\"/asdf/foo/bar.jpg\"\");\nurl(' '/asdf/foo/bar.jpg' ');\nurl(\"'/asdf/foo/bar.jpg'\");\nurl(\"/asdf/foo/bar.jpg'\");\nurl(\"' \");\nurl(\" \");\nurl(\"\");\nurl(\" ');\nurl(' ');\nurl( );\nurl();\nurl(\"/asdf/foo/bar.jpg');\nurl(/asdf/foo/bar.jpg');\nurl('/asdf/foo/bar.jpg);\n\n\nurl(\"http://remote.com/asdf/foo/bar.jpg\");\nurl( \"http://remote.com/asdf/foo/bar.jpg\" );\nurl('https://remote.com/asdf/foo/bar.jpg');\nurl(http://remote.com/asdf/foo/bar.jpg);\nurl('http://remote.com/asdf/foo/bar.jpg\");\nurl('http:www');\nurl('http:/');\nurl(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7);\nurl(\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\");\nurl(\"data:image/gif;base64,\");\nurl('data:image/gif;base64,\");\nurl(\"'data:image/gif;base64,'\");\nurl(\"data:;base64,\");\nurl(\"data:;base64,');\nurl( data:\");\nurl(data:\");\nurl(data:);\nurl(\"data.jpg');\nurl(data:;base64,);"
    },
    {
        "Pattern": "http://[^/]*/",
        "MatchingText": "http://www.google.com",
        "NonMatchingText": "http://www.google.com/products/bob?gmail.ckj",
        "Description": "I was looking for a long time for a simple regex to strip the domain name from a long url or to Get rid of directories and pages. I found a simple one that I wanted to share. If you have http://www.google.com/products/bob?gmail.ckj it will return only http://www.google.com getting rid of all the other parts of the url"
    },
    {
        "Pattern": "(([A-Za-z0-9_\\\\-]+\\\\.?)*)[A-Za-z0-9_\\\\-]+\\\\.[A-Za-z0-9_\\\\-]{2,6}",
        "MatchingText": "athenatechnologies.co.in",
        "NonMatchingText": ".athena.technologies.ccccccccc",
        "Description": "It checks for the domain name validity. A domain name can't start with a dot(.). It can't have consecutive dots. If there are moe than one dot then there can be only 2 to 6 characters after the final dot. e.g. nitin.athena.com is valid."
    },
    {
        "Pattern": "name.matches(\"a-z\")",
        "MatchingText": "a to z",
        "NonMatchingText": "numbers and capital letters and special characters",
        "Description": "to allow the only small letters."
    },
    {
        "Pattern": "\\d{5,12}|\\d{1,10}\\.\\d{1,10}\\.\\d{1,10}|\\d{1,10}\\.\\d{1,10}",
        "MatchingText": "12.0020|||10.07015.3|||1222.5",
        "NonMatchingText": "10|||.0020|||10.07015.3.4",
        "Description": "regex for IPCodeSectionSeriesRim."
    },
    {
        "Pattern": "[0-9]{4}[A-Z]{2}",
        "MatchingText": "1000AB|||3035KA|||9999ZZ",
        "NonMatchingText": "AA1000|||Z1000|||1000-CC",
        "Description": "Match for dutch zipcodes.\nDutch zipcodes are always in the format of 4 digits and 2 letters."
    },
    {
        "Pattern": "(?:\\([2-9][0-8]\\d\\)\\ ?|[2-9][0-8]\\d[\\-\\ \\.\\/]?)[2-9]\\d{2}[- \\.\\/]?\\d{4}\\b",
        "MatchingText": "8296399623|||741 556-4630|||319.380.3232|||(859)673.5793|||660/471.5749",
        "NonMatchingText": "(195)979-5873|||763 027 5552|||596 270.0326|||8915551212",
        "Description": "Matches NANP requirements for valid telephone numbers in the USA, its territories, Canada, Bermuda, and 16 Caribbean nations.<br> \nArea code: [2-9][0-8][0-9]<br>\nExchange code: [2-9][0-9][0-9]<br>\nStation code: [0-9][0-9][0-9][0-9]<br>\nAccepts common phone number separators like parentheses, dash/hyphen, slash, period, and space. Stops matching at any word boundary, including end of line. Adapted from Don Johnston's pattern."
    },
    {
        "Pattern": "\\b([2-9][p-z][a-h][2-9]{1,2}[a-z]+[p-z][2-9][p-z][2-9][p-z]|[a-z][a-z]+\\d{2}[a-z]|[2-9][p-z]{2}[a-h][2-9]{1,2}[a-z]+[p-z][2-9]{3}[p-z]|\\d{12}|[2-9][p-z][a-h][2-9][a-z0-9]+[p-z][2-9]{3}[p-z])\\b",
        "MatchingText": "2wg8ingress5r9q|826661003000|8yd8resonateq892q",
        "NonMatchingText": "everywhere|w28gingressr5q9|9266610030",
        "Description": "Matches most common Ingress passcode patterns."
    },
    {
        "Pattern": "^([0-9a-f]{4}\\.[0-9a-f]{4}\\.[0-9a-f]{4})$",
        "MatchingText": "001e.1324.683f|1234.abcd.1234|ffff.ffff.ffff",
        "NonMatchingText": "001E.1324.683f|001234.abcd.abcd|abcd.1234.abcd.1234|aa-bb-cc-dd-ee-ff|11:22:33:44:55:66",
        "Description": "Matches against dumps of Cisco MAC address tables on newer versions of Cisco IOS."
    },
    {
        "Pattern": "^[-]?((1[6789]|[2-9][0-9])[0-9]{2}-(0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$|^[-]?((1[6789]|[2-9][0-9])[0-9]{2}-(0[469]|11)-(0[1-9]|[12][0-9]|30))T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$|^[-]?((16|[248][048]|[3579][26])00)|(1[6789]|[2-9][0-9])(0[48]|[13579][26]|[2468][048])-02-(0[1-9]|1[0-9]|2[0-9])T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$|^[-]?(1[6789]|[2-9][0-9])[0-9]{2}-02-(0[1-9]|1[0-9]|2[0-8])T([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])([Z]|\\.[0-9]{4}|[-|\\+]([0-1][0-9]|2[0-3]):([0-5][0-9]))?$",
        "MatchingText": "2007-11-02T18:00:00.1234||2000-02-29T12:00:12+03:00",
        "NonMatchingText": "2005-01-20|| 23:00:00",
        "Description": "This pattern matches valid w3c compatible datetime values  from 1600 to 9999 in the form of [-]YYYY-MM-DDTHH:MM:SS[.ssss|[[+|-][HH:MM]][Z] also takes into account leap years."
    },
    {
        "Pattern": "(?:[a-z]{3},\\s+)?(\\d{1,2})\\s+([a-z]{3})\\s+(\\d{4})\\s+([01][0-9]|2[0-3])\\:([0-5][0-9])",
        "MatchingText": "Fri, 7 Dec 2007 17:48:46 +0100 || 07 DEC 2007 17:35",
        "NonMatchingText": "07.12.2007 || AAA bb CCCC DDDDD 85:88",
        "Description": "Extracts Day, Monthname, Year, Hour and Minute into 5 Groups. This Regex is useful for E-Mail Apps."
    },
    {
        "Pattern": "'`.*?((http|ftp|https)://[\\w#$&+,\\/:;=?@.-]+)[^\\w#$&+,\\/:;=?@.-]*?`i'",
        "MatchingText": "<a href=\"http://foobar.com\"> ||| Hello world I'm a http://google.fr ||| Did you mean:http://google.fr/index.php?id=1&b=6#2310",
        "NonMatchingText": "http:// ||| http://<foobar ||| www.google.fr",
        "Description": "With this expresion you ll be able to extract all the urls of a given text or HTML page.\nWorks fine using the PHP preg_match function"
    },
    {
        "Pattern": "((\\d{1,6}\\-\\d{1,6})|(\\d{1,6}\\\\\\d{1,6})|(\\d{1,6})(\\/)(\\d{1,6})|(\\w{1}\\-?\\d{1,6})|(\\w{1}\\s\\d{1,6})|((P\\.?O\\.?\\s)((BOX)|(Box))(\\s\\d{1,6}))|((([R]{2})|([H][C]))(\\s\\d{1,6}\\s)((BOX)|(Box))(\\s\\d{1,6}))?)$",
        "MatchingText": "4444, G 4444,  333/555, P.O. Box 432, RR 4 Box 567",
        "NonMatchingText": "po box 432, GG4321, 48392021",
        "Description": "This is my first attempt at creating a regex.  For a street number only field, allows 7 digit number, 6 digit number with one preceding letter (the letter can have a hyphen, space, or nothing between it and the numbers), two 7 digit numbers divided by a \"/\",\"\\\", or \"-\", variations of P.O. Box we allow, Rural Route, and Highway Contract acoording to U.S. Postal rules."
    },
    {
        "Pattern": "((^[0-4])^(\\d+))$",
        "MatchingText": "5,10,100,9999999",
        "NonMatchingText": "-2,0,4.2,6.5",
        "Description": "Allows only a positive whole number greater than 4.  Obviously it can be easily changed to be greater than any number desired."
    },
    {
        "Pattern": "(\\d{3}\\-\\d{2}\\-\\d{4})",
        "MatchingText": "111-22-3333",
        "NonMatchingText": "11-222-3333, 1111-22-333",
        "Description": "pattern match for U.S. social security number"
    },
    {
        "Pattern": "^http://\\\\.?video\\\\.google+\\\\.\\\\w{2,3}/videoplay\\\\?docid=[\\\\w-]{19}",
        "MatchingText": "http://video.google.it/videoplay?docid=3947293349740494460",
        "NonMatchingText": "nothing",
        "Description": "A simple regex for validating a Google link."
    },
    {
        "Pattern": "<\\s*[\\/]?(?P<tag>[a-z:_][-a-z0-9._:]*)(\\s+(?P<attributes>[a-z:_]*[-a-z0-9._:]*[^\\s=><]*)\\s*=?\\s*(\"[^\"]*\"|'[^']*'|\"|')*[^\\s><]*)*\\s*[\\/]?>?",
        "MatchingText": "<h1>, </h1>, <span class=\u201Dxyz\u201D style=\u201Dfont-style:italics;\u201D> <script a> <script abc=> <script abc=\"...\">, <script abc=\"afgd\"abc    >, <script abc=\"\"abc def=\"\">",
        "NonMatchingText": "Plain text, 1 > 0, 5 < 3",
        "Description": "Designed to find tags and attributes despite formatting issues, since it may help to find tags like <script a>, since they'll render even though not properly formatted.\nAlso finds closing tags. Designed with the intention of sanitizing html input prior to rendering. However, for some inputs, this can be very slow. I don't recommend doing this with regex"
    },
    {
        "Pattern": "<script.*/*>|</script>|<[a-zA-Z][^>]*=['\"]+javascript:\\w+.*['\"]+>|<\\w+[^>]*\\son\\w+=.*[ /]*>",
        "MatchingText": "<a href=\"javascript:alert('test0');\"> or <a href=\"#\" onClick=\"alert('test');\" /> etc...",
        "NonMatchingText": "This should not appear because in javascript: you can use the < operator or the > operator.",
        "Description": "Matches any opening or closing script tags, inline javascript: tags, inline on<function> (ex: onClick) tags.\n\nMATCHES:\n<a href=\"javascript:alert('test0');\">\n<a href='javascript:alert(\"test1\");'>\n<a href=\"#\" onClick=\"alert('test2');\" />\n<script language=\"javascript\" src=\"somewhere.js\">\n<script language=\"javascript\" src=\"somewhere.js\" />\n<script>\n</script>"
    },
    {
        "Pattern": "<\\?xml.*</note>",
        "MatchingText": "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>",
        "NonMatchingText": "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></BADnote>",
        "Description": "This will find any XML within a string starting with the <?xml header and ending with the closing root tag. Replace </note> with your closing root tag. (use singleline and case insensitive) - I use this to pull xml written in a web document."
    },
    {
        "Pattern": "^(([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5}){1,25})+(\\s*[;.]\\s*(([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5}){1,25})+)*$",
        "MatchingText": "info@domain.com; contact@domain.com",
        "NonMatchingText": "info@domain.com, contact@domain.com",
        "Description": "This is a minor change to the Regex found at http://regexlib.com/RETester.aspx?regexp_id=1007 to allow for spaces around the delimiters."
    },
    {
        "Pattern": "^[A-Za-z]{1,2}[0-9A-Za-z]{1,2}[ ]?[0-9]{0,1}[A-Za-z]{2}$",
        "MatchingText": "SW112LE|||SW11 2LE|||CR05LE",
        "NonMatchingText": "12CR0LE|||12CR 0LE|||SWLE05",
        "Description": "This regular expression can be used to validate UK postcodes. Especially useful if want to provide a client side validation on a web site."
    },
    {
        "Pattern": "^[A-Za-z]{2}[0-9]{6}[A-Za-z]{1}$",
        "MatchingText": "SP939393H|||PX123456D|||SW355667G",
        "NonMatchingText": "12SP9393H|||S3P93930D|||11223344SP00ddSS",
        "Description": "UK National Insurance Number validation. Especially useful to validate through clientside/server side script on a website."
    },
    {
        "Pattern": "^[\\+\\-]?[0-9]+([\\,\\.][0-9]+)?$",
        "MatchingText": "\u00AB1\u00BB \u00AB-1\u00BB \u00AB+1\u00BB \u00AB1.0\u00BB \u00AB-1.0\u00BB \u00AB+1.0\u00BB \u00AB1,0\u00BB \u00AB-1,0\u00BB \u00AB+1,0\u00BB ",
        "NonMatchingText": "\u00ABabc\u00BB \u00AB1e2\u00BB ",
        "Description": "Accepts integer and decimal numbers, the decimal delimiter beeing either a point or a comma, prefixed or not by a plus or minus sign."
    },
    {
        "Pattern": "^(\\d{4},?)+$",
        "MatchingText": "2001,2002,2003|||1999|||1999,2000,",
        "NonMatchingText": "123|||1234,e,1234|||1234, 1234,1234",
        "Description": "Accepts a list of 4 digits separated by commas. Used to validate a list of years. Can be easily customized to change the number of digits."
    },
    {
        "Pattern": "^([A-Z]{1,}[a-z]{1,}[A-Z]{0,}[a-z]{0,}[A-Z]{0,}[a-z]{0,}[A-Z]{0,}[a-z]{0,}[A-Z]{0,}[a-z]{0,}[A-Z]{0,}[a-z]{0,}[A-Z]{0,}[a-z]{0,}[A-Z]{0,}[a-z]{0,}[A-Z]{0,}[a-z]{0,}[A-Z]{0,}[a-z]{0,}[A-Z]{0,}[a-z]{0,}[A-Z]{0,}[a-z]{0,})$",
        "MatchingText": "MyLongClassName,ABClassName",
        "NonMatchingText": "my1stLong ClassName",
        "Description": "Matches words in PascalCase. Only alphas, no spaces or other special characters, the first character must be upper case. Matches up to 12 PascalCase words."
    },
    {
        "Pattern": "^[+-]?([0-9]*\\.?[0-9]+|[0-9]+\\.?[0-9]*)([eE][+-]?[0-9]+)?$",
        "MatchingText": "23|||-17.e23|||+.23e+2",
        "NonMatchingText": "+.e2|||23.17.5|||10e2.0",
        "Description": "A regular expression that matches numbers. Integers or decimal numbers with or without the exponential form."
    },
    {
        "Pattern": "^[^\\~\\`\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\_\\=\\+\\\\\\|\\[\\]\\{\\}\\;\\:\\\"\\'\\,\\<\\./\\>\\?\\s](([a-zA-Z0-9]*[-_\\./]?[a-zA-Z0-9]{1,})*)$",
        "MatchingText": "a.b-c_d a1-b2.c3_d4 0a-b_c2.d.3",
        "NonMatchingText": "-a1b2c3d_ _a1b2c3d- .abcd- -abcd. _abcd. .abcd_",
        "Description": "allows a username of any length a-z 0-9 including one of ._- between each letter or number but not at the start or end of the name"
    },
    {
        "Pattern": "('(?:(?:\\\\'|[^'])*)'|NULL)",
        "MatchingText": "'A car'|'Mary\\'s car'|NULL",
        "NonMatchingText": "'asdasdasd|adsfadsf|23123",
        "Description": "This is useful to find single quoted strings in mysql dumps. \n\nIt accepts \\' inside the strings."
    },
    {
        "Pattern": "(\\(0\\d\\d\\)\\s\\d{3}[\\s-]+\\d{4})|(0\\d\\d[\\s-]+\\d{3}[\\s-]+\\d{4})|(0\\d{9})|(\\+\\d\\d\\s?[\\(\\s]\\d\\d[\\)\\s]\\s?\\d{3}[\\s-]?\\d{4})",
        "MatchingText": "(011) 123 4543,(011) 123-4543,(011) 212 8765,011 876 8789,0118768789,011-876-8789,082 821 9090,+27 11 123 1231,+27 (11) 123-1231,+27 (11) 123 1231,+27(11)123-1231,+27 11 1238765",
        "NonMatchingText": "011 1234 242",
        "Description": "Tries to match the format of phone numbers within South Africa. Does not try to validate phone numbers based on actual numbers (e.g. cell networks or other landline prefixes)"
    },
    {
        "Pattern": "<(\\s*/?\\s*)\\w+?(\\s*(([\\w-]+=\"[^\"]*?\")|([\\w-]+='[^']*?')|([\\w-]+=[^'\"<>\\s]+)))*(\\s*/?\\s*)>",
        "MatchingText": "<html>, <meta http-equiv=Content-Type content=\"text/html; charset=windows-1250\">, < / html     body=\"<'something'>\"    body='\"any thing\"'    b=jj123-qqj / >",
        "NonMatchingText": "<html / d>, <html body='something\">, <d /html>",
        "Description": "This RE strips HTML open and close tags from text with any attributes provided, including not properly formatted tags."
    },
    {
        "Pattern": "((0[1-9])|(1[0-9])|(2[0-9])|(3[0]))/((0[1-9])|(1[0-2]))/14[3-9]{2}",
        "MatchingText": "29/12/1434|||01/02/1435|||30/11/1434",
        "NonMatchingText": "31/12/144|||01/2/1435|||5/5/1435",
        "Description": "Matches DD/MM/YYYY for Arabic Hijri Dates. It starts range from 1434 ( current year ) to 1499"
    },
    {
        "Pattern": "^.+@[^\\.].+\\.[a-z]{2,}(\\.[a-z]{2,}$|$)",
        "MatchingText": "abc@test.com|||abc@test.com.br|||a.b_c@test.com.br",
        "NonMatchingText": "abc@.test.com|||abc@test.|||abc@test.com.",
        "Description": "Simple email validator.\nShould cover most emails."
    },
    {
        "Pattern": "^\\$\\d{1,3}(,?\\d{3})*(\\.\\d{2})?$",
        "MatchingText": "$333,444,444,555.99",
        "NonMatchingText": "$333,444,444,55",
        "Description": "Looks for a number which can be optionally comma separated at thousands and may or may not have two decimal places. Tweaking: 1. Replace the \\$ symbol with your currency. 2. Toggle , and . as separators (Some European countries follow this convention) 3. Mandate comma separation by removing the ? after ,"
    },
    {
        "Pattern": "^\\S{2}\\d{7}$",
        "MatchingText": "AB1234567",
        "NonMatchingText": "AB 1234567, AB12345678, 12345678",
        "Description": "A DEA number is a number assigned to a health care provider (such as a medical practitioner, dentist, or veterinarian) by the U.S. Drug Enforcement Administration.  This regex validates correct format"
    },
    {
        "Pattern": "(000)(666)^([0-8]\\d{2})(\\d{2})(\\d{4})$",
        "MatchingText": "001191873 ||| 667191873 ||| 899191873",
        "NonMatchingText": "000191873 ||| 666191873 ||| 901191873",
        "Description": "Validates SSN for INTEGERS ONLY. This does not allow spaces or dashes.\n\n\nFollowing this info: \n\nhttp://www.socialsecurity.gov/employer/randomization.html\n\nStarting in June 2011, the SSA will begin randomizing SSN creation. The only exclusions are SSNs beginning with 000, 666, or 900-999. That rather simplifies things."
    },
    {
        "Pattern": "(^[A-Za-z])|(\\s)([A-Za-z])",
        "MatchingText": "James Kramer|||Sir Richard Branson|||33 yoYo 654 ma",
        "NonMatchingText": "33 66 4ju",
        "Description": "This expression will return the first letter of each word in a string. Best used if you need to get initials from a name.\n&quot;James Kramer&quot; = &quot;J K&quot; &amp; &quot;Sir Richard Branson&quot; = &quot;S R B&quot; &amp; &quot;33 yoYo 654 ma&quot; = &quot;y m&quot;\n"
    },
    {
        "Pattern": "^(\\d{5})$|^([a-zA-Z]\\d[a-zA-Z]( )?\\d[a-zA-Z]\\d)$",
        "MatchingText": "12345|A6A 6A6|A6A6A6",
        "NonMatchingText": "aaaaa|6A6A6A",
        "Description": "Created for input validation of major part of zip code.  Normal Canadian entry has an optional space between the first group of three and the second group.  Original pattern taken from Steven Smith and modified for our entries."
    },
    {
        "Pattern": "[:;]{1}[-~+o]?[(&lt;\\[]+",
        "MatchingText": " :o( ||| :+&lt; |||;-((",
        "NonMatchingText": " :) ||| :/ ",
        "Description": "I searched for a smiley expression but couldn't find one. This one should find all the usual ways of writing the sad emotion icon."
    },
    {
        "Pattern": "[:]{1}[-~+o]?[)&gt;]+",
        "MatchingText": ":)))))|||:+&gt;|||:o)",
        "NonMatchingText": ";o)|||:-(",
        "Description": "This ist the Expression for a happy smiley. It should find all the usual writings of the emotion icon :)"
    },
    {
        "Pattern": "^\\$([0]|([1-9]\\d{1,2})|([1-9]\\d{0,1},\\d{3,3})|([1-9]\\d{2,2},\\d{3,3})|([1-9],\\d{3,3},\\d{3,3}))([.]\\d{1,2})?$|^\\(\\$([0]|([1-9]\\d{1,2})|([1-9]\\d{0,1},\\d{3,3})|([1-9]\\d{2,2},\\d{3,3})|([1-9],\\d{3,3},\\d{3,3}))([.]\\d{1,2})?\\)$|^(\\$)?(-)?([0]|([1-9]\\d{0,6}))([.]\\d{1,2})?$",
        "MatchingText": "($1,234,567.89)|||$1,234,567.89|||$1234567.89|||$-1234567.89",
        "NonMatchingText": "$1,234,567.890|||$12345678.90|||$023,456.78",
        "Description": "Matches number with optional commas and decimal places. Allows only max 7 digits before decimal and max 2 digits after decimal. Does not allow numbers beginning with 0 e.g., $0,234,567 but allows $0.05"
    },
    {
        "Pattern": "^[\\+\\-]?\\d+(,\\d+)?$",
        "MatchingText": "65,50|||-45,5|||10",
        "NonMatchingText": "65.50|||-45.5|||10a",
        "Description": "A simple expression for validate in .net RegularExpressionValidator."
    },
    {
        "Pattern": "^(www\\.regxlib\\.com)$",
        "MatchingText": "www.regxlib.com",
        "NonMatchingText": "everything else",
        "Description": "Looking for Regular Expression Library"
    },
    {
        "Pattern": "^(0?[1-9]|1[012])/([012][0-9]|[1-9]|3[01])/([12][0-9]{3})$",
        "MatchingText": "1/12/2003|||04/8/1995|||12/31/2035|||5/06/1911",
        "NonMatchingText": "13/04/2000|||4/32/1593||||5/6/98",
        "Description": "In month/day/year format. Matches valid months (1-12) and valid days (1-31) and a valid 4 digit year (from 1000-2999). $1 = month, $2 = day, $3 = year. Sadly, it doesn't check to make sure that months have a valid number of days (no Feb 30th checks, etc)."
    },
    {
        "Pattern": "[^A-Za-z0-9_@\\.]|@{2,}|\\.{5,}",
        "MatchingText": "user name|||user#name|||.....",
        "NonMatchingText": "User_Name1|||username@foo.com|||user.name@mail.foo.com",
        "Description": "Used as a username validation script requires:\n1. Allows All Alphanumeric characters &amp; underscore\n2. Allows One &quot;@&quot; character\n3. Allows Five &quot;.&quot; periods\n4. Rejects spaces\n\n"
    },
    {
        "Pattern": "^(Function|Sub)(\\s+[\\w]+)\\([^\\(\\)]*\\)",
        "MatchingText": "Function MyFunc(Arg1, Arg2, Arg3, Arg4)",
        "NonMatchingText": "'This is a comment for MyFunc(Arg1,Arg2,Arg3) and this regexp wouldn't work.",
        "Description": "Updated, changed [\\w]* to [\\w]+ because pattern should not match Sub (), there would be no function name which would be incorrect.\n\nWill extract function declarations from ASP or also VB I assume. Will even capture declarations that break across new lines or ones that use the underscore(line continuation character) in Microsoft's VB, VBA, ASP, etc. Had to put this together to document some code on a project and didn't see anything like it on the web. I hope it helps out anyone else who has to re-engineer ASP or VB code. "
    },
    {
        "Pattern": "^(\\d{1,3},)?(\\d{3},)+\\d{3}(\\.\\d*)?$|^(\\d*)(\\.\\d*)?$",
        "MatchingText": "12 - 12.45 - 12,456,456.45 - ",
        "NonMatchingText": "123,455.45.    - 45,4564,12   - ,12,456",
        "Description": "Validates numbers with commas."
    },
    {
        "Pattern": "^.*[_A-Za-z0-9]+[\\t ]+[\\*&]?[\\t ]*[_A-Za-z0-9](::)?[_A-Za-z0-9:]+[\\t ]*\\(( *[ \\[\\]\\*&A-Za-z0-9_]+ *,? *)*\\).*$",
        "MatchingText": "void helloworld(), FILE *MyClass::getFile(), int getFibbNum (int place)",
        "NonMatchingText": "getFibbNum(3), int MyNum;, for (int x=1 ... )",
        "Description": "This (while not perfect) locates c++ function declarations.  Useful for working with large source files"
    },
    {
        "Pattern": "^[a-z\\.]*\\s?([a-z\\-\\']+\\s)+[a-z\\-\\']+$",
        "MatchingText": "Miss H Ryan|||Miss Ryan|||Miss Hazel Joanne Ryan",
        "NonMatchingText": "Hazel|||Hazel  Ryan",
        "Description": "Matches Names - written for credit card matching. \nOptional Prefix that can contain a fullstop, one or more forenames that can contain hyphens and apostrophes followed by a surname that can contain hyphens and apostrophes"
    },
    {
        "Pattern": "^((67\\d{2})|(4\\d{3})|(5[1-5]\\d{2})|(6011))-?\\s?\\d{4}-?\\s?\\d{4}-?\\s?\\d{4}|3[4,7]\\d{13}$",
        "MatchingText": "5154-1234-1234-1342|||4444333322221111|||6767 1111 1111 1111",
        "NonMatchingText": "1234123412341234|||1111111|||987654321",
        "Description": "Credit Card Matching - Matches Switch, Solo, Visa, MasterCard and Discover. Matches length and valid prefix. Accepts input optional spaces and dashes between number groups"
    },
    {
        "Pattern": "^((67\\d{2})|(4\\d{3})|(5[1-5]\\d{2})|(6011))(-?\\s?\\d{4}){3}|(3[4,7])\\d{2}-?\\s?\\d{6}-?\\s?\\d{5}$",
        "MatchingText": "4234 1234 1234 1234|||5434123412341234|||3712 123456 12345",
        "NonMatchingText": "1234123412341234|||1111111|||987654321",
        "Description": "Credit Card Validation. Matches Switch/Solo, Visa, MasterCard and Discover in 4-4-4-4/4 4 4 4/4444 format and Amex in 4-6-5/4 6 5/465 format.\nIncludes checks for prefixes, (67 for switch/solo, 4 for visa, 51-55 for MasterCard, 37/34 for Amex and 6011 for Discover. \nMatches all major UK debit and credit cards with spaces dashes or as a continous number"
    },
    {
        "Pattern": "((\\s*([^,{]+)\\s*,?\\s*)*?){((\\s*([^:]+)\\s*:\\s*([^;]+?)\\s*;\\s*)*?)}",
        "MatchingText": "div#main { position:relative; width:809px; margin-left:auto; margin-right:auto; padding:0; }",
        "NonMatchingText": "-----",
        "Description": "will break out a valid CSS stylesheet into it's components.  Groups on each style, all selectors, each selector within a comma delimited list of selectors, all properties, each property set, each property and each value.  In other words, it breaks it all down for you :)  \n\nThe only two problems I'm having with it:\nA) it is ignorant of comment blocks.  so if you have styles within a /*  */ block, it'll pick those up.  \n\nB) the first style following a comment block is not parsed correctly (it incorrectly includes the comment as a selector\n\nbest thing to do would be to use another regexp to remove all comments before processing with this one"
    },
    {
        "Pattern": "(^[a-zA-Z0-9]+://)",
        "MatchingText": "myprot://server/path.asp",
        "NonMatchingText": "server/path.asp",
        "Description": "Use in a .net Regex.Split() to pull the protocol out of a url into the first array entry."
    },
    {
        "Pattern": "^((.*//.*)(.*/ .*)/{1}([^\\\\(){}:\\*\\?<>\\|\\\"\\'])+\\.(csv|jpg|txt|pdf|dat|xls|doc))$",
        "MatchingText": "/usr/local/data/userdata.xls, /home/userdata.doc, /accounts.txt",
        "NonMatchingText": "//usr/local/data/userdata.xls, //usr/local/,/usr/local/ data/users.txt",
        "Description": "This will match with all absolute file paths in Unix/Linux. The extensions added are csv|jpg|txt|pdf|dat|xls|doc. Can be customized for specific extensions."
    },
    {
        "Pattern": "^((\\b[A-Z0-9](\\w)*\\b)|\\s)*$",
        "MatchingText": "Amit Chandrakantbhai Rami",
        "NonMatchingText": "Amit chandrakantbhai Rami",
        "Description": "Validate first letter of each word must capital."
    },
    {
        "Pattern": "(^|\\s|\\()((([1-9]){1}|([0][1-9]){1}|([1][012]){1}){1}[\\/-]((2[0-9]){1}|(3[01]){1}|([01][1-9]){1}|([1-9]){1}){1}[\\/-](((19|20)([0-9][0-9]){1}|([0-9][0-9]){1})){1}(([\\s|\\)|:])|(^|\\s|\\()((([0-9]){1}|([0][1-9]){1}|([1][012]){1}){1}[\\/-](([11-31]){1}|([01][1-9]){1}|([1-9]){1}){1}[\\/-](((19|20)([0-9][0-9]){1}|([0-9][0-9]){1})){1}(([\\s|\\)|:|$|\\&gt;])){1}){1}){1}){1}",
        "MatchingText": "01/01/2001 |||01-01-2001:|||(1-1-01)",
        "NonMatchingText": "13/1/2001|||1-32-2001|||1-1-1801",
        "Description": "Will match the following date formats: Preceded by a Space, Left-parentheses, or at the beginning of a line.  Followed by a Space, Right-parentheses, or Colon(:), word boundary or End of line.  Can have / or - as separator.  Accepts 2 digit year 00-99 or 4 digit years 1900-2099 (can modify to accept any range)"
    },
    {
        "Pattern": "(\\w(\\s)?)+",
        "MatchingText": "Test|||TesT|||tesT9 _test9",
        "NonMatchingText": "\\\\\\",
        "Description": "Used to verify that the string consists of only A-z, 0 - 9 and underscore. Several words allowed, only one space between them. No spaces up front. Hey, I know it's easy, but it was not in the library! Plus, the test option here is not working well all the time."
    },
    {
        "Pattern": "\\x1f\\x8b\\x08\\x00.+\\x00\\x00",
        "MatchingText": "\\x1f\\x8b\\x08\\x00laber\\x00\\x00|||\\x1f\\x8b\\x08\\x00rhababer\\x00\\x00|||\\x1f\\x8b\\x08\\x00gelabere\\x00\\x00",
        "NonMatchingText": "\\x1f\\x8b\\x08\\x01laber\\x00\\x00|||\\x1f\\x8b\\x08\\x00rhababer\\x00\\x01|||\\x1f\\x8b\\x08\\x00ddddd\\x01\\x00",
        "Description": "regexp to get only gzip parts of alfred output.\non a shell you can pipe data which is gzip compressed. \non a Freifunk OPENWRT Gluonbased Router it looks like:\n# /lib/gluon/announce/collect.lua nodeinfo | gzip | alfred -s 158; /lib/gluon/announce/collect.lua statistics | gzip | alfred -s 159; /lib/gluon/announce/collect.lua neighb"
    },
    {
        "Pattern": "^([V|E|J|G|v|e|j|g])([0-9]{5,8})$",
        "MatchingText": "V9123456, E81941",
        "NonMatchingText": "123, sapo, 9123456, V-9123456,",
        "Description": "valida una cedula venezolana:\ncomienza por:\nVEGJ (o vejg)\nsiguiendo con:\nentre 5 a 8 digitos."
    },
    {
        "Pattern": "((?:\\d+\\.){1,5})",
        "MatchingText": "1.|||1.2.|||1.2.3.4.5.",
        "NonMatchingText": "1|||10|||1.2.3.4.5.6.",
        "Description": "Captures numbers like found in legal contracts e.g.:\n1.1. Blah blah 1.1.2. Blah blah blah.\n\nUp to 5 levels - or edit {1,5} qualifier."
    },
    {
        "Pattern": "^((((((((jan(uary)?)|(mar(ch)?)|(may)|(july?)|(aug(ust)?)|(oct(ober)?)|(dec(ember)?)) ((3[01])|29))|(((apr(il)?)|(june?)|(sep(tember)?)|(nov(ember)?)) ((30)|(29)))|(((jan(uary)?)|(feb(ruary)?|(mar(ch)?)|(apr(il)?)|(may)|(june?)|(july?)|(aug(ust)?)|(sep(tember)?)|(oct(ober)?)|(nov(ember)?)|(dec(ember)?))) (2[0-8]|(1\\d)|(0?[1-9])))),? )|(((((1[02])|(0?[13578]))[\\.\\-/]((3[01])|29))|(((11)|(0?[469]))[\\.\\-/]((30)|(29)))|(((1[0-2])|(0?[1-9]))[\\.\\-/](2[0-8]|(1\\d)|(0?[1-9]))))[\\.\\-/])|(((((3[01])|29)[ \\-\\./]((jan(uary)?)|(mar(ch)?)|(may)|(july?)|(aug(ust)?)|(oct(ober)?)|(dec(ember)?)))|(((30)|(29))[ \\.\\-/]((apr(il)?)|(june?)|(sep(tember)?)|(nov(ember)?)))|((2[0-8]|(1\\d)|(0?[1-9]))[ \\.\\-/]((jan(uary)?)|(feb(ruary)?|(mar(ch)?)|(apr(il)?)|(may)|(june?)|(july?)|(aug(ust)?)|(sep(tember)?)|(oct(ober)?)|(nov(ember)?)|(dec(ember)?)))))[ \\-\\./])|((((3[01])|29)((jan)|(mar)|(may)|(jul)|(aug)|(oct)|(dec)))|(((30)|(29))((apr)|(jun)|(sep)|(nov)))|((2[0-8]|(1\\d)|(0[1-9]))((jan)|(feb)|(mar)|(apr)|(may)|(jun)|(jul)|(aug)|(sep)|(oct)|(nov)|(dec)))))(((175[3-9])|(17[6-9]\\d)|(1[89]\\d{2})|[2-9]\\d{3})|\\d{2}))|((((175[3-9])|(17[6-9]\\d)|(1[89]\\d{2})|[2-9]\\d{3})|\\d{2})((((1[02])|(0[13578]))((3[01])|29))|(((11)|(0[469]))((30)|(29)))|(((1[0-2])|(0[1-9]))(2[0-8]|(1\\d)|(0[1-9])))))|(((29feb)|(29[ \\.\\-/]feb(ruary)?[ \\.\\-/])|(feb(ruary)? 29,? ?)|(0?2[\\.\\-/]29[\\.\\-/]))((((([2468][048])|([3579][26]))00)|(17((56)|([68][048])|([79][26])))|(((1[89])|([2-9]\\d))(([2468][048])|([13579][26])|(0[48]))))|(([02468][048])|([13579][26]))))|(((((([2468][048])|([3579][26]))00)|(17((56)|([68][048])|([79][26])))|(((1[89])|([2-9]\\d))(([2468][048])|([13579][26])|(0[48]))))|(([02468][048])|([13579][26])))(0229)))$",
        "MatchingText": "20000229|||000229|||12/31/9999|||Dec 02, 99|||30MAR1753|||Feb 29, 1756|||1.1.2008",
        "NonMatchingText": "21000229|||990229|||12/32/9999|||Xxx 02, 99|||30MAR1752|||Feb 29, 1752|||1.0.2008",
        "Description": "This expression validates most legal dates for a SQL Server 2005 datetime format. It includes checking for leap years. (Written for a default U.S. install, not sure what results would be on versions for different regions)\n\nFor double digit dates, 00 is considered to be the year 2000, so leap years will be valid.\n\nThis will handle dates in the following formats\nyymmdd   \nyyyymmdd \nm/d/yy \nmm/dd/yy\nm/d/yyyy\nmm/dd/yyyy\nm-d-yy\nmm-dd-yy\nm-d-yyyy\nmm-dd-yyyy\nm.d.yy\nmm.dd.yy\nm.d.yyyy\nmm.dd.yyyy\nmmmm dd yy\nmmmm dd yyyy\nmmmm dd, yy\nmmmm dd, yyyy\nmmmm d yy\nmmmm d yyyy\nmmmm d, yy\nmmmm d, yyyy\nd mmmm yy\nd mmmm yyyy\ndd mmmm yy\ndd mmmm yyyy\nd-mmmm-yy\nd-mmmm-yyyy\ndd-mmmm-yy\ndd-mmmm-yyyy\nd.mmmm.yy\nd.mmmm.yyyy\ndd.mmmm.yy\ndd.mmmm.yyyy\nd/mmmm/yy\nd/mmmm/yyyy\ndd/mmmm/yy\ndd/mmmm/yyyy\nmmm dd yy\nmmm dd yyyy\nmmm dd, yy\nmmm dd, yyyy\nmmm d yy\nmmm d yyyy\nmmm d, yy\nmmm d, yyyy\ndd mmm yy\ndd mmm yyyy\nd mmm yy\nd mmm yyyy\nddmmmyy\nddmmmyyyy\ndd-mmm-yy\ndd-mmm-yyyy\nd-mmm-yy\nd-mmm-yyyy\ndd.mmm.yy\ndd.mmm.yyyy\nd.mmm.yy\nd.mmm.yyyy\ndd/mmm/yy\ndd/mmm/yyyy\nd/mmm/yy\nd/mmm/yyyy\n\nNote: This will also handle mixing and matching of separator characters. for example:\n'1/1.2000',\nIt would appear that this is valid in SQL Server 2005.\n\nThis is written to work for ECMA script (include the ignore case parameter i), but should also work in .Net.\n\nI have tested this in firefox 2.0 (Blazing Fast) and IE 7.0 and both seem to work just fine. I have not tested it in .Net.\n\nIt's pretty large and I have not attempted to optimize it. Feel free to optimize it any way you like."
    },
    {
        "Pattern": "^[0-9]{4}\\s{0,2}[a-zA-z]{2}$",
        "MatchingText": "4006 AB|||4006ab|||4006  AB",
        "NonMatchingText": "4006.ab|||4006_ab|||4006/ab",
        "Description": "Dutch postalcode expression. 4 digits followed by max. two spaces end ending on two letters. "
    },
    {
        "Pattern": "^(?i:(?P<local_part>[a-z0-9!#$%^&*{}'`+=-_|/?]+(?:\\.[a-z0-9!#$%^&*{}'`+=-_|/?]+)*)@(?P<labels>[a-z0-9]+\\z?.*[a-z0-9-_]+)*(?P<tld>\\.[a-z0-9]{2,}))$",
        "MatchingText": "my.sub.test.server@sub.host.server.uk.co",
        "NonMatchingText": ".stubs@com|.me@server.com|my..name@server.com",
        "Description": "RFC2822 compliant. Includes all special characters, except for allowance of quoted local-part. Also disallows '.' (period) to be at the front or end of local-part, or occurr more than once consecutively. It does allow for optional infinite number of sub-domains.\n\nThe following standards are not enforced, due to RegExp limitations (unable to check for group string length):\nAs per RFC2821 the local-part may have a maximum length of 64 characters, while the domain name may have a maximum length of 255 characters.\nEach domain label must be between 1 and 63 characters long, while the total length of the domain name may not exceed 255 characters."
    },
    {
        "Pattern": "^[1-9]{1}[0-9]{0,2}([\\.\\,]?[0-9]{3})*$",
        "MatchingText": "1,000|1.000|1|10|100|1000",
        "NonMatchingText": "1,00|1,0|1,,000|.1|10.",
        "Description": "Matches whole numbers with the two most common thousands-separators (comma and period). Will not handle decimals."
    },
    {
        "Pattern": "^(LDAP://([\\w]+/)?(CN=['\\w\\s\\-\\&amp;]+,)*(OU=['\\w\\s\\-\\&amp;]+,)*(DC=['\\w\\s\\-\\&amp;]+[,]*)+)$",
        "MatchingText": "LDAP://MyServer/CN=Peter,OU=Users,DC=dc1,DC=name,DC=com|||LDAP://OU=Dep1,OU=Users,DC=name,DC=com|||L",
        "NonMatchingText": "LDAP:///CN=Peter,OU=Users,DC=dc1,DC=name,DC=com|||LDAP://myserver1/myserver2/MyServer/CN=Peter,OU=Us",
        "Description": "LDAP path of Microsoft Active Directory entries (Organizational Units, Users, Computers and Groups). Requires LDAP protocol especification and allows a server name at the beginning."
    },
    {
        "Pattern": "^1?[1-2]$|^[1-9]$|^[1]0$",
        "MatchingText": "1|||6|||12",
        "NonMatchingText": "-1|||0|||13",
        "Description": "Get one and two numeric digits between 1 and 12 inclusive, positive numbers only (Zeros are excluded and so is values higher than 12)."
    },
    {
        "Pattern": "^[0-9]*$",
        "MatchingText": "2|||99|||15800",
        "NonMatchingText": "1,2|||f9|||a9j",
        "Description": "Matches only numbers, in any length. No characters or punctuation will be matched."
    },
    {
        "Pattern": "[+-]*[0-9]+[,]*[0-9]*|[+-]*[0-9]*[,]+[0-9]*",
        "MatchingText": "6,32 -409,00 -,0 -, ,05 +, +,0198 +, ,",
        "NonMatchingText": "8- 23+ 12.1  .01 0.0",
        "Description": "This Regex is usefull to validate if the text typed will still lead to a valid number for a international input.\nReplace , with \\. to get an american notation"
    },
    {
        "Pattern": "^((CN=(['\\w\\d\\s\\-\\&amp;\\.]+(\\\\/)*(\\\\,)*)+,\\s*)*(OU=(['\\w\\d\\s\\-\\&amp;\\.]+(\\\\/)*(\\\\,)*)+,\\s*)*(DC=['\\w\\d\\s\\-\\&amp;]+[,]*\\s*){1,}(DC=['\\w\\d\\s\\-\\&amp;]+\\s*){1})$",
        "MatchingText": "CN=John Smith, OU=Acc, DC=acme, DC=com|||CN=John\\, Smith US\\/EXT, OU=Acc, DC=acme ,DC=com",
        "NonMatchingText": "CN=John Smith, OU=Acc, DC=acme|||CN=John\\, Smith\\, OU=Acc, DC=acme, DC=com",
        "Description": "Matches LDAP path (AdsPath) in Active Directory. Modified version of regex which has been found in library. \nAccepts spaces after , character. Also \\/ and \\, sequences (escapes) in CN or OU name are accepted."
    },
    {
        "Pattern": "^[a-z0-9_.-]*@[a-z0-9-]+(.[a-z]{2,4})+$",
        "MatchingText": "test@abc.com.nl ||| test.new@mail-ex.com ||| test@at.ta",
        "NonMatchingText": "test@abc..com ||| test@a.a ||| test^@hello.com",
        "Description": "Validates your average email, it will not allow two periods to be placed adjacent to one another.\n\nDo note that there is no perfect expression."
    },
    {
        "Pattern": "(^[0][2][1579]{1})(\\d{6,7}$)",
        "MatchingText": "0211234567 025123456 027123456 029123456",
        "NonMatchingText": "(021)1234567 028282828 09828288",
        "Description": "This pattern matches the New Zealand mobile phone number. Only 021 025 027 029 number are matched."
    },
    {
        "Pattern": "^[-+]?(\\d?\\d?\\d?,?)?(\\d{3}\\,?)*$",
        "MatchingText": "+1|||-2|||3,000|||1,234,567",
        "NonMatchingText": "A|||1,23||2,34,567|||1.0",
        "Description": "This pattern matches on Integer values.  Handles leading positive or negative signs.  Supports commas where only the leading group can have less than three digits."
    },
    {
        "Pattern": "^[-+]?(\\d?\\d?\\d?,?)?(\\d{3}\\,?)*(\\.?\\d+)$",
        "MatchingText": "+1.0||-3||1,234.00||1,234,567",
        "NonMatchingText": "A||1,23||1,23,456",
        "Description": "This pattern matches decimal values.  It supports option leading positive or negative symbols.  Supports commas where only the leading group can have less than three numbers.  "
    },
    {
        "Pattern": "((&quot;|')[a-z0-9\\/\\.\\?\\=\\&amp;]*(\\.htm|\\.asp|\\.php|\\.jsp)[a-z0-9\\/\\.\\?\\=\\&amp;]*(&quot;|'))|(href=*?[a-z0-9\\/\\.\\?\\=\\&amp;&quot;']*)",
        "MatchingText": "href=&quot;produktsida.asp?kategori2=218&quot;|||href=&quot;NuclearTesting.htm&quot;",
        "NonMatchingText": "U Suck",
        "Description": "Will locate an URL in a webpage.\nIt'll search in 2 ways - first it will try to locate a href=, and then go to the end of the link. If there is nu href=, it will search for the end of the file instead (.asp, .htm and so on), and then take the data between the &quot;xxxxxx&quot; or 'xxxxxx'"
    },
    {
        "Pattern": "^(sip|sips):.*\\@((\\d{1,3}.\\d{1,3}.\\d{1,3}.\\d{1,3})|([a-zA-Z\\-\\.]+\\.[a-zA-Z]{2,5}))(:[\\d]{1,5})?([\\w\\-?\\@?\\;?\\,?\\=\\%\\&]+)?",
        "MatchingText": "sip:778@190.00.00.009:789?7893=003",
        "NonMatchingText": "sip:D@cat",
        "Description": "A SIP regex."
    },
    {
        "Pattern": "(01*0|1)*",
        "MatchingText": "0011010010",
        "NonMatchingText": "10",
        "Description": "A string of even zeros and any number of ones anywhere."
    },
    {
        "Pattern": "^[\"a-zA-Z0-9\\040]+$",
        "MatchingText": "2 words \"Search String\"",
        "NonMatchingText": "hi' or 1=1--",
        "Description": "Accepts words or quoted phrases for search strings. Stops SQL injection."
    },
    {
        "Pattern": "^\\s*(([/-9!#-'*+=?A-~-]+(?:\\.[/-9!#-'*+=?A-~-]+)*|\"(?:[^\"\\r\\n\\\\]|\\\\.)*\")@([A-Za-z][0-9A-Za-z-]*[0-9A-Za-z]?(?:\\.[A-Za-z][0-9A-Za-z-]*[0-9A-Za-z]?)*|\\[(?:[^\\[\\]\\r\\n\\\\]|\\\\.)*\\]))\\s*$",
        "MatchingText": "user@example.com|user+sub@example.com|\"user name\"@example.com|user@[192.0.2.4]",
        "NonMatchingText": "no_at_sign|invalid...adjacent_dots@example.com|no quote@example.com|user@192.0.2.4",
        "Description": "This validates against the RFC 2821 (SMTP) syntax unit 'Mailbox' [equiv. to addr-spec - not address - element of RFC 2822] (the one a certain critic keeps linking to validates the RFC822 'address' element which includes support for stuff like \"Group:User <address>,User <address>;\", obsolete smtp routing syntax like <@host1,@host2:user@host>, etc)\n\nThere are some differences. This version does not allow line breaks for continuation lines. It also applies the stricter standards of RFC 2821 (SMTP) to the domain portion of the address.\n\nUsername may be a quoted string (but not \"multiple\".\"quoted\".\"strings\" - RFC 2822's grammar appears to allow this but the SMTP grammar does not). Also only one piece enclosed in [Brackets] (for IP email addresses) is allowed in the domain; that is you can't have user@[1.2.3.4].[5.6.7.8] as implied by the RFC2822 but not SMTP. Whitespace is only allowed in quoted strings. It is silently ignored at the beginning or end.\n\nCapture group 1 is the email address, group 2 is the username, group 3 is the domain."
    },
    {
        "Pattern": "^\\(0[1-9]{1}\\)[0-9]{8}$",
        "MatchingText": "(02)12341234|||(03)12341234|||(05)12341234",
        "NonMatchingText": "00 1234 1234|||00-1234-1234|||(00)12341234",
        "Description": "This is used to validate an Australian telephone number with no other characters than the () being used. Validates area code being between 01 - 09."
    },
    {
        "Pattern": "[A-Za-z]{1,2}[\\d]{1,2}[A-Za-z]{0,1}",
        "MatchingText": "AA9A 9AA ||| A9A 9AA ||| A9 9AA ||| A99 9AA ||| AA9 9AA ||| AA99 9AA ||| EC1A 1BB ||| W1A 1HQ ||| M1 1AA ||| B33 8TH ||| CR2 6XH ||| DN55 1PT",
        "NonMatchingText": "SAN TA1 ||| GIR 0AA",
        "Description": "The postcode district is the first block of a UK postcode. For example with DN55 1PT it would match DN55. Its a loose match as it only ensures that the format is correct, it doesn't validate the letters and numbers. It doesn't let in the non-geographic codes postcodes SAN TA1 and GIR 0AA. It will pull out the first block of any of the matching examples below. Examples of the names of the different parts of a UK postcode can be found here: http://en.wikipedia.org/wiki/Postcodes_in_the_United_Kingdom#Life-cycle_of_post_codes"
    },
    {
        "Pattern": "[A-Za-z]{1,2}[\\d]{1,2}[A-Za-z]{0,1}\\s*[\\d]",
        "MatchingText": "AA9A 9AA ||| A9A 9AA ||| A9 9AA ||| A99 9AA ||| AA9 9AA ||| AA99 9AA ||| EC1A 1BB ||| W1A 1HQ ||| M1 1AA ||| B33 8TH ||| CR2 6XH ||| DN55 1PT ||| AA9A9AA  ||| A9A9AA ||| A99AA ||| A999AA ||| AA99AA ||| AA999AA",
        "NonMatchingText": "SAN TA1 ||| GIR 0AA",
        "Description": "The postcode sector is the first block (the postcode district) of a UK postcode plus the first number of the second block. For example with DN55 1PT it would match DN55 1. Its a loose match as it only ensures that the format is correct, it doesn't validate the letters and numbers. It doesn't let in the non-geographic codes postcodes SAN TA1 and GIR 0AA. It will pull out the first block & the sector code of any of the matching examples below. Examples of the names of the different parts of a UK postcode can be found here: http://en.wikipedia.org/wiki/Postcodes_in_the_United_Kingdom#Life-cycle_of_post_codes"
    },
    {
        "Pattern": "^([A-z]{2}\\d{7})|([A-z]{4}\\d{10})$",
        "MatchingText": "AA1234567 ||| AAAA1234567890",
        "NonMatchingText": "non ||| matching ||| examples",
        "Description": "UK Parcelforce delivery tracking code for internal UK posts. Comes in two formats 2 letters and 7 numbers (e.g. AA1234567) and 4 letters and 10 numbers (e.g. AAAA1234567890). Case insensitive."
    },
    {
        "Pattern": "^([A-z]{2}\\d{9}[Gg][Bb])|(\\d{12})$",
        "MatchingText": "AA123456789GB ||| 123456789012",
        "NonMatchingText": "non ||| matching ||| examples",
        "Description": "UK Parcelforce delivery tracking code for international tracking of exports. Comes in two formats: 2 letters and 9 numbers and GB (e.g. AA123456789GB) and 12 numbers (e.g. 123456789012). Case insensitive."
    },
    {
        "Pattern": "^[A-z]{2}\\d{9}([Gg][Bb])[A-z]{2}$",
        "MatchingText": "AA123456789AA",
        "NonMatchingText": "AA123456789GB ||| AA123456789gb ||| AA123456789Gb ||| AA123456789gB",
        "Description": "UK Parcelforce delivery tracking  code for international tracking of imports. Uses a negative look ahead to prevent it ending in GB which would be an international export code."
    },
    {
        "Pattern": "^(?P<ParcelForceUK>(?:[A-z]{2}\\d{7})|(?:[A-z]{4}\\d{10}))$|^(?P<ParcelForceExport>(?:[A-z]{2}\\d{9}[Gg][Bb])|(?:\\d{12}))$|^(?P<ParcelForceImport>[A-z]{2}\\d{9}([Gg][Bb])[A-z]{2})$",
        "MatchingText": "AA1234567 ||| AAAA1234567890 ||| AA123456789GB ||| 123456789012 ||| AA123456789AA",
        "NonMatchingText": "non ||| matching ||| examples",
        "Description": "A combined version of my other three Parcelforce tracking code regexes listed on this site. Uses named capture groups to capture and identify  between UK tracking, international export and international import tracking codes. Case insensitive."
    },
    {
        "Pattern": "^(?:[A-z]{2})?\\d{9}(?:[A-z]{2})?$",
        "MatchingText": "123456789 ||| GE123456781WW",
        "NonMatchingText": "non ||| matching ||| examples",
        "Description": "TNT UK delivery company consignment number tracking code for TNT Track and Trace service. The system will use the 9 digit code (e.g. 123456789) or you can use the letters as shown on your consignment note (e.g. GE123456781WW). Case insensitive."
    },
    {
        "Pattern": "^(?:1[Zz])(?P<ShipperNumber>[A-z\\d]{6})(?P<ServiceCode>[A-z\\d]{2})(?P<PackageId>\\d{8})$",
        "MatchingText": "1z5475953256813457 ||| 1Z9999999999999999",
        "NonMatchingText": "non ||| matching ||| examples",
        "Description": "Uses named capture groups to extract components. More information on the components meanings can be found on the wikipedia page list in the source."
    },
    {
        "Pattern": "^(?P<ServiceCode>[A-z]{2})(?P<ParcelNumber>\\d{8})(?P<CheckDigit>\\d{1})(?P<IsoCountryCode>[A-z]{2})$",
        "MatchingText": "AA473124829GB",
        "NonMatchingText": "non ||| matching ||| examples",
        "Description": "Uses named capture groups to parse an S10 (UPU standard) code which is the tracking format used by many postal services including the United States Postal Service and most European Postal Services. Full spec in source link."
    },
    {
        "Pattern": "([A-PR-UWYZa-pr-uwyz]([0-9]{1,2}|([A-HK-Ya-hk-y][0-9]|[A-HK-Ya-hk-y][0-9]([0-9]|[ABEHMNPRV-Yabehmnprv-y]))|[0-9][A-HJKS-UWa-hjks-uw]))",
        "MatchingText": "LN5 ||| SW1 ||| ln5",
        "NonMatchingText": "ln5 7nq ||| GIR ||| SAN",
        "Description": "Matches the first part of a UK Postcode (known as a postcode district).\n\nCase insensitive.\n\nDoesnt match:\nGIR # the postcode for the formerly Post Office-owned Girobank is GIR 0AA.\nSAN # the postcode for correctly addressed letters to Father Christmas is SAN TA1"
    },
    {
        "Pattern": "^http[s]?://twitter\\.com/(#!/)?[a-zA-Z0-9]{1,15}[/]?$",
        "MatchingText": "http://twitter.com/rtpharry/ ||| http://twitter.com/rtpharry ||| https://twitter.com/rtpharry/ ||| https://twitter.com/rtpharry ||| http://twitter.com/#!/rtpharry/",
        "NonMatchingText": "http://www.twitter.com/wwwprefix/ ||| http://twitter.com/longerthan15characters/ ||| http://twitter.com/illegal$chars/",
        "Description": "Allows http and https, bans www prefix, username portion is clamped to the rules it gives you at signup and also allows an optional trailing slash. [UPDATED] allows the #! notation that twitter used."
    },
    {
        "Pattern": "http[s]?://(www|[a-zA-Z]{2}-[a-zA-Z]{2})\\.facebook\\.com/(pages/[a-zA-Z0-9\\.-]+/[0-9]+|[a-zA-Z0-9\\.-]+)[/]?$",
        "MatchingText": "http://www.facebook.com/pages/Andy-Worthington/196377860390800 ||| http://en-gb.facebook.com/pages/Andy-Worthington/196377860390800 ||| http://www.facebook.com/pages/  ||| http://www.facebook.com/coca-cola/ ||| http://www.facebook.com/thesimpsons/",
        "NonMatchingText": "http://facebook.com/pages/Andy-Worthington/196377860390800 ||| www.facebook.com/pages/Andy-Worthington/196377860390800 ||| http://www.facebook.com/people/Andy-Worthington/738143803",
        "Description": "Validating a Facebook page can be a little bit tricky. This is because there are two valid formats. The first is facebook.com/pages/USERNAME/numbers/, the second is designed for big business which grants them a clean url such as facebook.com/coca-cola/.  I see this regex being used in a user profile admin page and I think it does a good enough job for this purpose. The problem is bad urls could slip through which meet the criteria for the clean facebook page url but aren't in valid pages on the site. \nThe main example being that an incomplete numbered url could slip through as http://www.facebook.com/pages/ would validate. Facebook also uses various subdomains such as en-gb.facebook.com to provide localised versions of the site. This regex will accept a prefix of either www or a locale code of two letters dash two letters. It doesn't validate the actual country code though.\n\n[UPDATED] Added full stop to list of valid characters for page names."
    },
    {
        "Pattern": "^(^(5|15|18|30)$)\\d+$",
        "MatchingText": "1 ||| 325 ||| 515 ||| 300",
        "NonMatchingText": "5 ||| 15 ||| 18 ||| 30",
        "Description": "Because a regular expression only deals with a single character at a time it can be a challenge to work with numbers as they often contain multiple digits. This regex allows any number except the numbers in the list. It does this by using a negative look ahead to fail the regex if it finds an excluded number."
    },
    {
        "Pattern": "^UA-\\d+-\\d+$",
        "MatchingText": "UA-686645-1 ||| UA-71354555-50 ||| UA-1-1",
        "NonMatchingText": "UA-686645-1DD ||| UA-68DD6645-1 ||| GA-686645-1",
        "Description": "This is an intentionally loose implementation. The number in the middle (account num) is constantly increasing as new accounts are made. The number on the end represents the profile number which shouldn't go over 50 but I haven't locked this down so that both elements are future proofed."
    },
    {
        "Pattern": "(?:\\?=.*)?$",
        "MatchingText": "?with=querystring ||| ||| ?with=multiple&query=strings",
        "NonMatchingText": "?with=querystring#fragment",
        "Description": "Add this on to the end of your url rewriting regex to allow an optional querystring to be appended to whatever you are matching. Useful for example when you set up a Google PPC campaign and all of your urls break. Note: doesn't handle #fragments."
    },
    {
        "Pattern": "^~/(?:default\\.aspx)?(?:\\?=.*)?$",
        "MatchingText": "/default.aspx ||| /default.aspx?query=string ||| / ||| /?query=string",
        "NonMatchingText": "/default.aspx#fragment ||| /default.aspx?query=string#fragment ||| /#fragment ||| /?query=string#fragment",
        "Description": "Designed for asp.net default document matching. It allows either a plain url (~/) or a default document url (~/default.aspx) both with an optional querystring. Cassini and IIS7 handle default document matching differently. The user could type it either way. The breadcrumb / sitemap system is funny about omitting default.aspx. Note: Doesn't handle #fragements"
    },
    {
        "Pattern": "^[1-9]{1,2}(.5)?$",
        "MatchingText": "1.5 ||| 99.5 ||| 35.5 ||| 43 ||| 64 ||| 24",
        "NonMatchingText": ".5 ||| 100 ||| 0 ||| 0.5 ||| 34.3 ||| 24.356 ||| 36.55",
        "Description": "This is a simple regular expression which allows 1 to 99 in .5 increments which I originally developed for a forum post"
    },
    {
        "Pattern": ":(6553[0-5]|655[0-2][0-9]\\d|65[0-4](\\d){2}|6[0-4](\\d){3}|[1-5](\\d){4}|[1-9](\\d){0,3})",
        "MatchingText": ":1 ||| :65535 ||| :2546",
        "NonMatchingText": ":99999 ||| :0684 ||| :2ab23",
        "Description": "This was based on the regex in the source but it was buggy so I fixed it and then optimized it.\n\nIt matches port numbers in the form of :1 to :65535\n\nThis is designed to be plugged onto the end of your favourite url regex because when I was looking for a IPv4 regex I noticed that a lot of them either didn't match the port or matched it badly (allowing the port number to start with a 0 or be higher than 65535)\n\nThis regex solves those two problems."
    },
    {
        "Pattern": "(:(6553[0-5]|655[0-2][0-9]\\d|65[0-4](\\d){2}|6[0-4](\\d){3}|[1-5](\\d){4}|[1-9](\\d){0,3}))?",
        "MatchingText": ":1 ||| :65535 ||| :2546 ||| no port entered",
        "NonMatchingText": ":99999 ||| :0684 ||| :2ab23",
        "Description": "This is the same as my regex listed in the source except that it is wrapped in (regex)? which makes it optional. The intended use for this regex is to be combined with buggy url/ip regex's to strengthen the port matching. It matches port numbers in the form of :1 to :65535 and also allows no port to be entered. I noticed that a lot of url/ip regexs either didn't match the port or matched it badly (allowing the port number to start with a 0 or be higher than 65535) This regex solves those two problems."
    },
    {
        "Pattern": "^(02\\d\\s?\\d{4}\\s?\\d{4})|((01|05)\\d{2}\\s?\\d{3}\\s?\\d{4})|((01|05)\\d{3}\\s?\\d{5,6})|((01|05)\\d{4}\\s?\\d{4,5})$",
        "MatchingText": "020 1234 5678 ||| 0123 4567890 ||| 01234 456789 ||| 05234 456789",
        "NonMatchingText": "02476 123456 ||| 0845 123456 ||| 07712 345678 ||| 0800 100 2496",
        "Description": "Based on the source listed below. I have added in the 05 prefix for allowing UK voip landlines. I dont know if the spacings are all ofcom approved like the original regex but the patterns it supports are:\n\n029 99999999 or 029 9999 9999; 0199 9999999 or 0199 999 9999; 01999 99999; 01999 999999; 019999 9999; 019999 99999; 0599 9999999 or 0599 999 9999; 05999 99999; 05999 999999; 059999 9999; 059999 99999;"
    },
    {
        "Pattern": "^[\\d]{4}[-\\s]{1}[\\d]{3}[-\\s]{1}[\\d]{4}$",
        "MatchingText": "0800 333 4444 ||| 0870-333-4444 ||| 0844 333-4444",
        "NonMatchingText": "08003334444 ||| 0800=333=4444 ||| 0800  333  4444",
        "Description": "Allows dashes or spaces to separate."
    },
    {
        "Pattern": "^[\\d]{5}[-\\s]{1}[\\d]{3}[-\\s]{1}[\\d]{3}$",
        "MatchingText": "08000 333 333 ||| 08700-333-333 ||| 08440 333-333",
        "NonMatchingText": "08000333333 ||| 08000=333=333 ||| 08000  333  333",
        "Description": "Allows dashes or spaces to separate."
    },
    {
        "Pattern": "^[\\d]{5}[-\\s]{1}[\\d]{2}[-\\s]{1}[\\d]{2}[-\\s]{1}[\\d]{2}$",
        "MatchingText": "08000 22 22 22 ||| 08700-22-22-22 ||| 08440 22-22-22",
        "NonMatchingText": "08000222222 ||| 08000=22=22=22 ||| 08000  22  22  22",
        "Description": "Allows dashes or spaces to separate."
    },
    {
        "Pattern": "^[\\d]{5}[-\\s]{1}[\\d]{4}[-\\s]{1}[\\d]{2}$",
        "MatchingText": "0800 4444 22 ||| 0870-4444-22 ||| 0844 4444-22",
        "NonMatchingText": "0800444422 ||| 0800=4444=22 ||| 0800  4444  22",
        "Description": "Allows dashes or spaces to separate."
    },
    {
        "Pattern": "^[\\d]{5}[-\\s]{1}[\\d]{2}[-\\s]{1}[\\d]{4}$ ",
        "MatchingText": "0800 22 4444 ||| 0870-22-4444 ||| 0844 22-4444",
        "NonMatchingText": "0800224444 ||| 0800=22=4444 ||| 0800  22  4444",
        "Description": "Allows dashes or spaces to separate."
    },
    {
        "Pattern": "^[0-9]{1,15}(\\.([0-9]{1,2}))?$",
        "MatchingText": "1 ||| 123456789012345 ||| 123456789012345.1 ||| 123456789012345.12 ||| 123456.12",
        "NonMatchingText": ".12 ||| 12345.123 ||| 1234567890123456",
        "Description": "This might seem like a contrived example but it was written to answer a question on a forum. For regex newbies you can just change the numbers in {} to change the number of required digits to suit your requirements"
    },
    {
        "Pattern": "^http\\://www.[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}/$",
        "MatchingText": "http://www.somedomain.co.uk/ ||| http://www.somedomain.com/ ||| http://www.dodgydomain.com.com/",
        "NonMatchingText": "http://www.somedomain.co.uk/withpath.aspx ||| http://somedomainwithoutwww.co.uk ||| http://www.com/ ||| www.noprotocolprefix.com/ ||| https://www.secureprotocolprefix.com/ ||| http://www.notrailingslash.co.uk ||| HTTP://WWW.beginswithcaps.com/",
        "Description": "This regex only matches clean domain names. No path after. Ends in a forward slash. Starts with http://www. It is pretty slack on the TLD requiring a 2 or 3 letter ending. This part could be tightened up if you wanted to be restrict it to specific TLDs."
    },
    {
        "Pattern": "^(\\d){2}-(\\d){2}-(\\d){2}$",
        "MatchingText": "20-40-36 ||| 50-25-48 ||| 45-85-66",
        "NonMatchingText": "204036 ||| 2564584 ||| 444-58-54 ||| 45/45/85",
        "Description": "Validates the format of a UK bank sort code."
    },
    {
        "Pattern": "^(\\d){8}$",
        "MatchingText": "08464524 ||| 45832484 ||| 24899544",
        "NonMatchingText": "1234567 ||| 1 5 2226 44 ||| 123456789",
        "Description": "UK Bank account numbers are 8 digits. One bank uses 7 digits so in the validation error message you should instruct the user to prefix with a zero of their code is too short. If you want to allow the 7 digit codes as well use this regex: http://regexlib.com/REDetails.aspx?regexp_id=2707"
    },
    {
        "Pattern": "^(\\d){7,8}$",
        "MatchingText": "1234567 ||| 12345678",
        "NonMatchingText": "123456 ||| 123 4567 ||| 123456789",
        "Description": "UK Bank Account. One bank account issues 7 digit bank codes and you should prefix a 0 yourself after input. If you want strict validation of 8 characters use this regex: http://regexlib.com/REDetails.aspx?regexp_id=2706"
    },
    {
        "Pattern": "^(?P<user>.+)@(?P<domain>.+)$",
        "MatchingText": "bill@microsoft ||| peter.gibbons@initech ||| blackbeard@jollyroger",
        "NonMatchingText": "bil+microsoft ||| microsoft\\bill",
        "Description": "This uses named groups to extract the user and domain portions of an Active Directory user in user@domain format.\n\nYou can use the following c# code to convert this into domain\\user format:\n\npublic string ConvertUserAtDomainToDomainUser(string userAtDomain)\n{\n    return Regex.Replace(userAtDomain,\n            @\"^(?<user>.+)@(?<domain>.+)$\",\n            @\"${domain}\\${user}\");\n}\n\nThis regex is intended to provide extraction from valid user@domain strings rather than validate its format."
    },
    {
        "Pattern": "^[a-z][a-z0-9\\.,\\-_]{5,31}$",
        "MatchingText": "ASd_RT45326FR",
        "NonMatchingText": "ASd_@#$*&(",
        "Description": "Validate for Skype Name:\nmust be between 6-32 characters, start with a letter and contain only letters and numbers (no spaces or special characters)."
    },
    {
        "Pattern": "(?m)^(?P<scheme>\\w+?://)?(?P<path>(?:[\\w.%$\\-_+!*'(),=@]+\\/|\\b)+(?:[\\w.%$\\-_+!*'(),=@]*))(?P<query>\\?(?:[\\w.%$\\-_+!*'(),=@]+=[\\w.%$\\-_+!*'(),=@]*&?)*)?(?P<fragment>#[\\w\\.%$\\-_+!*'(),=@]*)?",
        "MatchingText": "http://regexlib.com/",
        "NonMatchingText": "~~~~",
        "Description": "Identifies scheme, path, query, and fragment in any URI, putting them into named groups. All groups are optional except path."
    },
    {
        "Pattern": "(?s)<tr[^>]*>(?P<content>.*?)</tr>",
        "MatchingText": "<tr><td>abc</td></tr>",
        "NonMatchingText": "<tr><td>abc</td>",
        "Description": "Matches complete table rows (<tr>...</tr>) and puts everything between the tr tags into a group named \"content\"."
    },
    {
        "Pattern": "&lt;!--[\\s\\S]*?--[ \\t\\n\\r]*&gt;",
        "MatchingText": "&lt;!-- anything --    &gt;|||&lt;!-- anything -&gt; -&gt; --&gt;",
        "NonMatchingText": "&lt;!-- something -- and more &gt;",
        "Description": "As I could understand the HTML standard, this is the valid reg.exp. for comments.\nThe only differenc from the last one is that the comment can be terminated by two minuses followed by none OR SOME space caracters and then by character &gt;"
    },
    {
        "Pattern": "^0(((1[0-9]{2}[ -]?[0-9]{3}[ -]?[0-9]{4})|(1[0-9]{3}[ -]?[0-9]{6})|(1[0-9]{4}[ -]?[0-9]{4,5}))|((1[0-9]1)|(11[0-9]))[ -]?[0-9]{3}[ -]?[0-9]{4}|(2[0-9][ -]?[0-9]{4}[ -]?[0-9]{4})|((20[ -]?[0-9]{4})|(23[ -]?[8,9][0-9]{3})|(24[ -]?7[0-9]{3})|(28[ -]?(25|28|37|71|82|90|92|95)[0-9]{2})|(29[ -]?2[0-9]))[ -]?[0-9]{4}|(7[4-9][0-9]{2}[ -]?[0-9]{6})|((3[0,3,4,7][0-9])[ -]?[0-9]{3}[ -]?[0-9]{4})|((5[5,6][ -]?[0-9]{4}[ -]?[0-9]{4})|(500[ -]?[0-9]{3}[ -]?[0-9]{4}))|(8[0247][0-9]{1}[ -]?[0-9]{3}[ -]?[0-9]{4})|(9[0-9]{2}[ -]?[0-9]{3}[ -]?[0-9]{4}))$",
        "MatchingText": "020 1234 1234 | 020-1234-1234 | 02012341234 | 01234 123456 | 012345 1234",
        "NonMatchingText": "0201 234 1234 | 0201-234-1234 | 0201234123 | 012341 23456 | 0123451 234 | 00000 000000",
        "Description": "Follows http://en.wikipedia.org/wiki/Telephone_numbers_in_the_United_Kingdom\nmust have a specific length and be a valid telephone number in the UK\nMust start with a 0, have included 01 02 03 05 08 numbers. character spacing have be \" \", \"-\",\naccepts 01 02 03 05 07 08 numbers, rejects everything else."
    },
    {
        "Pattern": "^([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$",
        "MatchingText": "www.myurl.com ||| myurl.com/default.aspx?i=id ||| www3.myurl.com/?a",
        "NonMatchingText": "www.my url.com ||| myurl.com/default.aspx?i=1 2 3 ||| www3.myurl.com?a ||| http://myurl.com",
        "Description": "Use this expression to check that a valid web address is used without any protocol."
    },
    {
        "Pattern": "/^([a-zA-Z0-9])(([\\-.]|[_]+)?([a-zA-Z0-9]+))*(@){1}([a-z0-9]|([a-z0-9][\\-]))+[.]{1}(([a-z]{2,3})|([a-z]{2,3}[.]{1}[a-z]{2,3}))$/",
        "MatchingText": "aa@abc.com,aa@abc.co.in,aa@aa-bb.com,aa.bb@abc.com,aa-bb@abc.com,aa_bb@abc.com",
        "NonMatchingText": "aaa@abc.co.in.co,aaa@abc.com.sg121",
        "Description": "This expression will validates most of the email formats."
    },
    {
        "Pattern": "/^([a-zA-Z0-9])(([\\-.]|[_]+)?([a-zA-Z0-9]+))*(@){1}[a-z0-9]+[.]{1}(([a-z]{2,3})|([a-z]{2,3}[.]{1}[a-z]{2,3}))$/",
        "MatchingText": "a@abc.com,a@abc.co.in,aa.bb@abc.com.sg,aa_bb@abc.biz,aa.C.bb@abc.com,aa_1900@abc.co.in",
        "NonMatchingText": "@abc.com,a@abc.co.in.in,a@abc.com.in.in,a@a-b-c.com",
        "Description": "This expresssion will validate all possible formats except if web site URL contains hyphen characters like aa@a-b-c.com. I will include this feature also in next version."
    },
    {
        "Pattern": "(http|https)\\:\\/\\/(([\\d]{1,3}\\.[\\d]{1,3}\\.[\\d]{1,3}\\.[\\d]{1,3})|([\\w\\-]+\\.)+(((af|ax|al|dz|as|ad|ao|ai|aq|ag|am|aw|au|at|az|bs|bh|bd|bb|by|be|bz|bj|bm|bt|bo|ba|bw|bv|br|io|bn|bg|bf|kh|cm|ca|cv|ky|cf|td|cl|cn|cx|cc|km|cg|cd|ck|cr|ci|hr|cu|cy|cz|dk|dj|dm|do|ec|eg|sv|gq|er|ee|et|fk|fo|fj|fi|fr|gf|pf|tf|ga|gm|ge|de|gh|gi|gr|gl|gd|gp|gu|gt| gg|gn|gw|gy|ht|hm|va|hn|hk|hu|is|id|ir|iq|ie|im|il|it|jm|jp|je|jo|kz|ke|ki|kp|kr|kw|kg|la|lv|lb|ls|lr|ly|li|lt|lu|mo|mk|mg|mw|my|mv|ml|mt|mh|mq|mr|yt|mx|fm|md|mc|mn|ms|ma|mz|mm|nr|np|nl|an|nc|nz|ni|ng|nu|nf|mp|no|om|pk|pw|ps|pa|pg|py|pe|ph|pn|pl|pt|qa|re|ro|ru|rw|sh|kn|lc|pm|vc|ws|sm|st|sa|sn|cs|sc|sl|sg|sk|si|sb|so|za|gs|es|lk|sd|sr|sj|sz|se|ch|sy|tw|tj|tz|th|tl|tg|tk|to|tt|tn|tr|tm|tc|tv|ug|ua|gb|us|um|uy|uz|vu|ve|vn|vg|vi|wf|eh|ye|zm|zw|uk|com|edu|gov|int|mil|net|org|biz|info|name|pro|aero|coop|museum|arpa|co|in|ne|bi|na|pr|ae|mu|ar))))(:[\\d]{1,4})?($|(\\/([a-zA-Z0-9\\.\\?=/#%&\\+-])*)*|\\/)",
        "MatchingText": "http://www.gianlucaesposito.it, http://www.gianluca.esposito.it, http://www.gianluca-esposito.it, http://www.gianlucaesposito.it/, http://www.gianlucaesposito.it/index.html, http://www.gianlucaesposito.it/index.php?id=1, http://www.gianlucaesposito.it:8080, http://www.gianlucaesposito.it:8080/, http://www.gianlucaesposito.it:8080/index.html, http://127.0.0.1, http://127.0.0.1:8080/, http://127.0.0.1:8080/index.html",
        "NonMatchingText": "http://www.gianlucaesposito.xx, http://www.gianluca-esposito.yy, http://www.gianluca.esposito.zzz",
        "Description": "An URL validation pattern with respect for TLD domains. It also validates ip urls, but it doesn't check for ip single parts range (1-255). It supports port specification."
    },
    {
        "Pattern": "([\\w\\-\\.]*)@(([\\d]{1,3}\\.[\\d]{1,3}\\.[\\d]{1,3}\\.[\\d]{1,3})|([\\w\\-]+\\.)+(((af|ax|al|dz|as|ad|ao|ai|aq|ag|am|aw|au|at|az|bs|bh|bd|bb|by|be|bz|bj|bm|bt|bo|ba|bw|bv|br|io|bn|bg|bf|kh|cm|ca|cv|ky|cf|td|cl|cn|cx|cc|km|cg|cd|ck|cr|ci|hr|cu|cy|cz|dk|dj|dm|do|ec|eg|sv|gq|er|ee|et|fk|fo|fj|fi|fr|gf|pf|tf|ga|gm|ge|de|gh|gi|gr|gl|gd|gp|gu|gt| gg|gn|gw|gy|ht|hm|va|hn|hk|hu|is|id|ir|iq|ie|im|il|it|jm|jp|je|jo|kz|ke|ki|kp|kr|kw|kg|la|lv|lb|ls|lr|ly|li|lt|lu|mo|mk|mg|mw|my|mv|ml|mt|mh|mq|mr|yt|mx|fm|md|mc|mn|ms|ma|mz|mm|nr|np|nl|an|nc|nz|ni|ng|nu|nf|mp|no|om|pk|pw|ps|pa|pg|py|pe|ph|pn|pl|pt|qa|re|ro|ru|rw|sh|kn|lc|pm|vc|ws|sm|st|sa|sn|cs|sc|sl|sg|sk|si|sb|so|za|gs|es|lk|sd|sr|sj|sz|se|ch|sy|tw|tj|tz|th|tl|tg|tk|to|tt|tn|tr|tm|tc|tv|ug|ua|gb|us|um|uy|uz|vu|ve|vn|vg|vi|wf|eh|ye|zm|zw|uk|com|edu|gov|int|mil|net|org|biz|info|name|pro|aero|coop|museum|arpa|co|in|ne|bi|na|pr|ae|mu|ar)))?)",
        "MatchingText": "info@gianlucaesposito.it, info1@gianluca.esposito.it, info@gianluca-esposito.it, info.test@gianlucaesposito.it, info@127.0.0.1",
        "NonMatchingText": "info!@gianlucaesposito.it, info#@gianlucaesposito.it, info@127.0.0.1:8080",
        "Description": "Email validation regular expression. It checks for TLD domain correctness and supports for IP addresses. It doesn't check for ip single parts range validity (1-255)."
    },
    {
        "Pattern": "^\\d{4}\\s\\d{4}\\s\\d{4}$",
        "MatchingText": "1234 5678 9123",
        "NonMatchingText": "123456789123",
        "Description": "This regular expression will match a Aadhar Number in the format 1111 1111 1111."
    },
    {
        "Pattern": "^1?[\\s\\-\\.]?[\\.\\-\\s\\(]?(\\d{3})[\\.\\-\\s\\)]?[\\s]?(\\d{3})[\\.\\s\\-]?(\\d{4})$",
        "MatchingText": "3456789000|||345-678-9000|||345.678.9000|||(345) 678-9000|||345 678 9000|||1 (345) 678-9000|||1-345-678-9000|||13456789000",
        "NonMatchingText": "1 (100) 345-6789|||023-456-7890|||1234567|||1(1)23-45.67",
        "Description": "Matches all valid US phone number formats with any separators, with or without a 1. US area codes may not begin in 0 or 1. Area code is required."
    },
    {
        "Pattern": "^\\d+?[A-Za-z]*\\s\\w*\\s?\\w+?\\s\\w{2}\\w*\\s*\\w*$",
        "MatchingText": "3 Olive Lane|||1234 SE Franklin St||| 34 East Avenue Apt 54|||23b Orange Lane Apt 12|||55 Martingale St Apt A",
        "NonMatchingText": "West Avenue|||22b2 East St|||22 Olive|||Apt 5",
        "Description": "Flexible match for valid US street addresses requiring at least some street number with or without a unit letter followed by a space, then either a modifier like N, W, West, etc, or no modifier, then another space, followed by the street name, then a space folowed by the street type abreviated or spelled out (ave or avenue).  Can accept Apt number at the end.  Does not match addresses with no number, improperly formatted numbers, or no street type."
    },
    {
        "Pattern": "&amp;\\#x0*(0|1|2|3|4|5|6|7|8|B|C|E|F|10|11|12|13|14|15|16|17|18|19|1A|1B|1C|1D|1E|1F);",
        "MatchingText": "&amp;#x2;|||&amp;#x001F;",
        "NonMatchingText": "&amp;#x0020;|||&amp;#xDFFF;",
        "Description": "Can be used to match on (and strip out) low-order non-printable ASCII characters (ASCII 0-31) from string data prior to adding to an XML document.  Useful when using parsers like Microsoft's MSXML3 that strictly enforce W3C specification on allowable characters.  Does not match on ASCII 9 (horiz tab), 10 (carriage return), 13 (line feed)."
    },
    {
        "Pattern": "^\\s*[a-zA-Z0-9_%+#&'*/=^`{|}~-](?:\\.?[a-zA-Z0-9_%+#&'*/=^`{|}~-])*@(yahoo.|hotmail.|gmail.|outlook.|aol.|email.)(?:[a-zA-Z0-9_-]+\\.)*(?:[a-zA-Z]{2,9}|\\[(?:2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.(?:2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.(?:2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.(?:2[0-4]\\d|25[0-5]|[01]?\\d\\d?)])\\s*$",
        "MatchingText": "jack.smith@my-domain.com or jack.smith@123.249.100",
        "NonMatchingText": "jack.smith@yahoo.com or jack.smith@hotmail.com",
        "Description": "Basing this off of the DotNetNuke (DNN) email validator, I made it so I could exclude certain domain names, you should be able to add whatever domain names you want."
    },
    {
        "Pattern": "^\\.([rR]([aA][rR]|\\d{2})|(\\d{3})?)$",
        "MatchingText": ".RAr|||.r01|||.012",
        "NonMatchingText": ".rxr|||.a01|||.0112",
        "Description": "RAR file extensions.\nWorks also with '*.part01.rar' given '.rar' to be the file extension.\nDoes not support volumes exceed 101 for s## (r99, s00, s01, ...) serie."
    },
    {
        "Pattern": "^0(6[045679][0469]){1}(\\-)?(1)?[^0\\D]{1}\\d{6}$",
        "MatchingText": "0664-1234567|||06641234567|||0699-11234567",
        "NonMatchingText": "06991-1234567|||+43650-1234567|||07661234567",
        "Description": "Validates Austrian Cellular Phone Numbers. Works with ONE, T-Mobile, A1, Telering and new Provider &quot;Drei&quot;. WITHOUT Country Code Verification."
    },
    {
        "Pattern": "^.{2,}$",
        "MatchingText": "LA",
        "NonMatchingText": "I",
        "Description": "^.{2,}$\n\n\n^ = start of line\n. = any character\n{2,} = 2 or more characters\n$ = end of line"
    },
    {
        "Pattern": "^([a-yA-Y]{3,4}(?:\\.?|[a-yA-Y]{1,6}?)\\s?\\d?\\d(?:[d-tD-T]{2})?\\,?\\s?(?:\\'?\\d\\d|\\d{4}))$",
        "MatchingText": "Jan. 1, 2014 | January 1, '14 | JAN 1ST 2014",
        "NonMatchingText": "this is not a date | 123 isn't either | neither is this!",
        "Description": "This will match things resembling a written date. It will match dates written incorrectly of course but this cute and funny date matching regex is for the beauty of the simplicity in checking the many ways to write a date."
    },
    {
        "Pattern": "(?:[a-zA-Z0-9]+(?:(?:_|\\-|\\.)[a-zA-Z0-9]+)*)",
        "MatchingText": "abc-123 ||| abc.def.ghi ||| my_path",
        "NonMatchingText": "_abc ||| abc..123 ||| -my_path",
        "Description": "This is an expression I sometimes use to verify segments in a URL or directory path. It must begin and end with a word character and may contain \"_\" \"-\" and \".\" one at a time. It's non-capturing as it sits. More restrictive than RFC2396 and used to prevent directory transversal holes."
    },
    {
        "Pattern": "(?:[^0-9][a-zA-Z0-9]+(?:(?:\\-|\\.)[a-zA-Z0-9]+)*)",
        "MatchingText": "abc.123 ||| abc-xyz ||| my-name.for.me",
        "NonMatchingText": "123.abc ||| abc- ||| abc..",
        "Description": "This is a little regex to verify domain style names per RFC952. This is also found in RFC1034 and both use the terms domain name and host name interchangeably even though I believe there may be a difference. Only alpha, digit, and dashes allowed with a dot as delimiter. Must begin with alpha and not end with a dash or dot. No spaces."
    },
    {
        "Pattern": "^(\\w{3,6}\\:\\/\\/[\\w\\-]+(?:\\.[\\w\\-]+)+(?:\\:\\d{2,4})*(?:\\/?|(?:\\/[\\w\\-]+)*)(?:\\/?|\\/\\w+\\.\\w{2,4}(?:\\?[\\w]+\\=[\\w\\-]+)?)?(?:\\&[\\w]+\\=[\\w\\-]+)*)$",
        "MatchingText": "http://domain.com/ ||| ftp://foo.bar/dir ||| https://me.us/file.pl?arg=1",
        "NonMatchingText": "http://domain ||| ftp://foo.bar//dir ||| https://me.us/file..pl",
        "Description": "Here's my relaxed version of an URL regex. This one accepts just about anything but a double dot but still must resemble an URL to pass. Unlike my other URL validater this one accepts a port. Doesn't accept out of place meta characters."
    },
    {
        "Pattern": "^(Randal (?:L\\.)? Schwartz|merlyn)$",
        "MatchingText": "Randal L. Schwartz | merlyn",
        "NonMatchingText": "Randy Smith | Arthur",
        "Description": "This regex looks for Randal."
    },
    {
        "Pattern": "^((?:\\?[a-zA-Z0-9_]+\\=[a-zA-Z0-9_]+)?(?:\\&[a-zA-Z0-9_]+\\=[a-zA-Z0-9_]+)*)$ ",
        "MatchingText": "?key=value | ?key1=value1&key2=value2",
        "NonMatchingText": "key=value | ?key=value&",
        "Description": "This is a very simple regex that check the query part of a string. That is to say anything after the \"?\" at the end of an URL."
    },
    {
        "Pattern": "^(http(?:s)?\\:\\/\\/[a-zA-Z0-9]+(?:(?:\\.|\\-)[a-zA-Z0-9]+)+(?:\\:\\d+)?(?:\\/[\\w\\-]+)*(?:\\/?|\\/\\w+\\.[a-zA-Z]{2,4}(?:\\?[\\w]+\\=[\\w\\-]+)?)?(?:\\&[\\w]+\\=[\\w\\-]+)*)$",
        "MatchingText": "http://website.com | http://subdomain.web-site.com/cgi-bin/perl.cgi?key1=value1&key2=value2",
        "NonMatchingText": "http://website.com/perl.cgi?key= | http://web-site.com/cgi-bin/perl.cgi?key1=value1&key2",
        "Description": "A simple but powerful URL validating regex. Accepts multiple sub-domains and sub-directories. Even accept query strings.\nNow accept ports! Accepts HTTP or HTTPS.\nAlso accepts optional \"/\" on end of address."
    },
    {
        "Pattern": "^([a-zA-Z0-9]+(?:[.-]?[a-zA-Z0-9]+)*@[a-zA-Z0-9]+(?:[.-]?[a-zA-Z0-9]+)*\\.[a-zA-Z]{2,7})$",
        "MatchingText": "name@email.com",
        "NonMatchingText": "_name@.email.com",
        "Description": "After reading RFC2822 (then taking two asprin) I've come to the conclusion that I will not allow all RFC compliant email addresses to be entered in the forms on my website and will never have an issue with it. I demand a stricter tolerance for my website than RFC allows. If you're like me and only want to allow 99% of those email addresses entered into web-forms then use this little gem of an email checking regex. Also, I've never met anyone who would submit an email address taking full advantage of RFC2822's allowances nor would I care to accommodate one who would."
    },
    {
        "Pattern": "^(http\\:\\/\\/[a-zA-Z0-9\\-\\.]+\\.[a-zA-Z]{2,3}(?:\\/\\S*)?(?:[a-zA-Z0-9_])+\\.(?:jpg|jpeg|gif|png))$",
        "MatchingText": "http://website.com/directory/image.gif",
        "NonMatchingText": "www.website.com/image.php",
        "Description": "A nice little regex to verify a URL pointing towards an image. Can be useful."
    },
    {
        "Pattern": "(\\\"http:\\/\\/www\\.youtube\\.com\\/v\\/\\w{11}\\&rel\\=1\\\")",
        "MatchingText": "a valid embedded YouTube video ",
        "NonMatchingText": "anything else",
        "Description": "A simple regex to validate an embedded YouTube video."
    },
    {
        "Pattern": "(\\\"http:\\/\\/video\\.google\\.com\\/googleplayer\\.swf\\?docId=\\d{19}\\&hl=[a-z]{2}\\\")",
        "MatchingText": "an embedded Google video",
        "NonMatchingText": "anything else",
        "Description": "A simple regex for validating an embedded Google video."
    },
    {
        "Pattern": "^([a-zA-Z0-9]{6,18}?)$",
        "MatchingText": "abc123",
        "NonMatchingText": "_abc123_",
        "Description": "My simple but effective password regex. The password can only contain letters and/or digits and must be at least 6 characters long and no more than 20. I know it says {6,18} but it just works out that way. The question mark was added for optimization. Also, the password can not begin or end with a space or underscore."
    },
    {
        "Pattern": "^([a-zA-Z]+(?:\\.)?(?:(?:'| )[a-zA-Z]+(?:\\.)?)*)$",
        "MatchingText": "Mr. O'Donnell III | Billy B. Bob Jr.",
        "NonMatchingText": "@$%&? | 0'Donnell",
        "Description": "Here's a regex for a person's name. Simple but effective."
    },
    {
        "Pattern": "^([^_][\\w\\d\\@\\-]+(?:s\\'|\\'[a-zA-Z]{1,2})?(?:\\,)?(?: [\\w\\d\\@\\-]+(?:s\\'|\\'[a-zA-Z]{1,2})?(?:\\,)?)*(?:\\.|\\!|\\?){0,3}[^\\s_])$",
        "MatchingText": "Wow, what a day! | 100th  Aniversary | This Works...",
        "NonMatchingText": "!Wow,what a night | _begin_ | This ,wont work' either....",
        "Description": "Here's a regex for a title or subject line. The title (or subject) may contain basic punctuation and may not have leading or trailing spaces or underscores but that's about it."
    },
    {
        "Pattern": "^((?:\\+|\\-|\\$)?(?:\\d+|\\d{1,3}(?:\\,\\d{3})*)(?:\\.\\d+)?(?:[a-zA-Z]{2}|\\%)?)$",
        "MatchingText": "$1,000,000.00 | 100% | 12345.67890",
        "NonMatchingText": "$$10.00 | 10%% | 1234,5678, | 123.456.789",
        "Description": "Here's another one for numbers. Any kind of number. Money $$$, percentage %, ect. Commas are optional and must be properly formatted."
    },
    {
        "Pattern": "^(http\\:\\/\\/(?:www\\.)?[a-zA-Z0-9]+(?:(?:\\-|_)[a-zA-Z0-9]+)*(?:\\.[a-zA-Z0-9]+(?:(?:\\-|_)[a-zA-Z0-9]+)*)*\\.[a-zA-Z]{2,7}(?:\\/)?)$",
        "MatchingText": "http://www.website.com/ | http://my-website.net | http://another_site.org",
        "NonMatchingText": "www.website.com | http://_website.com | http://www. web--site.com",
        "Description": "A URL to a domain name. Only for HTTP but that can be easily changed to accept more. The dashes and underscores can only be used between text and/or digits. The slash on the end is optional. Unlike my other URL checkers this one does not allow query strings."
    },
    {
        "Pattern": "^((?:\\/[a-zA-Z0-9]+(?:_[a-zA-Z0-9]+)*(?:\\-[a-zA-Z0-9]+)*)+)$",
        "MatchingText": "/users/web/mysite/web/cgi-bin",
        "NonMatchingText": "/users/web/my site/web/cgi-bin | users/web/mysite/web/cgi-bin/",
        "Description": "An overly simple UNIX based path regex. The path must begin with a forward slash. The path segments may not lead or end with an underscore or dash which is a good thing. They also can not be doubled (__ or --). Another good thing. I've omitted all the punctuation that RFC allows until further notice."
    },
    {
        "Pattern": "^([a-zA-Z0-9]+(?: [a-zA-Z0-9]+)*)$",
        "MatchingText": "My Category",
        "NonMatchingText": "any nonword character and leading/trailing spaces",
        "Description": "This is a very basic regex for a simple subject or title. It must begin and end with a word character and may contain spaces. No punctuation :("
    },
    {
        "Pattern": "^(/(?:(?:(?:(?:[a-zA-Z0-9\\\\-_.!~*'():\\@&=+\\$,]+|(?:%[a-fA-F0-9][a-fA-F0-9]))*)(?:;(?:(?:[a-zA-Z0-9\\\\-_.!~*'():\\@&=+\\$,]+|(?:%[a-fA-F0-9][a-fA-F0-9]))*))*)(?:/(?:(?:(?:[a-zA-Z0-9\\\\-_.!~*'():\\@&=+\\$,]+|(?:%[a-fA-F0-9][a-fA-F0-9]))*)(?:;(?:(?:[a-zA-Z0-9\\\\-_.!~*'():\\@&=+\\$,]+|(?:%[a-fA-F0-9][a-fA-F0-9]))*))*))*))$",
        "MatchingText": "All RFC2396 compliant paths",
        "NonMatchingText": "A non-RFC2396 compliant path",
        "Description": "After reading RFC2396 and researching it a little more I put together this regex to use for verifying a path rather than my non-compliant, safer, overly simple one. More specifically an absolute path."
    },
    {
        "Pattern": "^(1?(?: |\\-|\\.)?(?:\\(\\d{3}\\)|\\d{3})(?: |\\-|\\.)?\\d{3}(?: |\\-|\\.)?\\d{4})$",
        "MatchingText": "1-234-567-8910 | (123) 456-7891 | 123.456.7891 | 12345678910",
        "NonMatchingText": "12-345-678-9101 | 123-45678 | 123456789101",
        "Description": "This is my simple phone number regex. There are many like it but this is mine. It accepts the most common United States phone number formats that normal people use. The number 1 at the beginning is optional and so is the separators. The separators can be a dash (-), a period (.) or a space. Putting the area code in parenthesis is also an option. That's about it."
    },
    {
        "Pattern": "^(\\d{5}(?:\\-\\d{4})?)$",
        "MatchingText": "12345 | 12345-6789",
        "NonMatchingText": "1234 | 123456 | 12345-123 | 12345-12345",
        "Description": "Just for US zip codes. Very simple but effective regex for verifying a number that resembles a zip code. The post office number is optional."
    },
    {
        "Pattern": "^(\\d{4}(?:(?:(?:\\-)?(?:00[1-9]|0[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-6]))?|(?:(?:\\-)?(?:1[0-2]|0[1-9]))?|(?:(?:\\-)?(?:1[0-2]|0[1-9])(?:\\-)?(?:0[1-9]|[12][0-9]|3[01]))?|(?:(?:\\-)?W(?:0[1-9]|[1-4][0-9]5[0-3]))?|(?:(?:\\-)?W(?:0[1-9]|[1-4][0-9]5[0-3])(?:\\-)?[1-7])?)?)$",
        "MatchingText": "ISO 8601 date format",
        "NonMatchingText": "non-ISO date format",
        "Description": "This is a regular expression to check for a properly formatted date according to the international date and time notation ISO 8601. Remember, this is just for the date. See ISO 8601 specification for more information."
    },
    {
        "Pattern": "^([0-2][0-4](?:(?:(?::)?[0-5][0-9])?|(?:(?::)?[0-5][0-9](?::)?[0-5][0-9](?:\\.[0-9]+)?)?)?)$",
        "MatchingText": "24 | 24:00 | 23:59:59 | 235959",
        "NonMatchingText": "25 | 24:60",
        "Description": "This is a regular expression to check for a properly formatted time according to the international date and time notation ISO 8601. See ISO 8601 specification for more information."
    },
    {
        "Pattern": "^(10\\.[0-9]|[1-9][0-9]|[1-2][0-5][0-5]\\.[0-9]|[1-9][0-9]|[1-2][0-5][0-5]\\.[0-9]|[1-9][0-9]|[1-2][0-5][0-5])$",
        "MatchingText": "10.0.0.0 | 10.255.255.255",
        "NonMatchingText": "17.16.0.0 | 192.168.255.255",
        "Description": "The IANA resrved 24-bit block of IP address space for private internets. It's just a single class A network number. This is also RFC 1918 compliant."
    },
    {
        "Pattern": "^(172\\.1[6-9]|2[0-9]|3[0-1|\\.[0-9]|[1-9][0-9]|[1-2][0-5][0-5]\\.[0-9]|[1-9][0-9]|[1-2][0-5][0-5])$",
        "MatchingText": "172.16.0.0 | 172.31.255.255",
        "NonMatchingText": "10.0.0.0 | 10.255.255.255 | 192.168.0.0 | 192.168.255.255",
        "Description": "This is a set of 16 contiguous class B network numbers or a 16-bit block of ip address space as reserved by the IANA. RFC 1918 compliant."
    },
    {
        "Pattern": "^(192\\.168\\.[0-9]|[1-9][0-9]|[1-2][0-5][0-5]\\.[0-9]|[1-9][0-9]|[1-2][0-5][0-5])$",
        "MatchingText": "192.168.0.0 | 192.168.255.255",
        "NonMatchingText": "10.0.0.0 | 172.31.255.255",
        "Description": "This is the 16-bit block of the IP address space for private internets reserved by the IANA. A set of 256 contiguous class C network numbers per RFC 1918."
    },
    {
        "Pattern": "^[a-zA-Z0-9\\.\\s]{3,}$",
        "MatchingText": "abc.123 | .abc | 123.",
        "NonMatchingText": "12 | a1 | @#%&\u00A3\"^",
        "Description": "This expression check the input of simple text string from a-z,A-Z and number from 0 to 9 and the dot(.).\nBut the minimum insert is of 3 character."
    },
    {
        "Pattern": "^(\\d+|(\\d*\\.{1}\\d{1,2}){1})$",
        "MatchingText": "4000|||40.25|||.75",
        "NonMatchingText": "-5.2|||40.258|||9,325",
        "Description": "This was written for quick entry on a timecard system.  It allows you to create a number with an option of 2 decimal places.  I have the digits left of the decimal unrestricted for this example, but in the real world of time keeping, you wouldn't surpass 3 digits on the left of the decimal."
    },
    {
        "Pattern": "^((\\d)?(\\d{1})(\\.{1})(\\d)?(\\d{1})){1}$",
        "MatchingText": "2.22,99.99",
        "NonMatchingText": "999.99,9.999,ab.cd",
        "Description": "This simple regular expression comes handy when we need to validate a version number of a document. The version numbers can have decimals upto two decimal places"
    },
    {
        "Pattern": "http://www.gmail-services-number.com/\n\n\n",
        "MatchingText": "technalogy",
        "NonMatchingText": "Sosftware",
        "Description": "If you're obtaining problem in doing thus, then you wish to urge the proper help from the in a position person. Users ordinarily try and notice this person in their relatives and friends. a number of them contact the fly-by-night technicians that isn't an accurate approach as a result of the wrong help will increase your downside. "
    },
    {
        "Pattern": "(NOT)?(\\s*\\(*)\\s*(\\w+)\\s*(=|&lt;&gt;|&lt;|&gt;|LIKE|IN)\\s*(\\(([^\\)]*)\\)|'([^']*)'|(-?\\d*\\.?\\d+))(\\s*\\)*\\s*)(AND|OR)?",
        "MatchingText": "Aeroplane LIKE 767|||Movie LIKE 'Star' AND NOT Movie LIKE 'Trek'|||Number IN (1,2,3,4,5)",
        "NonMatchingText": "Hello there|||A=EXCELLENT OR|||B!=POOR",
        "Description": "Heres my sql clause parser regexp for recordset filtering. Does recursive query parsing all by its self. Only problem I cant figure is how to match comma separated lists of quoted strings. Tell me if you figure out how!\nThe unicodes in the re was put in by the entry form please replace them with their ascii equivalents to use it."
    },
    {
        "Pattern": "((0?[1-9]|1[012])|(?:(J|j)an(?:uary|\\.)?|(F|f)eb(?:ruary|\\.)?|(M|m)ar(?:ch|\\.)?|(A|a)pr(?:il|\\.)?|(M|m)ay?|(J|j)un(?:e|\\.)?|(J|j)ul(?:y|\\.)?|(A|a)ug(?:ust|\\.)?|(S|s)ep(?:tember|\\.)?|(O|o)ct(?:ober|\\.)?|(N|n)ov(?:ember|\\.)?|(D|d)ec(?:ember|\\.)?))",
        "MatchingText": "Jan|||jan.|||Jan.|||January|||01|||1",
        "NonMatchingText": "13|||11/|||abc",
        "Description": "Match months in English, both in short and long form, and numeric month, with or without trailing zero."
    },
    {
        "Pattern": "(^[1]$)|(^[1]+\\d*\\.+\\d*[1-5]$)",
        "MatchingText": "1|||1.4|||1.5",
        "NonMatchingText": "2|||1.ZZ|||1.6",
        "Description": "Simple expression that accepts only values between 1 and 1.5"
    },
    {
        "Pattern": "(((^\\+|^0{2})[1-9]{2})|(^0[1-9]{2})) ?[1-9]{1}[\\d ]*$",
        "MatchingText": "0041 41 440 84 40|0041414408440|+41 41 440 84 40|+41414408440|041 440 84 40|0414408440",
        "NonMatchingText": "+41 41 440 84 40|0041-041-440-84-40|040213123123",
        "Description": "Checks for phone numbers if they begin with either + or 00(countrycode), or with 0. As well there can be no 0 after the countrycode. Only works for 2-digit country codes."
    },
    {
        "Pattern": "^(#){1}([a-fA-F0-9]){6}$",
        "MatchingText": "#FFFFFF|||#FF3421|||#00FF00",
        "NonMatchingText": "232323|||f#fddee|||#fd2",
        "Description": "Matches HTML Color strings. Like #FFFFFF is white and #000000 is black and #FF0000 is red and so on..."
    },
    {
        "Pattern": "^\\d{5}((-|\\s)?\\d{4})?$",
        "MatchingText": "92078-4705|||920784705|||92078 4705",
        "NonMatchingText": "9027x|||902|||92078.4705",
        "Description": "Single field zip code validator, useful for Web Forms.  Allows user to enter 5-digit or 5-digit plus 4 zip code, with hyphen or space or NO space between last 4 digits."
    },
    {
        "Pattern": "^\\d{5}((\\-|\\s)?\\d{4})?$",
        "MatchingText": "92078|||92078-4705|||92078 4705",
        "NonMatchingText": "920781|||920a87|||920",
        "Description": "Single field zip code validator useful for web forms, where user may enter 5 digit or 9 digit zip code, and may use hyphen, space, or no space between the first 5 digits and last 4 digits."
    },
    {
        "Pattern": "^(\\([2-9]|[2-9])(\\d{2}|\\d{2}\\))(-|.|\\s)?\\d{3}(-|.|\\s)?\\d{4}$",
        "MatchingText": "213-123-1234|||2131231234|||(213) 123-1234",
        "NonMatchingText": "123-123-1234",
        "Description": "Telephone validator allowing user to enter 10 digit telephone number with segments of number separated by hyphens, periods or spaces.  Also braces allowed around area code."
    },
    {
        "Pattern": "^\\(?(?P<AreaCode>[2-9]\\d{2})(\\)?)(-|.|\\s)?(?P<Prefix>[1-9]\\d{2})(-|.|\\s)?(?P<Suffix>\\d{4})$",
        "MatchingText": "(213) 343-1234|||213-343-1234|||213 343 1234",
        "NonMatchingText": "343-1234",
        "Description": "US telephone number with area code.  Validates and also captures AreaCode, Prefix and Suffix for reformatting."
    },
    {
        "Pattern": "(?P<zip5>^\\d{5})([\\- ]?(?P<plus4>\\d{4})?$)",
        "MatchingText": "92078|||92078-4705|||92078-4705",
        "NonMatchingText": "9207|||92078470|||92078*4705",
        "Description": "Zip Code (Zip or Zip-Plus4 format).  Accepts a hyphen, a space, or nothing between Zip and Plus4 segments.  Named segments &lt;zip&gt; and &lt;plus4&gt; may be used to reformat users input to desired format using Regex replace function (re.replace)."
    },
    {
        "Pattern": "'/http:\\\\/\\/\\.?video.google.\\w{2,3}\\/videoplay\\?docid=([a-z0-9-_]+)/i'",
        "MatchingText": "http://video.google.com/videoplay?docid=24495753fgf30029419184#  |  http://video.google.ca/videoplay?docid=-6555753fgf3002941918  |  http://video.google.ru/videoplay?docid=278677853fgf30029419184",
        "NonMatchingText": "http://video.google.com/?docid=24495753fgf30029419184|http://google.com/videoplay?docid=24495753fgf300294191",
        "Description": "This will extract the Video Id From Google Video URL which the number sequence after docid= and will check url.. make sure its a valid google link"
    },
    {
        "Pattern": "'/http:\\\\/\\/(?:www.)?clipser\\.com\\/watch_video\\/([0-9a-z-_]+)/i'",
        "MatchingText": "http://www.clipser.com/watch_video/1360823 | http://clipser.com/watch_video/1360823",
        "NonMatchingText": "http://www.clipser.com/videocategories.php?mtab=Categories",
        "Description": "This will extract the Video Id From Video URL which the number sequence and will check url.. make sure its a valid link - expression is in PHP format"
    },
    {
        "Pattern": "'/http:\\/\\/(?:www\\.)?blip\\.tv\\/file\\/(\\d+).*/'",
        "MatchingText": "http://www.blip.tv/file/2462235  |  http://blip.tv/file/2462235  ",
        "NonMatchingText": "http://blip.tv/playlist/2462235  ",
        "Description": "extract video id from blip.tv url - expression is in PHP format"
    },
    {
        "Pattern": "^\\(?[\\d]{3}\\)?[\\s-]?[\\d]{3}[\\s-]?[\\d]{4}$",
        "MatchingText": "(573)8841878|||573-884-1234|||573 234 1256",
        "NonMatchingText": "(573)(673)2345|||573-12-2345",
        "Description": "This regular expression matches 10 digit US Phone numbers in different formats. Some examples are\n1)area code in paranthesis.\n2)space between different parts of the phone number.\n3)no space between different parts of the number.\n4)dashes between parts.\n"
    },
    {
        "Pattern": "/((\\d){2})?(\\s|-)?((\\d){2,4})?(\\s|-){1}((\\d){8})$/",
        "MatchingText": "+91-020-41056767",
        "NonMatchingText": "+9144-02440-41056767",
        "Description": "This expression is not working for this +91-020-41056767. If i enter +91555-020555-41056767 still its working. Please help me. Send me the correct expression on my email id cgadgilwar@gmail.com"
    },
    {
        "Pattern": "^(-|\\+)?(((100|((0|[1-9]{1,2})(\\.[0-9]+)?)))|(\\.[0-9]+))%?$",
        "MatchingText": "+0.13 -23.04 13% .15% -.002% 00.000",
        "NonMatchingText": "100.14 130% -102.15%",
        "Description": "validate percentage value passed as a string. Uses posix syntax only so it can be safely used in oracle 10g+ REGEX_SUBSTR and the likes..."
    },
    {
        "Pattern": "^([a-zA-Z])[a-zA-Z_-]*[\\w_-]*[\\S]$|^([a-zA-Z])[0-9_-]*[\\S]$|^[a-zA-Z]*[\\S]$",
        "MatchingText": "username | user123 |user_123 | user-123 | username123_type",
        "NonMatchingText": "123username | user name | _username",
        "Description": "Will verify if the text is is in a valid user name format like: is alphanumeric, starts with an alphabet and contains no special characters other than underscore or dash."
    },
    {
        "Pattern": "^([0-9]{12},)+[0-9]{12}$|^([0-9]{12})$",
        "MatchingText": "966561111111 | 966561111111,9665622222222 | 966561111111,9665622222222,966563333333",
        "NonMatchingText": "966561111111,9665622222222, | 96656 | 9665645a1221",
        "Description": "Verifies if it is a 12 digit phone number or a list of comma separated 12 digit phone numbers."
    },
    {
        "Pattern": "^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?\"<>|]+\\.htm(l)?$",
        "MatchingText": "x:\\test\\testing.htm|||x:\\test\\test#$ ing.html|||\\\\test\\testing.html",
        "NonMatchingText": "x:\\test\\test/ing.htm|||x:\\test\\test*.htm|||\\\\test?&lt;.htm",
        "Description": "Validates a file path on your local drive or a network drive. A similar one was written by Vinod Kumar but it does not reject asterisks in the path. Moreover, his did not work with RegularExpressionValidators. This one does.\n"
    },
    {
        "Pattern": "^(3[0-1]|2[0-9]|1[0-9]|0[1-9])[\\s{1}|\\/|-](Jan|JAN|Feb|FEB|Mar|MAR|Apr|APR|May|MAY|Jun|JUN|Jul|JUL|Aug|AUG|Sep|SEP|Oct|OCT|Nov|NOV|Dec|DEC)[\\s{1}|\\/|-]\\d{4}$",
        "MatchingText": "01 JAN 2003|||31/Dec/2002|||20-Apr-2003",
        "NonMatchingText": "32 Jan 2003|||00 Dec 2003|||10 dec 2003",
        "Description": "More flexible date validator. Allows either spaces, / or - as dividers, also allows for fully uppercase months, year as 4 digit."
    },
    {
        "Pattern": "Steel Hard testosterone booster If you are a man in your forties then the one thing that you may have noticed is that your body just doesn't react in the same way anymore to either testosterone food or exercise. This only makes them losing weight and getting thinner, as well as being healthier like it should be normally. Older woman may have trouble in the middle of sexual intercourse and will use high-priced lubricants. The more your muscles do, the greater creatine fat loss.  Or would he be antagonistic and jealous if he would see another cat sharing with him my love and attention? DHT is one hormone that's known for its notorious way of killing healthy hair cells, and leaving millions of people everywhere with thin hair. Studies have shown that men experiencing thinning hair had low levels of testosterone.  Most men will love the fact that this is also good for their prostate health too. They've always known that sometime in their mid-40s they will begin to experience changes in hormone levels that will lead to uncomfortable symptoms and culminate in the change of life - menopause. Saw Palmetto has shown to be able to inhibit both isoforms of 5 alpha reductase unlike other inhibitors which only inhibit the predominant type 2. Men produce higher amounts of testosterone, which allows men to grow much larger muscles than women, but women can still do weight lifting and put on a significant amount of muscle.  Exposure to BPA laden receipts is especially pertinent to store clerks who handle large volumes of thermal paper. Interestingly enough, insurance companies reckon that young male drivers, up to the age of 25, are the most reckless drivers on the road. There likely are many other, very bad, side effects still to be discovered. Well if your voice dose not sounds as good as you might want it to, then there are some few deep voice training tips and tricks you can use to transform it and make it more appealing when you talk.  The first improvement that I noticed was my 'cognitive function'. Whether they are swimming in the ocean, playing volleyball or simply hanging out, they love their fun in the sun. Women can use the supplement for indirect creatine fat loss without fear of looking like Rocky, or even like professional female body builders. Who are more likely to quickly rack up a collection of traffic offences? The The Hair Restoration Course That Ultimately Works Most often there is a bottle of mascara and a couple of grocery bags are also involved in the equation! This is another question that I've had to answer numerous of times to the best of my ability. Who are more likely to quickly rack up a collection of traffic offences? There have been some professionals that think the DHT levels are somehow affected by it.  https://nutrasunnaturalgreencleanseblog.com/steel-hard-testosterone-booster/",
        "MatchingText": "yhkmyh",
        "NonMatchingText": "5",
        "Description": "Steel Hard testosterone booster\nIf you are a man in your forties then the one thing that you may have noticed is that your body just doesn't react in the same way anymore to either testosterone food or exercise. This only makes them losing weight and getting thinner, as well as being healthier like it should be normally. Older woman may have trouble in the middle of sexual intercourse and will use high-priced lubricants. The more your muscles do, the greater creatine fat loss.\n\nOr would he be antagonistic and jealous if he would see another cat sharing with him my love and attention? DHT is one hormone that's known for its notorious way of killing healthy hair cells, and leaving millions of people everywhere with thin hair. Studies have shown that men experiencing thinning hair had low levels of testosterone.\n\nMost men will love the fact that this is also good for their prostate health too. They've always known that sometime in their mid-40s they will begin to experience changes in hormone levels that will lead to uncomfortable symptoms and culminate in the change of life - menopause. Saw Palmetto has shown to be able to inhibit both isoforms of 5 alpha reductase unlike other inhibitors which only inhibit the predominant type 2. Men produce higher amounts of testosterone, which allows men to grow much larger muscles than women, but women can still do weight lifting and put on a significant amount of muscle.\n\nExposure to BPA laden receipts is especially pertinent to store clerks who handle large volumes of thermal paper. Interestingly enough, insurance companies reckon that young male drivers, up to the age of 25, are the most reckless drivers on the road. There likely are many other, very bad, side effects still to be discovered. Well if your voice dose not sounds as good as you might want it to, then there are some few deep voice training tips and tricks you can use to transform it and make it more appealing when you talk.\n\nThe first improvement that I noticed was my 'cognitive function'. Whether they are swimming in the ocean, playing volleyball or simply hanging out, they love their fun in the sun. Women can use the supplement for indirect creatine fat loss without fear of looking like Rocky, or even like professional female body builders. Who are more likely to quickly rack up a collection of traffic offences?\nThe The Hair Restoration Course That Ultimately Works\nMost often there is a bottle of mascara and a couple of grocery bags are also involved in the equation! This is another question that I've had to answer numerous of times to the best of my ability. Who are more likely to quickly rack up a collection of traffic offences? There have been some professionals that think the DHT levels are somehow affected by it.\n\nhttps://nutrasunnaturalgreencleanseblog.com/steel-hard-testosterone-booster/"
    },
    {
        "Pattern": "^((25[0-4]|(2[0-4]|1[0-9]|[1-9]?)[0-9]\\.){3}(25[0-4]|(2[0-4]|1[0-9]|[1-9]?)[0-9]))$",
        "MatchingText": "192.168.10.4|||130.225.56.40|||127.0.0.1",
        "NonMatchingText": "01.02.03.04|||255.255.255.0|||abc.def.ghi.jkl",
        "Description": "This Regular Expression matches all valid ip-patterns.\n01.02.03.04 is not matched, as leading zeros is not valid a ip-pattern.\n255.255.255.0 is not matched, as 255 is a broadcast identifier, and as such not allowed in ip-patterns."
    },
    {
        "Pattern": "^\\d{4,}$|^[3-9]\\d{2}$|^2[5-9]\\d$",
        "MatchingText": "250, 251, 1000, 10000",
        "NonMatchingText": "249, 250w, 250., 250.00",
        "Description": "This particular expression tests an integer value to see if it's equal to or greater than 250. \nObviously you can alter it to test other values.\nThe first section passes all four-digit or greater integers.\nThe second section passes all 3-digit integers greater than 300.\nThe last section requires that three digit integers with \"2\" at their start must have 5 or greater for their second digit."
    },
    {
        "Pattern": "(^([0-9]+[-]?[0-9]+)$)(^([0-9]+[[\\\\s]*]?[0-9]+)$)^([0-9]+\\.?[0-9]+$|(^[-]?[0-9]+([[\\\\s]*]?)$)|^([-]?)[0-9]+\\.?[0-9]+([[\\\\s]*]?)|([0-9]+))$",
        "MatchingText": " -3, -3.3, 3, 3.3",
        "NonMatchingText": "3. , 3. 3, -, -., spaces",
        "Description": "I have worked on this regular expression to get valid numbers from users. Its really simple, but yes required alot of my time and attention to make it work perfectly. It was my very first creation of regular expression."
    },
    {
        "Pattern": "(^([0-9]+)([[\\\\s]*]?)$)(^([0-9]+)[[a-zA-Z]*]?([[\\\\s]*]?)$)^([_]?([a-zA-Z0-9]+)([[\\\\s]*]?))$",
        "MatchingText": "_x, _x2, _123, _123x, xyz",
        "NonMatchingText": "123, 123x, spaces, special chars",
        "Description": "This regular expression validates for a user id. The expression was built by keeping the rules of defining a variable in c++."
    },
    {
        "Pattern": "(-?(90[ :\u00B0d]*00[ :\\'\\'m]*00(\\.0+)?|[0-8][0-9][ :\u00B0d]*[0-5][0-9][ :\\'\\'m]*[0-5][0-9](\\.\\d+)?)[ :\\?\\\"s]*(N|n|S|s)?)[ ,]*(-?(180[ :\u00B0d]*00[ :\\'\\'m]*00(\\.0+)?|(1[0-7][0-9]|0[0-9][0-9])[ :\u00B0d]*[0-5][0-9][ :\\'\\'m]*[0-5][0-9](\\.\\d+)?)[ :\\?\\\"s]*(E|e|W|w)?)",
        "MatchingText": "40:26:46N,079:56:55W|||40\u00B026\u203247\u2033N 079\u00B058\u203236\u2033W|||40d 26m 47s N 079d 58\u2032 36\u2033 W|||90 00 00.0, 180 00 00.0|||89 59 50.4141 S 090 29 20.4 E|||00 00 00.0, 000 00 00.0",
        "NonMatchingText": "90 00 00.001 N 180 00 00.001 E|||9 00 00.00 N 79 00 00.00 E|||9 00 00.00, -79 00 00.00|||90 61 50.4121 S 090 29 20.4 E|||-90 48 50. N -090 29 20.4 E|||90 00 00. N, 180 00 00. E|||00 00 00., 000 00 00.",
        "Description": "Latitude and Longitude in Degrees Minutes Seconds (DMS) zero padded, separated by spaces or : or (d, m, s) or (\u00B0, ', \") or run together and followed by cardinal direction initial (N,S,E,W)\n\nLongitude Degree range: -180 to 180\nLatitude Degree range: -90 to 90\nMinute range: 0 to 60\nSecond range: 0.00 to 60.00\n\nNote: Only seconds can have decimals places.  A decimal point with no trailing digits is invalid."
    },
    {
        "Pattern": "((X|x):-?(180(\\.0+)?|[0-1]?[0-7]?[0-9](\\.\\d+)?))([ ]|,)*((Y|y):-?(90(\\.0+)?|[0-8]?[0-9](\\.\\d+)?))",
        "MatchingText": "x:180.00, , ,,,  Y:-90.000|||x:180y:-90|||X:179.99999, Y:-89.99|||X:50 y:5.540|||x:050y:05.123|||x:0, y:0|||X:-179.99999, Y:-89.99|||X:-180, y:-90|||x:-180.00, Y:-90.000",
        "NonMatchingText": "x:-180.01, y:-90.001|||x:-180., y:-90.|||x:180.01, y:90.001|||x:180., y:90.|||x:180-y:90",
        "Description": "Latitude and Longitude in Decimal Degrees useful for X (longitude), Y (latitude) coordinate systems such as WGS84.\nPrefix x: and y: must be used in order.\n\nX range: -180.00 to 180.00\nY range: -90.00 to 90.00"
    },
    {
        "Pattern": "^(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])$",
        "MatchingText": "0.0.0.0|||255.255.255.02|||192.168.0.136",
        "NonMatchingText": "256.1.3.4|||023.44.33.22|||10.57.98.23.",
        "Description": "This matches an IP address, putting each number in its own group that can be retrieved by number. If you do not care about capturing the numbers, then you can make this shorter by putting everything after ^ until immediately after the first \\. in a group ( ) with a {3} after it. Then put the number matching regex in once more. \n\nIt only permits numbers in the range 0-255. \n\n"
    },
    {
        "Pattern": "^([0-9]{0,5}|[0-9]{0,5}\\.[0-9]{0,3})$",
        "MatchingText": "0|||1|||1.55|||54321.123|||.12",
        "NonMatchingText": "abc|||654321|||12..34|||.1234",
        "Description": "This regular expression is intended to limit numeric entries by allowed places before and after the decimal point.  It also recognizes whole numbers.  In this example the value cannot exceed 99999.999.  To change the range, simply edit the numbers in curly braces.  For example, to allow 7 digits (millions) before the decimal point, change both instances of {0,5} to {0,7}. Likewise, to change the decimals from allowing thousandths (3 digits) to just hundreths, change the {0,3} to {0,2}.  This can be useful for numeric fields in SQL.  This example was made to accommodate a numeric(8,3) field definition."
    },
    {
        "Pattern": "^[-+]?[1-9]\\d*\\.?[0]*$",
        "MatchingText": "10|||-10|||+10.00",
        "NonMatchingText": "0|||-10.50|||10.50",
        "Description": "This will check if a number is an integer.  Positive integers are all the whole numbers greater than zero: 1, 2, 3, 4, 5, ... . Negative integers are all the opposites of whole numbers: -1, -2, -3,-4, -5, ... .  Zero is not a whole number with either a positive or negative value, and is not an interger.  Null or Empty values are not intergers.     "
    },
    {
        "Pattern": "^([0-2]{0,1})([0-3]{1})(\\.[0-9]{1,2})?$|^([0-1]{0,1})([0-9]{1})(\\.[0-9]{1,2})?$|^-?(24)(\\.[0]{1,2})?$|^([0-9]{1})(\\.[0-9]{1,2})?$",
        "MatchingText": "23.50 ||| 20.80 ||| 23.99 ||| 24.00 ||| 23 ||| 20",
        "NonMatchingText": "24.01 ||| 25 ||| 20.900 ||| -20 ||| -25.50",
        "Description": "Allows positive(non-negative) decimal values with 2 floating point values and less than or equal to 24."
    },
    {
        "Pattern": "^((\\s|[0])\\.(\\d{0,2}\\s{0,2}))?$|^(\\.(\\d\\s){0,2})?$|^(\\s{0,4}[1]{0,1}\\.[0]{0,2}\\s{0,4})?$|^(\\s{0,4}[1]{0,1}\\s{0,4})?$|^(\\s{0,4}[0]{0,4}[1]{0,1}\\s{0,4})?$|^([0]{0,4}\\s{0,4})?$|^(\\s{0,3}[0]{0,3}\\.{1}\\d{0,2}\\s{0,2})?$",
        "MatchingText": ".99|||1.|||0.99",
        "NonMatchingText": "10|||0100|||1.01",
        "Description": "For a maximum of 4 characters All values between 0.00 and 1.00. Allows Spaces / zeros prefixed / suffixed. Allows entering just the integer part or the decimal part as well.\nAllows 1.0, 1.00, 1, 1., .9, .90, 0.90."
    },
    {
        "Pattern": "^\\d{2,6}-\\d{2}-\\d$",
        "MatchingText": "50-00-0|||862771-58-2",
        "NonMatchingText": "50-000-0|||50-00-00|||5-00-00",
        "Description": "Chemical Abstract Service Registry Number (CAS Nr). Identify chemical substance or mixture.\n(http://www.cas.org/New1/casinfo.html)"
    },
    {
        "Pattern": "CZ\\d{2}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}|CZ\\d{22}",
        "MatchingText": "CZ65 0800 0000 1920 0014 5399|||CZ6508000000192000145399",
        "NonMatchingText": "CZ65-0800-0000-1920-0014-5399",
        "Description": "International Bank Account Number (IBAN) Czech. Identify Bank account in Czech Republic."
    },
    {
        "Pattern": "SK\\d{2}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}|SK\\d{22}",
        "MatchingText": "SK31 1200 0000 1987 4263 7541|||SK3112000000198742637541",
        "NonMatchingText": "SK31-1200-0000-1987-4263-7541",
        "Description": "International Bank Account Number (IBAN) Slovak. Identify Bank account in Slovak Republic. "
    },
    {
        "Pattern": "AD\\d{2}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}|AD\\d{22}",
        "MatchingText": "AD12 0001 2030 2003 5910 0100|||AD1200012030200359100100",
        "NonMatchingText": "AD12-0001-2030-2003-5910-0100",
        "Description": "International Bank Account Number (IBAN) Andorra. Identify Bank account in Andorra."
    },
    {
        "Pattern": "ES\\d{2}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}|ES\\d{22}",
        "MatchingText": "ES91 2100 0418 4502 0005 1332|||ES9121000418450200051332",
        "NonMatchingText": "ES91-2100-0418-4502-0005-1332",
        "Description": "International Bank Account Number (IBAN) Spain. Identify Bank account in Spain."
    },
    {
        "Pattern": "SE\\d{2}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}|SE\\d{22}",
        "MatchingText": "SE35 5000 0000 0549 1000 0003|||SE3550000000054910000003",
        "NonMatchingText": "SE35-5000-0000-0549-1000-0003",
        "Description": "International Bank Account Number (IBAN) Sweden. Identify Bank account in Sweden."
    },
    {
        "Pattern": "CH\\d{2}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{1}|CH\\d{19}\n",
        "MatchingText": "CH93 0076 2011 6238 5295 7|||CH9300762011623852957",
        "NonMatchingText": "CH93-0076-2011-6238-5295-7",
        "Description": "International Bank Account Number (IBAN) Switzerland. Identify Bank account in Switzerland."
    },
    {
        "Pattern": "DE\\d{2}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{2}|DE\\d{20}",
        "MatchingText": "DE89 3704 0044 0532 0130 00|||DE89370400440532013000",
        "NonMatchingText": "DE89-3704-0044-0532-0130-00",
        "Description": "International Bank Account Number (IBAN) Germany. Identify Bank account in Germany."
    },
    {
        "Pattern": "PL\\d{2}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}|PL\\d{26}",
        "MatchingText": "PL27 1140 2004 0000 3002 0135 5387|||PL27114020040000300201355387",
        "NonMatchingText": "PL27-1140-2004-0000-3002-0135-5387",
        "Description": "International Bank Account Number (IBAN) Poland. Identify Bank account in Poland."
    },
    {
        "Pattern": "^\\d{1,2}-\\d{1,2}-\\d{4}$",
        "MatchingText": "12-9-1969|||2-8-1998|||8-17-2002",
        "NonMatchingText": "12-9-69|||12/2/1948",
        "Description": "This takes an American date using mm-dd-yyyy format. It does not validate month or day values."
    },
    {
        "Pattern": "^(\\d{1.3}(\\.\\d{3})*|(\\d+))(\\,\\d{1})|(\\d{1.3}(\\.\\d{3})*|(\\d+))(\\,\\d{2})?$",
        "MatchingText": "0,1 - 0,11 - 12,00 - 1.253,55 etc.",
        "NonMatchingText": "0,0,00 - 1.11,12 - 1,123 - ,02 - 2, etc.",
        "Description": "This expression allow controling to formatted numeric values."
    },
    {
        "Pattern": "^(\\d{1}|\\d{2}|\\d{3})(\\.\\d{3})*?$",
        "MatchingText": "1.210.122 - 12.215 - 100 etc",
        "NonMatchingText": "1.21.122 - 123. - 123.22 - 123,55 etc",
        "Description": "You can change \\. separator with which you need as a separator like \\, (en-US numbers separator) or \\. (tr-TR numbers separator) etc."
    },
    {
        "Pattern": "^ *([0-1]?[0-9]|[2][0-3]):[0-5][0-9] *(a|p|A|P)(m|M) *$",
        "MatchingText": "11:15 PM, 23:15 PM",
        "NonMatchingText": "28:00 PM, 01:99 AM",
        "Description": "Validates time that's formatted by the ajax MaskedEditEditor (typically in 00:00 AM/PM). Validates 12/24 hour times."
    },
    {
        "Pattern": "^(\\d{3}|\\d{4})[-](\\d{5})$",
        "MatchingText": "654-45654|||5544-65486",
        "NonMatchingText": "455645564|||44-55545|||55455-54565",
        "Description": "Canadian Branch-Transit number test.\n\nThe branch number must be 3 or 4 didgits then '-' then five didgets."
    },
    {
        "Pattern": "\\d\\d?\\d?\\.\\d\\d?\\d?\\.\\d\\d?\\d?\\.\\d\\d?\\d?",
        "MatchingText": "192.168.1.19",
        "NonMatchingText": "19x.168.1.19",
        "Description": "Quick and simple way of matching a well-formed IPV4 (dotted quad) ip address."
    },
    {
        "Pattern": "^((\\(0?[1-9][0-9]\\))|(0?[1-9][0-9]))[ -.]?([1-9][0-9]{3})[ -.]?([0-9]{4})$",
        "MatchingText": "011 5555-1234|||(011) 5555 1234|||(11) 5555.1234|||1155551234",
        "NonMatchingText": "(011 5555-1234|||(01) 5555 1234|||(11) 0555.1234|||(11) 5555 abcd",
        "Description": "Matches Brazilian phone numbers, includes DDD (long-distance call) with or without 0. Accepts characters -, . and [space] as separators."
    },
    {
        "Pattern": "((MON|TUE|WED|THU|FRI|SAT|SUN)[A-Z]*)*[\\ ,-]*(\\d|\\d{2})*(st|nd|rd|th)*[\\ ,-]*(JAN|FEB|MAR|MAY|APR|JUL|JUN|AUG|OCT|SEP|NOV|DEC)[A-Z]*[\\ ,]*(\\d|\\d{2}|\\d{4})*(st|nd|rd|th)*([\\ ,])*'*(\\d{2}|\\d{4})*\\b",
        "MatchingText": "Wednesday March 25, 2015||| 14 MAR 2017||| 4 MAR, 2017|||  March 4, 2017||| Tue March 4, 2017||| Saturday March 4, 2017||| Sun March 24, 2017||| March 3rd||| 1st March||| May||| Oct||| Jun 3rd, '17|||Tue 4th Nov '17",
        "NonMatchingText": "5-23-18 03/25/2015 2015-03-25 2015/03/25 2015.03.25",
        "Description": "Match any date with non digit, text months. Includes day of week prefix. Very permissive. http://regexr.com/3gtaf"
    },
    {
        "Pattern": "^(1\\s*[-\\/\\.]?)?(\\((\\d{3})\\)|(\\d{3}))\\s*([\\s-./\\\\])?([0-9]*)([\\s-./\\\\])?([0-9]*)$",
        "MatchingText": "(305) 555-1234 ||| 305-555-1234 ||| 305 555 1234 ||| 011-52-71405555",
        "NonMatchingText": "ABCD",
        "Description": "This pattern matches most international phone numbers using various versions of phone number patters."
    },
    {
        "Pattern": "^\\$( )*\\d*(.\\d{1,2})?$",
        "MatchingText": "$100.00|||$100|||$10.25",
        "NonMatchingText": "100.|||$10.233|||$10.",
        "Description": "Validates US currency but allows for spaces between the dollar sign and dollar amount. If there is cents the period validates to two decimal places"
    },
    {
        "Pattern": "^\\d+\\x20*([pP][xXtT])?$",
        "MatchingText": "1px|||100 PT|||20Px",
        "NonMatchingText": "1abc|||px|||1 sdfs",
        "Description": "It can be used to validate Font Sizes.\n\nThanks to Gideon Engelberth for the shorter version of my original expression."
    },
    {
        "Pattern": "href[ ]*=[ ]*('|\\&quot;)([^\\&quot;'])*('|\\&quot;)",
        "MatchingText": "href=&quot;index.php&quot;|||href =  'http://www.dailymedication.com'|||href =  &quot;irc://irc.junk",
        "NonMatchingText": "href=http://www.dailymedication.com",
        "Description": "the regex's on this site for pulling links off a page always seemed to be faulty, or at least never worked with PHP, so i made this one.  simple, as i'm an amateur with regex's, but stumbled thru it and this one actually works.  tested with PHP function: preg_match_all(&quot;/href[ ]*=[ ]*('|\\&quot;)([^\\&quot;'])*('|\\&quot;)/&quot;,$string,$matches)"
    },
    {
        "Pattern": "^M{0,1}T{0,1}W{0,1}(TH){0,1}F{0,1}S{0,1}(SU){0,1}$",
        "MatchingText": "MWF | TTHS | MT | WFS | MFSU",
        "NonMatchingText": "MM | WM | FTH | SM",
        "Description": "Matches a string if it is valid in the form of MWF or TTHS.  Maybe used for validating the \"days part\" of a class schedule field.  The string should only accept any of the ff set of letters: 'M' 'T' 'W' 'TH' 'F' 'S' 'SU' .  Only one instance of these set of letters is accepted."
    },
    {
        "Pattern": "^(([0][0-9]|[1][0-2])|[0-9]):([0-5][0-9])( *)((AM|PM)|(A|P))$",
        "MatchingText": "1:30 AM | 01:20 AM | 10:00A | 11:50P",
        "NonMatchingText": "13:00 A | 01:5 AM",
        "Description": "Matches a string if it is a valid time in the format of \"HH:MM AM\" or \"HH:MM A\"."
    },
    {
        "Pattern": "^(?:[\\+]?[\\(]?([\\d]{1,3})[\\s\\-\\.\\)]+)?(?:[\\(]?([\\d]{1,3})[\\s\\-\\/\\)]+)([2-9][0-9\\s\\-\\.]{6,}[0-9])(?:[\\s\\D]+([\\d]{1,5}))?$",
        "MatchingText": "011-656-555-1234|||(217)555-1234|||+82-10-5551-2345|||+(82) 10-5551-2345|||(907) 555-1234|||+886-2-55512345|||1-416-555-1234||| 714 555 1234|||714 555 1234 / 1234|||+886-2-55512345 x 1234|||+886-2-55512345x1234|||1-416-555-1234 ext 1234",
        "NonMatchingText": "7735551234|||+11231234567|||1(123)1234567",
        "Description": "Parses most phone numbers into four groups: country code, area code, number, and extension. "
    },
    {
        "Pattern": "^(?P<Date>.+\\s\\d+\\s\\d+\\:\\d+\\:\\d+).+\\:.+\\:(?P<Traffic>.+)\\:(?P<Rule>.+)\\:IN\\=(?P<InboundInterface>.+)\\sOUT\\=(?P<OutboundIntercace>.*?)\\s(?:MAC\\=(?P<MacAddress>.+)\\s|)SRC\\=(?P<Source>.+)\\sDST\\=(?P<Destination>.+)\\sLEN\\=.+TOS\\=.+PROTO\\=(?P<Protocol>.+)\\sSPT\\=(?P<SourcePort>.+)\\sDPT\\=(?P<DestinationPort>.+)\\s.+$",
        "MatchingText": "Jul 20 13:05:08 123.123.123.123 kernel: Shorewall:loc2net:REJECT:IN=eth0 OUT=eth1 SRC=444.333.222.111 DST=111.222.333.444 LEN=59 TOS=0x00 PREC=0x00 TTL=127 ID=12267 PROTO=UDP SPT=2121 DPT=53 LEN=39",
        "NonMatchingText": "Anything Else",
        "Description": "The goal of my regular expression is to allow me to break apart IP Table log files so that I can build a basic web front-end to allow me to view the traffic on the network. The MAC address is optional, because the way that this firewall works, is by providing the MAC address when the outbound address is not available."
    },
    {
        "Pattern": "if\\s[(][A-Za-z]*\\s[=]\\s",
        "MatchingText": "if ( aces = true ) | if ( alice = 100)",
        "NonMatchingText": "if ( aces != true) | if ( alice === 100)",
        "Description": "finds if statements with only one = sign."
    },
    {
        "Pattern": "^[^\\\\\\/\\?\\*\\\"\\>\\<\\:\\|]*$",
        "MatchingText": "New Folder",
        "NonMatchingText": "New ' Folder",
        "Description": "Validates entry for a valid Windows folder name. Excludes all forbidden characters."
    },
    {
        "Pattern": "(^N/A$)|(^[-]?(\\d+)(\\.\\d{0,3})?$)|(^[-]?(\\d{1,3},(\\d{3},)*\\d{3}(\\.\\d{1,3})?|\\d{1,3}(\\.\\d{1,3})?)$)",
        "MatchingText": "405.234|||50|||213123.456|||-1|||N/A",
        "NonMatchingText": "bathreader|||this is N/A|||3.14159|||+10",
        "Description": "This pattern matches a decimal value with up to 3 digits after the decimal. Comma is allowed as a thousands separator but not required. N/A is also allowed."
    },
    {
        "Pattern": "&lt;[^&gt;]*name[\\s]*=[\\s]*&quot;?[^\\w_]*&quot;?[^&gt;]*&gt;",
        "MatchingText": "&lt;input type = text name = &quot;bob&quot;&gt;|||&lt;select name = &quot;fred&quot;&gt;|||&lt;form",
        "NonMatchingText": "&lt;input type = submit&gt;|||&lt;font face = &quot;arial&quot;&gt;|||The drity brown fox stank like",
        "Description": "This RX is used to find get all named tags in an html string. If you find a problem with it, please email drew@lordstrange.com"
    },
    {
        "Pattern": "(\"[^\"]*\")|('[^\\r]*)(\\r\\n)?",
        "MatchingText": "\"my string\"|||\"a string with ' in it\"|||' comment",
        "NonMatchingText": "asd \"",
        "Description": "Will match a VBScript string and/or comment\n\nEx:\n\n' userinfo\nstrUsername = &quot;tomsve&quot; \niAge = 20\n' temp\nstrPassword = &quot;halloj&quot;\n\n\n...Would result in the following matches:\n' userinfo\n&quot;tomsve&quot;\n' temp\n&quot;halloj&quot;\n\n\nGood luck!\nTom S. info@tomsvensson.com"
    },
    {
        "Pattern": "^(?P<nombre>\\D{4})(?P<fechanac>\\d{6})(?P<homoclave>.{1}\\D{1}\\d{1})?$",
        "MatchingText": "CAET7305157T4",
        "NonMatchingText": "NA",
        "Description": "Validacion de Registro Federal de Contribuyentes (RFC). Para M\u00E9xico. Valida 4 caracteres alfab\u00E9ticos para el nombre, 4 num\u00E9ricos para la fecha de nacimiento, y, opcional, 3 alfanum\u00E9ricos para la homoclave, de los cuales, el primero puede ser num\u00E9rico o alfab\u00E9tico, el segundo es alfabetico y el tercero siempre es num\u00E9rico."
    },
    {
        "Pattern": "^([A-Za-z\\-]+)\\s+(\\w+)\\s+([A-Za-z0-9_\\-\\.]+)\\s+([A-Za-z0-9_\\-\\.]+)\\s+(\\d+)\\s+(.{3} [0-9 ]{2} ([0-9][0-9]:[0-9][0-9]| [0-9]{4}))\\s+(.+)$",
        "MatchingText": "drwxr-xr-x   5 user     dba         1024 Sep 24 21:24 dirname",
        "NonMatchingText": "drwxr-xr-x   5 user     dba         1024 Sep 24_21:24 dirname",
        "Description": "GLOB the output of an \"ls -l\" command to extract specific details.  It takes into account issues with older files/directories having a year in place of an hour:minute entry."
    },
    {
        "Pattern": "^((((31\\/(0?[13578]|1[02]))|((29|30)\\/(0?[1,3-9]|1[0-2])))\\/(1[6-9]|[2-9]\\d)?\\d{2})|(29\\/0?2\\/(((1[6-9]|[2-9]\\d)?(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))))|(0?[1-9]|1\\d|2[0-8])\\/((0?[1-9])|(1[0-2]))\\/((1[6-9]|[2-9]\\d)?\\d{2})) (20|21|22|23|[0-1]?\\d):[0-5]?\\d:[0-5]?\\d$",
        "MatchingText": "29/02/2004 20:15:27|||29/2/04 8:9:5|||31/3/2004 9:20:17",
        "NonMatchingText": "29/02/2003 20:15:15|||2/29/04 20:15:15|||31/3/4 9:20:17",
        "Description": "this expression validates a date-time field in European d/m/y h:m:s format. It is a european variation of Michael Ash's date-validation expression in this library.\nThe days are validated for the given month and year. Leap years are validated for all 4 digits years from 1600-9999, and all 2 digits years except 00"
    },
    {
        "Pattern": "<img[^>]* src=\\\"([^\\\"]*)\\\"[^>]*>",
        "MatchingText": "<img src=\"joka.jpg\" /> <img src=\"joka.jpg\">",
        "NonMatchingText": "<img> <img src=dada>",
        "Description": "It searches for a IMG tag and group information about source of image."
    },
    {
        "Pattern": "^.{0,0}",
        "MatchingText": "\"only an empty string\"",
        "NonMatchingText": "absolutely any text whatsoever",
        "Description": "Only accepts nothing. I know, sounds stupid, but useful for \"Invisible Textbox Captcha\". Bots will fill in a hidden textbox, and this expression busts them."
    },
    {
        "Pattern": "^((19[0-9][0-9])|(20[0-1][0-5]))\\-((0?[1-9])|(1[0-2]))\\-((0?[1-9])|([1-2][0-9])|(3[0-1]))$",
        "MatchingText": "2012-05-21|||1960-12-14|||1910-5-3",
        "NonMatchingText": "2011/5/21|||60-12-14|||2021-5-3",
        "Description": "Year, month and day with dashes.Year starts from 1900 to 2015 and must be 4 digits."
    },
    {
        "Pattern": "((\\(?\\d{2,5}\\)?)?(\\d|-| )?(15((\\d|-| ){6,13})))",
        "MatchingText": "0342-156 310 761  (03404)-154 734 841 11 156 310 761 (011) 154 734 841",
        "NonMatchingText": "0342-6 310 761  (03404)-4 734 841 11     310 761 (011) 4 734 841",
        "Description": "This regex will match cellphones from Argentina, which have a 15 prefix. It takes into account optional parenthesis and various digit groupings"
    },
    {
        "Pattern": "(^[1-9]$)|(^10$)",
        "MatchingText": "1|||8|||10",
        "NonMatchingText": "0|||11|||99",
        "Description": "Matches the numbers 1-10 and only the numbers 1-10."
    },
    {
        "Pattern": "^[A-Za-z]$",
        "MatchingText": "B|||L|||a|||k|||z",
        "NonMatchingText": "BL|||akz|||Az",
        "Description": "Matches a string that contains exactly one letter in the range A-Z or a-z. "
    },
    {
        "Pattern": "^([\\w\\-\\.]+)@((\\[([0-9]{1,3}\\.){3}[0-9]{1,3}\\])|(([\\w\\-]+\\.)+)([a-zA-Z]{2,4}))$",
        "MatchingText": "bob@somewhere.com|||bob.jones@[1.1.1.1]|||bob@a.b.c.d.info",
        "NonMatchingText": "bob@com|||bob.jones@some.where|||bob@1.1.1.123",
        "Description": "Expression 1 of 2 used to check email address syntax."
    },
    {
        "Pattern": "^(([-\\w \\.]+)|(&quot;&quot;[-\\w \\.]+&quot;&quot;) )?&lt;([\\w\\-\\.]+)@((\\[([0-9]{1,3}\\.){3}[0-9]{1,3}\\])|(([\\w\\-]+\\.)+)([a-zA-Z]{2,4}))&gt;$",
        "MatchingText": "&lt;ab@cd.ef&gt;|||bob A. jones &lt;ab@cd.ef&gt;|||bob A. jones &lt;ab@[1.1.1.111]&gt;",
        "NonMatchingText": "ab@cd.ef|||&quot;bob A. jones &lt;ab@cd.ef&gt;|||bob A. jones &lt;ab@1.1.1.111&gt;",
        "Description": "Expression 2 or 2 for matching email address syntax. This one matches the &lt;angle bracket syntax&gt;."
    },
    {
        "Pattern": "([0-9]+\\.[0-9]*)|([0-9]*\\.[0-9]+)|([0-9]+)",
        "MatchingText": "123.456|||.123|||123",
        "NonMatchingText": ".|||apple|||pear",
        "Description": "This is just a very simple matcher for real numbers."
    },
    {
        "Pattern": "\\w.+(\\n\\t.+){0,}",
        "MatchingText": "line\\n\\tnext line start with tab",
        "NonMatchingText": "line\\n\\line\\n",
        "Description": "This can be easily modified for whatever log parsing purpose you have that matches this structure. \n\nFor Example I use this on postgres logs so I can easily group each message together. When postgres logs queries if there is a lf/cr then it copies it verbatim. I suppose you could try to change this in the postgres config for logging not sure if it would be possible or a good idea but you can use this regex to help."
    },
    {
        "Pattern": "^((([a-zA-Z\\'\\.\\-]+)?)((,\\s*([a-zA-Z]+))?)|([A-Za-z0-9](([_\\.\\-]?[a-zA-Z0-9]+)*)@([A-Za-z0-9]+)(([\\.\\-]?[a-zA-Z0-9]+)*)\\.([A-Za-z]{2,})))(;{1}(((([a-zA-Z\\'\\.\\-]+){1})((,\\s*([a-zA-Z]+))?))|([A-Za-z0-9](([_\\.\\-]?[a-zA-Z0-9]+)*)@([A-Za-z0-9]+)(([\\.\\-]?[a-zA-Z0-9]+)*)\\.([A-Za-z]{2,})){1}))*$",
        "MatchingText": "rohrbach|||rohrbach, wi|||rohrbach, wi;roemer;emiles@carlson.com;lagrander, ni",
        "NonMatchingText": "rohrbach;miles;|||rohrbach, wa;|||wrohrbach@carlson.com;miles;;",
        "Description": "This regular expression matches a series of names and/or email addresses much like you would do in Outlook's To field (e.g. To: wrohrbach@carlson.com;miles, er;roemer;lagrander, nitra). The first entry must be a name (in the form of last name followed by a comma and first name) or an email address. The following entries are a semicolon followed by one name or email address. The comma and first name are optional components of the name part."
    },
    {
        "Pattern": "^((8|\\+7)[\\- ]?)?(\\(?\\d{3}\\)?[\\- ]?)?[\\d\\- ]{7,10}$",
        "MatchingText": "+79261234567  ||| 8(926)123-45-67  ||| +7 926 123 45 67",
        "NonMatchingText": "+9 000 000 00 00",
        "Description": "Focused on the Russian mobile + city code of 3 digits (eg, Russia).\n+79261234567\n89261234567\n79261234567\n+7 926 123 45 67\n8(926)123-45-67\n123-45-67\n9261234567\n79261234567\n(495)1234567\n(495) 123 45 67\n89261234567\n8-926-123-45-67\n8 927 1234 234\n8 927 12 12 888\n8 927 12 555 12\n8 927 123 8 123"
    },
    {
        "Pattern": "^\\d{1,2}((,)|(,25)|(,50)|(,5)|(,75)|(,0)|(,00))?$",
        "MatchingText": "1,25 3,75 4,5 7 9,0",
        "NonMatchingText": "1.25 1,4 100,50",
        "Description": "Maximum 2 digits followed by an optional comma and a valid quarter to be used in time calculations. I wasn't satisfied with the quarter regex posted earlier by Bob Kranson."
    },
    {
        "Pattern": "(?:\\b(([0-2]\\d|3[01])|\\d)\\.[ ]?(?:jan|feb|mar|apr|m\u00E1j|j\u00FAn|j\u00FAl|aug|sep|okt|nov|dec|janu\u00E1r\\w{0,2}|febru\u00E1r\\w{0,2}|mar\\w{0,2}|apr\u00EDl\\w{0,2}|m\u00E1j\\w{0,2}|j\u00FAn\\w{0,2}|j\u00FAl\\w{0,2}|august\\w{0,2}|septemb\\w{0,2}|okt\u00F3b\\w{0,2}|novemb\\w{0,2}|decemb\\w{0,2})[ ][12][0-9]\\d\\d\\b)",
        "MatchingText": "\"3. febru\u00E1ra 1988\",  \"23. feb 1988\"",
        "NonMatchingText": "\"33. feb 1988\", \"3. febru\u00E1rov\u00FD 1988\"",
        "Description": "Recognizes dates of format \"[d]d.<slovak name of month>.YYYY\". Months part can be either a 3-letter long abbreviation of a month, or full name (with a possible declination suffix)."
    },
    {
        "Pattern": "^[-+]?[0-9]\\d{0,2}(\\.\\d{1,2})?%?$",
        "MatchingText": "12.3|||123|||-123.45",
        "NonMatchingText": "-|||10.1234|||-1234",
        "Description": "Required and regular expression validator. For supporting \n-999.99 to +999.99 . Positive and Negative integer/ decimal validations. Percentage sign is also supported. Will not allow empty strings. Can increase/decrease the range as you need."
    },
    {
        "Pattern": "(([\\w]+:)?//)?(([\\d\\w]|%[a-fA-f\\d]{2,2})+(:([\\d\\w]|%[a-fA-f\\d]{2,2})+)?@)?([\\d\\w][-\\d\\w]{0,253}[\\d\\w]\\.)+[\\w]{2,4}(:[\\d]+)?(/([-+_~.\\d\\w]|%[a-fA-f\\d]{2,2})*)*(\\?(&?([-+_~.\\d\\w]|%[a-fA-f\\d]{2,2})=?)*)?(#([-+_~.\\d\\w]|%[a-fA-f\\d]{2,2})*)?",
        "MatchingText": "http://www.domain.com || http://domain.com || http://domain.com || https://domain.com || https://sub.domain-name.com:8080 || http://domain.com/dir%201/dir_2/program.ext?var1=x&var2=my%20value || domain.com/index.html#bookmark",
        "NonMatchingText": "Normal Text. || http://a.com || http://www.domain-.com",
        "Description": "A pretty decent URL matching expression.  I've followed most RFC guidelines, so it'll match most anything ya throw at it (And wont match what it's not supposed to).  If you see any problems with it, please email me so I can make the appropriate changes :)"
    },
    {
        "Pattern": "^([^S]|S[^E]|SE[^P]).*",
        "MatchingText": "SEk001 | TAK002",
        "NonMatchingText": "SEP001 | SEP002",
        "Description": "Matches everything except lines that begin with SEP.\n\nNow I just need to figure out how to exclude a string that appears in the middle of a line."
    },
    {
        "Pattern": "^((([!#$%&'*+\\-/=?^_`{|}~\\w])|([!#$%&'*+\\-/=?^_`{|}~\\w][!#$%&'*+\\-/=?^_`{|}~\\.\\w]{0,}[!#$%&'*+\\-/=?^_`{|}~\\w]))[@]\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*)$",
        "MatchingText": "a&d@somedomain.com, a*d@somedomain.com,a/d@somedomain.com,",
        "NonMatchingText": ".abc@somedomain.com, abc.@somedomain.com, a>b@somedomain.com",
        "Description": "According to RFC 2821 (<see cref=\"http://tools.ietf.org/html/2821\"/>)\nand RFC 2822 (<see cref=\"http://tools.ietf.org/html/2822\"/>), the local-part\nof an email addresses may use any of these ASCII characters:\n1. Uppercase and lowercare letters\n2. The digits 0 through 9\n3. The characters, !#$%&'*+-/=?^_`{|}~\n4. The character \".\" provided that it is not the first or last character in the local-part."
    },
    {
        "Pattern": "(^\\([0]\\d{2}\\))(\\d{6,7}$)",
        "MatchingText": "(021)1234567|||(021)123456|||(000)000000",
        "NonMatchingText": "(123)1234567|||025123456|||0252345678",
        "Description": "Validator for New Zealand Mobile phone numbers. Will look for the first number being a 0 and must be a number or either 6 or 7 digits long after to initial (021) suffix"
    },
    {
        "Pattern": "(^\\d{2}\\.\\d{3}\\.\\d{3}\\/\\d{4}\\-\\d{2}$)",
        "MatchingText": "02.025.659/0001-98|||12.043.129/0001-98|||43.456.654/2222-87",
        "NonMatchingText": "a2.025.659/0001-98|||02.025.659/0001-981|||022.025.659/0001-98",
        "Description": "Brazilian CNPJ (xx.xxx.xxx/xxxx-xx)"
    },
    {
        "Pattern": "(([01][\\.\\- +]\\(\\d{3}\\)[\\.\\- +]?)|([01][\\.\\- +]\\d{3}[\\.\\- +])|(\\(\\d{3}\\) ?)|(\\d{3}[- \\.]))?\\d{3}[- \\.]\\d{4}",
        "MatchingText": "1 (999) 999 9999|||999 999 9999|||999 9999",
        "NonMatchingText": "19999999999|||9999999999|||9999999",
        "Description": "167 different US telephone patterns. Options includes a)0 or 1 dial, b)area code, c).+-()space between number dial-area code-number.  "
    },
    {
        "Pattern": "^([-+]?(\\d+\\.?\\d*|\\d*\\.?\\d+)([Ee][-+]?[0-2]?\\d{1,2})?[r]?|[-+]?((\\d+\\.?\\d*|\\d*\\.?\\d+)([Ee][-+]?[0-2]?\\d{1,2})?)?[i]|[-+]?(\\d+\\.?\\d*|\\d*\\.?\\d+)([Ee][-+]?[0-2]?\\d{1,2})?[r]?[-+]((\\d+\\.?\\d*|\\d*\\.?\\d+)([Ee][-+]?[0-2]?\\d{1,2})?)?[i])$",
        "MatchingText": "[+|-]#[.[#]]|[#].#[E|e[+|-]0...299][r] -OR- [+|-][#[.[#]]|[#].#[E|e[+|-]0...299]]i -OR- [+|-]#[.[#]]|[#].#[E|e[+|-]0...299][r]+|-[#[.[#]]|[#].#[E|e[+|-]0...299]]i",
        "NonMatchingText": "[+|-][.][E|e[+|-][0...299]][r] -OR- [+|-].[E|e[+|-][0...299]]i -OR- [+|-][.][E|e[+|-][0...299]][r]+|-[#[.[#]]|[#].#[E|e[+|-][0...299]]]i -OR- any number with more than one sign or decimal seperator -OR- any string with non-leading signs on mantissa and on exponent",
        "Description": "DESCRIPTION \nParses a complex number of kind 'a+bi' from an input string. Please remove all spaces from the input string before using this regex pattern. \nMATCHING EXAMPLES\n'[]'  means is an optional parameter; \n'|'   means OR;\n'+'   is the positive sign;\n'-'   is the negative sign;\n'#'   is one ore more decimal digits;\n'E|e' are the valid exponent symbols;\n'...' is the range for the exponent;\n'r'   means the real part of complex number;\n'i'   means the imaginary part of complex number.\nNOTE\nHas the imaginary part of the input string not a numeric value (e.g. '5-i' is a valid format) it should be interpreted as '5-1i'!"
    },
    {
        "Pattern": "^((?P<r>([-+]?(\\d+\\.?\\d*|\\d*\\.?\\d+)([Ee][-+]?[0-2]?\\d{1,2})?[r]?))|(?P<i>([-+]?((\\d+\\.?\\d*|\\d*\\.?\\d+)([Ee][-+]?[0-2]?\\d{1,2})?)?[i]))|(?P<r>([-+]?(\\d+\\.?\\d*|\\d*\\.?\\d+)([Ee][-+]?[0-2]?\\d{1,2})?[r]?))(?P<i>([-+]((\\d+\\.?\\d*|\\d*\\.?\\d+)([Ee][-+]?[0-2]?\\d{1,2})?)?[i])))$",
        "MatchingText": "see base example",
        "NonMatchingText": "see base example",
        "Description": "This is the same regex pattern as 'Floating Complex Number' but extented by group names. This makes it much easier to extract the parts of the complex number (e.g. string realPart=myMatch.Result(\"${r}\");string imgPart=myMatch.Result(\"${i}\"); )."
    },
    {
        "Pattern": "^([-+]?(\\d+\\.?\\d*|\\d*\\.?\\d+))$",
        "MatchingText": "[+|-]#[.[#]]|[#].#",
        "NonMatchingText": "[+|-][.] -OR- any floating number with an exponent (e.g. 1.0E-8) -OR- any string with more than one sign or decimal seperator -OR- any string with non-leading sign",
        "Description": "DESCRIPTION\nParses a floating number (such as double or float) from an input string. Please remove all spaces from the input string before using this regex pattern.\nMATCHING EXAMPLES\nThe following symbols are used:\n'[]'  means optional parameter;\n'|'   means OR;\n'+'   is the positive sign;\n'-'   is the negative sign;\n'#'   means one or more decimal digits;\n'.'   is decimal seperator."
    },
    {
        "Pattern": "^([-+]?(\\d+\\.?\\d*|\\d*\\.?\\d+)([Ee][-+]?[0-2]?\\d{1,2})?)$",
        "MatchingText": "[+|-]#[.[#]]|[#].#[E|e[+|-]0...299]",
        "NonMatchingText": "[+|-][.][E|e[+|-][0...299]] -OR- [+|-]#[.[#]]|[#].#E|e[+|-]300...\u221E -OR- any string with more than one sign on mantissa or on exponent -OR- any string with non-leading signs on mantissa or exponent -OR- any string with more than one decimal seperator on mantissa ||| any string with one or more decimal seperators on exponent",
        "Description": "DESCRIPTION \nParses a floating number with an optional exponent from an input string. Please remove all spaces from the input string before using this regex pattern. \nMATCHING EXAMPLES\nThe following symbols are used:\n'[]'  means an optional parameter;\n'|'   means OR;\n'+'   means the positive sign;\n'-'   means the negative sign;\n'#'   means one or more numbers (0...9);\n'.'   is the decimal seperator;\n'E|e' are the valid exponent symbols;\n'...' is the range of values for the exponent."
    },
    {
        "Pattern": "@{2}((\\S)+)@{2}",
        "MatchingText": "@@test@@|||@@name@@|||@@2342@@",
        "NonMatchingText": "@test@|||@@na me@@|||@@ name@@",
        "Description": "This will match results in a template situation. For example:\ntemplate reads\nDear @@Name@@,\n....\nwould become\nDear John,\nIf you dont want to use the @@ change the @ to what ever characters you want.\n"
    },
    {
        "Pattern": "^([a-zA-Z]:\\\\)?[^\\x00-\\x1F\"<>\\|:\\*\\?/]+\\.[a-zA-Z]{3,4}$",
        "MatchingText": "file.txt | fie.txt.pdf  | file(with parenthesis).pdf",
        "NonMatchingText": "*file.pdf | file.tx",
        "Description": "This matches a valid windows filename. Not a valid path.I wanted something simple that covered all the bases"
    },
    {
        "Pattern": "(^0[1-9]\\d{1}\\s\\d{4}\\s?\\d{4}$)|(^0[1-9]\\d{2}\\s\\d{3}\\s?\\d{4}$)|(^0[1-9]\\d{2}\\s\\d{4}\\s?\\d{3}$)|(^0[1-9]\\d{3}\\s\\d{3}\\s?\\d{2}$)|(^0[1-9]\\d{3}\\s\\d{3}\\s?\\d{3}$)|(^0[1-9]\\d{4}\\s\\d{3}\\s?\\d{2}$)|(^0[1-9]\\d{4}\\s\\d{2}\\s?\\d{3}$)|(^0[1-9]\\d{4}\\s\\d{2}\\s?\\d{2}$)",
        "MatchingText": "01323 293 374|||020 73643763|||017354 7478",
        "NonMatchingText": "02 83838 74|||(01323) 828223|||+44 88282 828",
        "Description": "This will match valid UK telephone numbers.  This adheres to ofcom's code and number length guide available at http://www.ofcom.org.uk/licensing_numbering/numbers/num_user_guide#1b           Brackets and international codes are not allowed. \nA space MUST be used after the dialling code, and spaces at the expected points within the remainder of the number can be used if need be, but not nessesary, hence 0208 6473 373 is the same as 0208 647 3373 and 0208 6473373"
    },
    {
        "Pattern": "[DJF]{1}[0-9]{5,8}",
        "MatchingText": "D82837 J23578 F23546530",
        "NonMatchingText": "K23456 D4573 J354 F3493849384",
        "Description": "I needed to ensure that a valid hospital number is entered into one of my systems.  They must be prefixed with D,J,F (upper case) and a number (5 to 8 digits in length). "
    },
    {
        "Pattern": "^[+-]?\\d+(\\,\\d{3})*\\.?\\d*\\%?$",
        "MatchingText": "1234 ||| 1,234 ||| 12.34 ||| +123 ||| -123.4 ||| 1,234,567.890 ||| 100%",
        "NonMatchingText": "abc ||| 12-34 ||| 1.234,56 ||| 1,2345",
        "Description": "Matches standard US number formats."
    },
    {
        "Pattern": "^\\d{3}-\\d{7}[0-6]{1}$",
        "MatchingText": "999-99999995|||123-47859683|||156-78965422",
        "NonMatchingText": "123-47859689|||9999999999|||9588-58964",
        "Description": "Airway bill no that allows only the format 999-99999998 and does not allow the last digit to be 7,8,9."
    },
    {
        "Pattern": "(^0.*[1-9]*)|(^860+)|(^8613)|(\\D)|([0-9])",
        "MatchingText": "0234568|||8601063971622|||1-221555",
        "NonMatchingText": "861063971622",
        "Description": "forbidden tele numbers when it starts with 0,\n860+,8613,character or has any SBC case.\nyou can also use it to any international phone dialed by E1 ,etc . this regex has been tested by java, perl,.net\nPS: the last regex [0-9]is in SBC case"
    },
    {
        "Pattern": "(^4\\d{12}$)|(^4[0-8]\\d{14}$)|(^(49)[^013]\\d{13}$)|(^(49030)[0-1]\\d{10}$)|(^(49033)[0-4]\\d{10}$)|(^(49110)[^12]\\d{10}$)|(^(49117)[0-3]\\d{10}$)|(^(49118)[^0-2]\\d{10}$)|(^(493)[^6]\\d{12}$)",
        "MatchingText": "4111111111111111",
        "NonMatchingText": "4903020000000008",
        "Description": "Matches Visa CC types 13 or 16 digits starting with 4 including Visa CC, Visa ATM only, Visa Electron and Visa Delta.  Safe for international and will NOT match \"^(49)\" Switch debit cards."
    },
    {
        "Pattern": "(^(5[0678])\\d{11,18}$)\n|(^(6[^0357])\\d{11,18}$)\n|(^(601)[^1]\\d{9,16}$)\n|(^(6011)\\d{9,11}$)\n|(^(6011)\\d{13,16}$)\n|(^(65)\\d{11,13}$)\n|(^(65)\\d{15,18}$)\n|(^(633)[^34](\\d{9,16}$))\n|(^(6333)[0-4](\\d{8,10}$))\n|(^(6333)[0-4](\\d{12}$))\n|(^(6333)[0-4](\\d{15}$))\n|(^(6333)[5-9](\\d{8,10}$))\n|(^(6333)[5-9](\\d{12}$))\n|(^(6333)[5-9](\\d{15}$))\n|(^(6334)[0-4](\\d{8,10}$))\n|(^(6334)[0-4](\\d{12}$))\n|(^(6334)[0-4](\\d{15}$))\n|(^(67)[^(59)](\\d{9,16}$))\n|(^(6759)](\\d{9,11}$))\n|(^(6759)](\\d{13}$))\n|(^(6759)](\\d{16}$))\n|(^(67)[^(67)](\\d{9,16}$))\n|(^(6767)](\\d{9,11}$))\n|(^(6767)](\\d{13}$))\n|(^(6767)](\\d{16}$))",
        "MatchingText": "5600000000000003",
        "NonMatchingText": "6011000000000004",
        "Description": "Meastro ONLY card matching - begins with \"50\" or \"56-58\" or \"6\" & 13 to 20 total digits. Overlap of Discover, Solo and Switch is handled and NOT matched."
    },
    {
        "Pattern": "^5[1-5]\\d{14}$",
        "MatchingText": "5100000000000008",
        "NonMatchingText": "201400000000009",
        "Description": "Matches MasterCard credit cards.  International safe, no overlap with other cards."
    },
    {
        "Pattern": "(^(6011)\\d{12}$)|(^(65)\\d{14}$)",
        "MatchingText": "6011000000000004",
        "NonMatchingText": "4508750000000009",
        "Description": "Discover Credit Card matching.  International safe, no overlap"
    },
    {
        "Pattern": "(^3[47])((\\d{11}$)|(\\d{13}$))",
        "MatchingText": "340000000000009",
        "NonMatchingText": "4508750000000009",
        "Description": "AMEX Credit Card match.  International safe"
    },
    {
        "Pattern": "(^(6334)[5-9](\\d{11}$|\\d{13,14}$))\n|(^(6767)(\\d{12}$|\\d{14,15}$))",
        "MatchingText": "6334500000000003",
        "NonMatchingText": "3528000000000007",
        "Description": "Solo Credit Card match.  International safe."
    },
    {
        "Pattern": "(^(49030)[2-9](\\d{10}$|\\d{12,13}$))\n|(^(49033)[5-9](\\d{10}$|\\d{12,13}$))\n|(^(49110)[1-2](\\d{10}$|\\d{12,13}$))\n|(^(49117)[4-9](\\d{10}$|\\d{12,13}$))\n|(^(49118)[0-2](\\d{10}$|\\d{12,13}$))\n|(^(4936)(\\d{12}$|\\d{14,15}$))\n|(^(564182)(\\d{11}$|\\d{13,14}$))\n|(^(6333)[0-4](\\d{11}$|\\d{13,14}$))\n|(^(6759)(\\d{12}$|\\d{14,15}$))",
        "MatchingText": "4903020000000008",
        "NonMatchingText": "4111111111111111",
        "Description": "Switch CC match.  International safe."
    },
    {
        "Pattern": "(^(352)[8-9](\\d{11}$|\\d{12}$))|(^(35)[3-8](\\d{12}$|\\d{13}$))",
        "MatchingText": "3528000000000007",
        "NonMatchingText": "4508750000000009",
        "Description": "JCB cc match.  International safe"
    },
    {
        "Pattern": "(^(30)[0-5]\\d{11}$)|(^(36)\\d{12}$)|(^(38[0-8])\\d{11}$)",
        "MatchingText": "30000000000004",
        "NonMatchingText": "3528000000000007",
        "Description": "Diners CC match.  International safe"
    },
    {
        "Pattern": "^(389)[0-9]{11}$",
        "MatchingText": "38900000000007",
        "NonMatchingText": "30000000000004",
        "Description": "Cart Blance Credit Card match. International safe"
    },
    {
        "Pattern": "(^(2014)|^(2149))\\d{11}$",
        "MatchingText": "201400000000009",
        "NonMatchingText": "38900000000007",
        "Description": "EnRoute Credit Card match. international safe."
    },
    {
        "Pattern": "(^(5[0678])\\d{11,18}$)|(^(6[^05])\\d{11,18}$)|(^(601)[^1]\\d{9,16}$)|(^(6011)\\d{9,11}$)|(^(6011)\\d{13,16}$)|(^(65)\\d{11,13}$)|(^(65)\\d{15,18}$)|(^(49030)[2-9](\\d{10}$|\\d{12,13}$))|(^(49033)[5-9](\\d{10}$|\\d{12,13}$))|(^(49110)[1-2](\\d{10}$|\\d{12,13}$))|(^(49117)[4-9](\\d{10}$|\\d{12,13}$))|(^(49118)[0-2](\\d{10}$|\\d{12,13}$))|(^(4936)(\\d{12}$|\\d{14,15}$))",
        "MatchingText": "6334500000000003",
        "NonMatchingText": "6011000000000004",
        "Description": "Matches any of Solo, Switch or Maestro.  International safe. Will not match on Discover, Visa or Mastercard.  For example; Most recommendations for matching Visa are that they start with \"4\".  If outside the US, this are incomplete on will falsly ID most Switch cards as Visa."
    },
    {
        "Pattern": "(\\d{5})[\\.\\-\\+ ]?(\\d{4})?",
        "MatchingText": "03576|||12345-1234|||123456789|||03576 1234",
        "NonMatchingText": "abcde|||03576-abcd|||3211",
        "Description": "Matches any 5 or 9 digit U.S. zip code with a period, hyphen, plus sign, space delimiter or no delimiter. The first capture is the first 5 digits and, optionally, the second capture is the last 4 digits.\nAdd ^ at the beginning and $ to force the entire string to be a valid zip."
    },
    {
        "Pattern": "^([A-Z]{1}[a-z]{1,})$|^([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^([A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,}\\040[A-Z]{1}[a-z]{1,})$|^$",
        "MatchingText": "Sacramento|||San Francisco|||San Luis Obispo",
        "NonMatchingText": "SanFrancisco|||SanLuisObispo|||San francisco",
        "Description": "Matches up to three alphabet words separated by spaces with first alphabet character of each word uppercase. Also matches empty strings."
    },
    {
        "Pattern": "^((\\$?\\-?)|(\\-?\\$?))([0-9]{1,3},([0-9]{3},)*[0-9]{3}|[0-9]+)?(\\.[0-9]*)?$",
        "MatchingText": "$.01|||1,234.003|||834223.1|||$0.01|||-$1.50||$-50.123",
        "NonMatchingText": ".0,001|||1,1.01|||1E|||5$",
        "Description": "Matches any number which includes the US currency symbol ($), a negative sign (-), comma separators, and a decimal.  It matches an unlimited number of decimal places.  It does NOT reject an empty string passed to it.  Credit goes to Al Kahler for posting the original expression from http://regxlib.com/REDetails.aspx?regexp_id=70 along with a fix for the decimal place."
    },
    {
        "Pattern": "^((\\.)?([a-zA-Z0-9_-]?)(\\.)?([a-zA-Z0-9_-]?)(\\.)?)+$",
        "MatchingText": "_-.aAa._-.aAa_-.",
        "NonMatchingText": "special charachters",
        "Description": "Allows letters,numbers,hyphens,periods and underscores. Such as : Aa.Aa.Aa, .Aa.Aa. , -Aa-Aa- , _Aa_Aa_ , Aa_Aa_Aa , Aa-Aa-Aa , . , - , _ \n\n\nI was asked by my client for this scenario to allow letters,numbers,hyphens,periods and underscores in User ID field in web application."
    },
    {
        "Pattern": "(?:youtu\\.be\\/|youtube.com\\/(?:watch\\?.*\\bv=|embed\\/|v\\/)|ytimg\\.com\\/vi\\/)(.+?)(?:[^-a-zA-Z0-9]|$)",
        "MatchingText": "http://www.youtube.com/watch?v=QH2-TGUlwu4|||http://youtu.be/QH2-TGUlwu4|||http://www.youtube.com/embed/QH2-TGUlwu4|||http://www.youtube.com/v/QH2-TGUlwu4?version=3&amp;hl=en_US|||http://i4.ytimg.com/vi/QH2-TGUlwu4/default.jpg",
        "NonMatchingText": "asdf",
        "Description": "This regex should recognize a Youtube video ID from any Youtube URL, embed snippet, or preview image."
    },
    {
        "Pattern": "((http(s)?:\\/\\/)?[a-z0-9-]{3,}(\\.[a-z0-9-]{2,})+(:[0-9]+)?((\\/[^\\/\\s.]+\\.[^\\/\\s.,!]+)|(\\/[^\\/\\s.,!]*))*)",
        "MatchingText": "http://google.com, http://google.com/, google.com, https://google.com/, https://www.google.com/imghp?hl=en&tab=wi, http://www.google.com/index.html, http://google.com/samplepage?param=val&p2=val2",
        "NonMatchingText": "https://www.google.com/index.something.html, http://google.com/samplepage?param=val,&p2=val2, http://google.com/samplepage?param=val!&p2=val2",
        "Description": "This works for valid URLs of all sizes. All slashes have been escaped, replace \\/ with / to undo."
    },
    {
        "Pattern": "^(05)[0-9]{8}$",
        "MatchingText": "05dddddddd , 054ddddddd, 056ddddddd ...",
        "NonMatchingText": "55dddddddd or 09dddddddd ",
        "Description": "Saudi Arabia Mobile Numbers Format without country key."
    },
    {
        "Pattern": "^(966)(5)[0-9]{8}$",
        "MatchingText": "9665dddddddd",
        "NonMatchingText": "9666dddddddd , 9626dddddddd",
        "Description": "Saudi Arabia Mobile Numbers Format with country key, If you required to use 00966 just replace it with 966 in the expression."
    },
    {
        "Pattern": "^((http|https):[/][/]|www.)([\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&=]*)?",
        "MatchingText": "http://www.google.com,https://www.google.com,www.google.com",
        "NonMatchingText": "google.com",
        "Description": "This regular expression allows http,https also."
    },
    {
        "Pattern": "[A-Z|a-z]{4}[0][\\d]{6}$",
        "MatchingText": "CITI0344444",
        "NonMatchingText": "CITI3444444",
        "Description": "IFSC Code normally contains 11 characters.In that first 4 characters are alphabets,5th character is 0 and next 6 characters are numerics"
    },
    {
        "Pattern": "^[a-zA-Z]{3}[0-9]{6}$",
        "MatchingText": "abc123456|||ptx654321",
        "NonMatchingText": "abc 123456||| ab12345x|||abc12345",
        "Description": "Simple Pac code regex, first 3 should be letters and last 6 should be digits."
    },
    {
        "Pattern": "(\\s|\\n|^)(\\w+://[^\\s\\n]+)",
        "MatchingText": "http://www.acme.com|||ftp://ftp.acme.com/hede|||gopher://asdfasd.asdfasdf",
        "NonMatchingText": "&lt;a href=&quot;http://acme.com&quot;&gt;http://www.acme.com&lt;/a&gt;|||&lt;br&gt;http://www.acme.",
        "Description": "will match free floating valid protocol + urls in text ... will not touch the ones wrapped in a tag, so that you can auto-link the ones that aren't :) couple of things to know :\n1. if the url is next to a tag this won't work (eg : &lt;br&gt;http://www.acme.com), the url must either start with a \\s, \\n or any character other than &gt;.\n2. the pattern will match the preceding \\s and \\n too, so when you replace put them back in place $1 will either be \\s or \\n, $2 will be the exact match\n\nvb usage :\nset re = New RegExp\nre.Pattern =&quot;(\\s|\\n|^)(\\w+://[^\\s\\n]+)&quot;\nstrResult = re.Replace(strText, &quot;$1&lt;a href='$2' target='_new'&gt;$2&lt;/a&gt;&quot;)"
    },
    {
        "Pattern": "^(?P<type>(\\w+(\\.?\\w+)+))\\s*,\\s*(?P<assembly>[\\w\\.]+)(,\\s?Version=(?P<version>\\d+\\.\\d+\\.\\d+\\.\\d+))?(,\\s?Culture=(?P<culture>\\w+))?(,\\s?PublicKeyToken=(?P<token>\\w+))?$",
        "MatchingText": "aaa.bbb.ccc, Aaa, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null",
        "NonMatchingText": " Aaa, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null",
        "Description": ".Net full type name with full assembly name "
    },
    {
        "Pattern": "^([a-zA-Z]+)://([a-zA-Z0-9_\\-]+)((\\.[a-zA-Z0-9_\\-]+|[0-9]{1,3})+)\\.([a-zA-Z]{2,6}|[0-9]{1,3})((:[0-9]+)?)((/[a-zA-Z0-9_\\-,.;=%]*)*)((\\?[a-zA-Z0-9_\\-,.;=&%]*)?)$",
        "MatchingText": "this://is.accepted.com/?and=it&sO=K|||this://is.accept.ed?too=|||and://also.this.one:12/?is=right",
        "NonMatchingText": "this.is.NOT.accepted|||neither://this.is&one|||abs://olut.ely.no:way",
        "Description": "Checks whether the entered string looks like a URI, with a specified protocol. Optionally, you can add the port number, and some GET variables.\n\nThe control is quite loose, but it's a choice of mine.\n\nComments and corrections are welcome."
    },
    {
        "Pattern": "(00[02-5]|099|213|269|34[358]|353|419|42[89]|51[789]|529|53[36]|552|5[67]8|5[78]9|621|6[348]2|6[46]3|659|69[4-9]|7[034]2|709|715|771|81[789]|8[3469]9|8[4568]8|8[6-9]6|8[68]7|9[02]9|987)\\d{5}",
        "MatchingText": "10038 11205 20723",
        "NonMatchingText": "09911 26942 98763",
        "Description": "This matches all 5 digit numbers whose first three digits match valid US ZIP code prefixes."
    },
    {
        "Pattern": "(00[02-5]|099|213|269|34[358]|353|419|42[89]|51[789]|529|53[36]|552|5[67]8|5[78]9|621|6[348]2|6[46]3|659|69[4-9]|7[034]2|709|715|771|81[789]|8[3469]9|8[4568]8|8[6-9]6|8[68]7|9[02]9|987)\\d{5}(-\\d{4}){0,1}",
        "MatchingText": "10038 11205 20723 12345-1222",
        "NonMatchingText": "09911 26942 98763 12345-122",
        "Description": "Matches all US ZIP and ZIP+4 codes with vaild prefixes."
    },
    {
        "Pattern": "^(^(PRN|AUX|CLOCK\\$|NUL|CON|COM\\d|LPT\\d|\\..*)(\\..+)?$)[^\\x00-\\x1f\\\\?*:\\\";|/]+$",
        "MatchingText": "test.txt|||test.jpg.txt|||a&b c.bmp",
        "NonMatchingText": "CON|||.pdf|||test:2.pdf",
        "Description": "Checks for a valid windows file name (Must be used with the case-insensitive option \n\nChecks that the file has at lease one char, does not contain any invalid characters and does not have a reserved word as a file name.\n\n&quot;If you see a &amp;quot; in the regex replace it with a &quot; character&quot;"
    },
    {
        "Pattern": "^\\d{4}[\\-\\/\\s]?((((0[13578])|(1[02]))[\\-\\/\\s]?(([0-2][0-9])|(3[01])))|(((0[469])|(11))[\\-\\/\\s]?(([0-2][0-9])|(30)))|(02[\\-\\/\\s]?[0-2][0-9]))$",
        "MatchingText": "0001-12-31|||9999 09 30|||2002/03/03",
        "NonMatchingText": "0001\\02\\30|||9999.15.01|||2002/3/3",
        "Description": "- validates a yyyy-mm-dd, yyyy mm dd, or yyyy/mm/dd date\n- makes sure day is within valid range for the month\n- does NOT validate Feb. 29 on a leap year, only that Feb. CAN have 29 days"
    },
    {
        "Pattern": "^(FR)?\\s?[A-Z0-9-[IO]]{2}[0-9]{9}$",
        "MatchingText": "FR 1R123456789|||FR R1123456789|||FRR1123456789|||K1232345674",
        "NonMatchingText": " FR I123456789|||FR O123456789|||FR 1O23456789",
        "Description": "0 or one FR +\n0 or one space +\n11 characters (that may include alphabetical characters - any except O or I (first or second or first and second))\n12345678901 - \nX1234567890 - \n1X123456789 - \nXX123456789 - \n\n. "
    },
    {
        "Pattern": "^(\\(\\d{3}\\)[- ]?|\\d{3}[- ])?\\d{3}[- ]\\d{4}$",
        "MatchingText": "(555)555-5555|||(555) 555-5555|||555-5555",
        "NonMatchingText": "5555555555|||555.555.5555|||(555 555-5555",
        "Description": "US telephone pattern.  Optional area code with or without '()'.  If area code has parentheses then it is optionally followed by - or space. If no parentheses then it must be followed by - or space.  Number must be separated by either a space or -."
    },
    {
        "Pattern": "(^\\d*\\.?\\d*[0-9]+\\d*$)|(^[0-9]+\\d*\\.\\d*$)",
        "MatchingText": "0.00|||1.23|||4.56",
        "NonMatchingText": "-1.03|||-0.01|||-0.00",
        "Description": "This matches all positive decimal values. There was one here already which claimed to but would fail on value 0.00 which is positive AFAIK..."
    },
    {
        "Pattern": "^([1-9]\\d*|0)(([.,]\\d*[1-9])?)$",
        "MatchingText": "1500|||0,331|||12.005",
        "NonMatchingText": "01500|||0,330|||012.0050",
        "Description": "Positive real multi-digit  number: don't allow preciding zero, last decimal digit zero not allowed."
    },
    {
        "Pattern": "^((01[0-9])\\d{9}$|(1[0-9])\\d{9}$|((00\\d{5,6}|\\+\\d{4,6}|\\+[(]\\d{1,3}[)]\\d{3}))(|[-\\/])\\d{8}$)",
        "MatchingText": "+(49)15732561545 | +4915732561545 | 004915732561545 | +(49)157/32561545 | +49157/32561545 | 0049157/32561545 | +(49)157-32561545 | +49157-32561545 | 0049157-32561545",
        "NonMatchingText": "+[49]15732561545 | +-4915732561545 | 0049-15732561545 | +[49]157*32561545 | +49157_32561545 | 0049157_32561545 | +(49)157_*32561545 | +49_157-32561545 | 0049157//32561545",
        "Description": "I created my own RegEx for German/International, it includes Operators like + and / in the RegEx. The Prefix can be from 1 to 999. \n\nBe free to use it !"
    },
    {
        "Pattern": "^(\\d{5}([-\\/]|)\\d{0,9}$|((00\\d{5,6}|\\+\\d{4,6}|\\+[(]\\d{1,3}[)]))\\d{1,4}(|[-\\/])\\d{1,7}$)",
        "MatchingText": "+(49)70425159535 | +4970425159535 | 004970425159535 | +(49)7042/5159535 | +497042/5159535 | 00497042/5159535 | +(49)7042-5159535 | +497042-5159535 | 00497042-5159535",
        "NonMatchingText": "+[49]70455159535 | +-4970425159535 | 0049-70425159535 | +[49]7045*5159535 | +497045_5159535 | 00497045_5159535 | +(49)7045_*5159535 | +49_7045-5159535 | 00497045//5159535",
        "Description": "I created my own RegEx for German/International, it includes Operators like + and / in the RegEx. The Prefix can be from 1 to 999. \n\nBe free to use it !"
    },
    {
        "Pattern": "^(?:\\d+,\\s*)*\\d+\\s*$",
        "MatchingText": "7|||11,9,7,5, 1 ,3|||2 , 6",
        "NonMatchingText": "Hello|||9,,,5,1|||2,",
        "Description": "Checks if the target string is an array consisted of integer numbers or not. An integer array string means that a series of integer numbers that separated by comma (,)"
    },
    {
        "Pattern": "^((\\+?(?P<CountryCode>1)\\s(?P<AreaCode>[2-9][0-8][0-9])\\s)|((?P<AreaCode>[2-9][0-8][0-9])\\s))?(?P<ExchangeCode>[2-9][0-9][0-9])\\s(?P<StationCode>[0-9][0-9][0-9][0-9])$",
        "MatchingText": "+1 206 555 3080",
        "NonMatchingText": "1 555 3080",
        "Description": "Matches normalized (space separated) phone numbers according to the NANP (North American Numbering Plan). It doesn't support extension numbers."
    },
    {
        "Pattern": "\\x26(((amp\\x3B)|(nbsp\\x3B)|(lt\\x3B)|(gt\\x3B)|(copy\\x3B)|(reg\\x3B)|(cent\\x3B)|(deg\\x3B)|(deg\\x3B)|(micro\\x3B)|(middot\\x3B)|(not\\x3B)|(para\\x3B)|(plusmn\\x3B)|(pound\\x3B)|(raquo\\x3B)|(sect\\x3B)|(yen\\x3B)|([\\x23][0-9]{1,3}\\x3B)|(lsquo\\x3B)|(rsquo\\x3B)|(sbquo\\x3B)|(ldquo\\x3B)|(rdquo\\x3B)|(bdquo\\x3B)|(dagger\\x3B)|(Dagger\\x3B)|(permil\\x3B)|(lsaquo\\x3B)|(rsaquo\\x3B)|(spades\\x3B)|(clubs\\x3B)|(hearts\\x3B)|(diams\\x3B)|(oline\\x3B)|(larr\\x3B)|(uarr\\x3B)|(rarr\\x3B)|(darr\\x3B)|(trade\\x3B)|([\\x23]x2122\\x3B)|(quot\\x3B)|(frasl\\x3B)|(ndash\\x3B)|(mdash\\x3B)|(iexcl\\x3B)|(cent\\x3B)|(curren\\x3B)|(brvbar\\x3B)|(brvbar\\x3B)|(uml\\x3B)|(die\\x3B)|(ordf\\x3B)|(laquo\\x3B)|(not\\x3B)|(shy\\x3B)|(macr\\x3B)|(hibar\\x3B)|(sup2\\x3B)|(sup3\\x3B)|(acute\\x3B)|(micro\\x3B)|(cedil\\x3B)|(sup1\\x3B)|(ordm\\x3B)|(raquo\\x3B)|(frac14\\x3B)|(frac12\\x3B)|(frac34\\x3B)|(iquest\\x3B)|(Agrave\\x3B)|(Aacute\\x3B)|(Acirc\\x3B)|(Atilde\\x3B)|(Auml\\x3B)|(Aring\\x3B)|(AElig\\x3B)|(Ccedil\\x3B)|(Egrave\\x3B)|(Eacute\\x3B)|(Ecirc\\x3B)|(Euml\\x3B)|(Igrave\\x3B)|(Iacute\\x3B)|(Icirc\\x3B)|(Iuml\\x3B)|(ETH\\x3B)|(Ntilde\\x3B)|(Ograve\\x3B)|(Oacute\\x3B)|(Ocirc\\x3B)|(Otilde\\x3B)|(Ouml\\x3B)|(times\\x3B)|(Oslash\\x3B)|(Ugrave\\x3B)|(Uacute\\x3B)|(Ucirc\\x3B)|(Uuml\\x3B)|(Yacute\\x3B)|(THORN\\x3B)|(szlig\\x3B)|(agrave\\x3B)|(aacute\\x3B)|(acirc\\x3B)|(atilde\\x3B)|(auml\\x3B)|(aring\\x3B)|(aelig\\x3B)|(ccedil\\x3B)|(egrave\\x3B)|(eacute\\x3B)|(ecirc\\x3B)|(euml\\x3B)|(igrave\\x3B)|(iacute\\x3B)|(icirc\\x3B)|(iuml\\x3B)|(eth\\x3B)|(ntilde\\x3B)|(ograve\\x3B)|(oacute\\x3B)|(ocirc\\x3B)|(otilde\\x3B)|(ouml\\x3B)|(divide\\x3B)|(oslash\\x3B)|(ugrave\\x3B)|(uacute\\x3B)|(ucirc\\x3B)|(uuml\\x3B)|(yacute\\x3B)|(thorn\\x3B)|(yuml\\x3B)|(Alpha\\x3B)|(Alpha\\x3B)|(Beta\\x3B)|(beta\\x3B)|(Gamma\\x3B)|(gamma\\x3B)|(Delta\\x3B)|(delta\\x3B)|(Epsilon\\x3B)|(epsilon\\x3B)|(Zeta\\x3B)|(zeta\\x3B)|(Eta\\x3B)|(eta\\x3B)|(Iota\\x3B)|(iota\\x3B)|(Kappa\\x3B)|(kappa\\x3B)|(Lambda\\x3B)|(lambda\\x3B)|(Mu\\x3B)|(mu\\x3B)|(Nu\\x3B)|(nu\\x3B)|(Xi\\x3B)|(xi\\x3B)|(Omicron\\x3B)|(omicron\\x3B)|(Pi\\x3B)|(pi\\x3B)|(Rho\\x3B)|(rho\\x3B)|(Sigma\\x3B)|(sigma\\x3B)|(Tau\\x3B)|(tau\\x3B)|(Upsilon\\x3B)|(upsilon\\x3B)|(Phi\\x3B)|(phi\\x3B)|(Chi\\x3B)|(chi\\x3B)|(Psi\\x3B)|(psi\\x3B)|(Omega\\x3B)|(omega\\x3B)))",
        "MatchingText": "&",
        "NonMatchingText": "&amp; &psi; &#24;",
        "Description": "This expression will match ampersands('&') that are not part an HTML Special Character string."
    },
    {
        "Pattern": "([0-9]+)(?:st|nd|rd|th)",
        "MatchingText": "1st|2nd|3rd|4th|232nd",
        "NonMatchingText": "11 th|abc|30ty|15xx|56",
        "Description": "This will only pull the number off of something like 23rd."
    },
    {
        "Pattern": "^([a-zA-Z]\\:|\\\\\\\\[^\\/\\\\:*?\"<>|]+\\\\[^\\/\\\\:*?\"<>|]+)(\\\\[^\\/\\\\:*?\"<>|]+)+(\\.[^\\/\\\\:*?\"<>|]+)$",
        "MatchingText": "c:\\Test.txt|||\\\\server\\shared\\Test.txt|||\\\\server\\shared\\Test.t",
        "NonMatchingText": "c:\\Test|||\\\\server\\shared|||\\\\server\\shared\\Test.?",
        "Description": "This regular expression match any valid file path. It checks local drives and network path. The file extension is required."
    },
    {
        "Pattern": "^\\+?\\(?\\d+\\)?(\\s|\\-|\\.)?\\d{1,3}(\\s|\\-|\\.)?\\d{4}$",
        "MatchingText": "555 5555|||(555) 555-5555|||+555 5555555",
        "NonMatchingText": "+ 55 5555|||() 555 5555",
        "Description": "Simply matches a telephone number. Not meant to be extremly accurate but more for q uick match or extracting from a body of text. Does not support extensions"
    },
    {
        "Pattern": "^\\+?\\(?\\d+\\)?(\\s|\\-|\\.)?\\d{1,3}(\\s|\\-|\\.)?\\d{4}$",
        "MatchingText": "555 5555|||(555) 555-5555|||+555 5555555",
        "NonMatchingText": "+ 55 5555|||() 555 5555",
        "Description": "Simply matches a telephone number. Not meant to be extremly accurate but more for q uick match or extracting from a body of text. Does not support extensions"
    },
    {
        "Pattern": "(((ht|f)tp(s?))\\://)?(\\bw{3}[^w]\\b)?[^w{4}][^\\@]([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(/\\S*)?",
        "MatchingText": "http://www.url.com|www.url.com|www.url.com/dominos.asp|url.com|www.url.com.au|www.url.travel|travel.url.com",
        "NonMatchingText": "wwww.url.com|rob@url.com||http://wwww.url.com|http://www.w",
        "Description": "This is a modification to an existing Regular Expression I had that was modified to cater for things like wwww., travel.url.com, url.com/travel, .com.au, and others."
    },
    {
        "Pattern": "[\\t ]+",
        "MatchingText": "space ||| tab",
        "NonMatchingText": "line break",
        "Description": "Whitespace (a space or tab) . From http://tools.twainscanning.com/getmyregex ."
    },
    {
        "Pattern": "[\\s]+",
        "MatchingText": "space ||| tab",
        "NonMatchingText": "12345",
        "Description": "Whitespace (a space, tab or line break) . From http://tools.twainscanning.com/getmyregex ."
    },
    {
        "Pattern": "[A-Za-z]{5}",
        "MatchingText": "TWAIN|||forum",
        "NonMatchingText": "test",
        "Description": "Word 5-letter word (TWAIN forum) . From http://tools.twainscanning.com/getmyregex ."
    },
    {
        "Pattern": "[\\dA-Za-z]+",
        "MatchingText": "TWAIN23",
        "NonMatchingText": "whitespace",
        "Description": "Word Alphanumeric characters (TWAIN23) . From http://tools.twainscanning.com/getmyregex ."
    },
    {
        "Pattern": "[\\w!&quot;#$%&amp;&apos;()*+,./:;&lt;=&gt;?@[\\\\\\]`{|}~^-]+",
        "MatchingText": "TWAIN2.3",
        "NonMatchingText": "null",
        "Description": "Word Alphanumeric characters and symbols (TWAIN2.3) . From http://tools.twainscanning.com/getmyregex ."
    },
    {
        "Pattern": "[A-Za-z]+",
        "MatchingText": "any word",
        "NonMatchingText": "we32",
        "Description": "Word of any length (is nice) . From http://tools.twainscanning.com/getmyregex ."
    },
    {
        "Pattern": "^[[V|E|J|G]\\d\\d\\d\\d\\d\\d\\d\\d]{0,9}$",
        "MatchingText": "V14653267|||J65412378|||E64578911",
        "NonMatchingText": "A45465654|||AE1234567|||J15E12345",
        "Description": "Regexp to validate Venezuelan Id number Or Cedula de identidad.\n"
    },
    {
        "Pattern": "^([1-9]\\d{3}|0[1-9]\\d{2}|00[1-9]\\d{1}|000[1-9]{1})$",
        "MatchingText": "0001 ||| 0064 ||| 0948 ||| 7697",
        "NonMatchingText": "1 ||| 64 ||| 948",
        "Description": "This RE will match all numbers between (including) 0001 and 9999. Four places of digits are mandatory in this expression."
    },
    {
        "Pattern": "^([\\d]*[1-9]+[\\d]*)$",
        "MatchingText": "0001 ||| 120064 ||| 1000000 ||| 1",
        "NonMatchingText": "0 ||| 000000000 ||| 0000",
        "Description": "RE to match numbers with value greater than 0."
    },
    {
        "Pattern": "(^(\\d{2}\\x2E\\d{3}\\x2E\\d{3}[-]\\d{1})$|^(\\d{2}\\x2E\\d{3}\\x2E\\d{3})$)",
        "MatchingText": "12.123.123|||12.123.123-1",
        "NonMatchingText": "12123123|||12.12.123|||12.123.12|||12.123.123-|||12.123.123-12",
        "Description": "Brazilian ID document, known in Brazil as RG (Registro Geral)."
    },
    {
        "Pattern": "-([^-]*)-([^-]*)-([^-]*)-([^-]*)-([^-]*)-([^-]*)-([^-]*)-([^-]*)-([^-]*)-([^-]*)-([^-]*)-([^-]*)-([^-]*)-([^-]*)-([^-]*)-([^-]*)-",
        "MatchingText": "paosdi-wqpeiwapodksad-wqerwegfsd-4s6df78dsf-ds53as4df6ewart-rgda53g749tr-gsdfa8t4et9red-gqwe-34reg315-g#%$#%-UJYTJGDGST-bfdgdhtehn-rewqr32r23-gf-6etrsgrt--erayrtsu--jysrurytfhrtyt",
        "NonMatchingText": "paosdi-wqpeiwapodksad-wqerwegfsd-4s6df78dsf-ds53as4df6ewart-rgda53g749tr-gsdfa8t4et9red-gqwe-34reg315-g#%$#%-UJYTJGDGST-bfdgdhtehn-rewqr32r23-gf-6etrsgrt-",
        "Description": "Test payload"
    }
]