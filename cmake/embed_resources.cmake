# Function to embed JSON files as C++ string literals using raw string literals
function(embed_json_files target_name)
    set(oneValueArgs OUTPUT_FILE NAMESPACE)
    set(multiValueArgs JSON_FILES)
    cmake_parse_arguments(EMBED "" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
    
    # Create the output directory
    get_filename_component(OUTPUT_DIR ${EMBED_OUTPUT_FILE} DIRECTORY)
    file(MAKE_DIRECTORY ${OUTPUT_DIR})
    
    # Start building the header content
    set(HEADER_CONTENT "// Auto-generated by CMake - DO NOT EDIT\n")
    string(APPEND HEADER_CONTENT "#pragma once\n")
    string(APPEND HEADER_CONTENT "#include <string_view>\n")
    string(APPEND HEADER_CONTENT "#include <unordered_map>\n\n")
    string(APPEND HEADER_CONTENT "namespace ${EMBED_NAMESPACE} {\n\n")
    
    # Process each JSON file
    foreach(JSON_FILE ${EMBED_JSON_FILES})
        # Get the filename without extension for the variable name
        get_filename_component(FILE_NAME ${JSON_FILE} NAME_WE)
        
        # Read the JSON file content
        file(READ ${JSON_FILE} JSON_CONTENT)
        
        # Use raw string literal to avoid escaping issues (default being `")`, any json containing that would break)
        # Generate a unique delimiter to avoid conflicts
        string(RANDOM LENGTH 8 ALPHABET "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" DELIMITER)
        set(RAW_DELIMITER "JSON_${DELIMITER}")
        
        # Add the raw string literal to header
        string(APPEND HEADER_CONTENT "const std::string_view ${FILE_NAME}_json = R\"${RAW_DELIMITER}(${JSON_CONTENT})${RAW_DELIMITER}\";\n\n")
    endforeach()
    

    string(APPEND HEADER_CONTENT "} // namespace ${EMBED_NAMESPACE}\n")
    
    # Write the header file
    file(WRITE ${EMBED_OUTPUT_FILE} "${HEADER_CONTENT}")
    
    # Add the generated file as a target dependency
    add_custom_target(${target_name}_resources
        DEPENDS ${EMBED_OUTPUT_FILE}
        COMMENT "Generating embedded resources for ${target_name}"
    )
endfunction()

# Function to embed YAML files as C++ string literals using raw string literals
function(embed_yaml_files target_name)
    set(oneValueArgs OUTPUT_FILE NAMESPACE)
    set(multiValueArgs YAML_FILES)
    cmake_parse_arguments(EMBED "" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
    
    # Create the output directory
    get_filename_component(OUTPUT_DIR ${EMBED_OUTPUT_FILE} DIRECTORY)
    file(MAKE_DIRECTORY ${OUTPUT_DIR})
    
    # Start building the header content
    set(HEADER_CONTENT "// Auto-generated by CMake - DO NOT EDIT\n")
    string(APPEND HEADER_CONTENT "#pragma once\n")
    string(APPEND HEADER_CONTENT "#include <string_view>\n\n")
    string(APPEND HEADER_CONTENT "namespace ${EMBED_NAMESPACE} {\n\n")
    
    # Process each YAML file
    foreach(YAML_FILE ${EMBED_YAML_FILES})
        # Get the filename without extension for the variable name
        get_filename_component(FILE_NAME ${YAML_FILE} NAME_WE)
        
        # Read the YAML file content
        file(READ ${YAML_FILE} YAML_CONTENT)
        
        # Use raw string literal to avoid escaping issues
        # Generate a unique delimiter to avoid conflicts
        string(RANDOM LENGTH 8 ALPHABET "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" DELIMITER)
        set(RAW_DELIMITER "YAML_${DELIMITER}")
        
        # Add the raw string literal to header
        string(APPEND HEADER_CONTENT "const std::string_view ${FILE_NAME}_yaml = R\"${RAW_DELIMITER}(${YAML_CONTENT})${RAW_DELIMITER}\";\n\n")
    endforeach()
    
    string(APPEND HEADER_CONTENT "} // namespace ${EMBED_NAMESPACE}\n")
    
    # Write the header file
    file(WRITE ${EMBED_OUTPUT_FILE} "${HEADER_CONTENT}")
    
    # Add the generated file as a target dependency
    add_custom_target(${target_name}_resources
        DEPENDS ${EMBED_OUTPUT_FILE}
        COMMENT "Generating embedded YAML resources for ${target_name}"
    )
endfunction()